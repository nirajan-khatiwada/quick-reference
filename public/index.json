[{"content":"44. Optimizing Performance 44.1. memo memo is a higher-order function in React that optimizes functional components by preventing unnecessary re-renders. It returns a new component that behaves the same as the original one but only re-renders if its props change or internal state changes not every time the parent component re-renders.\nWhy Use memo? When a parent component re-renders, all its child components also re-render by default—even if their props remain unchanged. This behavior can lead to performance bottlenecks. Using memo, we can avoid these unnecessary re-renders for child components.\nExample:\nimport { memo } from \u0026#39;react\u0026#39;; const MyComponent = memo((props) =\u0026gt; { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;{props.title}\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ); }); export default MyComponent; In the above example, the MyComponent functional component is wrapped with the memo function. This ensures that the component will only re-render if its props have changed or if its satate has been change not every time the parent component re-renders.\nUse Case:\nBefore using memo: In this example, the Custom component re-renders unnecessarily whenever the parent component re-renders, even if its props haven\u0026rsquo;t changed or internal state hasn\u0026rsquo;t changed. Custom.js import { useState } from \u0026#39;react\u0026#39;; const Custom = ({ title }) =\u0026gt; { const [count, setCount] = useState(0); return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;{title}\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;{count}\u0026lt;/p\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;Increment\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); }; export default Custom; App.js\nimport { useState } from \u0026#39;react\u0026#39;; import Custom from \u0026#39;./Custom\u0026#39;; function App() { const [count, setCount] = useState(0); return ( \u0026lt;div\u0026gt; \u0026lt;Custom title=\u0026#34;Counter\u0026#34; /\u0026gt; \u0026lt;p\u0026gt;{count}\u0026lt;/p\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;Increment Parent Count\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; Problem: The Custom component re-renders whenever the count state in the App component changes, even though the title prop remains the same. This can cause unnecessary rendering and reduce performance.i.e child component re-renders even if the props are not changed when the parent component re-renders.\nAfter using memo: Using memo, we can optimize the Custom component to only re-render when its props change. Custom.jsx import { useState, memo } from \u0026#39;react\u0026#39;; const Custom = memo(({ title }) =\u0026gt; { const [count, setCount] = useState(0); return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;{title}\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;{count}\u0026lt;/p\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;Increment\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); }); export default Custom; App.js\nimport { useState } from \u0026#39;react\u0026#39;; import Custom from \u0026#39;./Custom\u0026#39;; function App() { const [count, setCount] = useState(0); return ( \u0026lt;div\u0026gt; \u0026lt;Custom title=\u0026#34;Counter\u0026#34; /\u0026gt; \u0026lt;p\u0026gt;{count}\u0026lt;/p\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;Increment Parent Count\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; After using memo the Custom component will only re-render when its props change or state change i.e when the title prop changes or the count state of the Custom component changes . It will not re-render when the count state of the App component changes, which optimizes performance in this scenario as that change does not affect the Custom component.\n44.2. useCallback In every rerender of a component, the functions defined inside the component are recreated. This can lead to performance issues, especially when passing functions as props to child components. useCallback is a hook in React that memoizes functions to prevent unnecessary re-creations.\nSyntax:\nuseCallback(fn, dependencies) fn: The function value that you want to cache. It can take any arguments and return any values. React will return (not call!) your function back to you during the initial render. On next renders, React will give you the same function again if the dependencies have not changed since the last render. Otherwise, it will give you the function that you have passed during the current render, and store it in case it can be reused later. React will not call your function. The function is returned to you so you can decide when and whether to call it. dependencies: An array of values that, when changed, will cause the function to be re-created. If the dependencies array is empty, the function will only be created once, and will not be re-created on subsequent renders. Whats the use of dependencies array in useCallback? just because dependency array the function is recreated with the new values of the dependencies.\nBefore using useCallback:\nimport { useState,memo } from \u0026#39;react\u0026#39;; const Child = memo(({ handleClick }) =\u0026gt; { return ( \u0026lt;button onClick={handleClick}\u0026gt;Click Me\u0026lt;/button\u0026gt; ); }); const Parent = () =\u0026gt; { const [count, setCount] = useState(0); const handleClick = () =\u0026gt; { setCount(count + 1); }; return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;{count}\u0026lt;/p\u0026gt; \u0026lt;Child handleClick={handleClick} /\u0026gt; \u0026lt;/div\u0026gt; ); }; In the above example, the handleClick function is re-created on every re-render of the Parent component. As a result, the reference to the handleClick function passed as a prop to the Child component changes on every re-render of the Parent component. This causes the Child component to re-render unnecessarily, even though the handleClick function remains logically the same After using useCallback:\nimport { useState, useCallback, memo } from \u0026#39;react\u0026#39;; const Child = memo(({ handleClick }) =\u0026gt; { return ( \u0026lt;button onClick={handleClick}\u0026gt;Click Me\u0026lt;/button\u0026gt; ); }); const Parent = () =\u0026gt; { const [count, setCount] = useState(0); const handleClick = useCallback(() =\u0026gt; { setCount(count + 1); }, [count]); return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;{count}\u0026lt;/p\u0026gt; \u0026lt;Child handleClick={handleClick} /\u0026gt; \u0026lt;/div\u0026gt; ); }; By using useCallback, the handleClick function is memoized and will only be re-created when the count state changes. The reference to the handleClick function remains the same across re-renders of the Parent component unless the dependencies specified in the dependency array (in this case, [count]) change. This ensures that the Child component only re-renders when the count state changes, and not when the handleClick function reference changes, thus improving performance.\n44.3. useMemo useMemo is a hook in React that memoizes the result of a function. It is similar to useCallback, but instead of memoizing a function, it memoizes the result of a function.\nSyntax:\nconst cachedValue = useMemo(calculateValue, dependencies) calculateValue: The function calculating the value that you want to cache. It should be pure, should take no arguments, and should return a value of any type. React will call your function during the initial render. On next renders, React will return the same value again if the dependencies have not changed since the last render. Otherwise, it will call calculateValue, return its result, and store it so it can be reused later. dependencies: An array of values that, when changed, will cause the function to be re-executed.\nreturn On the initial render, useMemo returns the result of calling calculateValue with no arguments.During next renders, it will either return an already stored value from the last render (if the dependencies haven’t changed), or call calculateValue again, and return the result that calculateValue has returned.\nBefore using useMemo:\nimport { useState, memo } from \u0026#39;react\u0026#39;; const fibonacci = (n) =\u0026gt; { if (n \u0026lt;= 1) { return n; } return fibonacci(n - 1) + fibonacci(n - 2); }; const Fib = ()=\u0026gt;{ const [count, setCount] = useState(1); const result = fibonacci(100000000000); return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;{result} and count is {count}\u0026lt;/p\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;Increase Count\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } In the above example, the fibonacci function is called on every re-render of the Fib component. This can lead to performance issues, especially when the function is computationally expensive. In this case, the fibonacci function is called with a large number, which can cause the component to freeze or crash.\nAfter using useMemo:\nimport { useState, useMemo } from \u0026#39;react\u0026#39;; const fibonacci = (n) =\u0026gt; { if (n \u0026lt;= 1) { return n; } return fibonacci(n - 1) + fibonacci(n - 2); }; const Fib = ()=\u0026gt;{ const [count, setCount] = useState(1); const result = useMemo(() =\u0026gt; fibonacci(100000000000), []); return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;{result} and count is {count}\u0026lt;/p\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;Increase Count\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } By using useMemo, the result of the fibonacci function is memoized and will only be re-calculated when the dependencies specified in the dependency array change. In this case, the fibonacci function is only called once during the initial render of the Fib component, and the result is stored and reused on subsequent renders. This optimizes performance by preventing unnecessary re-calculation of the fibonacci function on every re-render of the component.\n45.Key conside a scenarion where your base component state variable need to be initialized with the value of the props passed to the component. since the state variable is initialized with the props value, the state variable will not be updated when the props value changes as it is initialized only. to handle we can either use useEffect or we can use key prop.\nUsing useEffect:\nimport { useEffect, useState } from \u0026#39;react\u0026#39;; const Parent = () =\u0026gt; { const [value, setValue] = useState(0); return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={() =\u0026gt; setValue(value + 1)}\u0026gt;Increment\u0026lt;/button\u0026gt; \u0026lt;Child value={value} /\u0026gt; \u0026lt;/div\u0026gt; ); }; const Child = ({ value }) =\u0026gt; { const [stateValue, setStateValue] = useState(value); useEffect(() =\u0026gt; { setStateValue(value); }, [value]); return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;State Value: {stateValue}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Props Value: {value}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); }; stateValue is initialized with the value prop and const [stateValue, setStateValue] = useState(value); runs only once during initial render so useEffect is used to update the stateValue when the value prop changes.\nUsing key prop:\nimport { useState } from \u0026#39;react\u0026#39;; const Parent = () =\u0026gt; { const [value, setValue] = useState(0); return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={() =\u0026gt; setValue(value + 1)}\u0026gt;Increment\u0026lt;/button\u0026gt; \u0026lt;Child key={value} value={value} /\u0026gt; \u0026lt;/div\u0026gt; ); }; const Child = ({ value }) =\u0026gt; { const [stateValue, setStateValue] = useState(value); return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;State Value: {stateValue}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Props Value: {value}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); }; IN the above example,When a key changes between renders, React will create a new instance of the component. By using the key prop with the value prop, we ensure that a new instance of the Child component is created whenever the value prop changes. This allows the stateValue to be initialized with the new value prop on every render, without the need for useEffect.\nNote:The useState() hook us run only one time during the initial render of the component. If the state variable is initialized with a prop value, it will not be updated when the prop value changes. To handle this scenario, we can use the useEffect() hook to update the state variable when the prop value changes. Alternatively, we can use the key prop to create a new instance of the component whenever the prop value changes, allowing the state variable to be initialized with the new prop value on every render. Similar goes for useReducer() and useRef() hooks as well.\n","permalink":"http://localhost:1313/posts/pages/react/react10/","summary":"Learn how to optimize React applications using memo for component memoization, useCallback for function memoization, and useMemo for value memoization.","title":"React : 10"},{"content":"40. useEffect useEffect is a React hook that lets you perform side effects in functional components. Common use cases include:\nEstablishing a database connection when the DOM content loads. Updating the page title when the content changes. Note: The useEffect hook runs after the component has rendered.\n41. What to Put in useEffect Use useEffect for:\nNetwork requests Operations that take time to complete (e.g., fetching data, setting timers, etc.) 42. useEffect Syntax 42.1. Importing useEffect import React, { useEffect } from \u0026#39;react\u0026#39;; 42.2. useEffect Syntax useEffect(() =\u0026gt; { // code here return () =\u0026gt; { // cleanup code here }; }, [dependencies]); The first argument is a function containing the code to execute. The second argument is an array of dependencies. If any dependency changes, the function runs again. The return statement is optional and is used for cleanup tasks, such as removing event listeners or canceling subscriptions. This cleanup function is executed: Just before the the useEffect function runs again cause due to dependency change, with variables from the previous render. After the component unmounts (i.e., when removed from the DOM). Note: When your component is added to the DOM, React runs the setup function. After each re-render with changed dependencies, React first executes the cleanup function (if provided) with old values, then runs the setup function with new values.\nExample: useEffect(() =\u0026gt; { const id = setTimeout(() =\u0026gt; { console.log(count); }, 1000); return () =\u0026gt; { clearTimeout(id); }; }, [count]); In this example, the useEffect hook runs whenever the count variable changes. It sets a timeout to log the count value after 1 second, and the cleanup function clears the previous timeout before the next execution. Cleanup Function:\nUsed for tasks like removing event listeners or clearing timeouts. Ensures stale operations are cleared before new ones are executed. Executes when dependencies change or when the component unmounts. 43. Variations of useEffect 43.1. useEffect Without Dependencies Array useEffect(() =\u0026gt; { // code here }); The useEffect function runs after every re-render. 43.2. useEffect With Empty Dependencies Array useEffect(() =\u0026gt; { // code here }, []); The useEffect function runs only once after the initial render, making it ideal for tasks like loading local storage data. 43.3. useEffect With Multiple Dependencies useEffect(() =\u0026gt; { // code here }, [count, name]); The useEffect function runs when either count or name changes. Note: In all of the variation, useEffect always runs after the first render no matter what is passed in the dependencies array.\nExample: Loading Local Storage Data Correct Usage:\nimport React, { useState, useEffect } from \u0026#39;react\u0026#39;; const App = () =\u0026gt; { const [data, setData] = useState([]); useEffect(() =\u0026gt; { const data = localStorage.getItem(\u0026#39;data\u0026#39;); if (data) { setData(JSON.parse(data)); } }, []); return ( \u0026lt;div\u0026gt; {data.map((item, index) =\u0026gt; ( \u0026lt;p key={index}\u0026gt;{item}\u0026lt;/p\u0026gt; ))} \u0026lt;/div\u0026gt; ); }; Incorrect Usage:\nimport React, { useState } from \u0026#39;react\u0026#39;; const App = () =\u0026gt; { const [data, setData] = useState([]); const loadData = () =\u0026gt; { const data = localStorage.getItem(\u0026#39;data\u0026#39;); if (data) { setData(JSON.parse(data)); } }; loadData(); return ( \u0026lt;div\u0026gt; {data.map((item, index) =\u0026gt; ( \u0026lt;p key={index}\u0026gt;{item}\u0026lt;/p\u0026gt; ))} \u0026lt;/div\u0026gt; ); }; Problem: Calling loadData directly causes an infinite loop because it triggers a re-render, which calls loadData again. Solution: Use useEffect with an empty dependency array to ensure the function runs only once after the initial render. ","permalink":"http://localhost:1313/posts/pages/react/react9/","summary":"Learn how to use the useEffect hook in React for performing side effects in functional components.","title":"React : 9"},{"content":"38. Understanding the Concept of Prop Drilling Prop drilling refers to the process of passing data from a parent component to a deeply nested child component through all the intermediate components, even if those intermediate components don’t need the data themselves. Let’s break this down with an example.\nComponent Tree Imagine the following component hierarchy: Now, suppose we want to transfer some data from the Product component to the Cart component. Since Product and Cart are in separate branches of the component tree, they don’t have a direct connection.\nHow Prop Drilling Works To make this work, we need to store the shared state in a common ancestor, which is the App component in this case. Then, we have to pass the state down through all the intermediate components, even if those components don’t actually use the data.\nHere’s a visual representation of this:\nData flows from Product → Shop → App (common ancestor). The data then flows from App → Header → CardModel → Cart. This creates a lot of unnecessary overhead because the intermediate components (Shop, Header, and CardModel) don’t need the data but still have to handle it.\nProp drilling can quickly become cumbersome in large applications with deeply nested components. To solve this, we can use state management tools like Redux, Context API, or React Query, which allow us to manage and share state more effectively without passing it through every component.\n39. Introduction to React Context API Context API is a feature in React that allows you to share data between components without having to pass props down manually at every level. It provides a way to pass data through the component tree without having to pass props down manually at every level as shown in the image below.\nHow to use context API Create a context using the createContext function. import { createContext } from \u0026#39;react\u0026#39;; const CartContext = createContext(); export default CartContext; Wrap the parent component with the Provider component. Which Component to wrap? Wrap to the common ancestor of the components that need the context data. In the example below, we wrap the App component with the Provider component. For Example:\nimport CartContext from \u0026#39;./store/CartContext\u0026#39;; function App() { return ( \u0026lt;CartContext.Provider value={data}\u0026gt; \u0026lt;Header /\u0026gt; \u0026lt;Shop /\u0026gt; \u0026lt;/CartContext.Provider\u0026gt; ); } Explaination:Since we want to share the product Component data with the Cart Component SO in order to do that we wrap the first common ancestor of the Product and Cart Component i.e App Component with the Provider Component and pass the data to the value prop of the Provider Component.\nAccess the context data in the child component using the useContext hook. for example:\nimport { useContext } from \u0026#39;react\u0026#39;; import CartContext from \u0026#39;../store/CartContext\u0026#39;; function Cart() { const cartCtx = useContext(CartContext); return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Cart\u0026lt;/h1\u0026gt; {cartCtx.products.map(product =\u0026gt; ( \u0026lt;p key={product.id}\u0026gt;{product.name}\u0026lt;/p\u0026gt; ))} \u0026lt;/div\u0026gt; ); } What Whappen when the data is updated? When the data is updated in the Provider component, all the child components that are using the context data will be re-rendered automatically. Task: Design a simple application that has a component called App. App has two child components: Header and Shop. Header has one child, CartModel, and Shop has one child, Product. Pass the data from the Product component to the CartModel component using the Context API.\nStructure of the project\nsrc\r|_components\r|_App\r|_App.js\r|_Header\r|_Header.js\r|_CartModel.js\r|_Shop\r|_Shop.js\r|_Product.js\r|_store\r|_CartContext.js CartContext.js\nimport { createContext } from \u0026#39;react\u0026#39;; const CartContext = createContext(); export default CartContext; App.js\nimport CartContext from \u0026#39;../store/CartContext\u0026#39;; import Header from \u0026#39;../Header/Header\u0026#39;; import Shop from \u0026#39;../Shop/Shop\u0026#39;; import { useState } from \u0026#39;react\u0026#39;; function App() { const [cartProducts, setCartProducts] = useState([]); const addProductToCart = (product) =\u0026gt; { setCartProducts((prevProducts) =\u0026gt; [...prevProducts, product]); }; return ( \u0026lt;CartContext.Provider value={ { products: cartProducts, addProduct: addProductToCart } }\u0026gt; \u0026lt;Header /\u0026gt; \u0026lt;Shop /\u0026gt; \u0026lt;/CartContext.Provider\u0026gt; ); } export default App; Header.js\nimport CartModel from \u0026#39;./CartModel\u0026#39;; function Header() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Header\u0026lt;/h1\u0026gt; \u0026lt;CartModel /\u0026gt; \u0026lt;/div\u0026gt; ); } export default Header; CartModel.js\nimport { useContext } from \u0026#39;react\u0026#39;; import CartContext from \u0026#39;../../store/CartContext\u0026#39;; function CartModel() { const cartCtx = useContext(CartContext); return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;CartModel\u0026lt;/h1\u0026gt; {cartCtx.products.map(product =\u0026gt; ( \u0026lt;p key={product.id}\u0026gt;{product.name}\u0026lt;/p\u0026gt; ))} \u0026lt;/div\u0026gt; ); } export default CartModel; Shop.js\nimport Product from \u0026#39;./Product\u0026#39;; function Shop() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Shop\u0026lt;/h1\u0026gt; \u0026lt;Product /\u0026gt; \u0026lt;/div\u0026gt; ); } export default Shop; Product.js\nimport { useContext } from \u0026#39;react\u0026#39;; import CartContext from \u0026#39;../../store/CartContext\u0026#39;; function Product() { const cartCtx = useContext(CartContext); const product = { id: 1, name: \u0026#39;Laptop\u0026#39; }; return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Product\u0026lt;/h1\u0026gt; \u0026lt;button onClick={() =\u0026gt; cartCtx.addProduct(product)}\u0026gt;Add to Cart\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } export default Product; Outsoursing the Context Provider Since all the logic related to the context is in the App Component so we can outsource the context provider and its logic to a separate component in order to make the App Component more clean and readable.\nCartContext.js\nimport { createContext, useState } from \u0026#39;react\u0026#39;; const CartContext = createContext(); export const CartContextProvider = (props) =\u0026gt; { const [cartProducts, setCartProducts] = useState([]); const addProductToCart = (product) =\u0026gt; { setCartProducts((prevProducts) =\u0026gt; [...prevProducts, product]); }; const context = { products: cartProducts, addProduct: addProductToCart }; return ( \u0026lt;CartContext.Provider value={context}\u0026gt; {props.children} \u0026lt;/CartContext.Provider\u0026gt; ); }; App.js\nimport Header from \u0026#39;../Header/Header\u0026#39;; import Shop from \u0026#39;../Shop/Shop\u0026#39;; import { CartContextProvider } from \u0026#39;../store/CartContext\u0026#39;; function App() { return ( \u0026lt;CartContextProvider\u0026gt; \u0026lt;Header /\u0026gt; \u0026lt;Shop /\u0026gt; \u0026lt;/CartContextProvider\u0026gt; ); } export default App; Other Components remain the same.\n39.UseReducer Hook in React USe reducer is a hook that is used for state management in React. It is an alternative to useState. It is usually preferable when you have complex state logic that involves multiple sub-values or when the next state depends on the previous one.\nHow to use useReducer Hook Create a reducer function. A reducer function is a function that takes the current state and an action as arguments and returns a new state based on the action type.action . action:It contains the object that is sent by the dispatch function. For Example:\nconst counterReducer = (state, action) =\u0026gt; { if (action.type === \u0026#39;INCREMENT\u0026#39;) { return { counter: state.counter + 1 }; } if (action.type === \u0026#39;DECREMENT\u0026#39;) { return { counter: state.counter - 1 }; } return state; }; Here, the reducer function takes two arguments: state and action. It checks the action type and returns a new state based on the action type.\nUse the useReducer hook in the component. The useReducer hook takes two arguments: the reducer function and the initial state and returns the current state and a dispatch function as an array which is shown below. For Example: import { useReducer } from \u0026#39;react\u0026#39;; const [counterState, dispatchCounter] = useReducer(counterReducer, { counter: 0 }); Here, counterState is the current state and dispatchCounter is the dispatch function that is used to dispatch an action to the reducer function and { counter: 0 } is the initial state such that the counter is initialized to 0.\nDispatch an action to the reducer function. To dispatch an action to the reducer function, you need to call the dispatch function with an object that contains the action type and any additional data that is required by the reducer function. For Example: dispatchCounter({ type: \u0026#39;INCREMENT\u0026#39; }); To change the state, you need to call the dispatch function with an object that contains the action type.Here, the action type is \u0026lsquo;INCREMENT\u0026rsquo; which increments the counter by 1.\nTask: Design a simple counter application that has a component called Counter. The Counter component has two buttons: Increment and Decrement. Use the useReducer hook to manage the state of the counter.\nStructure of the project\nsrc\r|_components\r|_Counter\r|_Counter.js Counter.js\nimport { useReducer } from \u0026#39;react\u0026#39;; const counterReducer = (state, action) =\u0026gt; { if (action.type === \u0026#39;INCREMENT\u0026#39;) { return { counter: state.counter + 1 }; } if (action.type === \u0026#39;DECREMENT\u0026#39;) { return { counter: state.counter - 1 }; } return state; }; function Counter() { const [counterState, dispatchCounter] = useReducer(counterReducer, { counter: 0 }); const handleIncrement = () =\u0026gt; { dispatchCounter({ type: \u0026#39;INCREMENT\u0026#39; }); }; const handleDecrement = () =\u0026gt; { dispatchCounter({ type: \u0026#39;DECREMENT\u0026#39; }); }; return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Counter\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;{counterState.counter}\u0026lt;/p\u0026gt; \u0026lt;button onClick={handleIncrement}\u0026gt;Increment\u0026lt;/button\u0026gt; \u0026lt;button onClick={handleDecrement}\u0026gt;Decrement\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } If we use useState hook then the code will be like this:\nimport { useState } from \u0026#39;react\u0026#39;; function Counter() { const [counter, setCounter] = useState(0); const handleIncrement = () =\u0026gt; { setCounter(counter=\u0026gt;counter + 1); }; const handleDecrement = () =\u0026gt; { setCounter(counter=\u0026gt;counter - 1); }; return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Counter\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;{counter}\u0026lt;/p\u0026gt; \u0026lt;button onClick={handleIncrement}\u0026gt;Increment\u0026lt;/button\u0026gt; \u0026lt;button onClick={handleDecrement}\u0026gt;Decrement\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } What is the difference between useState and useReducer?\nuseState is a simple and straightforward way to manage state in React. It is suitable for managing simple state logic. useReducer is more powerful and flexible than useState. It is suitable for managing complex state logic that involves multiple sub-values or when the next state depends on the previous one. Looking the example case Scenario: Here using reducer we write all the logic in a single function and then we dispatch the action to the reducer function and then the reducer function returns the new state based on the action type. This makes the code more readable and maintainable.\nbut in the case of useState, we have to write the logic for each state change separately which makes the code more complex and difficult to maintain.\nNote: Always change in state variable will cause the re-rendering of the component.\n","permalink":"http://localhost:1313/posts/pages/react/react8/","summary":"Learn about prop drilling and how to use the Context API in React to manage and share state effectively.","title":"React : 8"},{"content":"1.1 When to use asyncio? Asyncio is a library to write concurrent code using the async/await syntax. It is a single-threaded, single-process design that is ideal for I/O-bound and high-level structured network code. It is not suitable for CPU-bound code, which is better handled by the multiprocessing module.It is used for :\n2.1 Coroutine Think of a coroutine like a regular Python function but with the superpower that it can pause its execution when it encounters an operation that could take a while to complete. When that long-running operation is complete, we can “wake up” our paused coroutine and finish executing any other code in that coroutine. While a paused coroutine is waiting for the operation it paused for to finish, we can run other code. This running of other code while waiting is what gives our application concur rency. We can also run several time-consuming operations concurrently, which can give our applications big performance improvements. To both create and pause a coroutine, we’ll need to learn to use Python’s async and await keywords. The async keyword will let us define a coroutine; the await key word will let us pause our coroutine when we have a long-running operation.\n2.2 Creating a coroutine with async creating a coroutine is straightforward and not much different from creating a nor mal Python function. The only difference is that, instead of using the def keyword, we use async def. The async keyword marks a function as a coroutine instead of a nor mal Python function.\nimport asyncio async def mero_coroutine(): print(\u0026#34;Hello From Asyncio\u0026#34;) The coroutine in the preceding listing does nothing yet other than print “Hello world!” It’s also worth noting that this coroutine does not perform any long-running operations; it just prints our message and returns. This means that, when we put the coroutine on the event loop, it will execute immediately because we don’t have any blocking I/O, and nothing is pausing execution yet. This syntax is simple, but we’re creating something very different from a plain Python function. To illustrate this, let’s create a function that adds one to an integer as well as a coroutine that does the same and compare the results of calling each. We’ll also use the type convenience function to look at the type returned by calling a corou tine as compared to calling our normal function.\ndef add_function(a,b): return a+b async def add_coroutine(a,b): return a+b function=add_function(1,2) coroutine=add_coroutine(1,2) print(type(function)) print(type(coroutine)) When we run this code, we’ll see output like the following\nMethod result is 3 and the type is \u0026lt;class \u0026#39;int\u0026#39;\u0026gt;\rCoroutine result is \u0026lt;coroutine object coroutine_add_one at 0x1071d6040\u0026gt; and the type is \u0026lt;class \u0026#39;coroutine\u0026#39;\u0026gt; Notice how when we call our normal add_one function it executes immediately and returns what we would expect, another integer. However, when we call coroutine_ add_one we don’t get our code in the coroutine executed at all. We get a coroutine object instead. This is an important point, as coroutines aren’t executed when we call them directly. Instead, we create a coroutine object that can be run later. To run a corou tine, we need to explicitly run it on an event loop. So how can we create an event loop and run our coroutine?\nIn versions of Python older than 3.7, we had to create an event loop if one did not already exist. However, the asyncio library has added several functions that abstract the event loop management. There is a convenience function, asyncio.run, we can use to run our coroutine. This is illustrated in the following listing.\nimport asyncio async def add_coroutine(a,b): return a+b res=asyncio.run(add_coroutine(1,2)) print(res) When we run this code, we’ll see output like the following:\n3 We’ve properly put our coroutine on the event loop, and we have executed it! asyncio.run is doing a few important things in this scenario. First, it creates a brand-new event. Once it successfully does so, it takes whichever coroutine we pass into it and runs it until it completes, returning the result. This function will also do some cleanup of anything that might be left running after the main coroutine fin ishes. Once everything has finished, it shuts down and closes the event loop. Possibly the most important thing about asyncio.run is that it is intended to be the main entry point into the asyncio application we have created. It only executes one coroutine, and that coroutine should launch all other aspects of our application. As we progress further, we will use this function as the entry point into nearly all our applications. The coroutine that asyncio.run executes will create and run other coroutines that will allow us to utilize the concurrent nature of asyncio.\n2.3 Pausing execution with the await keyword The example we saw in block 2.2 did not need to be a coroutine, as it executed only non-blocking Python code. The real benefit of asyncio is being able to pause execu tion to let the event loop run other tasks during a long-running operation. To pause execution, we use the await keyword. The await keyword is usually followed by a call to a coroutine (more specifically, an object known as an awaitable, which is not always a coroutine; we’ll learn more about awaitables later in the chapter). Using the await keyword will cause the coroutine following it to be run, unlike calling a coroutine directly, which produces a coroutine object. The await expression will also pause the coroutine where it is contained in until the coroutine we awaited finishes and returns a result. When the coroutine we awaited finishes, we’ll have access to the result it returned, and the containing coroutine will “wake up” to handle the result. We can use the await keyword by putting it in front of a coroutine call. Expanding on our earlier program, we can write a program where we call the add_coroutine function inside of a “main” async function and get the result\nimport asyncio async def add_one(number: int) -\u0026gt; int: return number + 1 async def main() -\u0026gt; None: one_plus_one = await add_one(1) # Pause, and wait for the result of add_one(1). two_plus_one = await add_one(2) # Pause, and wait for the result of add_one(2). print(one_plus_one) print(two_plus_one) asyncio.run(main()) Note: Coroutine will only run when we use await keyword. If we call the coroutine directly it will return a coroutine object.\nIn above code we pause execution twice. We first await the call to add_one(1). Once we have the result, the main function will be “unpaused,” and we will assign the return value from add_one(1) to the variable one_plus_one, which in this case will be two. We then do the same for add_one(2) and then print the results.We can visualize the execution flow of our application, as shown in figure\nAs it stands now, this code does not operate differently from normal, sequential code. We are, in effect, mimicking a normal call stack. Next, let’s look at a simple example of how to run other code by introducing a dummy sleep operation while we’re waiting.\n2.4 Introducing long-running coroutines with sleep Our previous examples did not use any slow operations and were used to help us learn the basic syntax of coroutines. To fully see the benefits and show how we can run mul tiple events simultaneously, we’ll need to introduce some long-running operations. Instead of making web API or database queries right away, which are nondeterministic as to how much time they will take, we’ll simulate long-running operations by specify ing how long we want to wait. We’ll do this with the asyncio.sleep function. We can use asyncio.sleep to make a coroutine “sleep” for a given number of sec onds. This will pause our coroutine for the time we give it, simulating what would hap pen if we had a long-running call to a database or web API. asyncio.sleep is itself a coroutine, so we must use it with the await keyword. If we call it just by itself, we’ll get a coroutine object. Since asyncio.sleep is a coroutine, this means that when a coroutine awaits it, other code will be able to run. Let’s examine a simple example, shown in the following listing, that sleeps for 1 sec ond and then prints a \u0026lsquo;Hello World!\u0026rsquo; message.\nimport asyncio async def hello_world_message(): await asyncio.sleep(1) print(\u0026#34;Hello World\u0026#34;) asyncio.run(hello_world_message()) When we run this application, our program will wait 1 second before printing our \u0026lsquo;Hello World!\u0026rsquo; message. Since hello_world_message is a coroutine and we pause it for 1 second with asyncio.sleep, we now have 1 second where we could be running other code concurrently.\nWe’ll be using sleep a lot in the next few examples, so let’s invest the time to cre ate a reusable coroutine that sleeps for us and prints out some useful information. We’ll call this coroutine delay. This is shown in the following listing\nimport asyncio async def delay(delaysecond): print(f\u0026#39;Sleeping for delay seconds : {delaysecond}\u0026#39;) await asyncio.sleep(delaysecond) print(f\u0026#39;finished sleeping for {delay_seconds} second(s)\u0026#39;) return delay_seconds delay will take in an integer of the duration in seconds that we’d like the function to sleep and will return that integer to the caller once it has finished sleeping. We’ll also print when sleep begins and ends. This will help us see what other code, if any, is run ning concurrently while our coroutines are paused.\nTo make referencing this utility function easier in future code listings, we’ll create a module that we’ll import in the remainder of this book when needed. We’ll also add to this module as we create additional reusable functions. We’ll call this module util, and we’ll put our delay function in a file called delay_functions.py. We’ll also add an init.py file with the following line, so we can nicely import the timer\nfrom util.delay_functions import delay From now on in this book, we’ll use from util import delay whenever we need to use the delay function. Now that we have a reusable delay coroutine, let’s combine it with the earlier coroutine add_one to see if we can get our simple addition to run concur rently while hello_world_message is paused.\nimport asyncio from util.delay_functions import delay async def add_one(number): return number + 1 async def hello_world_message(): await delay(1) print(\u0026#34;Hello World\u0026#34;) async def main() -\u0026gt; None: message = await hello_world_message() #pause until hello_world_message is finished one_plus_one = await add_one(1) #pause until add_one is finished print(one_plus_one) print(message) asyncio.run(main()) When we run this, 1 second passes before the results of both function calls are printed. What we really want is the value of add_one(1) to be printed immediately while hello_world_message()runs concurrently. So why isn’t this happening with this code? The answer is that await pauses our current coroutine and won’t execute any other code inside that coroutine until the await expression gives us a value. Since it will take 1 second for our hello_world_message function to give us a value, the main coroutine will be paused for 1 second. Our code behaves as if it were sequential in this case. This behavior is illustrated in figure\nWe can see that the main coroutine is paused for 1 second while hello_world_\nBoth main and hello_world paused while we wait for delay(1) to finish. After it has finished, main resumes and can execute add_one. We’d like to move away from this sequential model and run add_one concurrently with hello_world. To achieve this, we’ll need to introduce a concept called tasks.\n2.5 Running concurrently with task In Python\u0026rsquo;s asyncio, you can create tasks to run code concurrently. This is done using the asyncio.create_task function. When you create a task, it starts running in the background immediately, allowing your program to do other things while waiting for the task to finish.\nKey Points: Creating a Task:\nUse asyncio.create_task() with a coroutine function as its input. It returns a task object instantly. Awaiting a Task:\nYou can use await with the task object to pause your program until the task is done and get its result. Why Use Tasks?\nTasks allow other parts of your program to run without waiting for one operation to finish. Code Example: Creating and Using a Task import asyncio from util import delay # A custom function that simulates a delay async def main(): # Create a task that takes 3 seconds to complete sleep_for_three = asyncio.create_task(delay(3)) # Immediately print the type of the task object print(f\u0026#34;Task type: {type(sleep_for_three)}\u0026#34;) # Wait for the task to finish and get the result result = await sleep_for_three print(f\u0026#34;Task result: {result}\u0026#34;) # Run the main coroutine asyncio.run(main()) What’s Happening in the Code: Task Creation:\nasyncio.create_task(delay(3)) creates a task to run the delay(3) coroutine in the background. The task is of type \u0026lt;class '_asyncio.Task'\u0026gt;, which is different from a regular coroutine. Running Concurrently:\nAfter creating the task, the program does not wait for the task to finish. The print() statement runs immediately after the task is created. Waiting for the Task:\nThe await sleep_for_three line pauses the main coroutine until the task finishes. Once the task is complete, it returns its result, which is printed. Why Await is Important: If you don’t use await on a task, it might not get enough time to finish. When the asyncio.run function exits, the event loop stops, and any unfinished tasks are “cleaned up” without completing. Using await ensures the task has a chance to finish.\nNote : When we create task using asyncio.create_task it run the task immediately in the background. It does not wait for the task to finish and immediately return a task object such that our program can do other things while waiting for the task to finish.We can use await later on to pause the program until the task is done and get its result.\n2.6 Running multiple tasks concurrently Given that tasks are created instantly and are scheduled to run as soon as possible, this allows us to run many long-running tasks concurrently. We can do this by sequentially starting multiple tasks with our long-running coroutine.\nimport asyncio from util.delay_functions import delay async def main(): # Create two tasks that take 3 seconds to complete sleep_for_three=asyncio.create_task(delay(3)) sleep_again=asyncio.create_task(delay(3)) sleep_once_more=asyncio.create_task(delay(3)) await sleep_for_three await sleep_again await sleep_once_more asyncio.run(main()) In this code, we create three tasks that each sleep for 3 seconds. We then await each task in sequence. This will cause each task to run concurrently, and the total time to complete will be around 3 seconds, not 9 seconds. This is because we are not waiting for each task to finish before starting the next one. Lets breakdown\nStarting Three Tasks:\nThe program begins by creating three tasks, each of which takes 3 seconds to complete. The create_task function starts the tasks immediately but doesn\u0026rsquo;t wait for them to finish—it just sets them up to run in the background. The First Await Statement:\nWhen the code reaches the await sleep_for_three line, it pauses and gives control to the event loop. This pause allows the event loop to check for any tasks waiting to run and starts them “as soon as possible.” Tasks Run Simultaneously:\nAll three tasks begin running their sleep operations at the same time because the event loop handles them concurrently. This concurrency allows the program to complete the work in 3 seconds instead of 9. Concurrency in Action:\nWhile the sleep operations run concurrently, any other code in the tasks (like print statements) runs one at a time, not simultaneously. This means only the parts of the tasks that involve waiting (like sleeping) are parallelized. Time Saved:\nIf the tasks were executed one after another, the program would take 9 seconds (3 seconds × 3 tasks). By running the tasks concurrently, the program finishes in just 3 seconds, saving a lot of time. This is illustrated in figure NOTE This benefit compounds as we add more tasks; if we had launched 10 of these tasks, we would still take roughly 3 seconds, giving us a 10-fold speedup. This is the power of concurrency in asyncio.\nasyncio.gather function Gather function is a quick way to run multiple tasks concurrently and wait for all of them to complete. It takes in an iterable of awaitables and returns a single awaitable that will yield results in the order they were created. This is useful when we want to run multiple tasks concurrently and wait for all of them to finish before proceeding.\nimport asyncio from util.delay_functions import delay async def main(): # Create three tasks that take 3 seconds to complete and handel using asyncio.gather results = await asyncio.gather( delay(3), delay(3), delay(3) ) print(results) asyncio.run(main()) Note : For understanding You can use this logic . There is a task queue and event loop. When we only await coroutine there is only one task in the task queue and event loop .\ncoroutine need to await for running the task i.e keep in the task queue and eventloop if we directly run coroutine it will just give us coroutine object.\nWhen we use asyncio.createtask() there are as much task in the task queue as the number of tasks created and event loop will run all the tasks concurrently also when we await new coroutine it will be added to the task queue and event loop will run it concurrently.\nIt return a task object instantly and run all the task concurrently i.e keep in the task queue and event loop without awaiting but does not wait for the task to finish it need to be awaited to get the proper result.\nWhen we use asyncio.gather() it will run all the tasks concurrently and wait for all of them to finish before proceeding.\nIt need to be awaited to keep all the task in the task queue and event loop and wait for all of them to finish before proceeding.After finishing all the task it will return the result in the order they were created and jump to the next line of code of the main coroutine.\n3. Synchronization Premitives Locks Semaphores 3.1 Locks Locks are a synchronization primitive that allows us to limit access to a shared resource to only one coroutine at a time. This is useful when we have a resource that can only be accessed by one coroutine at a time, like a file or a database connection. Locks are created using the asyncio.Lock class and can be acquired using the acquire method and released using the release method.\n#basic example of lock\nimport asyncio async def locking(lock): print(\u0026#39;Waiting for the lock\u0026#39;) async with lock: print(\u0026#39;Acquired the lock\u0026#39;) await asyncio.sleep(2) print(\u0026#39;Released the lock\u0026#39;) async def main(): lock = asyncio.Lock() await asyncio.gather( locking(lock), locking(lock), locking(lock) ) asyncio.run(main()) Output:\nWaiting for the lock\rAcquired the lock\rWaiting for the lock\rWaiting for the lock\rReleased the lock\rAcquired the lock\rReleased the lock\rAcquired the lock\rReleased the lock In this example, we create a lock using asyncio.Lock and pass it to the locking coroutine. We then use the async with statement to acquire the lock and release it when we are done. When we run the program, we can see that only one coroutine can acquire the lock at a time, and the other coroutines have to wait until the lock is released.\n3.2 Semaphores Semaphores are a synchronization primitive that allows us to limit access to a shared resource to a fixed number of coroutines at a time. This is useful when we have a resource that can be accessed by a limited number of coroutines, like a connection pool or a web API. Semaphores are created using the asyncio.Semaphore class and can be acquired using the acquire method and released using the release method.\n#basic example of semaphore\nimport asyncio async def semaphoring(semaphore): async with semaphore: print(\u0026#39;Acquired the semaphore\u0026#39;) await asyncio.sleep(2) print(\u0026#39;Released the semaphore\u0026#39;) async def main(): semaphore = asyncio.Semaphore(2) await asyncio.gather( semaphoring(semaphore), semaphoring(semaphore), semaphoring(semaphore), semaphoring(semaphore) ) asyncio.run(main()) Output:\nAcquired the semaphore\rAcquired the semaphore\rAcquired the semaphore\rReleased the semaphore\rReleased the semaphore\rReleased the semaphore\rAcquired the semaphore\rReleased the semaphore In this example, we create a semaphore with a limit of 2 using asyncio.Semaphore and pass it to the semaphoring coroutine. We then use the async with statement to acquire the semaphore and release it when we are done. When we run the program, we can see that only two coroutines can acquire the semaphore at a time, and the other coroutines have to wait until the semaphore is released.\nSome popular asyncio libraries aiohttp: An HTTP client and server library for asyncio. fastapi: A modern web framework for building APIs with Python 3.6+ based on standard Python type hints. aiofiles: A file operations library for asyncio. ","permalink":"http://localhost:1313/posts/pages/asyncio/asyncio2/","summary":"how to write programs using this single-threaded concurrency model with asyncio","title":"Async io : Asyncio Basics (Day 2)"},{"content":"36. useRef Hook in React useRef is a hook that is specially designed to work with DOM elements. It allows you to create a reference to a DOM element and access it directly in your components so you can modify it or read its properties as needed.\nAnother important distinction is that useRef holds the same reference across re-renders of the component Similarly, useState also retains its value between renders. However, updating a state value with useState will always trigger a re-render, whereas updating the value of a useRef does not. Its explained in the below example in ## 2. Advanvced Usage\n1. Basic Usage 1. Import useRef import { useRef } from \u0026#39;react\u0026#39;; 2. Create a Reference const myRef = useRef(); 3. Attach to DOM Elements function MyComponent() { const myRef = useRef(); return ( \u0026lt;div ref={myRef}\u0026gt; \u0026lt;h1\u0026gt;useRef Example\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ); } 4. Accessing the Reference // Access the DOM element using .current const element = myRef.current; use myRef.current.value for input elements. use myRef.current.checked for checkbox elements. use myRef.current.focus() to focus on an element. use myRef.current.style to access the style object of an element.\nNote: While you can access DOM elements directly with useRef, it\u0026rsquo;s recommended to avoid manipulating them directly unless necessary.\nPractical Example: Form Input Here\u0026rsquo;s a complete example showing how to use useRef with form inputs:\nimport { useRef, useState } from \u0026#39;react\u0026#39;; function InputExample() { const inputRef = useRef(); const [inputValue, setInputValue] = useState(\u0026#39;\u0026#39;); const handleClick = () =\u0026gt; { setInputValue(inputRef.current.value); inputRef.current.value = \u0026#39;\u0026#39;; // Clear input after reading }; return ( \u0026lt;div\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; ref={inputRef} placeholder=\u0026#34;Type something...\u0026#34; /\u0026gt; \u0026lt;button onClick={handleClick}\u0026gt;Save Input\u0026lt;/button\u0026gt; \u0026lt;p\u0026gt;Saved value: {inputValue}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } Explanation:\nWe create a reference to the input element using useRef. When the button is clicked, we read the input value using inputRef.current.value and update the state. We clear the input field by setting inputRef.current.value to an empty string. 2. Advanced Usage of useRef and useState useRef and useState are both hooks used in React. Both hooks help us store values, but they behave differently: useState: The value is persistent across re-renders, but updating it triggers a re-render. useRef: The value is also persistent across re-renders, but updating it does not trigger a re-render. 2.1. Managing Previous Values in a Stopwatch Here’s an example of how to use useRef and useState to build a simple stopwatch in React:\nimport { useRef, useState } from \u0026#39;react\u0026#39;; function Stopwatch() { const timerRef = useRef(0); // To store the timer ID const [time, setTime] = useState(0); // To store the current time const [isRunning, setIsRunning] = useState(false); // To track if the stopwatch is running // Start the timer when the Start button is clicked const startTimer = () =\u0026gt; { if (!isRunning) { timerRef.current = setInterval(() =\u0026gt; { setTime((time) =\u0026gt; time + 1); // Increment the time every second }, 1000); setIsRunning(true); // Set the timer as running } }; // Stop the timer when the Stop button is clicked const stopTimer = () =\u0026gt; { clearInterval(timerRef.current); // Clear the interval to stop the timer setIsRunning(false); // Set the timer as not running }; // Reset the timer when the Reset button is clicked const resetTimer = () =\u0026gt; { clearInterval(timerRef.current); // Clear the interval to stop the timer setIsRunning(false); // Set the timer as not running setTime(0); // Reset the time to 0 }; return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Stopwatch\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;Time: {time} seconds\u0026lt;/p\u0026gt; \u0026lt;button onClick={startTimer}\u0026gt;Start\u0026lt;/button\u0026gt; \u0026lt;button onClick={stopTimer}\u0026gt;Stop\u0026lt;/button\u0026gt; \u0026lt;button onClick={resetTimer}\u0026gt;Reset\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } Explanation Creating useRef and useState variables:\ntimerRef: This holds the timer ID (returned by setInterval). We use useRef here because we don’t need the component to re-render when the timer ID changes. time: This stores the current time value of the stopwatch, and we use useState for this because we want the component to re-render whenever the time updates. isRunning: This tracks whether the stopwatch is running or not. Starting the timer (Start Button):\nWhen the \u0026ldquo;Start\u0026rdquo; button is clicked, we check if the timer is already running. If it isn’t, we start it by calling setInterval, which increments the time value every second. setInterval returns an interval ID that we store in timerRef.current. This ID will be used to stop the timer later. Stopping the timer (Stop Button):\nWhen the \u0026ldquo;Stop\u0026rdquo; button is clicked, we clear the interval using clearInterval(timerRef.current) to stop the timer. We also set isRunning to false to indicate that the timer is no longer running. Resetting the timer (Reset Button):\nWhen the \u0026ldquo;Reset\u0026rdquo; button is clicked, we clear the interval to stop the timer, set isRunning to false, and reset the time back to 0. Why useRef? Why not just use a regular variable?\nA regular variable inside the component would reset every time the component re-renders. Since the timer is being updated every second, this would cause issues because the value would be reset each time, and the timer wouldn’t function correctly. Why useRef over useState for the timer ID?\nWe use useRef to store the timer ID because updating it with useState would trigger a re-render every time the timer ID changes. Since the timer is running independently, we don’t need a re-render, so useRef is more efficient here. Key Takeaways useRef is useful for storing values that don’t require the component to re-render when they change. useState is used for values that should trigger a re-render when updated, like the time value in our stopwatch. useRef does not cause a re-render when its value changes, making it ideal for holding values like the interval ID that don’t need to affect the UI. Common Use Cases Storing previous values Managing focus, text selection, or media playback Integrating with third-party DOM libraries Accessing underlying DOM elements Isolation in Components: Any variable that is declared inside a component is isolated to that component. It is not shared with other components unless explicitly passed as props. This isolation helps maintain the encapsulation and modularity of components in React.\n37.Forwarding Refs in React Forwarding refs is a technique in React that allows you to pass a ref from a parent component to a child component. This is useful when you want to access the DOM element of a child component from a parent component.\n1. Basic Usage 1.Import useRef import { useRef } from \u0026#39;react\u0026#39;; 2. Create a Ref in the Parent Component const myRef= useRef(); 3. Pass the Ref to the Child Component \u0026lt;MyChildComponent ref={myRef} /\u0026gt; 4.Import forward ref in child component import React, { forwardRef } from \u0026#39;react\u0026#39;; 5. Using forwardRef to Forward the Ref const MyChildComponent = forwardRef((props, ref) =\u0026gt; { return \u0026lt;input ref={ref} /\u0026gt;; }); 6. Accessing the Ref in the Parent Component const element = myRef.current.value; Practical Example: Input Focus to take input from user and focus on the input field of the child component from the parent component.\nimport React, { useRef } from \u0026#39;react\u0026#39;; const InputComponent = forwardRef(({title}, ref) =\u0026gt; { return\u0026lt;\u0026gt; \u0026lt;h1\u0026gt;{title}\u0026lt;/h1\u0026gt; \u0026lt;input ref={ref}/\u0026gt; \u0026lt;/\u0026gt; }); function ParentComponent() { const inputRef = useRef(); const handleClick = () =\u0026gt; { inputRef.current.focus(); console.log(inputRef.current.value); }; return ( \u0026lt;div\u0026gt; \u0026lt;InputComponent ref={inputRef} title=\u0026#34;ENter the Input\u0026#34;/\u0026gt; \u0026lt;button onClick={handleClick}\u0026gt;Focus Input\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 38.useImperativeHandle in React In large-scale applications, we generally avoid using refs directly to access child components. Instead, we use the useImperativeHandle hook to expose specific methods from the child component to the parent component. This approach allows the developer working on the parent component to interact with the child component\u0026rsquo;s methods without needing to understand its internal implementation. Additionally, this separation enables the developer of the child component to modify or update the child component independently, without affecting the parent component. Since only the exposed methods are used by the parent, changes to the internal structure of the child component do not disrupt the parent-child interaction.This is specially used in forwardRef to expose methods of child component to parent component.\nBasic Usage 1.Pass a Ref to the Child Component import {useRef} from \u0026#39;react\u0026#39;; function App() { const childRef = useRef(); return \u0026lt;ChildComponent ref={childRef} /\u0026gt;; } =\u0026gt; Here, we create a ref using useRef and pass it to the ChildComponent using the ref prop.\n2. Use useImperativeHandle in the Child Component with forwardRef to expose methods import { useImperativeHandle, forwardRef } from \u0026#39;react\u0026#39;; const ChildComponent = forwardRef((props, ref) =\u0026gt; { useImperativeHandle(ref, () =\u0026gt; ({ focus: () =\u0026gt; { // Focus on the input element }, reset: () =\u0026gt; { // Reset the input element }, inputValue:\u0026#39;vaule\u0026#39; }),[dependencies]); return \u0026lt;input /\u0026gt;; }); In the ChildComponent, we use the useImperativeHandle hook to expose the focus and reset methods to the parent component. The ref object is passed as the first argument, and the second argument is a function that returns an object containing the methods to be exposed. dependencies is an optional array of values that, when changed, will trigger the re-evaluation of the function that returns the methods. If the dependencies array is not provided, the function will be called on every render and empty array will call only once in entire lifecycle.\n3. Access the Exposed Methods in the Parent Component function App() { const childRef = useRef(); const handleClick = () =\u0026gt; { childRef.current.focus(); }; const resetClick = () =\u0026gt; { childRef.current.reset(); }; return ( \u0026lt;\u0026gt; \u0026lt;ChildComponent ref={childRef} /\u0026gt; \u0026lt;button onClick={handleClick}\u0026gt;Focus Input\u0026lt;/button\u0026gt; \u0026lt;button onClick={resetClick}\u0026gt;Reset Input\u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; ); } In the parent component, we can access the exposed methods using the current property of the ref object. In this example, we call the focus method when the \u0026ldquo;Focus Input\u0026rdquo; button is clicked.\nPractical Example: Use forwardRef and useImperativeHandle to Expose Methods for reset the input field and get the value of the input field. import {useRef} from \u0026#39;react\u0026#39;; function App(){ const childRef = useRef(); const handleClick = () =\u0026gt; { childRef.current.focus(); }; const resetClick = () =\u0026gt; { childRef.current.reset(); }; const getValue = () =\u0026gt; { console.log(childRef.current.value); }; return ( \u0026lt;\u0026gt; \u0026lt;ChildComponent ref={childRef} /\u0026gt; \u0026lt;button onClick={handleClick}\u0026gt;Focus Input\u0026lt;/button\u0026gt; \u0026lt;button onClick={resetClick}\u0026gt;Reset Input\u0026lt;/button\u0026gt; \u0026lt;button onClick={getValue}\u0026gt;Get Value\u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; ); } export default App; import { useImperativeHandle, forwardRef,useRef } from \u0026#39;react\u0026#39;; const ChildComponent = forwardRef((props, ref) =\u0026gt; { const inputRef = useRef(); useImperativeHandle(ref, () =\u0026gt; ({ focus: () =\u0026gt; { inputRef.current.focus(); }, reset: () =\u0026gt; { inputRef.current.value = \u0026#39;\u0026#39;; }, value: inputRef.current.value }),[]); return \u0026lt;input ref={inputRef} /\u0026gt;; }); export default ChildComponent; =\u0026gt; By using useImperativeHandle, we can expose specific methods from the child component to the parent component, allowing for more controlled interactions between the components such as focusing on the input field, resetting the input field, and getting the value of the input field in this example. =\u0026gt; By using this approach, we can maintain a clear separation of concerns between the parent and child components, making it easier to manage and update the components independently.\n37. Portals in React Portals in React provide a way to render children components outside the DOM hierarchy of the parent component. This allows you to render a child component at a different location in the DOM, such as at the root level or inside a specific container, without affecting the parent\u0026rsquo;s layout or styles.\nImporting portal from react-dom import { createPortal } from \u0026#39;react-dom\u0026#39;; using createPortal const MyPortal = ({title}) =\u0026gt; { return createPortal( \u0026lt;\u0026gt; \u0026lt;h1\u0026gt;{title}\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;This is a portal\u0026lt;/p\u0026gt; \u0026lt;\u0026gt;, document.getElementById(\u0026#39;portal-root\u0026#39;)); }; =\u0026gt;When the MyPortal component is rendered, the content will be rendered inside the element with the id \u0026lsquo;portal-root\u0026rsquo;, which can be located anywhere in the DOM.\n","permalink":"http://localhost:1313/posts/pages/react/react7/","summary":"Learn about useRef hook, ref forwarding, useImperativeHandle and Portals in React for DOM manipulation and component interactions.","title":"React : Day 7"},{"content":"1. Some Important Concepts 1.1 Parallism vs Concurrency Parallism: Running multiple tasks at the same time. There are multiple Threads or Processes running at the same time. Concurrency: Switching between multiple tasks. When one task is waiting for I/O, another task can run. There is only one Thread or Process running at a time. 1.2 Synchronous vs Asynchronous Synchronous: Code is executed in sequence. Previous task/line must be completed before the next task/line execution starts. Asynchronous: Code is executed in parallel. Tasks can run concurrently. The next task can start before the previous task is completed. 1.3 Blocking vs Non-Blocking Blocking: The execution of the code is blocked until the task is completed. The next task can\u0026rsquo;t start until the previous task is completed. import time def task1(): print(\u0026#34;Task 1 started\u0026#34;) time.sleep(2) print(\u0026#34;Task 1 completed\u0026#34;) def task2(): print(\u0026#34;Task 2 started\u0026#34;) time.sleep(2) print(\u0026#34;Task 2 completed\u0026#34;) task1() task2() Non-Blocking: The excecution of the code is not blocked. The next task can start before the previous task is completed. import asyncio async def task1(): print(\u0026#34;Task 1 started\u0026#34;) await asyncio.sleep(2) print(\u0026#34;Task 1 completed\u0026#34;) async def task2(): print(\u0026#34;Task 2 started\u0026#34;) await asyncio.sleep(2) print(\u0026#34;Task 2 completed\u0026#34;) async def main(): await asyncio.gather(task1(), task2()) asyncio.run(main()) 1.4 I/O Bound vs CPU Bound I/O Bound: The program is waiting for input/output operations to complete. The program is not using the CPU much. CPU Bound: The program is using the CPU a lot. The program is not waiting for input/output operations to complete. import request response = request.get(\u0026#34;https://www.google.com\u0026#34;) # I/O Bound items = response.headers.items() # CPU Bound headers = [f\u0026#39;{key}: {header}\u0026#39; for key, header in items] # CPU Bound formatted_headers = \u0026#39;\\n\u0026#39;.join(headers) # CPU Bound with open(\u0026#39;headers.txt\u0026#39;, \u0026#39;w\u0026#39;) as file: # I/O Bound file.write(formatted_headers) # I/O Bound 2. How Concurrency is Achieved in Os level To better understand this, we’ll need to dive into how sockets work and, in particular, how non-blocking sockets work.\n2.1 Sockets A socket is a low-level abstraction for sending and receiving data over a network. It is the basis for how data is transferred to and from servers. Sockets support two main operations: sending bytes and receiving bytes. We write bytes to a socket, which will then get sent to a remote address, typically some type of server. Once we’ve sent those bytes, we wait for the server to write its response back to our socket. Once these bytes have been sent back to our socket, we can then read the result.\nIn the case of getting the contents from example.com as we saw earlier, we open a socket that connects to example.com’s server. We then write a request to get the contents to that socket and wait for the server to reply with the result: in this case, the HTML of the web page. We can visualize the flow of bytes to and from the server in figure 1.7\nSockets are blocking by default. Simply put, this means that when we are waiting for a server to reply with data, we halt our application or block it until we get data to read. Thus, our application stops running any other tasks until we get data from the server, an error happens, or there is a timeout. At the operating system level, we don’t need to do this blocking. Sockets can operate in non-blocking mode. In non-blocking mode, when we write bytes to a socket, we can just fire and forget the write or read, and our application can go on to perform other tasks. Later, we can have the operating system tell us that we received bytes and deal with it at that time. This lets the application do any number of things while we wait for bytes to come back to us. Instead of blocking and waiting for data to come to us, we become more reactive, letting the operating system inform us when there is data for us to act on. In the background, this is performed by a few different event notification systems, depending on which operating system we’re running. asyncio is abstracted enough that it switches between the different notification systems, depending on which one our operating system supports. The following are the event notification systems used by specific operating systems:\nkqueue—FreeBSD and MacOS epoll—Linux IOCP (I/O completion port)—Windows These systems keep track of our non-blocking sockets and notify us when they are ready for us to do something with them. This notification system is the basis of how asyncio can achieve concurrency.\nBut how do we keep track of multiple tasks that are waiting for data to come back to them? This is where the event loop comes in.\n2.2 Event Loop The event loop is the core of every asyncio application. In asyncio, the event loop keeps a queue of tasks.\n2.2.1 How the Event Loop Works The event loop works by keeping a queue of tasks instead of messages. Each task is a coroutine. When a task is added to the event loop, it will execute until it encounters an I/O operation (such as a web request). When a task hits an I/O-bound operation, it pauses and allows the event loop to run other tasks that are not waiting for I/O operations to complete. 2.2.2 Understanding Event Loops in Asynchronous Programming When working with event loops in asynchronous programming, the process can be understood as a sequence of steps that efficiently handle tasks without blocking the execution. Here\u0026rsquo;s a breakdown of how it works:\n2.2.2.1 Creating the Event Loop When an event loop is created, an empty queue of tasks is initialized. This queue will hold all the tasks that need to be executed.\n2.2.2.2 Adding Tasks to the Queue We add tasks to the event loop’s queue. These tasks are executed one at a time, based on their order in the queue.\n2.2.2.3 Processing Tasks Iteratively Each iteration of the event loop checks for tasks that need to be executed. It processes tasks sequentially, running them one by one.\n2.2.2.4 Handling I/O Operations If a task encounters an I/O operation (like reading from a file or making a network request), it cannot proceed immediately. In this case, the task is paused and put on hold.\n2.2.2.5 Pausing and Waiting for I/O Completion When a task is paused, the event loop instructs the operating system to monitor any associated sockets or resources for I/O completion. During this time, the event loop continues checking for and executing other tasks.\n2.2.2.6 Waking Up Paused Tasks On each iteration of the event loop, we check if any of the I/O operations have completed. If they have:\nThe paused task is woken up. The task resumes execution and completes its process. 2.2.2.7. Conclusion This cycle of pausing, waiting for I/O, and resuming tasks allows the event loop to run multiple tasks concurrently, making it an efficient way to handle asynchronous operations without blocking the program.\nBy continuously iterating and checking for completed I/O tasks, the event loop ensures that no task is left idle while waiting for I/O operations, enabling a smooth and efficient workflow.\nVisualizing the Event Loop with Asynchronous Tasks We can visualize how the event loop works with asynchronous tasks as shown in Figure 1.9: the main thread submits tasks to the event loop, which then runs them. When a task encounters an I/O operation, it pauses and allows other tasks to run. Once the I/O operation is complete, the paused task is resumed.\nExample: Submitting Multiple Asynchronous Tasks Let\u0026rsquo;s consider three tasks that each make an asynchronous web request. These tasks consist of:\nCPU-bound setup: Some code that prepares data for the web request. I/O-bound web request: The asynchronous part where we send the web request. CPU-bound post-processing: After the web request completes, we do some more CPU-intensive work. Now, let\u0026rsquo;s submit these tasks to the event loop simultaneously. Here’s how we can write this in pseudocode:\ndef make_request(): cpu_bound_setup() io_bound_web_request() cpu_bound_postprocess() task_one = make_request() task_two = make_request() task_three = make_request() First task starts executing code, and the other two are left waiting to run. Once the CPU-bound setup work is finished in Task 1, it hits an I/O-bound operation and will pause itself to say, “I’m waiting for I/O; any other tasks waiting to run can run.” Once this happens, Task 2 can begin executing. Task 2 starts its CPU-bound code and then pauses, waiting for I/O. At this time both Task 1 and Task 2 are waiting concurrently for their network request to complete. Since Tasks 1 and 2 are both paused waiting for I/O, we start running Task 3. Now imagine once Task 3 pauses to wait for its I/O to complete, the web request for Task 1 has finished. We’re now alerted by our operating system’s event notification system that this I/O has finished. We can now resume executing Task 1 while both Task 2 and Task 3 are waiting for their I/O to finish. In figure 1.10, we show the execution flow of the pseudocode we just described. If we look at any vertical slice of this diagram, we can see that only one CPU-bound piece of work is running at any given time; however, we have up to two I/O-bound operations happening concurrently. This overlapping of waiting for I/O per each task is where the real time savings of asyncio comes in.\n","permalink":"http://localhost:1313/posts/pages/asyncio/asyncio1/","summary":"An introduction to asynchronous programming in Python using asyncio.","title":"Async io : Async io Intro (Day 1)"},{"content":"34.Styling in CSS 34.1 Setting Inline Styles =\u0026gt; In react for inline styles we use the style attribute and pass an object with camelCase properties.\nimport React from \u0026#39;react\u0026#39;; const myStyle = { color: \u0026#39;blue\u0026#39;, backgroundColor: \u0026#39;yellow\u0026#39; } const MyComponent = () =\u0026gt; { return ( \u0026lt;div style={myStyle}\u0026gt; \u0026lt;h1\u0026gt;Inline Styles\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ) } or we can use the style attribute directly in the element.\nimport React from \u0026#39;react\u0026#39;; const MyComponent = () =\u0026gt; { return ( \u0026lt;div style={{color: \u0026#39;blue\u0026#39;, backgroundColor: \u0026#39;yellow\u0026#39;}}\u0026gt; \u0026lt;h1\u0026gt;Inline Styles\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ) } 34.2 Setting External Styles =\u0026gt; We can also use external CSS files in react. We can import the CSS file in the component file and use the class name in the\nimport React from \u0026#39;react\u0026#39;; import \u0026#39;./MyComponent.css\u0026#39;; const MyComponent = () =\u0026gt; { return ( \u0026lt;div className=\u0026#34;myStyle\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;External Styles\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ) } 34.3 Setting Inline Dynamic Styles =\u0026gt;You can also set the inline styles dynamically by using the state.\nimport React,{useState} from \u0026#39;react\u0026#39;; const App=()=\u0026gt;{ const [valid,setValid]=useState(true); function changeStyle(){ setValid(!valid); } const myStyle={ color:valid?\u0026#39;blue\u0026#39;:\u0026#39;red\u0026#39;, backgroundColor:valid?\u0026#39;yellow\u0026#39;:\u0026#39;green\u0026#39; } return( \u0026lt;div\u0026gt; \u0026lt;button onClick={changeStyle}\u0026gt;Change Style\u0026lt;/button\u0026gt; \u0026lt;div style={myStyle}\u0026gt; \u0026lt;h1\u0026gt;Inline Dynamic Styles\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) } export default App; or we can use the style attribute directly in the element.\nimport React,{useState} from \u0026#39;react\u0026#39;; const App=()=\u0026gt;{ const [valid,setValid]=useState(true); function changeStyle(){ setValid(!valid); } return( \u0026lt;div\u0026gt; \u0026lt;button onClick={changeStyle}\u0026gt;Change Style\u0026lt;/button\u0026gt; \u0026lt;div style={{color:valid?\u0026#39;blue\u0026#39;:\u0026#39;red\u0026#39;,backgroundColor:valid?\u0026#39;yellow\u0026#39;:\u0026#39;green\u0026#39;}}\u0026gt; \u0026lt;h1\u0026gt;Inline Dynamic Styles\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) } export default App; 34.4 Setting Css Classes Dynamically =\u0026gt; We can also set the CSS classes dynamically by using the state.\nimport React,{useState} from \u0026#39;react\u0026#39;; import \u0026#39;./MyComponent.css\u0026#39;; const App=()=\u0026gt;{ const [valid,setValid]=useState(true); const [active,setActive]=useState(true); function changeStyle(){ setValid(!valid); setActive(!active); } return( \u0026lt;div\u0026gt; \u0026lt;button onClick={changeStyle}\u0026gt;Change Style\u0026lt;/button\u0026gt; \u0026lt;div className={`div-control ${valid?\u0026#39;right\u0026#39;:\u0026#39;wrong\u0026#39;} ${active?\u0026#39;active\u0026#39;:\u0026#39;inactive\u0026#39;}`}\u0026gt; \u0026lt;h1\u0026gt;Setting Css Classes Dynamically\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) } export default App; 34.5 Css modules =\u0026gt; Every time we import Css file in react component they are regarded as global styles i.e One component style can affect another component style =\u0026gt;So, to avoid this we can use CSS modules. CSS modules are local by default. We can use CSS modules by naming the CSS file as filename.module.css. =\u0026gt; The CSS file is imported in the component file and the class name is used as an object.\nProblem1 =\u0026gt; Imagine that you have two components with the same class name. The styles of one component can affect the styles of another component.which is not good for the application to solve this problem we can use CSS modules.\nStructure of the project\nsrc\r|_components\r|_MyComponent\r|_MyComponent.js\r|_MyComponent.module.css Step 1: Create a CSS file with the name MyComponent.module.css\n.myStyle{ color: blue; background-color: yellow; } .right{ text-align: right; } Step 2: Import the CSS file in the component file as shown below.\nimport React from \u0026#39;react\u0026#39;; import styles from \u0026#39;./MyComponent.module.css\u0026#39;; step 3: Use the class name as shown below.\nconst MyComponent = () =\u0026gt; { return ( \u0026lt;div className={styles.myStyle}\u0026gt; \u0026lt;h1\u0026gt;CSS Modules\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ) } Combined code\nimport React from \u0026#39;react\u0026#39;; import styles from \u0026#39;./MyComponent.module.css\u0026#39;; const MyComponent = () =\u0026gt; { return ( \u0026lt;div className={styles.myStyle}\u0026gt; \u0026lt;h1\u0026gt;CSS Modules\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ) } export default MyComponent; 34.5.1 Combining multiple classes import React from \u0026#39;react\u0026#39;; import styles from \u0026#39;./MyComponent.module.css\u0026#39;; const MyComponent = () =\u0026gt; { return ( \u0026lt;div className={`${styles.myStyle} ${styles.right}`}\u0026gt; \u0026lt;h1\u0026gt;CSS Modules\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ) } export default MyComponent; 34.6 Dynamic CSS Modules =\u0026gt; We can also set the CSS classes dynamically by using the state.\nimport React,{useState} from \u0026#39;react\u0026#39;; import styles from \u0026#39;./MyComponent.module.css\u0026#39;; const MyComponent = () =\u0026gt; { const [valid,setValid]=useState(true); const [active,setActive]=useState(true); function changeStyle(){ setValid(!valid); setActive(!active); } return ( \u0026lt;div className={`${styles.myStyle} ${valid?styles.right:styles.wrong} ${active?styles.active:styles.inactive}`}\u0026gt; \u0026lt;h1\u0026gt;CSS Modules\u0026lt;/h1\u0026gt; \u0026lt;button onClick={changeStyle}\u0026gt;Change Style\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } export default MyComponent; ","permalink":"http://localhost:1313/posts/pages/react/react5/","summary":"Learn various methods to style React components including inline styles, external styles, dynamic styles, and CSS modules.","title":"React : Day 5"},{"content":"35. Debugging in react 35.1 Using console.log import React from \u0026#39;react\u0026#39;; const MyComponent = () =\u0026gt; { const name = \u0026#39;John Doe\u0026#39;; console.log(name); return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Debugging in React\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ) } export default MyComponent; 35.2 Strict Mode =\u0026gt; In Strict Mode,React will render components twice. It helps to idenify the issues in the code.\nimport React,{StrictMode} from \u0026#39;react\u0026#39;; const MyComponent = () =\u0026gt; { const name = \u0026#39;John Doe\u0026#39;; console.log(name); return ( \u0026lt;StrictMode\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Debugging in React\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/StrictMode\u0026gt; ) } export default MyComponent; You can wrap any component in StrictMode.Just difference is that it will render the component twice.\n=\u0026gt; We can wrap the entire application in StrictMode in the index.js file.\nimport React,{StrictMode} from \u0026#39;react\u0026#39;; import ReactDOM from \u0026#39;react-dom\u0026#39;; import App from \u0026#39;./App\u0026#39;; ReactDOM.render( \u0026lt;StrictMode\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/StrictMode\u0026gt;, document.getElementById(\u0026#39;root\u0026#39;) ); 35.3 React Developer Tools React Developer Tools is a Chrome extension that allows you to inspect the React component hierarchy in the Chrome Developer Tools. Videos\n","permalink":"http://localhost:1313/posts/pages/react/react6/","summary":"Learn how to debug React applications using console.log, Strict Mode, and React Developer Tools.","title":"React : Day 6"},{"content":"Python Fundamentals: A Beginner\u0026rsquo;s Guide (Part 1) 1. Virtual Environment A virtual environment is a feature in Python that allows you to install the same package with different versions on the same system. This enables you to work on multiple projects using different versions of the same package.\n1.1. Installing venv The venv module is included in the Python standard library, so you don\u0026rsquo;t need to install it separately. However, if you are using an older version of Python (before 3.3), you can install virtualenv using pip:\npip install virtualenv 1.2. Creating a Virtual Environment To create a virtual environment, you can use the venv module, which is included in the Python standard library. Here\u0026rsquo;s how you can create a virtual environment named myenv:\npython -m venv myenv This command creates a new directory named myenv that contains the necessary files for the virtual environment.\n1.3. Activating a Virtual Environment To activate the virtual environment, you may run the following command:\n# For Linux/Mac: source myenv/bin/activate # For Windows: myenv\\Scripts\\activate 2. Python Packages 2.1. List All the Python Packages To list or save all the installed packages in the current environment, you can use the following command using freeze:\npip freeze # To list all the installed packages pip freeze \u0026gt; requirements.txt # To save all the installed packages in a file 2.2. Installing Python Packages To install a Python package, you can use the pip install command followed by the package name. For example, to install the requests package, you can run:\npip install requests 2.3. Uninstalling Python Packages To uninstall a Python package, you can use the pip uninstall command followed by the package name. For example, to uninstall the requests package, you can run:\npip uninstall requests 2.4. Run Python Package/Script To run a python package or script, you can use the following command:\npython -m package_name 3. Python Basics 3.1. Running a Python Script To run a Python script, you can use the following command:\npython script.py 3.2. Python Indentation In Python, the code block (body of the function, loop, etc.) starts with a colon (:) and the line following the colon should be indented.\nif 5 \u0026gt; 2: print(\u0026#34;Five is greater than two!\u0026#34;) # Indented block 3.3. Python Comments There are two types of comments in Python:\n# This is a single line comment \u0026#34;\u0026#34;\u0026#34; This is a multiline comment This is a multiline comment This is a multiline comment This is a multiline comment \u0026#34;\u0026#34;\u0026#34; 3.4. Print Statement The print() function is used to display the output on the console. For example:\nprint(\u0026#34;Hello, World!\u0026#34;) 3.5. Data Types Python has the following data types:\nint float str bool list tuple set dict None a = 10 # int b = 10.5 # float c = \u0026#34;Hello\u0026#34; # str d = True # bool e = [1,2,3] # list f = (1,2,3) # tuple g = {1,2,3} # set h = {\u0026#34;name\u0026#34;:\u0026#34;John\u0026#34;,\u0026#34;age\u0026#34;:30} # dict i = None # None print(type(a)) # \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; Note:Use type() function to check the data type of a variable.As it return the class of the variable.\n3.6. Rules of Variable Declaration A variable name must start with a letter or the underscore character. A variable name cannot start with a number. A variable name can only contain alpha-numeric characters and underscores (A-z, 0-9, and _ ). Variable names are case-sensitive (age, Age, and AGE are three different variables). 3.7. Type Conversion You can convert one data type to another using the following functions:\nint(): To convert to an integer float(): To convert to a float str(): To convert to a string bool(): To convert to a boolean list(): To convert to a list tuple(): To convert to a tuple set(): To convert to a set dict(): To convert to a dictionary a = 10 #a=10 b = float(a) #b=10.0 c = str(a) #c=\u0026#39;10\u0026#39; d = bool(a) #d=True e = list(c) #e=[\u0026#39;1\u0026#39;,\u0026#39;0\u0026#39;] f = tuple(c) #f=(\u0026#39;1\u0026#39;,\u0026#39;0\u0026#39;) g = set(c) #g={\u0026#39;1\u0026#39;,\u0026#39;0\u0026#39;} h = dict(name=\u0026#34;John\u0026#34;,age=30) or dict([(\u0026#34;name\u0026#34;,\u0026#34;John\u0026#34;),(\u0026#34;age\u0026#34;,30)]) #h={\u0026#39;name\u0026#39;:\u0026#39;John\u0026#39;,\u0026#39;age\u0026#39;:30} Note: Python is dynamically typed, which means a variable\u0026rsquo;s data type can be changed.\n4. Operators 4.1. Arithmetic Operators +: Addition -: Subtraction *: Multiplication /: Division %: Modulus **: Power //: Floor Division a = 10 b = 3 print(a + b) # 13 print(a - b) # 7 print(a * b) # 30 print(a / b) # 3.3333333333333335 print(a % b) # 1 print(a ** b) # 1000 print(a // b) # 3 4.2. Assignment Operators =: Assign value +=: Add and assign -=: Subtract and assign *=: Multiply and assign /=: Divide and assign %=: Modulus and assign **=: Power and assign //=: Floor Division and assign a = 10 a += 5 # a = a + 5 a -= 5 # a = a - 5 a *= 5 # a = a * 5 a /= 5 # a = a / 5 a %= 5 # a = a % 5 a **= 5 # a = a ** 5 a //= 5 # a = a // 5 4.3. Comparison Operators ==: Equal to !=: Not equal to \u0026gt;: Greater than \u0026lt;: Less than \u0026gt;=: Greater than or equal to \u0026lt;=: Less than or equal to a = 10 b = 20 print(a == b) # False print(a != b) # True print(a \u0026gt; b) # False print(a \u0026lt; b) # True print(a \u0026gt;= b) # False print(a \u0026lt;= b) # True 4.4. Logical Operators and: Returns True if both statements are true or: Returns True if one of the statements is true not: Reverse the result, returns False if the result is true a = 10 b = 20 c = 30 print(a \u0026lt; b and b \u0026lt; c) # True print(a \u0026lt; b or b \u0026gt; c) # True print(not(a \u0026lt; b and b \u0026lt; c)) # False 4.5. Identity Operators is: Returns True if both variables are the same object is not: Returns True if both variables are not the same object a = [1,2,3] b = [1,2,3] print(a is b) # False print(a is not b) # True 4.6. Membership Operators in: Returns True if a sequence with the specified value is present in the object not in: Returns True if a sequence with the specified value is not present in the object a = [1,2,3] #Can be used in list , tuple , set , dict, string print(1 in a) # True print(4 not in a) # True 4.7. Bitwise Operators \u0026amp;: AND |: OR ^: XOR ~: NOT \u0026lt;\u0026lt;: Left Shift \u0026gt;\u0026gt;: Right Shift a = 10 b = 4 print(a \u0026amp; b) # 0 print(a | b) # 14 print(a ^ b) # 14 print(~a) # -11 print(a \u0026lt;\u0026lt; 2) # 40 print(a \u0026gt;\u0026gt; 2) # 2 Note: is vs ==\nis is used to compare the memory location of two objects. == is used to compare the values of two objects. # For Mutable objects (list, dict, set): a = [1,2,3] b = [1,2,3] print(a == b) # True print(a is b) # False # For immutable objects (int, float, string, tuple, None): a = 10 b = 10 print(a == b) # True print(a is b) # True c = None d = None print(c == d) # True print(c is d) # True 5.Taking User Input In Python, you can take user input using the input() function. Here\u0026rsquo;s an example:\nname = input(\u0026#34;Enter your name: \u0026#34;) print(\u0026#34;Hello, \u0026#34; + name) Note: The input() function always returns a string. If you want to convert it to another data type, you can use type conversion functions like int(), float(), etc.\n","permalink":"http://localhost:1313/posts/pages/python/python_basics/","summary":"A comprehensive guide to Python programming fundamentals covering core concepts for beginners","title":"Python Fundamentals: A Beginner's Guide (Part 1)"},{"content":"30. Sharing State Between React Components: Lifting State Up In React, components are the building blocks of a user interface. Each component can have its own state, but there are situations where multiple components need to share the same state. In such cases, the concept of \u0026ldquo;lifting state up\u0026rdquo; is used to manage the shared state in a common ancestor component.\u0026ldquo;Lifting state up\u0026rdquo; is a common pattern in React used when two or more components need to share data or state. Instead of managing the state in one of the components and creating a dependency between them, the state is \u0026ldquo;lifted up\u0026rdquo; to the closest common ancestor of the components that need the state.\nKey Concept When multiple components need to interact with the same state:\nThe closest common ancestor is identified. The state is moved to this common ancestor. This ancestor manages the state and passes it down to the child components as props. If any child needs to modify the state, the ancestor provides a function (passed as a prop) to handle the state update. Step-by-Step Procedure and Syntax Identify the Closest Common Ancestor:\nDetermine which component is the nearest common parent of all components that need to share the state. Lift the State Up:\nMove the state to the identified ancestor component. Use the useState hook (or class component state) to manage the state. const [state, setState] = useState(initialValue); Pass State Down as Props:\nPass the state to child components that need it via props. \u0026lt;ChildComponent state={state} /\u0026gt; Create State-Modifier Functions:\nDefine functions in the ancestor component to modify the state. const modifyStateHandler = (newData) =\u0026gt; { setState((prev) =\u0026gt; ({ ...prev, newData })); }; Pass Modifier Functions to Children:\nPass these functions to the child components as props so they can trigger state updates. \u0026lt;ChildComponent onModifyState={modifyStateHandler} /\u0026gt; Use Props in Child Components:\nAccess and use the state and modifier functions passed as props in the child components. function ChildComponent({ state, onModifyState }) { return ( \u0026lt;button onClick={() =\u0026gt; onModifyState(\u0026#34;new data\u0026#34;)}\u0026gt;Modify State\u0026lt;/button\u0026gt; ); } Example (Sharing State/Data Between Two Child Component) Parent Component (App.js) The parent component will hold the shared state and provide functions for updating it. It will pass the state and update functions as props to the child components.\nimport React, { useState } from \u0026#34;react\u0026#34;; import ChildOne from \u0026#34;./ChildOne\u0026#34;; import ChildTwo from \u0026#34;./ChildTwo\u0026#34;; const App = () =\u0026gt; { // Shared state const [sharedState, setSharedState] = useState(\u0026#34;Initial State\u0026#34;); // Function to update the state const updateState = (newState) =\u0026gt; { setSharedState(newState); }; return ( \u0026lt;div style={{ padding: \u0026#34;20px\u0026#34;, fontFamily: \u0026#34;Arial\u0026#34; }}\u0026gt; \u0026lt;h1\u0026gt;Parent Component\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;Shared State: {sharedState}\u0026lt;/p\u0026gt; \u0026lt;hr /\u0026gt; \u0026lt;ChildOne sharedState={sharedState} updateState={updateState} /\u0026gt; \u0026lt;hr /\u0026gt; \u0026lt;ChildTwo sharedState={sharedState} updateState={updateState} /\u0026gt; \u0026lt;/div\u0026gt; ); }; export default App; Child Component 1 (ChildOne.js) This component will display the shared state and allow the user to modify it through an input field.\nimport React from \u0026#34;react\u0026#34;; const ChildOne = ({ sharedState, updateState }) =\u0026gt; { const handleChange = (e) =\u0026gt; { updateState(e.target.value); }; return ( \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;Child Component One\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;Shared State: {sharedState}\u0026lt;/p\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; value={sharedState} onChange={handleChange} placeholder=\u0026#34;Update State\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; ); }; export default ChildOne; Child Component 2 (ChildTwo.js) This component will display the shared state and provide a button to reset it.\nimport React from \u0026#34;react\u0026#34;; import React from \u0026#34;react\u0026#34;; const ChildTwo = ({ sharedState, updateState }) =\u0026gt; { const handleReset = () =\u0026gt; { updateState(\u0026#34;Initial State\u0026#34;); }; return ( \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;Child Component Two\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;Shared State: {sharedState}\u0026lt;/p\u0026gt; \u0026lt;button onClick={handleReset}\u0026gt;Reset State\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); }; export default ChildTwo; Folder Structure src/ ├── App.js ├── ChildOne.js ├── ChildTwo.js ├── index.js Explanation:\nThe App component is the parent component that holds the shared state and passes it down to ChildOne and ChildTwo. ChildOne and ChildTwo are child components that receive the shared state and update functions as props. ChildOne allows the user to update the shared state through an input field, while ChildTwo provides a button to reset the state. Note: We cant directly pass data from one child component to another child component. We need to pass the data to the parent component and then pass it to the other child component. This is called lifting state up.\nExample (Sharing State/Data Between Two Sibling Components) Parent Component (App.js) import {usState} from \u0026#39;react\u0026#39;; import Expenses from \u0026#39;./Expenses\u0026#39;; import NewExpense from \u0026#39;./NewExpense\u0026#39;; const App=()=\u0026gt;{ const [expenses,setExpenses]=useState([ {id:1,title:\u0026#39;Car Insurance\u0026#39;,amount:294.67,date:new Date(2021,2,28)}, {id:2,title:\u0026#39;Health Insurance\u0026#39;,amount:394.67,date:new Date(2021,3,28)}, {id:3,title:\u0026#39;Home Insurance\u0026#39;,amount:494.67,date:new Date(2021,4,28)}, ]); const addExpenseHandler=(expense)=\u0026gt;{ setExpenses((prevExpenses)=\u0026gt;{ return [expense,...prevExpenses]; }); }; return ( \u0026lt;div\u0026gt; \u0026lt;NewExpense onAddExpense={addExpenseHandler}/\u0026gt; \u0026lt;Expenses items={expenses}/\u0026gt; \u0026lt;/div\u0026gt; ); }; export default App; NewExpense Component import ExpenseForm from \u0026#39;./ExpenseForm\u0026#39;; const NewExpense=(props)=\u0026gt;{ const saveExpenseDataHandler=(enteredExpenseData)=\u0026gt;{ const expenseData={ ...enteredExpenseData, id:Math.random().toString() }; props.onAddExpense(expenseData); }; return ( \u0026lt;div\u0026gt; \u0026lt;ExpenseForm onSaveExpenseData={saveExpenseDataHandler}/\u0026gt; \u0026lt;/div\u0026gt; ); }; export default NewExpense; Expenses function Expenses({iteam}){ return ( \u0026lt;\u0026gt; {items.map((expense)=\u0026gt;( \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;{expense.title}\u0026lt;/h2\u0026gt; \u0026lt;div\u0026gt;{expense.amount}\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;{expense.date.toISOString()}\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ))} \u0026lt;/div\u0026gt; ) } 31. Dynamically setting object keys In JavaScript, object keys are usually set statically, but there are situations where you may need to set object keys dynamically based on some conditions or variables. This can be achieved using the square bracket notation ([]) to set object keys dynamically.\nfor example:\nconst data=\u0026#34;name\u0026#34;; const person={ [data]:\u0026#39;John\u0026#39; }; console.log(person); // {name:\u0026#39;John\u0026#39;} If we dont use square bracket notation, then the key will be set as \u0026lsquo;data\u0026rsquo; instead of \u0026rsquo;name\u0026rsquo;.\nconst data=\u0026#34;name\u0026#34;; const person={ data:\u0026#39;John\u0026#39; }; console.log(person); // {data:\u0026#39;John\u0026#39;} 32.Using SAme State Variable to store multiple values =\u0026gt; We can use the same state variable to store multiple values by using an object.\nconst [userInput,setUserInput]=useState({ enteredTitle:\u0026#39;\u0026#39;, enteredAmount:\u0026#39;\u0026#39;, enteredDate:\u0026#39;\u0026#39; }); const titleChangeHandler=(event)=\u0026gt;{ setUserInput({ ...userInput, enteredTitle:event.target.value }); }; const amountChangeHandler=(event)=\u0026gt;{ setUserInput({ ...userInput, enteredAmount:event.target.value }); }; const dateChangeHandler=(event)=\u0026gt;{ setUserInput({ ...userInput, enteredDate:event.target.value }); }; return ( \u0026lt;div\u0026gt; Title:\u0026lt;input type=\u0026#34;text\u0026#34; value={userInput.enteredTitle} onChange={titleChangeHandler}/\u0026gt; Amount:\u0026lt;input type=\u0026#34;number\u0026#34; value={userInput.enteredAmount} onChange={amountChangeHandler}/\u0026gt; Date:\u0026lt;input type=\u0026#34;date\u0026#34; value={userInput.enteredDate} onChange={dateChangeHandler}/\u0026gt; The entered title is {userInput.enteredTitle} The entered amount is {userInput.enteredAmount} The entered date is {userInput.enteredDate} \u0026lt;/div\u0026gt; ); =\u0026gt; In the above code, we are using the same state variable userInput to store multiple values. We are using an object to store the values. We are using the spread operator to copy the existing values of the object and then updating the required value.\n33.Handeling page reloads when a form is submitted When a form is submitted, the page reloads by default. This is not what we want in a single page application. We want to stay on the same page and update the content of the page. We can do this by using the preventDefault() method on the event object. The preventDefault() method prevents the default behavior of the event object. In this case, it prevents the page from reloading when the form is submitted. const submitHandler=(event)=\u0026gt;{ event.preventDefault(); // code to handle form submission }; ","permalink":"http://localhost:1313/posts/pages/react/react4/","summary":"Learn how to share state between React components by lifting state up to a common ancestor.","title":"React : Day 4"},{"content":"1. Python Manupulation of Data Types We have already discussed the basic concepts of Python programming in the previous part of this series. In this part, we will dive deeper into operations and manipulations of different data types in Python.\n1.1.Numeric Operations 1.1.1. abs() Function The abs() function returns the absolute value of a number. For example:\nnum = -10 print(abs(num)) # Output: 10 1.1.2. round() Function The round() function rounds a number to the nearest integer. For example:\nnum = 3.14159 print(round(num)) # Output: 3 1.1.3. ord() Function The ord() function returns the Unicode code point of a character. For example:\nchar = \u0026#39;A\u0026#39; print(ord(char)) # Output: 65 1.2. String Operations String is a sequence of characters enclosed within single, double, or triple quotes. In Python, strings are immutable, meaning they cannot be changed once created. Here are some common string operations:\n1.2.1. Declaring a String we can declare a string using single, double, or triple quotes. For example:\nstr1 = \u0026#39;Hello, World!\u0026#39; #for single line string str2 = \u0026#34;Hello, World!\u0026#34; #for single line string str3 = \u0026#39;\u0026#39;\u0026#39;Hello, World! This is a multiline string.\u0026#39;\u0026#39;\u0026#39;#for multiline string 1.2.2. Text Decorators There are many text decorators available in Python to format strings among them we use \\n for a new line, \\t for a tab. For example:\nstr1 = \u0026#39;Hello, \\nWorld!\u0026#39; #for new line str2 = \u0026#34;Hello, \\tWorld!\u0026#34; #for tab 1.2.3. String Indexing The indexing of a string starts from 0 to n-1, where n is the length of the string. For example: for example: a=\u0026ldquo;hello\u0026rdquo;\na = H e l l o 0 1 2 3 4 0 -4 -3 -2 -1 1.2.4. Ascessing Characters in a String We can access characters in a string using the index using []. For example:\nstr = \u0026#34;Hello, World!\u0026#34; print(str[0]) # Output: H print(str[-1]) # Output: ! 1.2.5. String Concatenation We can concatenate two strings using the + operator and * operator . For example:\nstr1 = \u0026#34;Hello\u0026#34; str2 = \u0026#34;World\u0026#34; print(str1 + str2) # Output: HelloWorld print(str1 * 3) # Output: HelloHelloHello 1.2.6. String Slicing We can slice a string using the syntax variable[start:end:step] to get a substring.\nNote: The substring contains characters from index start to end-1, meaning the character at the end index is not included but character at the start index is included . The step refers to the increment or jump of the index\nFor example:\na = \u0026#34;hello\u0026#34; # Slice from index 1 to the end of the string print(a[1:]) # ello (Characters from index 1 to the end) # Slice from the beginning of the string to index 4 (doesn\u0026#39;t contain character at index 4) print(a[:4]) # hell (Characters from index 0 to 3) # Slice from index 1 to index 4 (doesn\u0026#39;t contain character at index 4) print(a[1:4]) # ell (Characters from index 1 to 3) # Full slice of the string with default values print(a[::]) # hello (Default start is 0, end is the string length, step is 1) # Defining a step value in slicing # Slice with a step of 2 print(a[::2]) # hlo (Start from index 0 to the end, select every 2nd character) # Reverse the string using a negative step print(a[::-1]) # olleh (Reverse the string by stepping backward) # Combining start, end, and step print(a[1:4:2]) # el #(Start from index 1 to 4 (doesn\u0026#39;t contain character at index 4), with a step of 2) 1.2.7. String Methods Python provides various built-in methods to manipulate strings. Some of the commonly used string methods are:\nlen() : Returns the length of the string. str = \u0026#34;Hello, World!\u0026#34; print(len(str)) # Output: 13 replace() : Replaces a substring with another substring. str = \u0026#34;Hello, World!\u0026#34; print(str.replace(\u0026#34;World\u0026#34;, \u0026#34;Universe\u0026#34;)) # Output: Hello, Universe! upper() : Converts the string to uppercase. str = \u0026#34;Hello, World!\u0026#34; print(str.upper()) # Output: HELLO, WORLD! lower() : Converts the string to lowercase. str = \u0026#34;Hello, World!\u0026#34; print(str.lower()) # Output: hello, world! split() : Splits the string into a list based on the delimiter. str = \u0026#34;Hello, World!\u0026#34; print(str.split(\u0026#34;,\u0026#34;)) # Output: [\u0026#39;Hello\u0026#39;, \u0026#39; World!\u0026#39;] capitalize() : Converts the first character of the string to uppercase.\nstr = \u0026#34;hello, world!\u0026#34; print(str.capitalize()) # Output: Hello, world! -find() : Returns the index of the first occurrence of a substring.\nstr = \u0026#34;Hello, World!\u0026#34; print(str.find(\u0026#34;World\u0026#34;)) # Output: 7 print(str.find(\u0026#34;e\u0026#34;)) # Output: 1 print(str.find(\u0026#34;Universe\u0026#34;)) # Output: -1 count() : Returns the number of occurrences of a substring. str = \u0026#34;Hello, World!\u0026#34; print(str.count(\u0026#34;l\u0026#34;)) # Output: 3 startswith() : Returns True if the string starts with a specified substring. str = \u0026#34;Hello, World!\u0026#34; print(str.startswith(\u0026#34;Hello\u0026#34;)) # Output: True endswith() : Returns True if the string ends with a specified substring. str = \u0026#34;Hello, World!\u0026#34; print(str.endswith(\u0026#34;World!\u0026#34;)) # Output: True strip() : Removes leading and trailing whitespaces from the string. We can also specify the characters to be removed. str = \u0026#34; Hello, World! \u0026#34; print(str.strip()) # Output: Hello, World! str = \u0026#34;!!!!!!!!Hello, World!!!!!\u0026#34; print(str.strip(\u0026#34;!\u0026#34;)) # Output: Hello, World! lstrip() : Removes leading whitespaces from the string.we can also specify the characters to be removed. str = \u0026#34; Hello, World! \u0026#34; print(str.lstrip()) # Output: Hello, World! str = \u0026#34;!!!!!!!!Hello, World!!!!!\u0026#34; print(str.lstrip(\u0026#34;!\u0026#34;)) # Output: Hello, World!!!!! rstrip() : Removes trailing whitespaces from the string.We can also specify the characters to be removed. str = \u0026#34; Hello, World! \u0026#34; print(str.rstrip()) # Output: Hello, World! str = \u0026#34;!!!!!!!!Hello, World!!!!!\u0026#34; print(str.rstrip(\u0026#34;!\u0026#34;)) # Output: !!!!!!!!Hello, World 1.2.8. f-Strings f-strings are a convenient way to format strings in Python. They allow you to embed expressions inside string literals, using curly braces {}. For example:\nname = \u0026#34;Alice\u0026#34; age = 30 print(f\u0026#34;My name is {name} and I am {age} years old.\u0026#34;) # Output: My name is Alice and I am 30 years old. 1.2.9. Raw Strings Raw strings are used to ignore escape characters in a string. They are prefixed with an r or R. For example:\npath=\u0026#34;C:\\Users\\Alice\\Documents\u0026#34; print(path) # Output: C:UsersAliceDocuments path = r\u0026#34;C:\\Users\\Alice\\Documents\u0026#34; print(path) # Output: C:\\Users\\Alice\\Documents Note:String is immutable in python.\na = \u0026#34;Hello\u0026#34; a[0] = \u0026#34;h\u0026#34; # Error: \u0026#39;str\u0026#39; object does not support item assignment #Instead To change the string value we can use the following method a=\u0026#39;k\u0026#39;+a[1::] # Output: \u0026#39;kello\u0026#39; 1.3. List Operations A list is a collection of items enclosed within square brackets []. Lists are mutable, meaning they can be changed after creation. Here are some common list operations: Key Points:\nList is mutable in python. List support indexing and slicing like string 1.3.1. Declaring a List We can declare a list by enclosing items within square brackets []. For example:\nlist1 = [1, 2, 3, 4, 5] list2 = [\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;] list3 = [1, \u0026#34;apple\u0026#34;, True, 3.14] 1.3.2 List Concatenation We can concatenate two or more lists using the + operator. For example:\nlist1 = [1, 2, 3] list2 = [4, 5, 6] print(list1 + list2) # Output: [1, 2, 3, 4, 5, 6] 1.3.3. Mutable property of List List is mutable in python and its example is shown below:\n#for string a = \u0026#34;Hello\u0026#34; a[0] = \u0026#34;h\u0026#34; # Error: \u0026#39;str\u0026#39; object does not support item assignment #for list list1 = [1, 2, 3] list1[0] = 10 print(list1) # Output: [10, 2, 3] 1.3.4. Built-in List Methods Python provides various built-in methods to manipulate lists. Some of the commonly used list methods are:\nlen() : Returns the length of the list. list1 = [1, 2, 3, 4, 5] print(len(list1)) # Output: 5 append() : Adds an element to the end of the list /Change orginal list does not return anything. list1 = [1, 2, 3] list1.append(4) print(list1) # Output: [1, 2, 3, 4] insert() : Inserts an element at a specified position in the list /Change orginal list does not return anything. list1 = [1, 2, 3] list1.insert(1, 4) print(list1) # Output: [1, 4, 2, 3] pop() : Removes the element at the specified position in the list and returns it. If no index is specified, it removes and returns the last element. list1 = [1, 2, 3] print(list1.pop(1)) # Output: 2 print(list1) # Output: [1, 3] print(list1.pop()) # Output: 3 print(list1) # Output: [1] remove() : Removes the first occurrence of the specified element from the list. list1 = [1, 2, 3, 2] list1.remove(2) print(list1) # Output: [1, 3, 2] -sort() : Sorts the list in ascending order.Does not return anything but change the original list.\nlist1 = [3, 1, 2] list1.sort() print(list1) # Output: [1, 2, 3] -reverse() : Reverses the order of the list. Does not return anything but change the original list.\nlist1 = [1, 2, 3] list1.reverse() print(list1) # Output: [3, 2, 1] -count() : Returns the number of occurrences of a specified element in the list.\nlist1 = [1, 2, 3, 2] print(list1.count(2)) # Output: 2 -index() : Returns the index of the first occurrence of the specified element in the list.\nlist1 = [1, 2, 3, 2] print(list1.index(2)) # Output: 1 1.3.5. List Comprehension List comprehension is a concise way to create lists from existing lists. There are 3 type of syntax.\nNot using if list1=[variable for variable in iterable] Using if only list1 = [variable for variable in iterable if condition] Using if else list1 = [variable if condition else variable for variable in iterable] Traditional way of creating list\nlist1 = [] for i in range(5): list1.append(i) print(list1) # Output: [0, 1, 2, 3, 4] Using list comprehension\nlist1 = [i for i in range(5)] print(list1) # Output: [0, 1, 2, 3, 4] list1 = [i for i in range(5) if i%2==0] print(list1) # Output: [0, 2, 4] list1 = [i if i%2==0 else i**2 for i in range(5)] print(list1) # Output: [0, 1, 2, 9, 4] Note: When you attempt to access an index that is out of range, Python will raise an IndexError so put it in try-except block to handle the error.\nNote: The indexing and slicing of list are similar to string.\n1.4 Dictionary Operations A dictionary is a collection of key-value pairs enclosed within curly braces {}. Dictionaries are mutable and unordered. Here are some common dictionary operations:\n1.4.1. Declaring a Dictionary We can declare a dictionary by specifying key-value pairs within curly braces {}. For example:\ndict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} dict2 = {1: \u0026#34;apple\u0026#34;, 2: \u0026#34;banana\u0026#34;, 3: \u0026#34;cherry\u0026#34;} dict3 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;, \u0026#34;hobbies\u0026#34;: [\u0026#34;reading\u0026#34;, \u0026#34;painting\u0026#34;]} 1.4.2. Accessing Dictionary Elements We can access dictionary elements using keys. For example:\ndict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} print(dict1[\u0026#34;name\u0026#34;]) # Output: Alice 1.4.3 Adding Dictionary Elements We can add new key-value pairs to a dictionary by specifying the key and value. For example:\ndict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30} dict1[\u0026#34;city\u0026#34;] = \u0026#34;New York\u0026#34; print(dict1) # Output: {\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 30, \u0026#39;city\u0026#39;: \u0026#39;New York\u0026#39;} 1.4.4. Updating Dictionary Elements We can update the value of an existing key in a dictionary. For example:\ndict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} dict1[\u0026#34;age\u0026#34;] = 35 print(dict1) # Output: {\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 35, \u0026#39;city\u0026#39;: \u0026#39;New York\u0026#39;} 1.4.5 Dictionary Methods Python provides various built-in methods to manipulate dictionaries. Some of the commonly used dictionary methods are:\nlen() : Returns the number of key-value pairs in the dictionary. dict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} print(len(dict1)) # Output: 3 keys() : Returns a list of all the keys in the dictionary. dict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} print(dict1.keys()) # Output: dict_keys([\u0026#39;name\u0026#39;, \u0026#39;age\u0026#39;, \u0026#39;city\u0026#39;]) values() : Returns a list of all the values in the dictionary. dict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} print(dict1.values()) # Output: dict_values([\u0026#39;Alice\u0026#39;, 30, \u0026#39;New York\u0026#39;]) items() : Returns a list of key-value pairs in the dictionary. dict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} print(dict1.items()) # Output: dict_items([(\u0026#39;name\u0026#39;, \u0026#39;Alice\u0026#39;), (\u0026#39;age\u0026#39;, 30), (\u0026#39;city\u0026#39;, \u0026#39;New York\u0026#39;)]) -pop() : Removes the element with the specified key and returns its value.\ndict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} print(dict1.pop(\u0026#34;age\u0026#34;)) # Output: 30 print(dict1) # Output: {\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;city\u0026#39;: \u0026#39;New York\u0026#39;} -get() : Returns the value of the specified key. If the key does not exist, it returns the specified default value.\ndict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} print(dict1.get(\u0026#34;age\u0026#34;)) # Output: 30 print(dict) # Output: {\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 30, \u0026#39;city\u0026#39;: \u0026#39;New York\u0026#39;} Note: When you attempt to access a key that does not exist in the dictionary, Python will raise a KeyError so put it in try-except block to handle the error or use get() method to avoid the error.\n1.4.6. Nested Dictionaries A dictionary can contain another dictionary as a value. This is known as a nested dictionary. For example:\ndict1 = { \u0026#34;person1\u0026#34;: {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30}, \u0026#34;person2\u0026#34;: {\u0026#34;name\u0026#34;: \u0026#34;Bob\u0026#34;, \u0026#34;age\u0026#34;: 25} } print(dict1[\u0026#34;person1\u0026#34;][\u0026#34;name\u0026#34;]) # Output: Alice 1.4.7. Dictionary Comprehension Dictionary comprehension is a concise way to create dictionaries. For example:\ndict1 = {x: x**2 for x in range(5)} # Output: {0: 0, 1: 1, 2: 4, 3: 9, 4: 16} #using if only dict1 = {x: x**2 for x in range(5) if x%2==0} # Output: {0: 0, 2: 4, 4: 16} #using if else dict1 = {x: x**2 if x%2==0 else x**3 for x in range(5)} # Output: {0: 0, 1: 1, 2: 4, 3: 27, 4: 16} 1.5. Tuple Operations A tuple is a collection of items enclosed within parentheses (). Tuples are immutable, meaning they similar to python as they cant be changed using indexing as a[0]=10 will give an error.\n1.5.1. Declaring a Tuple We can declare a tuple by enclosing items within parentheses (). For example:\ntuple1 = (1, 2, 3) tuple2 = (\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;) tuple3 = (1, \u0026#34;apple\u0026#34;, True, 3.14) 1.5.2. Accessing Tuple Elements We can access tuple elements using indexing . For example:\ntuple1 = (1, 2, 3) print(tuple1[0]) # Output: 1 1.5.3. Slice Tuple We can slice a tuple using the syntax variable[start:end:step] to get a sub-tuple. For example:\ntuple1 = (1, 2, 3, 4, 5) print(tuple1[1:4]) # Output: (2, 3, 4) 1.5.4. Tuple Methods Python provides various built-in methods to manipulate tuples. Some of the commonly used tuple methods are:\ncount() : Returns the number of occurrences of a specified element in the tuple. tuple1 = (1, 2, 3, 2) print(tuple1.count(2)) # Output: 2 index() : Returns the index of the first occurrence of the specified element in the tuple. tuple1 = (1, 2, 3, 2) print(tuple1.index(2)) # Output: 1 len() : Returns the length of the tuple. tuple1 = (1, 2, 3, 2) print(len(tuple1)) # Output: 4 1.5.5 concatenation of tuple We can concatenate two or more tuples using the + operator. For example:\ntuple1 = (1, 2, 3) tuple2 = (4, 5, 6) print(tuple1 + tuple2) # Output: (1, 2, 3, 4, 5, 6) 1.5.6. Tuple Unpacking Tuple unpacking allows us to assign multiple variables at once. For example:\ntuple1 = (1, 2, 3) a, b, c = tuple1 d,*e = tuple1 print(a) # Output: 1 print(b) # Output: 2 print(c) # Output: 3 print(d) # Output: 1 print(e) # Output: [2, 3] tuple1 = (1, 2, 3, 4, 5) a, *b, c = tuple1 print(a) # Output: 1 print(b) # Output: [2, 3, 4] print(c) # Output: 5 Note:Ascessing and slicing of tuple is similar to list and string.\n1.6. Boolean Operations Boolean is a data type that represents one of two values: True or False. Boolean values are used to evaluate conditions in programming. Here are some common boolean operations:\n1.6.1. Condition when variable is True When a variable has a non-zero value, it is considered True. a = 10 if a: print(\u0026#34;The value of a is True\u0026#34;) When a string is not empty, it is considered True. a = \u0026#34;Hello\u0026#34; if a: print(\u0026#34;The value of a is True\u0026#34;) When a list is not empty, it is considered True. a = [1, 2, 3] if a: print(\u0026#34;The value of a is True\u0026#34;) When a dictionary is not empty, it is considered True. a = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30} if a: print(\u0026#34;The value of a is True\u0026#34;) When a tuple is not empty, it is considered True. a = (1, 2, 3) if a: print(\u0026#34;The value of a is True\u0026#34;) When a set is not empty, it is considered True. a = {1, 2, 3} if a: print(\u0026#34;The value of a is True\u0026#34;) When a variable is explicitly set to True, it is considered True. a = True if a: print(\u0026#34;The value of a is True\u0026#34;) 1.6.2. Condition when variable is False Those which are not in the above condition are considered as False.\n1.7. Set Operations A set is a collection of unique items enclosed within curly braces {}. Main Uses of set are:\nTo remove duplicate elements from a list. To perform mathematical set operations like union, intersection, difference, etc. 1.7.1. Declaring a Set We can declare a set by enclosing items within curly braces {} or set(). For example:\nset1 = {1, 2, 3} set2 = {\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;} set3 = {1, \u0026#34;apple\u0026#34;, True, 3.14} #using set() set4 = set([1, 2, 3]) set5=set() 1.7.2. Set Methods Python provides various built-in methods to manipulate sets. Some of the commonly used set methods are:\n-len() : Returns the number of elements in the set.\nset1 = {1, 2, 3} print(len(set1)) # Output: 3 -add() : Adds an element to the set.Doesn\u0026rsquo;t return anything.\nset1 = {1, 2, 3} set1.add(4) print(set1) # Output: {1, 2, 3, 4} -clear() : Removes all elements from the set.Doesn\u0026rsquo;t return anything.\nset1 = {1, 2, 3} set1.clear() print(set1) # Output: set() -remove() : Removes the specified element from the set. If the element is not present, it raises an error.\nset1 = {1, 2, 3} set1.remove(2) print(set1) # Output: {1, 3} discard() : Removes the specified element from the set. If the element is not present, it does not raise an error.\nset1 = {1, 2, 3} set1.discard(2) print(set1) # Output: {1, 3} -union() : Returns a set containing the union of two sets.\nset1 = {1, 2, 3} set2 = {3, 4, 5} print(set1.union(set2)) # Output: {1, 2, 3, 4, 5} -intersection() : Returns a set containing the intersection of two sets.\nset1 = {1, 2, 3} set2 = {3, 4, 5} print(set1.intersection(set2)) # Output: {3} -difference() : Returns a set containing the difference between two sets.\nset1 = {1, 2, 3} set2 = {3, 4, 5} print(set1.difference(set2)) # Output: {1, 2} -symmetric_difference() : Returns a set containing the symmetric difference between two sets.\nset1 = {1, 2, 3} set2 = {3, 4, 5} print(set1.symmetric_difference(set2)) # Output: {1, 2, 4, 5} -issubset() : Returns True if all elements of a set are present in another set.\nset1 = {1, 2, 3} set2 = {1, 2, 3, 4, 5} print(set1.issubset(set2)) # Output: True 1.8 Used in All iterable 1.8.1. in Operator The in operator is used to check if an element is present in an iterable. For example:\n# in string str = \u0026#34;Hello, World!\u0026#34; print(\u0026#34;Hello\u0026#34; in str) # Output: True # in list list1 = [1, 2, 3, 4, 5] print(3 in list1) # Output: True # in tuple tuple1 = (1, 2, 3, 4, 5) print(6 in tuple1) # Output: False # in set set1 = {1, 2, 3, 4, 5} print(5 in set1) # Output: True # in dictionary dict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30} print(\u0026#34;name\u0026#34; in dict1) # Output: True 1.8.2. not in Operator The not in operator is used to check if an element is not present in an iterable. For example:\n# not in string str = \u0026#34;Hello, World!\u0026#34; print(\u0026#34;Alice\u0026#34; not in str) # Output: True # not in list list1 = [1, 2, 3, 4, 5] print(6 not in list1) # Output: True # not in tuple tuple1 = (1, 2, 3, 4, 5) print(5 not in tuple1) # Output: False # not in set set1 = {1, 2, 3, 4, 5} print(5 not in set1) # Output: False # not in dictionary dict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30} print(\u0026#34;name\u0026#34; not in dict1) # Output: False 1.8.3. len() Function The len() function is used to get the length of an iterable. For example:\n# for string str = \u0026#34;Hello, World!\u0026#34; print(len(str)) # Output: 13 # for list list1 = [1, 2, 3, 4, 5] print(len(list1)) # Output: 5 # for tuple tuple1 = (1, 2, 3, 4, 5) print(len(tuple1)) # Output: 5 # for set set1 = {1, 2, 3, 4, 5} print(len(set1)) # Output: 5 # for dictionary dict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30} print(len(dict1)) # Output: 2 1.8.4. max() and min() Functions The max() function is used to get the maximum value from an iterable, and the min() function is used to get the minimum value for list,string,set and tuples only. for dictionary you can use .keys() or .values() and use it. For example:\n# for list list1 = [1, 2, 3, 4, 5] print(max(list1)) # Output: 5 print(min(list1)) # Output: 1 # for tuple tuple1 = (1, 2, 3, 4, 5) print(max(tuple1)) # Output: 5 print(min(tuple1)) # Output: 1 # for string string = \u0026#34;Hello, World!\u0026#34; print(max(string)) # Output: r print(min(string)) # Output: \u0026#39; \u0026#39; # for set set1 = {1, 2, 3, 4, 5} print(max(set1)) # Output: 5 print(min(set1)) # Output: 1 1.8.5. join() Function The join() function is used to concatenate elements of an iterable with a separator. For example:\n# for list list1 = [\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;] print(\u0026#34;, \u0026#34;.join(list1)) # Output: apple, banana, cherry # for tuple tuple1 = (\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;) print(\u0026#34;, \u0026#34;.join(tuple1)) # Output: apple, banana, cherry # for set set1 = {\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;} print(\u0026#34;, \u0026#34;.join(set1)) # Output: apple, banana, cherry # for string string = \u0026#34;Hello, World!\u0026#34; print(\u0026#34;, \u0026#34;.join(string)) # Output: H, e, l, l, o, ,, , W, o, r, l, d, ! ","permalink":"http://localhost:1313/posts/pages/python/python_datatype_operations/","summary":"An in-depth look at Python data types, exploring their usage and importance in programming.","title":"Python Fundamentals: Understanding Data Types (Part 2)"},{"content":"22. Fragments in React Fragments are a way to group multiple elements in React without adding extra nodes to the DOM. Fragments are useful when you want to return multiple elements from a component, but you don\u0026rsquo;t want to add an extra div or span element to the DOM.\nFragments are represented by the \u0026lt;Fragment\u0026gt; tag or the shorthand syntax \u0026lt;\u0026gt;. You can use fragments to return multiple elements from a component without adding extra nodes to the DOM.\nWithout using fragments:\nfunction App() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Hello, World!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;Welcome to React\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } Here, the App component returns two elements, but they are wrapped in a div element. If you don\u0026rsquo;t want to add an extra div element to the DOM, you can use fragments.\nUsing fragments:\nfunction App() { return ( \u0026lt;\u0026gt; or \u0026lt;Fragment\u0026gt; \u0026lt;h1\u0026gt;Hello, World!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;Welcome to React\u0026lt;/p\u0026gt; \u0026lt;/\u0026gt; or \u0026lt;/Fragment\u0026gt; ); } 23. Passing jsx as props In React, you can pass JSX as props to other components. This allows you to create reusable components that can be used in different parts of your application.\nPassing JSX as props: function App() { const heading = \u0026lt;div\u0026gt;\u0026lt;h1\u0026gt;Hello, World!\u0026lt;/h1\u0026gt;\u0026lt;p\u0026gt;My name is nirajan Khatiwada\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;; return \u0026lt;Greeting message={heading} /\u0026gt;; } or function App() { return \u0026lt;Greeting message={\u0026lt;div\u0026gt;\u0026lt;h1\u0026gt;Hello, World!\u0026lt;/h1\u0026gt;\u0026lt;p\u0026gt;My name is nirajan Khatiwada\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;} /\u0026gt;; } Using props in the Greeting component: function Greeting(props) { return \u0026lt;div\u0026gt;{props.message}\u0026lt;/div\u0026gt;; } Passing built-in components as props: function App() { return \u0026lt;Greeting element=\u0026#34;button\u0026#34; /\u0026gt;; } 24. Isolation of Component in React Isolation of components is a key concept in React that allows you to create reusable components that are independent of each other. This means that each component should be self-contained and not rely on external data or state.\nfor example:\nfunction Button(props){ const [showText, setShowText] = useState(false); return ( \u0026lt;button onClick={() =\u0026gt; setShowText(!showText)}\u0026gt; {showText ? \u0026#39;Hide Text\u0026#39; : \u0026#39;Show Text\u0026#39;} \u0026lt;/button\u0026gt; ); } function App(){ return ( \u0026lt;div\u0026gt; \u0026lt;Button /\u0026gt; \u0026lt;Button /\u0026gt; \u0026lt;/div\u0026gt; ); } Here The component Button is isolated means one state of the component does not affect the other component. Each component is self-contained and does not rely on external data or state. for example, the showText state in one Button component does not affect the showText state in the other Button component.\n25. Taking User Input in React Using onChange event: function App() { const [name, setName] = useState(\u0026#39;\u0026#39;); const handleChange = (e) =\u0026gt; { setName(e.target.value); }; return ( \u0026lt;div\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; value={name} onChange={handleChange} /\u0026gt; \u0026lt;p\u0026gt;Hello, {name}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } Whats Happen Here\nHere, we have an input element that takes user input. When the user types in the input field,the onChange event is triggered for ervy keypress. The handleChange function is called with the event object as an argument for every keypress. The setName function is called with value of user input and it rerender the component with the updated value for every keypress. The value of the input field is set to the name state, and the name is displayed below the input field. Note: use onChange event to take user input in React and update the state accordingly to reflect the changes in the UI. If you use value as a prop in the input field, you must also provide an onChange event handler to update the state. Use this method if you want to update in real-time as the user types in the input field.\nOther method will be discussed in upcoming posts. 26.Rendering 2D Arrays in React In React, you can render 2D arrays by using nested map functions to iterate over the rows and columns of the array. This allows you to display tabular data or grid-like structures in your application.\nRendering a 2D array: function App() { const data = [ [\u0026#39;John\u0026#39;, \u0026#39;Doe\u0026#39;, 30], [\u0026#39;Jane\u0026#39;, \u0026#39;Smith\u0026#39;, 25], [\u0026#39;Alice\u0026#39;, \u0026#39;Brown\u0026#39;, 35], ]; return ( \u0026lt;table\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;First Name\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Last Name\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Age\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; {data.map((row, index) =\u0026gt; ( \u0026lt;tr key={index}\u0026gt; {row.map((cell, index) =\u0026gt; ( \u0026lt;td key={index}\u0026gt;{cell}\u0026lt;/td\u0026gt; ))} \u0026lt;/tr\u0026gt; ))} \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; ); } 27. Immutable update patterns in React In react while changing the state we shouldnot change the orginal state directly Instead, we should create a new copy of the state and update the copy with the new values. This is known as immutable update pattern.speciaaly when working with arrays and objects.\nThe Wrong way to update state: function App() { const [items, setItems] = useState([\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;cherry\u0026#39;]); const removeItem = (index) =\u0026gt; { items.splice(index, 1); setItems(items); }; return ( \u0026lt;div\u0026gt; \u0026lt;ul\u0026gt; {items.map((item, index) =\u0026gt; ( \u0026lt;li key={index}\u0026gt; {item} \u0026lt;button onClick={() =\u0026gt; removeItem(index)}\u0026gt;Remove\u0026lt;/button\u0026gt; \u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ); } The Correct way to update state: function App() { const [items, setItems] = useState([\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;cherry\u0026#39;]); const removeItem = (index) =\u0026gt; { const newItems = [...items]; newItems.splice(index, 1); setItems(newItems); }; return ( \u0026lt;div\u0026gt; \u0026lt;ul\u0026gt; {items.map((item, index) =\u0026gt; ( \u0026lt;li key={index}\u0026gt; {item} \u0026lt;button onClick={() =\u0026gt; removeItem(index)}\u0026gt;Remove\u0026lt;/button\u0026gt; \u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt;x x \u0026lt;/div\u0026gt; ); } Note: Always create a new copy of the state when updating arrays or objects in React. This ensures that the state is updated correctly and prevents unexpected behavior in your application. 28. Common Pattern for update,delete and add in React In React, you can use common patterns to update, delete, and add items to an array. These patterns involve creating new copies of the array and updating the state with the new values.\nAdd an item to an array: function App() { const [items, setItems] = useState([\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;cherry\u0026#39;]); const addItem = (item) =\u0026gt; { setItems([...items, item]); // or // const newItems = [...items]; // newItems.push(item); // setItems(newItems); }; return ( \u0026lt;div\u0026gt; \u0026lt;ul\u0026gt; {items.map((item, index) =\u0026gt; ( \u0026lt;li key={index}\u0026gt;{item}\u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;button onClick={() =\u0026gt; addItem(\u0026#39;orange\u0026#39;)}\u0026gt;Add Item\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } Deleting an item from an array: function App() { const [items, setItems] = useState([\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;cherry\u0026#39;]); const removeItem = (index) =\u0026gt; { const newItems = items.filter((item, i) =\u0026gt; i !== index); setItems(newItems); }; return ( \u0026lt;div\u0026gt; \u0026lt;ul\u0026gt; {items.map((item, index) =\u0026gt; ( \u0026lt;li key={index}\u0026gt; {item} \u0026lt;button onClick={() =\u0026gt; removeItem(index)}\u0026gt;Remove\u0026lt;/button\u0026gt; \u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ); } Updating an data of an array using map: function App() { const [items, setItems] = useState([ { id: 1, name: \u0026#39;apple\u0026#39;, price: 1 }, { id: 2, name: \u0026#39;banana\u0026#39;, price: 2 }, { id: 3, name: \u0026#39;cherry\u0026#39;, price: 3 }, ]); const updateItem = (id, price) =\u0026gt; { const newItems = items.map((item) =\u0026gt; item.id === id ? { ...item, price: price } : item ); setItems(newItems); }; return ( \u0026lt;div\u0026gt; \u0026lt;ul\u0026gt; {items.map((item) =\u0026gt; ( \u0026lt;li key={item.id}\u0026gt; {item.name} - ${item.price}{\u0026#39; \u0026#39;} \u0026lt;button onClick={() =\u0026gt; updateItem(item.id, item.price + 1)}\u0026gt; Increase Price \u0026lt;/button\u0026gt; \u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ); } Updating an data of an array using find: function App() { const [items, setItems] = useState([ { id: 1, name: \u0026#39;apple\u0026#39;, price: 1 }, { id: 2, name: \u0026#39;banana\u0026#39;, price: 2 }, { id: 3, name: \u0026#39;cherry\u0026#39;, price: 3 }, ]); const updateItem = (id, price) =\u0026gt; { const newItems= [...items]; const newItem = newItems.find((item) =\u0026gt; item.id === id); if (newItem) { newItem.price = price; setItems(newItems); } }; return ( \u0026lt;div\u0026gt; \u0026lt;ul\u0026gt; {items.map((item) =\u0026gt; ( \u0026lt;li key={item.id}\u0026gt; {item.name} - ${item.price}{\u0026#39; \u0026#39;} \u0026lt;button onClick={() =\u0026gt; updateItem(item.id, item.price + 1)}\u0026gt; Increase Price \u0026lt;/button\u0026gt; \u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ); } Note: Always prefer map over find when updating an array of objects in React. This ensures that the state is updated correctly and prevents unexpected behavior in your application.\n29.Updating object in react In React, you can update an object in state by creating a new copy of the object and updating the copy with the new values. This ensures that the state is updated correctly and prevents unexpected behavior in your application.\nUpdating an object in state: function App() { const [person, setPerson] = useState({ name: \u0026#39;John\u0026#39;, age: 30 }); const updatePerson = () =\u0026gt; { setPerson({ ...person, age: person.age + 1 }); }; return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;Name: {person.name}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Age: {person.age}\u0026lt;/p\u0026gt; \u0026lt;button onClick={updatePerson}\u0026gt;Increase Age\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } use list if you want to show the list of items and use object if you want to show the details of the item to identify which one is clicked or update you can pass the index or id of the item to the function. Or you can hardcode the value to update the object or list.\n","permalink":"http://localhost:1313/posts/pages/react/react3/","summary":"A comprehensive guide covering React\u0026rsquo;s advanced concepts including Fragments, JSX Props, Component Isolation, and proper state management patterns","title":"React : Day 3"},{"content":"Python Control Structures: Mastering Loops and Conditionals In Python programming, control structures are essential for managing the flow of execution in your code. They allow you to make decisions, repeat tasks, and create complex algorithms. In this guide, we will explore two fundamental control structures in Python: loops and conditionals.\n1. Conditional Statements Conditional statements in Python allow you to execute specific blocks of code based on certain conditions. The most common conditional statements are if, elif, and else.\n1.1. The if Statement The if statement is used to check a condition and execute a block of code if the condition is true.\nExample:\nx = 10 if x \u0026gt; 5: print(\u0026#34;x is greater than 5\u0026#34;) Output:\nx is greater than 5 1.2. The elif Statement The elif statement allows you to check multiple conditions after the initial if statement. If the previous conditions are false, the elif block is evaluated.\nExample:\nx = 5 if x \u0026gt; 5: print(\u0026#34;x is greater than 5\u0026#34;) elif x == 5: print(\u0026#34;x is equal to 5\u0026#34;) Output:\nx is equal to 5 1.3. The else Statement The else statement is used to execute a block of code when all the previous conditions are false.\nExample:\nx = 3 if x \u0026gt; 5: print(\u0026#34;x is greater than 5\u0026#34;) elif x == 5: print(\u0026#34;x is equal to 5\u0026#34;) else: print(\u0026#34;x is less than 5\u0026#34;) Output:\nx is less than 5 2. Loops Loops in Python allow you to execute a block of code repeatedly. There are two main types of loops in Python: for loops and while loops.\n2.1. The while Loop The while loop executes a block of code as long as a specified condition is true.\nSyntax:\nwhile condition: # Code block else: # Optional else block Example:\ncount = 0 while count \u0026lt; 5: print(count) count += 1 else: print(\u0026#34;Loop completed\u0026#34;) 2.2. The for Loop The for loop is used to iterate over a sequence (such as a list, tuple, or string) and execute a block of code for each item in the sequence.\nSyntax:\nfor item in sequence: # Code block else: # Optional else block Example:\nfruits = [\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;] for fruit in fruits: print(fruit) else: print(\u0026#34;No more fruits\u0026#34;) 2.3 Using For Loops with different data types 2.3.1. For Loop with Strings Example:\nfor char in \u0026#34;Python\u0026#34;: print(char) Output:\np\ry\rt\rh\ro\rn 2.3.2. For Loop with Lists Example:\nnumbers = [1, 2, 3, 4, 5] for num in numbers: print(num) Output:\n1\r2\r3\r4\r5 2.3.3. For Loop with tuples Example:\nfruits = (\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;) for fruit in fruits: print(fruit) Output:\napple\rbanana\rcherry Tuple unpacking can also be used in for loops to iterate over multiple values in a tuple.\ncoordinates = [(1, 2), (3, 4), (5, 6)] for x, y in coordinates: print(f\u0026#34;X: {x}, Y: {y}\u0026#34;) Output:\nX: 1, Y: 2\rX: 3, Y: 4\rX: 5, Y: 6 2.3.4. For Loop with Sets Example:\ncolors = {\u0026#34;red\u0026#34;, \u0026#34;green\u0026#34;, \u0026#34;blue\u0026#34;} for color in colors: print(color) Output:\nred\rgreen\rblue 2.3.5. For Loop with Dictionaries Example:\nperson = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} for key, value in person.items(): print(f\u0026#34;{key}: {value}\u0026#34;) Output:\nname: Alice\rage: 30\rcity: New York 2.4. break , pass and continue statements in loops 2.4.1. The break Statement The break statement is used to exit a loop prematurely. It terminates the current loop and resumes execution at the next statement after the loop.\nExample:\nfor num in [1, 2, 3, 4, 5]: if num == 3: break print(num) Output:\n1\r2 2.4.2. The continue Statement The continue statement is used to skip the rest of the code inside a loop for the current iteration and jump to the next iteration.\nExample:\nfor num in [1, 2, 3, 4, 5]: if num == 3: continue print(num) Output:\n1\r2\r4\r5 2.4.3. The pass Statement The pass statement is a null operation that does nothing. It is used when a statement is required syntactically but you do not want any code to execute.\nExample:\nfor num in [1, 2, 3, 4, 5]: pass ","permalink":"http://localhost:1313/posts/pages/python/python_control_structure/","summary":"A detailed examination of Python\u0026rsquo;s control structures, focusing on loops and conditionals to enhance your programming skills.","title":"Python Fundamentals: Mastering Control Structures (Part 3)"},{"content":"17. Hooks in React Anythong that start with prefix use is considered as a hook in react\n17.1. Rules of Hooks Only Call Hook inside a component function correct:\nfunction App() { const [val, setVal] = useState(0); } Incorrect:\nconst [val, setVal] = useState(0); function App() { } Only Call Hooks at the Top Level Hook must not be called inside code statement (e.g., inside an if statement, loop, or nested function). correct: function App() { const [val, setVal] = useState(0); } incorrect:\nfunction App() { if (true) { const [val, setVal] = useState(0); } } 3.Hook can be used inside other custom hooks too\n18. useState Hook useState is a React hook that allows you to manage component-specific state. It provides a way to declare state variables in functional components and ensure that changes to these variables cause the component or child component to re-render while the parent component remains unaffected from where the component whose set state is triggered.\nfor example:\nfunction App() { return ( \u0026lt;div\u0026gt; \u0026lt;MemoComp /\u0026gt; \u0026lt;/div\u0026gt; ); } function MemoComp() { const [data, setData] = useState(\u0026#34;No data\u0026#34;); function handle() { setData(\u0026#34;data\u0026#34;); } return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;{data}\u0026lt;/p\u0026gt; \u0026lt;button onClick={handle}\u0026gt;Click me\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } When button is clicked the handle function is called and the setData function is called which updates the data state variable. This cause the MemoComp and its child component to re-render with a new value of data.\n18.1. Syntax const [state, setState] = useState(initialState); 18.2. Managing State State management in React involves handling data and telling React to re-execute a function using the useState hook. This ensures that state updates lead to new state values. Example:\nconst [countes, setcountes] = useState(0); countes is the state variable that holds the current state value. setcountes is the function that updates the state variable. useState(0) is the initial state value. How it works: Initially, the state variable countes is set to 0. When the setcountes function is called, it updates the state variable to a new value. This triggers a re-render of the component, updating the UI with the new state value.\n18.3 Updating State Based on Previous State Suppose the age is 42. The handler calls setAge(age + 1) three times.\nfunction handleClick() { setAge(age + 1); // setAge(42 + 1) setAge(age + 1); // setAge(42 + 1) setAge(age + 1); // setAge(42 + 1) } if the initial age is 42, after calling this function, the age will be 43, not 45.\nTo solve this problem, we use an updater function to pass setAge calls.\nfunction handleClick() { setAge(a =\u0026gt; a + 1); // setAge(42 =\u0026gt; 43) setAge(a =\u0026gt; a + 1); // setAge(43 =\u0026gt; 44) setAge(a =\u0026gt; a + 1); // setAge(44 =\u0026gt; 45) } After this age will be 45 so use updater function when you want to update value based on previous value \u0026amp; it\u0026rsquo;s always recommended to use updater function in.\nIt is mostly used in:\nCounters Toggles Incrementing or decrementing a value 18.4. Pitfalls in useState In React state updates are asynchronous meaning they don\u0026rsquo;t immediately reflect in the current execution cycle. When you call a state setter function like setSelectedValue, React schedules the state update for the next render. This can lead to unexpected behavior if you try to access the updated state immediately after setting it.\nExample: function clickHandler(data) { setSelectedValue(`${data} is being clicked`); console.log(selectedTopic); // logs the old state, not updated one } Why It Happens State updates are asynchronous: React batches state updates and applies them during the next render cycle to optimize performance. Therefore, the state change you request won’t be immediately reflected in the current execution.\nLogging state immediately: Since the update happens after the current execution cycle, logging the state/selected topic immediately after calling setSelectedValue will show the old value (before the update).\nThis can be fixed using useEffect which is read later.\nNote: Always use the state variable when you want to reflect the changes in the UI.\n19. An Example demostrating useState Hook import {useState} from \u0026#39;react\u0026#39;; function App(){ const [count,setCount] = useState(0); return(){ \u0026lt;div\u0026gt; {count} \u0026lt;/div\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;Increment\u0026lt;/button\u0026gt; } } export default App; In the above example, we have a functional component App that uses the useState hook to manage the state of the count variable. The initial value of count is set to 0 using useState(0). The setCount function is used to update the value of count when the button is clicked. The count value is displayed in the UI, and clicking the button increments the count value by 1.\n20.Conditional Rendering in React Conditional rendering is a technique used to render different components or elements based on certain conditions. In React, conditional rendering can be achieved using ternary operators, and logical operators like \u0026amp;\u0026amp; .\n20.1. Ternary Operator The ternary operator is a concise way to write conditional statements in JavaScript. It consists of a condition followed by a question mark ?, an expression to execute if the condition is true, a colon :, and an expression to execute if the condition is false.\nExample:\nfunction App() { const isLoggedIn = true; return ( \u0026lt;div\u0026gt; {isLoggedIn ? \u0026lt;p\u0026gt;Welcome, User!\u0026lt;/p\u0026gt; : \u0026lt;p\u0026gt;Please log in\u0026lt;/p\u0026gt;} \u0026lt;/div\u0026gt; ); } Also We can write jsx code in variable and use it in return statement\nfunction App() { const isLoggedIn = true; const welcomeMessage=\u0026lt;p\u0026gt;Welcome, User!\u0026lt;/p\u0026gt;; const loginMessage=\u0026lt;p\u0026gt;Please log in\u0026lt;/p\u0026gt;; return ( \u0026lt;div\u0026gt; {isLoggedIn ? welcomeMessage : loginMessage} \u0026lt;/div\u0026gt; ); } 20.2. Logical \u0026amp;\u0026amp; Operator The logical \u0026amp;\u0026amp; operator is another way to conditionally render elements in React. The \u0026amp;\u0026amp; operator works by evaluating the expression on the left side of the \u0026amp;\u0026amp; operator. If the expression is true, the expression on the right side of the \u0026amp;\u0026amp; operator is executed. If the expression is false, the right side is not executed.\nExample:\nfunction App() { const isLoggedIn = true; return ( \u0026lt;div\u0026gt; {isLoggedIn \u0026amp;\u0026amp; \u0026lt;p\u0026gt;Welcome, User!\u0026lt;/p\u0026gt;} {isLoggedIn \u0026amp;\u0026amp; \u0026lt;button\u0026gt;Logout\u0026lt;/button\u0026gt;} {!isLoggedIn \u0026amp;\u0026amp; \u0026lt;p\u0026gt;Please log in\u0026lt;/p\u0026gt;} \u0026lt;/div\u0026gt; ); } Also We can write jsx code in variable and use it in return statement\nfunction App() { const isLoggedIn = true; const welcomeMessage=\u0026lt;p\u0026gt;Welcome, User!\u0026lt;/p\u0026gt;; const logoutButton=\u0026lt;button\u0026gt;Logout\u0026lt;/button\u0026gt;; const loginMessage=\u0026lt;p\u0026gt;Please log in\u0026lt;/p\u0026gt;; return ( \u0026lt;div\u0026gt; {isLoggedIn \u0026amp;\u0026amp; welcomeMessage} {isLoggedIn \u0026amp;\u0026amp; logoutButton} {!isLoggedIn \u0026amp;\u0026amp; loginMessage} \u0026lt;/div\u0026gt; ); } 21.Outputting list data dynamically In react we use map function to output list data dynamically as using map.\n21.1. Have a list of data You typically store the list in an array, which might come from a state, props, or external data source like an API\nconst data = [ { id: 1, name: \u0026#34;John\u0026#34; }, { id: 2, name: \u0026#34;Doe\u0026#34; }, { id: 3, name: \u0026#34;Jane\u0026#34; }, ]; 21.2 Using map function to output list data const listItems = data.map((item) =\u0026gt; \u0026lt;li key={item.id}\u0026gt;{item.name}\u0026lt;/li\u0026gt;); Key is used to uniquely identify each element in the list. It helps React identify which items have changed, are added, or are removed.It can be number or string.\n21.3. Rendering the list Use {} to embed the transformed list inside your component’s JSX.\n\u0026lt;ul\u0026gt;{listItems}\u0026lt;/ul\u0026gt;; 21.4. Putting it all together function App() { const data = [ { id: 1, name: \u0026#34;John\u0026#34; }, { id: 2, name: \u0026#34;Doe\u0026#34; }, { id: 3, name: \u0026#34;Jane\u0026#34; }, ]; const listItems = data.map((item) =\u0026gt; \u0026lt;li key={item.id}\u0026gt;{item.name}\u0026lt;/li\u0026gt;); return \u0026lt;ul\u0026gt;{listItems}\u0026lt;/ul\u0026gt;; } 21.5 Another form function App() { const data = [ { id: 1, name: \u0026#34;John\u0026#34; }, { id: 2, name: \u0026#34;Doe\u0026#34; }, { id: 3, name: \u0026#34;Jane\u0026#34; }, ]; return \u0026lt;ul\u0026gt;{data.map((item) =\u0026gt; \u0026lt;li key={item.id}\u0026gt;{item.name}\u0026lt;/li\u0026gt;); }\u0026lt;/ul\u0026gt;; } When will Rerender Occur?\nWhen state varaible or props value changes ","permalink":"http://localhost:1313/posts/pages/react/react1/","summary":"A detailed guide to help you understand and use hooks in React effectively.","title":"React : Day 2"},{"content":"Python Fundamentals: Exploring Advanced Operations (Part 4) In Python programming, advanced operations allow you to perform complex tasks efficiently. These operations include working with ranges, enumerations, zip functions, and more. In this guide, we will explore various advanced operations in Python to enhance your programming skills.\n1. Ranges Ranges in Python are used to generate a sequence of numbers. They are commonly used in loops to iterate over a specific range of values. Ranges can be created using the range() function.\n1.1. Creating a Range To create a range of numbers, you can use the range() function with the desired start, stop, and step values where start number is in inclusive and stop number is exclusive.\nExample:\n# Generate a range of numbers from 0 to 9 for i in range(10): print(i) Output:\n0\r1\r2\r3\r4\r5\r6\r7\r8\r9 Example:\n# Generate a range of numbers from 1 to 10 with a step of 2 for i in range(0, 10,2): print(i) Output:\n0\r2\r4\r6\r8 1.2 Enumerate Function The enumerate() function in Python is used to iterate over a sequence while keeping track of the index and value of each item. It returns a tuple containing the index and the value of the item.\nExample:\n# Enumerate a list of fruits fruits = [\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;cherry\u0026#39;] for index, fruit in enumerate(fruits): print(index, fruit) Output:\n0 apple\r1 banana\r2 cherry Example:\na=\u0026#34;nirajan\u0026#34; for index, char in enumerate(a): print(index, char) Output:\n0 n\r1 i\r2 r\r3 a\r4 j\r5 a\r6 n 1.3. Zip Function The zip() function in Python is used to combine multiple iterables (such as lists) element-wise. It returns an iterator of tuples where the i-th tuple contains the i-th element from each of the input iterables.\nExample:\n# Zip two lists together names = [\u0026#39;Alice\u0026#39;, \u0026#39;Bob\u0026#39;, \u0026#39;Charlie\u0026#39;] ages = [25, 30, 35] for name, age in zip(names, ages): print(name, age) Output:\nAlice 25\rBob 30\rCharlie 35 Example:\na=[1,2,3] b=[4,5,6] c=[7,8,9] print(list(zip(a,b,c))) Output:\n[(1, 4, 7), (2, 5, 8), (3, 6, 9)] 1.5 Sorted Function The sorted() function in Python is used to sort a list of elements. It returns a new sorted list without modifying the original list.The main feature of the sorted() function is that it can take a key argument that specifies a function to be called on each list element prior to making comparisons.\nExample:\n# Sort a list of numbers numbers = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5] sorted_numbers = sorted(numbers) print(sorted_numbers) Output:\n[1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] Example:\n# Sort a list of strings based on the length of the string fruits = [\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;cherry\u0026#39;, \u0026#39;date\u0026#39;] sorted_fruits = sorted(fruits, key=len) print(sorted_fruits) Output:\n[\u0026#39;date\u0026#39;, \u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;cherry\u0026#39;] Example:\n#Sort an dictionary based on the value d = {\u0026#39;apple\u0026#39;: 10, \u0026#39;banana\u0026#39;: 5, \u0026#39;cherry\u0026#39;: 15} sorted_d = sorted(d.items(), key=lambda x: x[1]) print(sorted_d) Output:\n[(\u0026#39;banana\u0026#39;, 5), (\u0026#39;apple\u0026#39;, 10), (\u0026#39;cherry\u0026#39;, 15)] Example:\n#Sort a list of tuples based on the second element t = [(1, 2), (3, 1), (5, 6)] sorted_t = sorted(t, key=lambda x: x[1]) print(sorted_t) Output:\n[(3, 1), (1, 2), (5, 6)] #2. Import in Python In Python, the import statement is used to import modules or packages into your script. It allows you to use functions, classes, and variables defined in other modules in your code.\n2.1. Importing Modules To import a module in Python, you can use the import keyword followed by the module name. You can then access the functions, classes, and variables defined in the module using dot notation.\nExample:\n# Import the math module import math # Calculate the square root of a number x = 16 print(math.sqrt(x)) Output:\n4.0 Example:\n# Import the datetime module import datetime # Get the current date and time now = datetime.datetime.now() print(now) Output:\n2024-11-17 10:30:00 2.2. Importing Specific Functions You can import specific functions or variables from a module using the from keyword. This allows you to use the imported functions directly without using the module name.\nExample:\n# Import the pi constant from the math module from math import pi # Print the value of pi print(pi) Output:\n3.141592653589793 Example:\n# Import the date class from the datetime module from datetime import date # Get the current date today = date.today() print(today) Output:\n2024-11-17 2.3. Aliasing Modules You can alias a module or package by using the as keyword. This allows you to refer to the module by a different name in your code.\nExample:\n# Import the math module and alias it as m import math as m # Calculate the square root of a number x = 25 print(m.sqrt(x)) Output:\n5.0 Example:\n# Import the datetime module using import and from and alias it as dt from datetime import datetime as dt now = dt.now() print(now) Output:\n2024-11-17 10:30:00 2.4. Importing All Functions You can import all functions and variables from a module using the * operator. This imports all the functions and variables defined in the module.\nExample:\n# Import all functions from the math module from math import * # Calculate the square root of a number x = 36 print(sqrt(x)) Output:\n6.0 The General Syntax is\nfrom module_name.submodule_name.submodule_name... import funtion_name or variable_name or filename as alias_name\nrandom module The random module in Python is used to generate random numbers. It provides various functions to generate random integers, floating-point numbers, and sequences.\n1. Generating Random Numbers The random module provides functions to generate random numbers within a specified range which can contain both integers starting and ending number.\nExample:\nfrom random import randint # Generate a random integer between 1 and 10 random_number = randint(1, 10) print(random_number) Output:\n5 2.Shuffling a List The random module provides a function to shuffle the elements of a list randomly. It modifies the original list in place.\nExample:\nfrom random import shuffle # Shuffle a list of numbers numbers = [1, 2, 3, 4, 5] shuffle(numbers) print(numbers) Output:\n[3, 1, 5, 2, 4] ","permalink":"http://localhost:1313/posts/pages/python/python_advanced_operations/","summary":"An in-depth exploration of advanced Python operations to enhance your programming skills.","title":"Python Fundamentals: Exploring Advanced Operations (Part 4)"},{"content":"Python Fundamentals: Understanding Functions In Python programming, functions are essential building blocks that allow you to organize and reuse code effectively. Functions help break down complex problems into smaller, manageable tasks, making your code more readable and maintainable. In this guide, we will explore the fundamentals of Python functions, including their syntax, parameters, return values, and more.\n1. Defining Functions A function in Python is defined using the def keyword followed by the function name and parentheses. You can also specify parameters inside the parentheses if the function requires input values.\nSyntax:\ndef function_name(parameters): # Function body # Statements Example:\ndef greet(): print(\u0026#34;Hello, World!\u0026#34;) 2. Calling Functions To call a function in Python, you simply write the function name followed by parentheses. If the function requires input values, you can pass them inside the parentheses.\nSyntax:\nfunction_name(arguments) Example:\ngreet() 3. return Statement The return statement in Python is used to exit a function and return a value to the caller. You can use the return statement to send a result back to the calling code.\nSyntax:\ndef function_name(parameters): # Function body return value Demostration using all:\ndef add_numbers(a, b): return a + b result = add_numbers(5, 3) print(result) 4. Args , Default Args and Kwargs 4.1. Args Using Args you can pass any number of arguments to a function. The arguments are passed as a tuple.\nSyntax:\ndef function_name(*args): # Function body Example:\ndef display_args(*args): print(args) display_args(1, 2, 3, 4, 5) Output:\n(1, 2, 3, 4, 5) 4.2. Default Args Default arguments are used when you do not pass a value for an argument in the function call. If a value is not provided, the default value is used.\nSyntax:\ndef function_name(arg=value): # Function body Example:\ndef add(a,b,c=0): return a+b+c result = add(5,3) print(result) result = add(5,3,2) print(result) Output:\n8\r10 4.3. Kwargs Using Kwargs you can pass any number of keyword arguments to a function. The arguments are passed as a dictionary.\nSyntax:\ndef function_name(**kwargs): # Function body Example:\ndef display_kwargs(**kwargs): print(kwargs) display_kwargs(name=\u0026#34;Alice\u0026#34;, age=30, city=\u0026#34;New York\u0026#34;) Output:\n{\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 30, \u0026#39;city\u0026#39;: \u0026#39;New York\u0026#39;} 4.4. Combination of Args and Kwargs Example:\ndef display_args_kwargs(*args, **kwargs): print(args) print(kwargs) display_args_kwargs(1, 2, 3, name=\u0026#34;Alice\u0026#34;, age=30) Output:\n(1, 2, 3)\r{\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 30} 4.5. Unpacking Args and Kwargs Example:\ndef display_args_kwargs(*args, **kwargs): print(args) print(kwargs) args = (1, 2, 3) kwargs = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30} display_args_kwargs(*args, **kwargs) Output:\n(1, 2, 3)\r{\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 30} 5. Lambda Functions Lambda functions, also known as anonymous functions, are small, single-expression functions that do not require a name. They are defined using the lambda keyword.\nSyntax:\nlambda arguments: expression Example:\nadd = lambda a, b: a + b result = add(5, 3) print(result) Output:\n8 6.Map and filter functions 6.1. Map Function The map() function in Python applies a given function to each item of an iterable (such as a list, tuple, or set) and returns a new iterable with the results.\nSyntax:\nmap(function, iterable) Example:\nnumbers = [1, 2, 3, 4, 5] squared = map(lambda x: x ** 2, numbers) print(list(squared)) Output:\n[1, 4, 9, 16, 25] 6.2. Filter Function The filter() function in Python filters elements from an iterable based on a given function. It returns an iterator with the elements that satisfy the condition.\nSyntax:\nfilter(function, iterable) Example:\nnumbers = [1, 2, 3, 4, 5] even = filter(lambda x: x % 2 == 0, numbers) print(list(even)) Output:\n[2, 4] 7.Local and Global Variables 7.1. Local Variables Local variables are defined within a function and are only accessible within that function. They are created when the function is called and destroyed when the function exits.\nExample:\ndef display(): message = \u0026#34;Hello, World!\u0026#34; print(message) display() # Trying to access the local variable outside the function will result in an error print(message) # NameError: name \u0026#39;message\u0026#39; is not defined 7.2. Global Variables Global variables are defined outside any function and can be accessed from any part of the code. You can use the global keyword to modify a global variable inside a function.\nExample:\nmessage = \u0026#34;Hello, World!\u0026#34; def display(): print(message) display() # Modifying a global variable inside a function def change_message(): global message message = \u0026#34;Hello, Python!\u0026#34; change_message() print(message) Output:\nHello, World!\rHello, Python! 7.3. Local vs. Global Variables If a local variable has the same name as a global variable, the local variable takes precedence within the function scope.\nExample:\nmessage = \u0026#34;Hello, World!\u0026#34; def display(): message = \u0026#34;Hello, Python!\u0026#34; print(message) display() print(message) Output:\nHello, Python!\rHello, World! ","permalink":"http://localhost:1313/posts/pages/python/python_function/","summary":"An in-depth exploration of Python functions, their usage, and importance in programming.","title":"Python Fundamentals: Understanding Functions (Part 5)"},{"content":"1. Create A React Project To create a React app we use Vite and its command is:\nnpm create vite@latest 2. Component In a React application, one page is broken down into multiple components. Components allow:\nReusability: For example, we can create one component for cards and use it to create multiple cards with different data. Related code lives together: Related items (JS code) are stored together. Separation of logic: Different components handle different data and logic. Diagram 3. Folder Structure my-app/\r├─ node_modules/\r├─ public/\r│ ├─ index.html\r│ ├─ image.png\r│ └─ favicon.ico\r├─ src/\r│ ├─ index.js\r│ ├─ App.js\r│ ├─ App.css\r│ └─ index.css\r├─ package.json\r└─ README.md node_module: Contains all the files of installed packages.\npublic: All static files are kept in this folder. For example, if image.png is in public, we can access it in the browser as 127.0.0.1:8000/image.png.\nindex.html: It is the page that is served to us and its content is managed by React using the DOM.Modify this file if you want to change the title or favicon.\npackage.json: Contains all the configuration of the project, package list, versions, and all related information.\nsrc: This is the folder where all the code is written.\nsrc/index.js React runs this file first.Code of index.js\nThe DOM selects the element of index.html whose id is root because of this code: document.getElementById('root') Then render() renders the \u0026lt;App/\u0026gt; component so that the root element will contain the data of the \u0026lt;App/\u0026gt; component. All changes are done in the index.html root element using the DOM. Remember that we never edit this file (code). src/App.js : This is where we will write all the SPA code. We start coding from App.jsx and link components as required.\nsrc/index.css : This CSS file is used by main.jsx, so it applies to the whole page. You can remove it if needed by removing its import in main.jsx.\n*** src/App.css:*** This CSS file is used by App.jsx, so it applies to all App components.\nRemember: Component functions must follow two rules:\nThe name should start with an uppercase letter (e.g., Head, MyHead). The function must return renderable content. The function must return a value that can be rendered (displayed on screen) by React. In most cases, return JSX. Example of a simple component:\nfunction App() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Hello world\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ); } As we know, App.jsx is provided by default when we create a React app. We can modify it and tailor it to our requirements\n4. Making Custom Components function FunctionName() { return ( \u0026lt;tagname\u0026gt; content \u0026lt;/tagname\u0026gt; ); } Important Note:\nTags that don\u0026rsquo;t have ending tags, such as \u0026lt;br\u0026gt; and \u0026lt;hr\u0026gt;, should be written as \u0026lt;br/\u0026gt; and \u0026lt;hr/\u0026gt;. class is replaced by className. For example, \u0026lt;body class=\u0026quot;data\u0026quot;\u0026gt; is written as \u0026lt;body className=\u0026quot;data\u0026quot;\u0026gt;. During a return in React, we cannot return multiple elements directly. Instead, we need to wrap them inside a single parent element like \u0026lt;div\u0026gt;, \u0026lt;\u0026gt;\u0026lt;/\u0026gt;. For Example :\nWrong Way: function component1() { return ( \u0026lt;div\u0026gt; Hi \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; Hello \u0026lt;/div\u0026gt; ); } right way: function component1() { return ( \u0026lt;div\u0026gt; {/* or \u0026lt;\u0026gt; */} \u0026lt;div\u0026gt; Hi \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; Hello \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; {/* or \u0026lt;/\u0026gt; */} ); } 5.Using One Component Inside Another Component To use one component inside another in React, follow the steps\nCreate a component. function Comp1() { return \u0026lt;div\u0026gt; Component \u0026lt;/div\u0026gt; } Use the component inside another component. function Comp2() { return ( \u0026lt;div\u0026gt; \u0026lt;Comp1 /\u0026gt; or \u0026lt;Comp1\u0026gt; \u0026lt;Comp1 /\u0026gt; content \u0026lt;/div\u0026gt; ) } Here, Comp1 is used inside Comp2.We can use Comp1 multiple times inside Comp2 as needed. Note: For proper management, create a components folder, create one file for each component, and export from there. Then, import and use it in another component.\nExample structure:\nsrc/\r├─ Assets/\r├─ App.jsx\r└─ Components/\r├─ Comp1.jsx\r└─ Comp2.jsx Task: Break Down a Component into Multiple Components\nfunction App() { return ( \u0026lt;\u0026gt; \u0026lt;header\u0026gt; I am header \u0026lt;/header\u0026gt; \u0026lt;main\u0026gt; I am main content \u0026lt;/main\u0026gt; \u0026lt;footer\u0026gt; I am footer \u0026lt;/footer\u0026gt; \u0026lt;/\u0026gt; ); } Solution: components/Header.jsx\nfunction Header() { return ( \u0026lt;header\u0026gt; I am header \u0026lt;/header\u0026gt; ); } export default Header; components/Footer.jsx\nfunction Footer() { return ( \u0026lt;footer\u0026gt; I am footer \u0026lt;/footer\u0026gt; ); } export default Footer; Finally, App.jsx\nimport Header from \u0026#39;./components/Header\u0026#39;; import Footer from \u0026#39;./components/Footer\u0026#39;; function App() { return ( \u0026lt;\u0026gt; \u0026lt;Header /\u0026gt; \u0026lt;main\u0026gt; I am main content \u0026lt;/main\u0026gt; \u0026lt;Footer /\u0026gt; \u0026lt;/\u0026gt; ); } export default App; structure:\nsrc/\r├─ Assets/\r├─ App.jsx\r└─ components/\r├─ Header.jsx\r└─ Footer.jsx Note: You Can Always break down a component as many times as you want. The main goal is to make the code more readable and maintainable.\n6. Some Component Hierarchies Examples THis is the simple example of a component hierarchy. 7. Embedding JavaScript code in JSX In JSX, we can embed JavaScript code using curly braces {}. We can write any JavaScript code inside the curly braces. For example, we can write a variable, function, or any JavaScript expression but of single line.\nfunction componentName() { return ( \u0026lt;div\u0026gt; { JavaScript code } \u0026lt;/div\u0026gt; ); } Example:\nfunction App() { const name = \u0026#39;John Doe\u0026#39;; return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt; Hello, {name} \u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ); } Where To Write Javascript Logic?\nWe can write JavaScript logic inside the component function. We can write JavaScript logic outside the component function and use it inside the component function. 7.1 Using JavaScript Logic Outside Component Function syntax:\n// Multiple lines of JavaScript code function ComponentName() { return ( \u0026lt;div\u0026gt; {/* JSX code */} \u0026lt;/div\u0026gt; ); } 7.2 Using JavaScript Logic Inside Component Function syntax:\nfunction ComponentName() { // Multiple lines of JavaScript code return ( \u0026lt;div\u0026gt; {/* JSX code */} \u0026lt;/div\u0026gt; ); } When to use Inside Component Function Outside Component Function Use Case When the logic is specific to the component and not used anywhere else. When the logic is used in multiple components. Advantages Logic is specific to the component. Logic can be reused in multiple components. Disadvantages Logic cannot be reused in other components. Logic is not specific to the component. Combined Example Task1: Create a component that generate random number between 1 to 10 and display in every page reload\nfunction RandomNumber(){ return \u0026lt;\u0026gt; \u0026lt;h1\u0026gt;Random Number: {Math.floor(Math.random() * 10) + 1}\u0026lt;/h1\u0026gt; } export default RandomNumber; This can be done in another ways which is more readable and maintainable\nfunction RandomNumber(){ const randomNumber = Math.floor(Math.random() * 10) + 1; return \u0026lt;h1\u0026gt;Random Number: {randomNumber}\u0026lt;/h1\u0026gt; } export default RandomNumber; Task2 : Create a component that generate random element from an array and display on each page reload\nconst elements = [\u0026#39;Earth\u0026#39;, \u0026#39;Water\u0026#39;, \u0026#39;Fire\u0026#39;, \u0026#39;Air\u0026#39;]; function generateRandomElement(){ return elements[Math.floor(Math.random() * elements.length)]; } function RandomElement(){ const randomElement = generateRandomElement(); return \u0026lt;h1\u0026gt;Random Element: {randomElement}\u0026lt;/h1\u0026gt; } export default RandomElement; This can be done by putting the logic inside the component function\nconst elements = [\u0026#39;Earth\u0026#39;, \u0026#39;Water\u0026#39;, \u0026#39;Fire\u0026#39;, \u0026#39;Air\u0026#39;]; function generateRandomElement(){ return elements[Math.floor(Math.random() * elements.length)]; } function RandomElement(){ const randomElement = elements[Math.floor(Math.random() * elements.length)]; return \u0026lt;h1\u0026gt;Random Element: {randomElement}\u0026lt;/h1\u0026gt; } export default RandomElement; The most optimal way is using this\nconst elements = [\u0026#39;Earth\u0026#39;, \u0026#39;Water\u0026#39;, \u0026#39;Fire\u0026#39;, \u0026#39;Air\u0026#39;]; function RandomElement(){ const randomElement = elements[Math.floor(Math.random() * elements.length)]; return \u0026lt;h1\u0026gt;Random Element: {randomElement}\u0026lt;/h1\u0026gt; } export default RandomElement; 8.Loading Images in React step 1: put the images in assets folder that need to be loaded step 2: import the image in the component where it is needed as shown below import imageName from Location Note: Location is the path of the image from the current file location and imageName can be set to any name\nstep 3: use the image in the component as shown below \u0026lt;img src={imageName} alt=\u0026#34;description\u0026#34; /\u0026gt; Note: imageName is the location of the image as src/Assets/logo.png\nTask: Load an image in a Header component with the image name logo.png and description logo. structure:\nsrc/\r├─ Assets/\r└─ logo.png\r├─ App.jsx\r└─ components/\r├─ Header.jsx import logo from \u0026#39;../Assets/logo.png\u0026#39;; function Header() { return ( \u0026lt;header\u0026gt; \u0026lt;img src={logo} alt=\u0026#34;logo\u0026#34; /\u0026gt; \u0026lt;/header\u0026gt; ); } 9.Importing CSS in React step 1: create a css file in the src folder step 2: import the css file in the component where it is needed as shown below import cssfileLocation Note: style.css is the name of the css file\nfor example:\nimport \u0026#39;./style.css\u0026#39; function App() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt; Hello world \u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ); } 9.1 Managing CSS in React Create css file in same directory as of your component src/ ├─ App.jsx └─ components/ ├─ Header.jsx └─ Header.css -Import the css file in the component where it is needed as shown below\r```jsx\rimport \u0026#39;./Header.css\u0026#39; 10.Props in React Props are used to pass data from parent component to child component. It is used to reuse the same component with different data. Props are passed as attributes to the component. Prop accept any type of value like string, number, array, object, function,compenent,jsx bool etc. 10.1 Passing Props from Parent to Child Component Parent Component function ParentComponent() { return ( \u0026lt;ChildComponent prop1={value1} prop2={value2} /\u0026gt; ); } 10.2 Receiving Props in Child Component Child Component function ChildComponent(props) { console.log(props); // will print object of props {prop1: value1, prop2:value2} return ( \u0026lt;\u0026gt; {props.prop1} {props.prop2} \u0026lt;/\u0026gt; ); } This approach is not recommended because it is not clear what props are being passed to the component. Instead, we can destructure the props as shown below.\n10.3 Destructuring Props Child Component function ChildComponent({prop1, prop2}) { return ( \u0026lt;\u0026gt; {prop1} {prop2} \u0026lt;/\u0026gt; ); } Task: Create a card cmponent and use multiple cards in the App component to make card section\nfunction Card({title, description, image}) { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;{title}\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;{description}\u0026lt;/p\u0026gt; \u0026lt;img src={image} alt=\u0026#34;description\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; ); } export default Card; import Card from \u0026#39;./components/Card\u0026#39;; function App() { return ( \u0026lt;div\u0026gt; \u0026lt;Card title=\u0026#34;Card 1\u0026#34; description=\u0026#34;This is card 1\u0026#34; image={image1} /\u0026gt; \u0026lt;Card title=\u0026#34;Card 2\u0026#34; description=\u0026#34;This is card 2\u0026#34; image={image2} /\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; 11. Children Props in React Children props are used to pass data between opening and closing tags of a component. 11.1 Passing Children Props Parent Component function ParentComponent() { return ( \u0026lt;ChildComponent\u0026gt; \u0026lt;h1\u0026gt; Hello \u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt; World \u0026lt;/p\u0026gt; \u0026lt;/ChildComponent\u0026gt; ); } 11.2 Receiving Children Props Child Component function ChildComponent({ children }) { return ( \u0026lt;div\u0026gt; {children} \u0026lt;/div\u0026gt; ); } 11.3 Output \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt; Hello \u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt; World \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; 12.Using Props and Children Props Together Task: Create a card component that accepts title, description, and children props. Use the card component in the App component to make a card section.\nfunction Card({ title, description, children }) { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;{title}\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;{description}\u0026lt;/p\u0026gt; {children} \u0026lt;/div\u0026gt; ); } export default Card; import Card from \u0026#39;./components/Card\u0026#39;; function App() { return ( \u0026lt;div\u0026gt; \u0026lt;Card title=\u0026#34;Card 1\u0026#34; description=\u0026#34;This is card 1\u0026#34;\u0026gt; \u0026lt;h1\u0026gt; Hello \u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt; World \u0026lt;/p\u0026gt; \u0026lt;/Card\u0026gt; \u0026lt;Card title=\u0026#34;Card 2\u0026#34; description=\u0026#34;This is card 2\u0026#34;\u0026gt; \u0026lt;h1\u0026gt; Hello \u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt; World \u0026lt;/p\u0026gt; \u0026lt;/Card\u0026gt; \u0026lt;/div\u0026gt; ); } 13. Making a Button Component 13.1 Using Props function App() { return ( \u0026lt;div\u0026gt; \u0026lt;Button text=\u0026#34;Click me\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; ); } function Button({ text}) { return ( \u0026lt;button\u0026gt; {text} \u0026lt;/button\u0026gt; ); } export default Button; 13.2 Using Children Props function App() { return ( \u0026lt;div\u0026gt; \u0026lt;Button\u0026gt;Click me\u0026lt;/Button\u0026gt; \u0026lt;/div\u0026gt; ); } function Button({ children }) { return ( \u0026lt;button\u0026gt; {children} \u0026lt;/button\u0026gt; ); } export default Button; 14. Reacting to Events In React, we can add event listeners like onClick, onMouseOver, onMouseOut, etc to buildin components lie button, div, etc using syntax \u0026lt;InbuiltComponent eventlistener={functionName} /\u0026gt; Note: functionName is the name of the function that will be called when the event is triggered.\nThere are Many eventlisteners that can be used in React like onClick, onMouseOver, onMouseOut etc.\nYou can check the full list of event listeners in the React documentation also note that the event listener will always start with on followed by the event name.\nWe can call the handle function in two ways:\n14.1 The First Way function App() { function handleClick() { console.log(\u0026#39;Button clicked\u0026#39;); } return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={handleClick}\u0026gt;Click me\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 14.2 The Second Way function App() { return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={() =\u0026gt; {console.log(\u0026#39;Button clicked\u0026#39;)}}\u0026gt;Click me\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 15. Event Listeners in Custom Components since by default when we add event listeners to custom component it doesnot work just because it is passed as prop but on simple tweaking we can make it work\nDesign Pattern for applying event listeners in custom components\nfunction App(){ function handleClick(){ console.log(\u0026#39;Button clicked\u0026#39;); } return ( \u0026lt;div\u0026gt; \u0026lt;Button onClick={handleClick} /\u0026gt; \u0026lt;/div\u0026gt; ); } The onclick method is passed as a prop to the button component and then used in the button component as shown below\nfunction Button({onClick}){ return ( \u0026lt;button onClick={onClick}\u0026gt;Click me\u0026lt;/button\u0026gt; ); } 16. Passing Arguments to Event Functions To pass Custom arguments to event functions, we can use the arrow function syntax as shown below \u0026lt;inbuildComponent eventListener={() =\u0026gt; functionName(argument)} /\u0026gt; Example function App() { function handleClick(name) { console.log(\u0026#39;Button clicked by\u0026#39;, name); } return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={() =\u0026gt; handleClick(\u0026#39;John\u0026#39;)}\u0026gt;Click me\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } ","permalink":"http://localhost:1313/posts/pages/react/react/","summary":"A detailed reference guide to help you quickly set up and manage React projects, components, and folder structures.","title":"React : Day 1"},{"content":"Python Fundamentals: Understanding Error Handling In Python programming, error handling is an essential concept that allows you to gracefully manage exceptions and errors that may occur during program execution. By handling errors effectively, you can prevent your program from crashing and provide meaningful feedback to users. In this guide, we will explore the fundamentals of error handling in Python, including exceptions, try-except blocks, and best practices.\n1. Exceptions In Python, exceptions are events that occur during the execution of a program that disrupt the normal flow of code. When an exception occurs, the interpreter raises an exception object that can be caught and handled by the program. Exceptions can be caused by various reasons, such as invalid input, file not found, or division by zero.\n2.What May Cause Exceptions Exceptions can be caused by various reasons, such as:\nDivision by zero Invalid input File not found Syntax errors Out of Index of list, tuple , String Key Error in dictionary 3.Types of Exceptions Commonly used exceptions in Python include:\nZeroDivisionError: Raised when division or modulo by zero occurs. ValueError: Raised when a function receives an argument of the correct type but an inappropriate value. TypeError: Raised when an operation or function is applied to an object of an inappropriate type. IndexError: Raised when a sequence subscript is out of range. KeyError: Raised when a dictionary key is not found. SyntaxError: Raised when the parser encounters a syntax error. Note: All exceptions in Python are subclasses of the Exception class.\n3.Handling Exceptions To handle exceptions in Python, you can use the try-except block, which allows you to catch and handle exceptions gracefully. The try block contains the code that may raise an exception, and the except block handles the exception if it occurs.The program control will transfer the control to the except block if any exception occurs in the try block but if there is not exception then the control will not transfer to the except block.\n4.1. Using try-except Block Here\u0026rsquo;s an example of using the try-except block to handle exceptions in Python:\nsyntax:\ntry: # Code that may raise an exception except ExceptionType as e: # Handle the exception Example:\ntry: x = 10 / 0 except Exception as e: print(\u0026#34;Error: Division by zero\u0026#34;) Output:\nError: Division by zero Note: if you don\u0026rsquo;t know the type of exception you can use Exception to catch all exceptions.\nIf you dont handel exception then it will show error and stop the program.\n4.2. Finally Block The finally block is used to execute code that should always run, regardless of whether an exception occurs or not. The finally block is typically used to release resources or clean up operations that need to be performed after the try block, regardless of the outcome Any how the finally block will run. if yout return from the try block then also the finally block will run.\nsyntax:\ntry: # Code that may raise an exception except ExceptionType as e: # Handle the exception finally: # Code that always runs Example:\ntry: x = 10 / 0 except Exception as e: print(\u0026#34;Error: Division by zero\u0026#34;) finally: print(\u0026#34;Cleanup code\u0026#34;) Output:\nError: Division by zero\rCleanup code 3.5. Raising Exceptions You can raise exceptions in Python using the raise statement. This allows you to create custom exceptions and raise them when needed. You can also raise built-in exceptions to indicate errors or exceptional conditions.\nsyntax:\nraise ExceptionType(\u0026#34;Error message\u0026#34;) Example:\nx = -1 if x \u0026lt; 0: raise ValueError(\u0026#34;Value cannot be negative\u0026#34;) Output:\nValueError: Value cannot be negative 3.6. Multiple except Blocks You can use multiple except blocks to handle different types of exceptions in Python. This allows you to catch and handle specific exceptions based on their type.\nsyntax:\ntry: # Code that may raise an exception except ExceptionType1 as e: # Handle ExceptionType1 except ExceptionType2 as e: # Handle ExceptionType2 Example:\ntry: x = 10 / 0 except ZeroDivisionError as e: print(\u0026#34;Error: Division by zero\u0026#34;) except ValueError as e: print(\u0026#34;Error: Invalid value\u0026#34;) Output:\nError: Division by zero 3.7. Custom Exceptions You can create custom exceptions in Python by defining a new exception class that inherits from the Exception class. Custom exceptions allow you to define specific error conditions for your application and raise them when needed.\nsyntax:\nclass CustomException(Exception): pass Example:\n#Will read about class in oop section class CustomError(Exception): def __init__(self,message,value): self.message=message self.value=value def __str__(self): return f\u0026#34;{self.message}\\nError code:{self.value}\u0026#34; try: x = -1 if x \u0026lt; 0: raise CustomError(\u0026#34;Value cannot be negative\u0026#34;,1001) except CustomError as e: print(e) Note: Custom exceptions should inherit from the Exception class or one of its subclasses. You can simply use:\ntry: #code except: #code try: #code except Exception as e: #code try: #code except Exception: #code try: #code except: #code finally: #code ","permalink":"http://localhost:1313/posts/pages/python/python_error_handeling/","summary":"An in-depth exploration of Python error handling, exceptions, and best practices.","title":"Python Fundamentals: Understanding Error Handling (Part 6)"},{"content":"Python Fundamentals: Packages, Generators, and Decorators In this guide, we will explore advanced Python topics including packages, generators, and decorators. These concepts are essential for writing efficient and maintainable Python code. Let\u0026rsquo;s dive in!\n1. Python Packages Python packages are a way of organizing and structuring your code into reusable modules. Packages allow you to group related modules together, making it easier to manage and maintain your codebase. In this section, we will explore how to create and use Python packages.\n1.1. Creating a Package To create a Python package, you need to organize your code into a directory structure with a special file called __init__.py. This file tells Python that the directory is a package and allows you to import modules from the package.\nExample directory structure:\nmy_package/\r│\r├── __init__.py\r├── module1.py\r└── module2.py 1.2. Using a Package To use a Python package, you can import modules from the package using the import statement. You can import specific modules or the entire package.\nExample:\n# Importing a specific module from my_package import module1 # Using a function from the imported module module1.my_function() # Importing the entire package import my_package # Using a function from a module within the package my_package.module2.another_function() #Importing Function from a module from my_package.module1 import my_function my_function() Note : init.py file can be empty or contain initialization code for the package. It will automatically run when the package is imported.\n1.3 Creating a Subpackage You can create subpackages within a package to further organize your code. Subpackages are simply packages within packages, allowing you to create a hierarchical structure for your codebase.\nExample directory structure:\nmy_package/\r│\r├── __init__.py\r├── module1.py\r└── subpackage/\r├── __init__.py\r├── module3.py\r└── module4.py 1.4. Using a Subpackage To use a subpackage, you can import modules from the subpackage using the dot notation.\nExample:\n# Importing a module from a subpackage from my_package.subpackage import module3 # Using a function from the imported module module3.another_function() # Importing the entire subpackage import my_package.subpackage # Using a function from a module within the subpackage my_package.subpackage.module4.some_function() #Importing Function from a module from my_package.subpackage.module3 import another_function another_function() 1.5. name == \u0026ldquo;main\u0026rdquo; We use the __name__ variable to check if a script is being run as the main program or being imported as a module. When a script is run as the main program, __name__ is set to \u0026quot;__main__\u0026quot;. This allows you to include code that should only run when the script is executed directly.\nFor Example:\nStructure:\nMain Directory/\r├── main.py\r└── package/\r├── __init__.py\r└── module1.py module1.py:\ndef my_function(): print(\u0026#34;Hello from module1\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: my_function() When you run module1.py directly, the my_function() will be executed. However, if you import module1 into another script, the my_function() will not be executed.\nFor Example:\nfrom package import module1 print(\u0026#34;Imported module1\u0026#34;) Output:\nImported module1 When use Dont use if __name__ == \u0026quot;__main__\u0026quot;: in module1.py:\ndef my_function(): print(\u0026#34;Hello from module1\u0026#34;) my_function() also,\nfrom package import module1 print(\u0026#34;Imported module1\u0026#34;) Output:\nHello from module1\rImported module1 2. Python Generators Using generator we can instantly return all the values using the yield keyword without storing them in memory. This is useful when working with large datasets or infinite sequences.\n2.1. Creating a Generator To create a generator in Python, you can use a function with the yield keyword. When a function contains the yield keyword, it becomes a generator function. The yield keyword suspends the function\u0026rsquo;s execution and returns a value to the caller.\nExample:\ndef my_generator(): yield 1 yield 2 yield 3 # Using the generator gen = my_generator() print(next(gen)) # Output: 1 print(next(gen)) # Output: 2 print(next(gen)) # Output: 3 Example:\n#using generator in loop def generate(n): for i in range(n): yield i for i in generate(10): print(i) 3. Python Decorators Decorators are a powerful feature in Python that allows you to modify or extend the behavior of functions or methods. Decorators are functions that take another function as an argument and return a new function that extends the behavior of the original function.\n3.1. Creating a Decorator To create a decorator in Python, you can define a function that takes another function as an argument and returns a new function that extends the behavior of the original function.\nSyntax:\ndef my_decorator(func): def wrapper(): # Code to execute before calling the decorated function func() # Code to execute after return wrapper Example:\ndef my_decorator(func): def wrapper(): print(\u0026#34;Before function call\u0026#34;) func() print(\u0026#34;After function call\u0026#34;) return wrapper @my_decorator def say_hello(): print(\u0026#34;Hello!\u0026#34;) say_hello() #call to my_decorator(say_hello)() just because we use @my_decorator Output:\nBefore function call\rHello!\rAfter function call Example For decorator :\ndef Add_Wrapper(func): def wrapper(a,b,c): print(\u0026#34;Status code is\u0026#34;,c) return func(a,b) return wrapper @Add_Wrapper def add(a,b): return a+b print(add(2,3,200)) Output:\nStatus code is 200\r5 3.2. Decorator with Arguments You can also create decorators that accept arguments by defining a decorator function that takes arguments and returns a decorator function.\nSyntax:\ndef my_decorator_with_args(arg1, arg2): def decorator(func): def wrapper(): # Code to execute before calling the decorated function func() # Code to execute after return wrapper return decorator Example:\ndef my_decorator_with_args(arg1, arg2): def decorator(func): def wrapper(): print(f\u0026#34;Decorator arguments: {arg1}, {arg2}\u0026#34;) func() return wrapper return decorator @my_decorator_with_args(\u0026#34;arg1\u0026#34;, \u0026#34;arg2\u0026#34;) def say_hello(): print(\u0026#34;Hello!\u0026#34;) say_hello() Output:\nDecorator arguments: arg1, arg2\rHello! ","permalink":"http://localhost:1313/posts/pages/python/python_advanced_topics/","summary":"An in-depth exploration of Python packages, generators, and decorators.","title":"Python Fundamentals: Packages, Generators, and Decorators (Part 7)"},{"content":"Python Fundamentals: Understanding request In this guide, we will explore request package in python. This package is used to make HTTP requests in python. Let\u0026rsquo;s dive in!\n1. Python request Python request is a simple and elegant HTTP library for Python. It provides methods for sending HTTP requests and handling the responses. The requests library allows you to send HTTP requests using a simple and intuitive API, and it also provides support for handling cookies, sessions, and authentication.\n1.1. Installing requests To use the requests library in your Python project, you need to install it using pip. You can install the requests library by running the following command in your terminal:\npip install requests 1.2. Types of requests The requests library supports various types of HTTP requests, including GET, POST, PUT, DELETE, and more. You can use these methods to interact with web services and APIs.\nExample:\nimport requests # Send a GET request response = requests.get(\u0026#39;https://api.github.com\u0026#39;) # Send a POST request response = requests.post(\u0026#39;https://httpbin.org/post\u0026#39;) # Send a PUT request response = requests.put(\u0026#39;https://httpbin.org/put\u0026#39;) # Send a DELETE request response = requests.delete(\u0026#39;https://httpbin.org/delete\u0026#39;) 1.3 Parameters for requests The requests library allows you to pass various parameters when making HTTP requests. These parameters include headers, query parameters, request body, and more.\nHeaders: You can pass custom headers in your request using the headers parameter. Example: import requests # Send a GET request with custom headers headers = {\u0026#39;User-Agent\u0026#39;: \u0026#39;Mozilla/5.0\u0026#39;} response = requests.get(\u0026#39;https://api.github.com\u0026#39;, headers=headers) # Send a POST request with custom headers response = requests.post(\u0026#39;https://httpbin.org/post\u0026#39;, headers=headers) #similarly for PUT and DELETE cookie: You can pass cookies in your request using the cookies parameter. Example: import requests # Send a GET request with cookies cookies = {\u0026#39;session_id\u0026#39;: \u0026#39;12345\u0026#39;} response = requests.get(\u0026#39;https://api.github.com\u0026#39;, cookies=cookies) # Send a POST request with cookies response = requests.post(\u0026#39;https://httpbin.org/post\u0026#39;, cookies=cookies) #similarly for PUT and DELETE file: You can upload files in your request using the files parameter. Example: import requests # Upload a file in a POST request files = {\u0026#39;file\u0026#39;: open(\u0026#39;file.txt\u0026#39;, \u0026#39;rb\u0026#39;)} response = requests.post(\u0026#39;https://httpbin.org/post\u0026#39;, files=files) #similarly for PUT and DELETE params: You can pass query parameters in your request using the params parameter. Example: import requests # Send a GET request with query parameters params = {\u0026#39;key1\u0026#39;: \u0026#39;value1\u0026#39;, \u0026#39;key2\u0026#39;: \u0026#39;value2\u0026#39;} response = requests.get(\u0026#39;https://api.github.com\u0026#39;, params=params) # Send a POST request with query parameters response = requests.post(\u0026#39;https://httpbin.org/post\u0026#39;, params=params) #similarly for PUT and DELETE data: You can pass data in your request body using the data parameter. Example: import requests # Send a POST request with data data = {\u0026#39;key1\u0026#39;: \u0026#39;value1\u0026#39;, \u0026#39;key2\u0026#39;: \u0026#39;value2\u0026#39;} response = requests.post(\u0026#39;https://httpbin.org/post\u0026#39;, data=data) #similarly for PUT and DELETE json: You can pass JSON data in your request body using the json parameter. Example: import requests # Send a POST request with JSON data data = {\u0026#39;key1\u0026#39;: \u0026#39;value1\u0026#39;, \u0026#39;key2\u0026#39;: \u0026#39;value2\u0026#39;} response = requests.post(\u0026#39;https://httpbin.org/post\u0026#39;, json=data) #similarly for PUT and DELETE Note: The requests library provides a wide range of parameters and options for making HTTP requests. You can refer to the official documentation for more details.\n** Note ** : While using json it will automatically set the content type to application/json and dump the data to json format but while using data it will set the content type to application/x-www-form-urlencoded and encode the data to urlencoded format.\n1.4. Handling responses The requests library provides methods for handling the responses returned by HTTP requests. You can access the response content, status code, headers, and more.\nResponse content: You can access the response content using the text attribute. Example: import requests # Send a GET request response = requests.get(\u0026#39;https://api.github.com\u0026#39;) # Get the response content content = response.text print(content) Response Content in bytes: You can access the response content in bytes using the content attribute. Example: import requests # Send a GET request response = requests.get(\u0026#39;https://api.github.com\u0026#39;) # Get the response content in bytes content = response.content print(content) json: You can access the response content as JSON using the json method. Example:\nimport requests # Send a GET request response = requests.get(\u0026#39;https://api.github.com\u0026#39;) # Get the response content as JSON data = response.json() print(data) Status code: You can access the response status code using the status_code attribute. Example: import requests # Send a GET request response = requests.get(\u0026#39;https://api.github.com\u0026#39;) # Get the response status code status_code = response.status_code print(status_code) Headers: You can access the response headers using the headers attribute. Example: import requests # Send a GET request response = requests.get(\u0026#39;https://api.github.com\u0026#39;) # Get the response headers headers = response.headers print(headers) Cookies: You can access the response cookies using the cookies attribute. Example: import requests # Send a GET request response = requests.get(\u0026#39;https://api.github.com\u0026#39;) # Get the response cookies cookies = response.cookies print(cookies) ","permalink":"http://localhost:1313/posts/pages/python/python_request/","summary":"An in-depth exploration of Python request.","title":"Python Fundamentals: Understanding request (Part 8)"},{"content":"Python Fundamentals: Understanding File Handeling In Python programming, file handling is an essential operation that allows you to read, write, and manipulate files on your system. Files are used to store data permanently, and Python provides various functions and methods to work with files efficiently. In this guide, we will explore the basics of file handling in Python, including opening, reading, writing, and closing files.\n1.Context Manager Python provides a built-in way to manage resources and ensure that they are properly released when they are no longer needed. This is done using the with statement and is known as a context manager. When working with files, it is recommended to use the with statement to ensure that the file is properly closed after use.\n1.1. Using the with Statement The with statement in Python is used to create a context manager that automatically takes care of resource management. When working with files, the with statement ensures that the file is properly closed after use, even if an error occurs during file operations.\nExample:\nwith open(\u0026#34;example.txt\u0026#34;, \u0026#34;r\u0026#34;) as file: data = file.read() print(data) 2. Opening a File Before you can read or write to a file, you need to open it using the open() function. The open() function takes two arguments: the file path and the mode in which you want to open the file.\n2.1. Modes for Opening Files Python supports various modes for opening files, depending on the operations you want to perform. Some common modes include:\nr: Read mode. Opens the file for reading. The file must exist. w: Write mode. Opens the file for writing. If the file exists, it will be truncated. If the file does not exist, a new file will be created. a: Append mode. Opens the file for writing. If the file exists, the data will be appended to the end. If the file does not exist, a new file will be created. b: Binary mode. Opens the file in binary mode.use for image,video,etc as it will not convert the data to text .You can add b to any mode to open the file in binary mode like rb,wb,ab. t: Text mode. Opens the file in text mode (default). 2.2. Opening a File To open a file, you can use the open() function with the desired file path and mode. You can also specify additional parameters such as encoding, buffering, and newline characters.\nExample:\n# Open a file in read mode with open(\u0026#34;example.txt\u0026#34;, \u0026#34;r\u0026#34;) as file: data = file.read() print(data) 3. Reading from a File Once you have opened a file, you can read its contents using various methods provided by Python. The most common methods for reading from a file is read().\n# Open a file in read mode with open(\u0026#34;example.txt\u0026#34;, \u0026#34;r\u0026#34;) as file: data = file.read() print(data) 4. Writing to a File To write data to a file, you can use the write() method provided by Python. You can write text data to a file using the write() method.\nUsing w mode: # Open a file in write mode with open(\u0026#34;example.txt\u0026#34;, \u0026#34;w\u0026#34;) as file: file.write(\u0026#34;Hello, World!\u0026#34;) Using a mode: # Open a file in append mode with open(\u0026#34;example.txt\u0026#34;, \u0026#34;a\u0026#34;) as file: file.write(\u0026#34;Hello, World!\u0026#34;) 5.Context Manager Reference\nUse of Context Manager: In any programming language, the usage of resources like file operations or database connections is very common. But these resources are limited in supply. Therefore, the main problem lies in making sure to release these resources after usage. If they are not released then it will lead to resource leakage and may cause the system to either slow down or crash. It would be very helpful if users have a mechanism for the automatic setup and teardown of resources. In Python, it can be achieved by the usage of context managers which facilitate the proper handling of resources.\nWhat is happened When the with statement is executed, it will automatically call the __enter__ before entering the code block, and __exit__ after exiting the code block.\nHow to create a context manager To create a context manager, you need to define a class that implements the __enter__ and __exit__ methods. The __enter__ method is called when the with statement is executed, and the __exit__ method is called after the code block is executed.\nSyntax:\nclass MyContextManager: def __init__(self,params): # Code to initialize resources def __enter__(self): # Code to setup resources return self def __exit__(self, exc_type, exc_value, traceback): # Code to release resources Example:\n#implementatio of own file handeling context manager class MeroHandle: def __init__(self,filename,mode): self.filename = filename self.mode = mode def __enter__(self): self.file = open(self.filename,self.mode) return self.file def __exit__(self,exc_type,exc_value,traceback): self.file.close() #using the context manager with MeroHandle(\u0026#34;example.txt\u0026#34;,\u0026#34;r\u0026#34;) as file: data = file.read() print(data) Normal way of file handeling try: file = open(\u0026#34;example.txt\u0026#34;,\u0026#34;r\u0026#34;) data = file.read() print(data) file.close() except: print(\u0026#34;Error Occured\u0026#34;) Advantage of context manager Over normal code When we use normal code shown above then when error occured in try block before file.close() then it will not close the file(i.e file will not be closed) and it will lead to resource leakage . But when we use context manager then it will automatically close the file just because __exit__ method is called after the code block is executed whether error occured or not. but in normal code we can manage this by using finally block but it is not recommended as it is not pythonic way of doing things. try: file = open(\u0026#34;example.txt\u0026#34;,\u0026#34;r\u0026#34;) data = file.read() print(data) except: print(\u0026#34;Error Occured\u0026#34;) finally: file.close() This will work but it is not pythonic way of doing things.Just because we have to write whole try,except,finally block for just opening and closing the file. which make code more complex and lengthy.\n","permalink":"http://localhost:1313/posts/pages/python/python_filehandeling/","summary":"An in-depth look at File Handeling.","title":"Python Fundamentals: Understanding File Handeling (Part 9)"},{"content":"Python Fundamentals: Some Important Package to Know In Python programming, packages are collections of modules that provide additional functionality to your programs. Python has a rich ecosystem of packages that can help you perform a wide range of tasks, from data analysis and visualization to web development and machine learning. In this guide, we will explore some of the most important packages in Python that you should be familiar with.\n1.json The json package in Python provides functions for encoding and decoding JSON data. JSON (JavaScript Object Notation) is a lightweight data interchange format that is easy for humans to read and write and easy for machines to parse and generate. The json package allows you to work with JSON data in Python by converting Python objects to JSON strings and vice versa.\nConversion of Python dictionary to JSON string We can convert a Python dictionary to a JSON string using the json.dumps() function. This function takes a Python object as input and returns a JSON string representation of the object. Example:\nimport json # Create a Python dictionary data = { \u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34; } # Convert the dictionary to a JSON string json_string = json.dumps(data) print(json_string) Conversion of JSON string to Python dictionary We can convert a JSON string to a Python dictionary using the json.loads() function. This function takes a JSON string as input and returns a Python object (usually a dictionary) representing the JSON data. Example:\nimport json # JSON string json_string = \u0026#39;{\u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;}\u0026#39; # Convert the JSON string to a Python dictionary data = json.loads(json_string) print(data) 2.os The os package in Python provides functions for interacting with the operating system.You can get indepth knowladge of os using its own documentation.but the most common methods are:\nos.path.join(\u0026quot;C:\u0026quot;,\u0026quot;users\u0026quot;,\u0026quot;bin\u0026quot;): Join one or more path components intelligently. os.rename(\u0026quot;old\u0026quot;,\u0026quot;new\u0026quot;): Rename a file or directory. 3.time The time package in Python provides functions for working with time-related tasks. You can use the time package to get the current time, sleep for a specified duration, and measure the execution time of your code.\ntime.time(): Returns the current time in seconds since the epoch. time.sleep(seconds): Suspends the execution of the current thread for the given number of seconds. 4.uuid The uuid package in Python provides functions for generating and working with UUIDs (Universally Unique Identifiers). UUIDs are unique identifiers that are used to identify objects in a distributed computing environment. The uuid package allows you to generate UUIDs based on various algorithms and formats.\nGenerating a UUID You can generate a UUID using the uuid.uuid4() function, which generates a random UUID. Example:\nimport uuid # Generate a random UUID uuid_value = uuid.uuid4() print(uuid_value) 5.Datetime The datetime package in Python provides classes for working with dates and times. You can use the datetime package to create, manipulate, and format dates and times in your Python programs.\nCreating a datetime object You can create a datetime object using the datetime.datetime() constructor, which takes the year, month, day, hour, minute, second, and microsecond as input. Example:\nimport datetime # Create a datetime object dt = datetime.datetime(2022, 11, 27, 10, 30, 0) print(dt) Output:\n2022-11-27 10:30:00 get current date and time You can get the current date and time using the datetime.now() method. Example:\nimport datetime # Get the current date and time now = datetime.datetime.now() print(now) Output:\n2022-11-27 10:30:00 Formatting a datetime object some Properties of datetime object:\nyear: The year of the datetime object month: The month of the datetime object (1-12) day: The day of the datetime object (1-31) hour: The hour of the datetime object (0-23) minute: The minute of the datetime object (0-59) second: The second of the datetime object (0-59) import datetime # Create a datetime object dt = datetime.datetime.now() # Format the datetime object print(dt.month()) print(dt.day()) print(dt.year()) print(dt.hour()) print(dt.minute()) print(dt.second()) Output:\n11\r27\r2022\r10\r30\r0 ","permalink":"http://localhost:1313/posts/pages/python/python_extrapackage/","summary":"An in-depth look at frequently used important package.","title":"Python Fundamentals: Some Important Package to Know (Part 10)"},{"content":"Shared References in Python: How Changes Propagate Across Variables In Python, variables are references to objects in memory. When you assign a value to a variable, you are creating a reference to the object that holds that value. In some cases, multiple variables can refer to the same object in memory. This is known as a shared reference.\nMutability and Shared References in Python: How Changes Propagate Across Variables List Lists are mutable, so if two variables reference the same list, changes through one variable will affect the other.\n# Create a list list1 = [1, 2, 3] # Create a reference to the list list2 = list1 # Modify the list through one reference list2.append(4) # Check the original list print(list1) # Output: [1, 2, 3, 4] Dictionary Dictionaries are mutable as well. If two variables point to the same dictionary, any change made through one will reflect in the other.\n# Create a dictionary dict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30} # Create a reference to the dictionary dict2 = dict1 # Modify the dictionary through one reference dict2[\u0026#34;age\u0026#34;] = 31 # Check the original dictionary print(dict1) # Output: {\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 31} Set Sets are mutable, so changes made through one reference will affect the other if two variables point to the same set.\n# Create a set set1 = {1, 2, 3} # Create a reference to the set set2 = set1 # Modify the set through one reference set2.add(4) # Check the original set print(set1) # Output: {1, 2, 3, 4} Custom Objects\nclass Person: def __init__(self, name, age): self.name = name self.age = age # Create an instance of the Person class person1 = Person(\u0026#34;Alice\u0026#34;, 30) # Create a reference to the instance person2 = person1 # Modify the instance through one reference person2.age = 31 # Check the original instance print(person1.age) # Output: 31 Note: Mutable objects like lists, dictionaries, sets, and custom objects allow changes to propagate across variables that reference the same object. Immutable objects like integers, strings, and tuples do not exhibit this behavior.\n","permalink":"http://localhost:1313/posts/pages/python/python_shared_references/","summary":"An in-depth look at shared references in Python.","title":"Python Fundamentals : Shared References in Python (part 11)"},{"content":"Object oriented programming in python Object oriented programming is a programming paradigm that provides a means of structuring programs so that properties and behaviors are bundled into individual objects.\n1. Class and Object Class is a blueprint for creating objects (a particular data structure), providing initial values for state (member variables or attributes), and implementations of behavior (member functions or methods).\nObject is an instance of a class. When class is defined, only the description for the object is defined. Therefore, no memory or storage is allocated.\n1.1 Creating a class We can create a class using the class keyword followed by the class name. The class definition can contain class variables, instance variables, methods, and constructors.\nSyntax:\nclass ClassName: #code block Example:\nclass Person: name=\u0026#34;Nirajan\u0026#34; age=20 classes=\u0026#34;Bachelor\u0026#34; 1.2 Creating an object To create an object of a class, we use the class name followed by parentheses. This calls the constructor method of the class and returns an object.\nSyntax:\nobject_name = ClassName() Example:\nperson1 = Person() 1.3 Accessing class attributes We can access the attributes of a class using the dot operator (.) followed by the attribute name.\nSyntax:\nobject_name.attribute_name Example:\nprint(person1.name) # Output: Nirajan print(person1.age) # Output: 20 print(person1.classes) # Output: Bachelor 1.4 Modifying class attributes We can modify the attributes of a class using the dot operator (.) followed by the attribute name.\nSyntax:\nobject_name.attribute_name = new_value Example:\nperson1.age = 21 print(person1.age) # Output: 21 1.5 Creating a member function We can create a member function (method) inside a class using the def keyword followed by the function name. The first parameter of the method should be self, which refers to the current instance of the class.we will see about self in next part.\nSyntax:\nclass ClassName: def method_name(self, parameters): #code block Example:\nclass Person: name=\u0026#34;Nirajan\u0026#34; age=20 classes=\u0026#34;Bachelor\u0026#34; def display(self): print(f\u0026#34;Name: {self.name}\u0026#34;) print(f\u0026#34;Age: {self.age}\u0026#34;) print(f\u0026#34;Class: {self.classes}\u0026#34;) 1.6 Calling a member function We can call a member function of a class using the dot operator (.) followed by the function name and parentheses.\nSyntax:\nobject_name.method_name(arguments) Example:\nperson1.display() 1.7 Nested member function We can call a member function from another member function of the same class using the self keyword.\nSyntax:\nclass ClassName: def method1(self): #code block self.method2() def method2(self): #code block Example:\nclass Person: name=\u0026#34;Nirajan\u0026#34; age=20 classes=\u0026#34;Bachelor\u0026#34; def display(self): print(f\u0026#34;Name: {self.name}\u0026#34;) print(f\u0026#34;Age: {self.age}\u0026#34;) print(f\u0026#34;Class: {self.classes}\u0026#34;) self.greet() def greet(self): print(\u0026#34;Hello, Welcome to the class\u0026#34;) 1.8 self parameter The self parameter is a reference to the current instance of the class, and is used to access variables and methods of the class. It is the first parameter of any method in a class.\nSyntax:\nclass ClassName: def method_name(self, parameters): #code block Example:\nclass Person: name=\u0026#34;Nirajan\u0026#34; age=20 classes=\u0026#34;Bachelor\u0026#34; def display(self): print(f\u0026#34;Name: {self.name}\u0026#34;) print(f\u0026#34;Age: {self.age}\u0026#34;) print(f\u0026#34;Class: {self.classes}\u0026#34;) self.greet() def greet(self): print(\u0026#34;Hello, Welcome to the class\u0026#34;) 2. Constructor in Python A constructor is a special type of method (function) which is used to initialize the instance members of the class. It is called when an object of the class is created.\n2.1 Creating a constructor In Python, the constructor method is called __init__. It is a special method that is automatically called when an object is created.\nSyntax:\nclass ClassName: def __init__(self, parameters): #code block Example:\nclass Person: def __init__(self, name, age, classes): self.name = name self.age = age self.classes = classes def display(self): print(f\u0026#34;Name: {self.name}\u0026#34;) print(f\u0026#34;Age: {self.age}\u0026#34;) print(f\u0026#34;Class: {self.classes}\u0026#34;) 2.2 Creating an object with constructor When an object is created, the constructor method is automatically called with the arguments passed to the class.\nSyntax:\nobject_name = ClassName(arguments) Example:\nperson1 = Person(\u0026#34;Nirajan\u0026#34;, 20, \u0026#34;Bachelor\u0026#34;) 3. Getters and Setters in Python 3.1. Getters Getters are methods is implementes by using the @property decorator. They are specially used\nto act as an value ie data instead of a method. to access the value of a private attribute without directly accessing it. Syntax:\nclass ClassName: @property def method_name(self): #code block Example:\nclass Person: def __init__(self, name, age): self._name = name self._age = age @property def display(self): return f\u0026#34;Name: {self._name}, Age: {self._age}\u0026#34; person1 = Person(\u0026#34;Nirajan\u0026#34;, 20) print(person1.display) # Output: Name: Nirajan, Age: 20 3.2. Setters Setters are methods is implementes by using the @method_name.setter decorator. They are specially used\nto set the value of a private attribute without directly setting it. to perform validation before setting the value of an attribute. Syntax:\nclass ClassName: @method_name.setter def method_name(self, value): #code block Example:\nclass Person: def __init__(self, name, age): self._name = name self._age = age @property def display(self): return f\u0026#34;Name: {self._name}, Age: {self._age}\u0026#34; @display.setter def display(self, value): self._name, self._age = value.split(\u0026#34;,\u0026#34;) self._age = int(self._age) person1 = Person(\u0026#34;Nirajan\u0026#34;, 20) print(person1.display) # Output: Name: Nirajan, Age: 20 person1.display = \u0026#34;Alice, 30\u0026#34; print(person1.display) # Output: Name: Alice, Age: 30 4. Inheritance in Python Inheritance is a mechanism in which one class acquires the properties and behavior of another class. The class which inherits the properties and behavior is known as the child class, and the class whose properties and behavior are inherited is known as the parent class.\n4.1. Creating a child class To create a child class that inherits from a parent class, we specify the parent class in parentheses after the child class name.\nSyntax:\nclass ChildClassName(ParentClassName): #code block Example:\nclass Employee: def __init__(self,name,age,id): self.name=name self.age=age self.id=id def display(self): print(f\u0026#34;Name: {self.name}\u0026#34;) print(f\u0026#34;Age: {self.age}\u0026#34;) print(f\u0026#34;ID: {self.id}\u0026#34;) class Manager(Employee):# it has all the properties of Employee class so we can access the # properties of Employee class also its method using object of Manager class def task(self): self.display() print(\u0026#34;Assigning tasks to employees\u0026#34;) class Developer(Employee): # it has all the properties of Employee class so we can access # the properties of Employee class also its method using object of Developer class def task(self): self.display() print(\u0026#34;Developing software applications\u0026#34;) manager1 = Manager(\u0026#34;Alice\u0026#34;, 30, 101) manager1.task() developer1 = Developer(\u0026#34;Bob\u0026#34;, 25, 102) developer1.task() Note : Only public and protected members are inherited by the child class. Private members are not inherited by the child class.\n5.Ascess Specifiers in Python 5.1. Public members Public members are accessible from outside the class. They can be accessed using the dot operator (.) from outside the class.\nExample:\nclass Person: name = \u0026#34;Alice\u0026#34; # Public member person1 = Person() print(person1.name) # Output: Alice 5.2. Protected members Protected members are accessible within the class and its subclasses. They are denoted by a single underscore (_) before the member name.\nExample:\nclass Person: _age = 30 # Protected member class Student(Person): def display(self): print(self._age) # Accessing protected member student1 = Student() student1.display() # Output: 30 Example of protected variable and method\nclass Person: _name = \u0026#34;Alice\u0026#34; # Protected variable def _display(self): # Protected method print(f\u0026#34;Name: {self._name}\u0026#34;) class Student(Person): def display(self): self._display() # Accessing protected metho student1 = Student() student1.display() # Output: Name: Alice 5.3. Private members Private members are accessible only within the class. They are denoted by a double underscore (__) before the member name.\nExample:\nclass Person: __city = \u0026#34;New York\u0026#34; # Private member person1 = Person() print(person1.__city) # Error: \u0026#39;Person\u0026#39; object has no attribute \u0026#39;__city\u0026#39; Example of private variable and method\nclass Person: __name = \u0026#34;Alice\u0026#34; # Private variable def __display(self): # Private method print(f\u0026#34;Name: {self.__name}\u0026#34;) person1 = Person() print(person1.__name) # Error: \u0026#39;Person\u0026#39; object has no attribute \u0026#39;__name\u0026#39; person1.__display() # Error: \u0026#39;Person\u0026#39; object has no attribute \u0026#39;__display\u0026#39; Table of Access Specifiers in Python:\nAccess Specifier Accessible from class Accessible from subclass Accessible from outside class Public Yes Yes Yes Protected Yes Yes No Private Yes No No Static Method in Python Static Method is those method that can be called without creating an object of the class. They are defined using the @staticmethod decorator. They can be called using the class name . Syntax: class ClassName: @staticmethod def method_name(parameters): #code block Example:\nclass Calculator: @staticmethod def add(a, b): return a + b result = Calculator.add(5, 3) print(result) # Output: 8 #Can call using object also calculator = Calculator() result = calculator.add(5, 3) print(result) # Output: 8 #this is also valid but it is not recommended Class Method in Python They are defined using the @classmethod decorator.The useage of class method is to access the class variable and change class variable. ie when we change variable using class method it will change for all the object of the class.THey can be called using the class name. Syntax:\nclass ClassName: @classmethod def method_name(cls, parameters): #code block Example:\nclass copany : copany=\u0026#34;Google\u0026#34; @classmethod def change_company(cls,new_company): cls.copany=new_company print(copany.copany) #Output: Google copany.change_company(\u0026#34;Microsoft\u0026#34;) print(copany.copany) #Output: Microsoft c1=copany() print(c1.copany) #Output: Microsoft c1.change_company(\u0026#34;Apple\u0026#34;) c2=copany() print(c2.copany) #Output: Applex Dir and dict method in Python dir() method is used to return a list of attributes and methods of any object. It returns a list of valid attributes and methods of the object. Syntax:\ndir(object) Example:\nclass Person: name = \u0026#34;Alice\u0026#34; age = 30 person1 = Person() print(dir(person1)) # Output: [\u0026#39;__class__\u0026#39;, \u0026#39;__delattr__\u0026#39;, \u0026#39;__dict__\u0026#39;, \u0026#39;__dir__\u0026#39;, \u0026#39;__doc__\u0026#39;, \u0026#39;__eq__\u0026#39;, \u0026#39;__format__\u0026#39;, \u0026#39;__ge__\u0026#39;, \u0026#39;__getattribute__\u0026#39;, \u0026#39;__gt__\u0026#39;, \u0026#39;__hash__\u0026#39;, \u0026#39;__init__\u0026#39;, \u0026#39;__init_subclass__\u0026#39;, \u0026#39;__le__\u0026#39;, \u0026#39;__lt__\u0026#39;, \u0026#39;__module__\u0026#39;, \u0026#39;__ne__\u0026#39;, \u0026#39;__new__\u0026#39;, \u0026#39;__reduce__\u0026#39;, \u0026#39;__reduce_ex__\u0026#39;, \u0026#39;__repr__\u0026#39;, \u0026#39;__setattr__\u0026#39;, \u0026#39;__sizeof__\u0026#39;, \u0026#39;__str__\u0026#39;, \u0026#39;__subclasshook__\u0026#39;, \u0026#39;__weakref__\u0026#39;, \u0026#39;age\u0026#39;, \u0026#39;name\u0026#39;] Example:\nl=[1,2,3] print(dir(l)) # Output: [\u0026#39;__add__\u0026#39;, \u0026#39;__class__\u0026#39;, \u0026#39;__class_getitem__\u0026#39;, \u0026#39;__contains__\u0026#39;, \u0026#39;__delattr__\u0026#39;, \u0026#39;__delitem__\u0026#39;, \u0026#39;__dir__\u0026#39;, \u0026#39;__doc__\u0026#39;, \u0026#39;__eq__\u0026#39;, \u0026#39;__format__\u0026#39;, \u0026#39;__ge__\u0026#39;, \u0026#39;__getattribute__\u0026#39;, \u0026#39;__getitem__\u0026#39;, \u0026#39;__getstate__\u0026#39;, \u0026#39;__gt__\u0026#39;, \u0026#39;__hash__\u0026#39;, \u0026#39;__iadd__\u0026#39;, \u0026#39;__imul__\u0026#39;, \u0026#39;__init__\u0026#39;, \u0026#39;__init_subclass__\u0026#39;, \u0026#39;__iter__\u0026#39;, \u0026#39;__le__\u0026#39;, \u0026#39;__len__\u0026#39;, \u0026#39;__lt__\u0026#39;, \u0026#39;__mul__\u0026#39;, \u0026#39;__ne__\u0026#39;, \u0026#39;__new__\u0026#39;, \u0026#39;__reduce__\u0026#39;, \u0026#39;__reduce_ex__\u0026#39;, \u0026#39;__repr__\u0026#39;, \u0026#39;__reversed__\u0026#39;, \u0026#39;__rmul__\u0026#39;, \u0026#39;__setattr__\u0026#39;, \u0026#39;__setitem__\u0026#39;, \u0026#39;__sizeof__\u0026#39;, \u0026#39;__str__\u0026#39;, \u0026#39;__subclasshook__\u0026#39;, \u0026#39;append\u0026#39;, \u0026#39;clear\u0026#39;, \u0026#39;copy\u0026#39;, \u0026#39;count\u0026#39;, \u0026#39;extend\u0026#39;, \u0026#39;index\u0026#39;, \u0026#39;insert\u0026#39;, \u0026#39;pop\u0026#39;, \u0026#39;remove\u0026#39;, \u0026#39;reverse\u0026#39;, \u0026#39;sort\u0026#39;] __dict__ method is used to return a dictionary containing the attributes of an object. It returns a dictionary containing the attributes of the object.\nSyntax:\nobject.__dict__ Example:\nclass Person: name = \u0026#34;Alice\u0026#34; age = 30 person1 = Person() print(person1.__dict__) # Output: {\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 30} 9.super() method in Python When a parent class and a child class define a method with the same name, and we create an object of the child class, invoking the method on the child class object will execute the method defined in the child class, not the one in the parent class. To explicitly call the parent class\u0026rsquo;s method, we can use the super() function.\nTo explicitly invoke the parent class\u0026rsquo;s version of the method, the super() function is used. This is especially useful when the child class\u0026rsquo;s method needs to build upon or extend the functionality of the parent class\u0026rsquo;s method.\nSyntax:\nsuper().method_name() Example:\nclass Person: def display(self): print(\u0026#34;Person class\u0026#34;) class Student(Person): def display(self): super().display() print(\u0026#34;Student class\u0026#34;) student1 = Student() student1.display() # Output: # Person class # Student class Example:\nclass Person: def __init__(self,name,age): self.name=name self.age=age class Student(Person): def __init__(self,name,age,roll): super().__init__(name,age) self.roll=roll def display(self): print(f\u0026#34;Name: {self.name}\u0026#34;) print(f\u0026#34;Age: {self.age}\u0026#34;) print(f\u0026#34;Roll: {self.roll}\u0026#34;) student1 = Student(\u0026#34;Alice\u0026#34;, 30, 101) student1.display() # Output: # Name: Alice # Age: 30 # Roll: 101 Note: Use super for single inheritance only. For multiple inheritance, use the class name directly.\nMagic/dunder methods in Python Magic methods are special methods that have double underscores at the beginning and end of their names. They are also known as dunder methods (short for \u0026ldquo;double underscore\u0026rdquo;). Magic methods are used to define the behavior of objects. They are automatically called when certain operations are performed on objects. Some of the commonly used magic methods are:\n__init__: Constructor method, called when an object is created. __str__: Called by the str() built-in function to return a string representation of an object. __repr__: Called by the repr() built-in function to return an unambiguous string representation of an object. __add__: Called by the + operator to perform addition. __len__: Called by the len() built-in function to return the length of an object. __call__: Called when an object is called as a function. Note : All magic method can be seen using dir(objectname) method and we can override the magic method in our class.\nexample of all method:\nclass Person: def __init__(self, name, age): self.name = name self.age = age def __str__(self): return f\u0026#34;Name: {self.name}, Age: {self.age}\u0026#34; def __repr__(self): return f\u0026#34;Person(\u0026#39;{self.name}\u0026#39;, {self.age})\u0026#34; def __add__(self, other): return self.age + other.age def __len__(self): return len(self.name) def __call__(self): return f\u0026#34;Name: {self.name}, Age: {self.age}\u0026#34; person1 = Person(\u0026#34;Alice\u0026#34;, 30) person2 = Person(\u0026#34;Bob\u0026#34;, 25) print(person1) # Output: Name: Alice, Age: 30 print(repr(person1)) # Output: Person(\u0026#39;Alice\u0026#39;, 30) print(person1 + person2) # Output: 55 print(len(person1)) # Output: 5 print(person1()) # Output: Name: Alice, Age: 30 Method Overriding Method overriding is a feature of object-oriented programming that allows a subclass to provide a specific implementation of a method that is already provided by its parent class. When a method in a subclass has the same name, same parameters or signature, and same return type as a method in its parent class, then the method in the subclass is said to override the method in the parent class. Example:\nclass Person: def display(self): print(\u0026#34;Person class\u0026#34;) class Student(Person): def display(self): print(\u0026#34;Student class\u0026#34;) student1 = Student() student1.display() # Output: Student class We can also call the parent class\u0026rsquo;s method from the overridden method using the super() function.\nExample:\nclass Person: def display(self): print(\u0026#34;Person class\u0026#34;) class Student(Person): def display(self): super().display() #Or Person.display(self) print(\u0026#34;Student class\u0026#34;) student1 = Student() student1.display() # Output: # Person class # Student class Operator overloading in Python Operator overloading is a feature of object-oriented programming that allows us to define the behavior of operators for user-defined objects. It allows us to define the behavior of operators such as +, -, *, /, ==, !=, etc., for objects of a class. To overload an operator, we need to define a special method in the class that corresponds to the operator. These special methods are called magic methods or dunder methods.\nExample:\nclass Point: def __init__(self, x, y): self.x = x self.y = y def __add__(self, other): x = self.x + other.x y = self.y + other.y return Point(x, y) def __str__(self): return f\u0026#34;({self.x}, {self.y})\u0026#34; point1 = Point(1, 2) point2 = Point(3, 4) point3 = point1 + point2 print(point3) # Output: (4, 6) Types of Inheritance in Python Inheritance is a mechanism in which one class acquires the properties and behavior of another class. There are different types of inheritance in Python: Single Inheritance: In single inheritance, a class inherits from only one parent class. The pictorial representation of single inheritance is:\nA\r|\rB Syntax:\nclass ParentClass: #code block class ChildClass(ParentClass): #code block Example:\nclass Person: def __init__(self, name, age): self.name = name self.age = age def display(self): return f\u0026#34;Name: {self.name}, Age: {self.age}\u0026#34; def __str__(self): return f\u0026#34;Name: {self.name}, Age: {self.age}\u0026#34; def __repr__(self): return f\u0026#34;Person(\u0026#39;{self.name}\u0026#39;, {self.age})\u0026#34; def __call__(self): return f\u0026#34;Name: {self.name}, Age: {self.age}\u0026#34; class Student(Person): def __init__(self,naem,age,id): super().__init__(name,age) #or Person.__init__(self,name,age) self.id=id def display(self): print(f\u0026#34;ID: {self.id}\u0026#34;,super().display()) #or Person.display(self) student1 = Student(\u0026#34;Alice\u0026#34;, 30, 101) student1.display() # Output: # ID: 101 # Name: Alice, Age: 30 Multiple Inheritance: In multiple inheritance, a class inherits from more than one parent class. The pictorial representation of multiple inheritance is:\nA B\r\\ /\rC Syntax:\nclass ParentClass1: #code block class ParentClass2: #code block class ChildClass(ParentClass1, ParentClass2): #code block Example:\nclass Person: def __init__(self, name, age): self.name = name self.age = age def display(self): return f\u0026#34;Name: {self.name}, Age: {self.age}\u0026#34; class Address: def __init__(self,city,state): self.city=city self.state=state def display(self): return f\u0026#34;City: {self.city}, State: {self.state}\u0026#34; class Student(Person,Address): def __init__(self,name,age,id,city,state): Person.__init__(self,name,age) Address.__init__(self,city,state) self.id=id def display(self): print(f\u0026#34;ID: {self.id}\u0026#34;,Person.display(self),Address.display(self)) student1 = Student(\u0026#34;Alice\u0026#34;, 30, 101,\u0026#34;New York\u0026#34;,\u0026#34;New York\u0026#34;) student1.display() # Output: # ID: 101 # Name: Alice, Age: 30 # City: New York, State: New York Multilevel Inheritance: In multilevel inheritance, a class inherits from a parent class, and another class inherits from the child class. The pictorial representation of multilevel inheritance is:\nA\r|\rB\r|\rC Syntax:\nclass ParentClass: #code block class ChildClass(ParentClass): #code block class GrandChildClass(ChildClass): #code block Example:\nclass Person: def __init__(self, name, age): self.name = name self.age = age def display(self): return f\u0026#34;Name: {self.name}, Age: {self.age}\u0026#34; class Student(Person): def __init__(self,name,age,id): super().__init__(name,age) # or Person.__init__(self,name,age) self.id=id def display(self): print(f\u0026#34;ID: {self.id}\u0026#34;,super().display()) # print(f\u0026#34;ID: {self.id}\u0026#34;,Person.display(self)) class CollegeStudent(Student): def __init__(self,name,age,id,classes): super().__init__(name,age,id) #or Student.__init__(self,name,age,id) self.classes=classes def display(self): print(f\u0026#34;Class: {self.classes}\u0026#34;,super().display()) #or print(f\u0026#34;Class: {self.classes}\u0026#34;,Student.display(self)) student1 = CollegeStudent(\u0026#34;Alice\u0026#34;, 30, 101,\u0026#34;Bachelor\u0026#34;) student1.display() # Output: # Class: Bachelor # ID: 101 # Name: Alice, Age: 30 Hierarchical Inheritance: In hierarchical inheritance, more than one class inherits from a single parent class. The pictorial representation of hierarchical inheritance is:\nA\r/ \\\rB C Syntax:\nclass ParentClass: #code block class ChildClass1(ParentClass): #code block class ChildClass2(ParentClass): #code block Example:\nclass Person: def __init__(self, name, age): self.name = name self.age = age def display(self): return f\u0026#34;Name: {self.name}, Age: {self.age}\u0026#34; class Student(Person): def __init__(self,name,age,id): super().__init__(name,age) #or Person.__init__(self,name,age) self.id=id def display(self): print(f\u0026#34;ID: {self.id}\u0026#34;,super().display()) #or print(f\u0026#34;ID: {self.id}\u0026#34;,Person.display(self)) class Employee(Person): def __init__(self,name,age,emp_id): super().__init__(name,age) #or Person.__init__(self,name,age) self.emp_id=emp_id def display(self): print(f\u0026#34;Emp ID: {self.emp_id}\u0026#34;,super().display()) #or print(f\u0026#34;Emp ID: {self.emp_id}\u0026#34;,Person.display(self)) student1 = Student(\u0026#34;Alice\u0026#34;, 30, 101) student1.display() employee1 = Employee(\u0026#34;Bob\u0026#34;, 25, 201) employee1.display() # Output: # ID: 101 # Name: Alice, Age: 30 # Emp ID: 201 # Name: Bob, Age: 25 Note: Hybrid inheritance is a combination of two or more types of inheritance.\n14. MRO (Method Resolution Order) in Python Method Resolution Order (MRO) is the order in which methods are resolved in the inheritance hierarchy. It defines the order in which the base classes are searched when executing a method.\nfor example:\nclass C: f=\u0026#34;dirajan\u0026#34; class A(C): f=\u0026#34;nirajan\u0026#34; class B(C): f=\u0026#34;kirajan\u0026#34; class D(A,B): pass def display(self): print(self.f) d=D() print(D.__mro__) d.display() Output:\n(\u0026lt;class \u0026#39;__main__.D\u0026#39;\u0026gt;, \u0026lt;class \u0026#39;__main__.A\u0026#39;\u0026gt;, \u0026lt;class \u0026#39;__main__.B\u0026#39;\u0026gt;, \u0026lt;class \u0026#39;__main__.C\u0026#39;\u0026gt;, \u0026lt;class \u0026#39;object\u0026#39;\u0026gt;)\rnirajan It means it will search for the method in the order of D-\u0026gt;A-\u0026gt;B-\u0026gt;C-\u0026gt;object if the method is not found in the D it will search in A and so on. but if the method is found in the D it will not search in the A,B,C and object.\n15.Class Inside a Class in Python A class can be defined inside another class. The class inside the class is known as nested class. The nested class can access the attributes and methods of the outer class.\nSyntax:\nclass OuterClass: class InnerClass: #code block Example:\nclass OuterClass: def __init__(self): self.name = \u0026#34;Alice\u0026#34; self.age = 30 class InnerClass: def display(self, outer): print(f\u0026#34;Name: {outer.name}\u0026#34;) print(f\u0026#34;Age: {outer.age}\u0026#34;) outer1 = OuterClass() inner1 = outer1.InnerClass() inner1.display(outer1) # Output: # Name: Alice # Age: 30 16. Nested class in Python A class can be defined inside another class. The class inside the class is known as nested class. The nested class can access the attributes and methods of the outer class.\nSyntax:\nclass OuterClass: class InnerClass: #code block Creating an object of the nested class: Syntax:\nouter_object = OuterClass() inner_object = outer_object.InnerClass() Example:\nclass OuterClass: def __init__(self): self.name = \u0026#34;Alice\u0026#34; self.age = 30 class InnerClass: def display(self, outer): print(f\u0026#34;Name: {outer.name}\u0026#34;) print(f\u0026#34;Age: {outer.age}\u0026#34;) outer1 = OuterClass() inner1 = outer1.InnerClass() inner1.display(outer1) # Output: # Name: Alice # Age: 30 creating an object of the nested class inside the outer class:\nclass OuterClass: def __init__(self): self.name = \u0026#34;Alice\u0026#34; self.age = 30 self.inner = self.InnerClass() class InnerClass: def display(self, outer): print(f\u0026#34;Name: {outer.name}\u0026#34;) print(f\u0026#34;Age: {outer.age}\u0026#34;) outer1 = OuterClass() outer1.inner.display(outer1) # Output: # Name: Alice # Age: 30 ","permalink":"http://localhost:1313/posts/pages/python/python_object_oriented1/","summary":"This is the first part of series of Object Oriented Programming in Python","title":"Python Fundamentals: Exploring OOP (Part 12)"},{"content":"DOM (Document Object Model) Theory The DOM is a programming interface for HTML and XML documents. It represents the document as a tree structure where each node is an object representing a part of the document. This allows programming languages to interact with the document structure, style, and content.\n1. DOM Selection Methods a) document.getElementById() Selects an element by its ID attribute.\n\u0026lt;!-- HTML --\u0026gt; \u0026lt;div id=\u0026#34;myDiv\u0026#34;\u0026gt;Hello\u0026lt;/div\u0026gt; // JavaScript const element = document.getElementById(\u0026#39;myDiv\u0026#39;); console.log(element.innerText); // Output: // \u0026#34;Hello\u0026#34; b) document.getElementsByClassName() Returns a collection of elements with the specified class name.\n\u0026lt;!-- HTML --\u0026gt; \u0026lt;div class=\u0026#34;myClass\u0026#34;\u0026gt;Item 1\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;myClass\u0026#34;\u0026gt;Item 2\u0026lt;/div\u0026gt; // JavaScript const elements = document.getElementsByClassName(\u0026#39;myClass\u0026#39;); for (let i = 0; i \u0026lt; elements.length; i++) { console.log(elements[i].innerText); } // Output: // \u0026#34;Item 1\u0026#34; // \u0026#34;Item 2\u0026#34; c) document.getElementsByTagName() Returns a collection of elements with the specified tag name.\n\u0026lt;!-- HTML --\u0026gt; \u0026lt;p\u0026gt;Paragraph 1\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Paragraph 2\u0026lt;/p\u0026gt; // JavaScript const paragraphs = document.getElementsByTagName(\u0026#39;p\u0026#39;); for (let i = 0; i \u0026lt; paragraphs.length; i++) { console.log(paragraphs[i].innerText); // Output: // \u0026#34;Paragraph 1\u0026#34; // \u0026#34;Paragraph 2\u0026#34; d) document.querySelector() Returns the first element that matches the CSS selector.\n\u0026lt;!-- HTML --\u0026gt; \u0026lt;div class=\u0026#34;myClass\u0026#34;\u0026gt;First Element\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;myClass\u0026#34;\u0026gt;Second Element\u0026lt;/div\u0026gt; // JavaScript const firstElement = document.querySelector(\u0026#39;.myClass\u0026#39;); console.log(firstElement.innerText); // Output: // \u0026#34;First Element\u0026#34; e) document.querySelectorAll() Returns all elements that match the CSS selector.\n\u0026lt;!-- HTML --\u0026gt; \u0026lt;div class=\u0026#34;myClass\u0026#34;\u0026gt;First Element\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;myClass\u0026#34;\u0026gt;Second Element\u0026lt;/div\u0026gt; // JavaScript const allElements = document.querySelectorAll(\u0026#39;.myClass\u0026#39;); allElements.forEach(el =\u0026gt; console.log(el.innerText)); // Output: // \u0026#34;First Element\u0026#34; // \u0026#34;Second Element\u0026#34; 2. DOM Properties a) innerText Gets or sets the text content of an element.\n\u0026lt;!-- HTML --\u0026gt; \u0026lt;div id=\u0026#34;textElement\u0026#34;\u0026gt;Original Text\u0026lt;/div\u0026gt; // JavaScript const element = document.getElementById(\u0026#39;textElement\u0026#39;); element.innerText = \u0026#39;Hello World\u0026#39;; console.log(element.innerText); // Output: // \u0026#34;Hello World\u0026#34; b) innerHTML Gets or sets the HTML content of an element.\n\u0026lt;!-- HTML --\u0026gt; \u0026lt;div id=\u0026#34;htmlElement\u0026#34;\u0026gt;Original Content\u0026lt;/div\u0026gt; // JavaScript const element = document.getElementById(\u0026#39;htmlElement\u0026#39;); element.innerHTML = \u0026#39;\u0026lt;span\u0026gt;Hello World\u0026lt;/span\u0026gt;\u0026#39;; console.log(element.innerHTML); // Output: // \u0026#34;\u0026lt;span\u0026gt;Hello World\u0026lt;/span\u0026gt;\u0026#34; c) textContent Gets or sets the text content of a node and its descendants.\n\u0026lt;!-- HTML --\u0026gt; \u0026lt;div id=\u0026#34;contentElement\u0026#34;\u0026gt;Original Content\u0026lt;/div\u0026gt; // JavaScript const element = document.getElementById(\u0026#39;contentElement\u0026#39;); element.textContent = \u0026#39;Hello World\u0026#39;; console.log(element.textContent); // Output: // \u0026#34;Hello World\u0026#34; d) style Gets or sets inline styles of an element.\n\u0026lt;!-- HTML --\u0026gt; \u0026lt;div id=\u0026#34;styledElement\u0026#34;\u0026gt;Style Me\u0026lt;/div\u0026gt; // JavaScript const element = document.getElementById(\u0026#39;styledElement\u0026#39;); element.style.backgroundColor = \u0026#39;red\u0026#39;; element.style.fontSize = \u0026#39;16px\u0026#39;; // Result: Element with red background and font size of 16px 3. Events in JavaScript Events are actions that occur in a web page that can be detected by JavaScript.\nClick Event Example \u0026lt;!-- HTML --\u0026gt; \u0026lt;button id=\u0026#34;clickButton\u0026#34;\u0026gt;Click Me\u0026lt;/button\u0026gt; // JavaScript const button = document.getElementById(\u0026#39;clickButton\u0026#39;); button.addEventListener(\u0026#39;click\u0026#39;, function(e) { console.log(\u0026#39;Clicked!\u0026#39;); }); // Output when clicked: // \u0026#34;Clicked!\u0026#34; Mouse Over Event Example \u0026lt;!-- HTML --\u0026gt; \u0026lt;div id=\u0026#34;hoverElement\u0026#34;\u0026gt;Hover Over Me\u0026lt;/div\u0026gt; // JavaScript const element = document.getElementById(\u0026#39;hoverElement\u0026#39;); element.addEventListener(\u0026#39;mouseover\u0026#39;, function(e) { console.log(\u0026#39;Mouse over!\u0026#39;); }); // Output when hovered: // \u0026#34;Mouse over!\u0026#34; ","permalink":"http://localhost:1313/posts/pages/js/domevents/","summary":"A complete reference guide for DOM manipulation and Events","title":"Javascript : Dom and Events"},{"content":"Asynchronous Programming in JavaScript Asynchronous programming allows a program to perform multiple tasks simultaneously. It enables non-blocking operations, making it possible to execute long-running tasks without freezing the main program.\nFor example:\nconsole.log(\u0026#39;Start\u0026#39;); setTimeout(() =\u0026gt; { console.log(\u0026#39;This message is delayed by 2 seconds\u0026#39;); }, 2000); console.log(\u0026#39;End\u0026#39;); When you run this code, the output will be:\nStart\rEnd\rThis message is delayed by 2 seconds Explanation:\nconsole.log('Start'); is executed, and \u0026ldquo;Start\u0026rdquo; is printed. setTimeout() sets up a callback function to run after 2000 milliseconds (2 seconds) but does not block the next line. console.log('End'); is executed immediately after, and \u0026ldquo;End\u0026rdquo; is printed. After 2 seconds, the callback function in setTimeout() is executed, and \u0026ldquo;This message is delayed by 2 seconds\u0026rdquo; is printed. This demonstrates how asynchronous functions like setTimeout() work without blocking the execution of subsequent code.\nPromises Promises are a way to handle asynchronous operations in JavaScript. They represent a value that may be available now, in the future, or never. Promises can be in one of three states: pending, fulfilled, or rejected. They allow us to run code when the promise is fulfilled or rejected using the .then() and .catch() methods.\nSyntax to create a new Promise:\nconst promise = new Promise((resolve, reject) =\u0026gt; { // Perform an asynchronous operation // If successful, call resolve(value) // If an error occurs, call reject(error) }); Why We Use Promises Consider the following code:\nfunction main() { setTimeout(() =\u0026gt; { console.log(\u0026#34;Hello\u0026#34;); }, 1000); } main(); main(); main(); This code waits for 1 second and then logs \u0026ldquo;Hello\u0026rdquo; three times instantly. But what if we want to wait for the first to be completed before the second?\nThis can be solved using promises:\nfunction promise() { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { console.log(\u0026#34;Hello\u0026#34;); resolve(\u0026#34;Done\u0026#34;); }, 2000); }); } let data = promise(); When a promise is called, it returns a promise object instantly in a pending state. When the asynchronous operation completes, the promise is either fulfilled or rejected.\nHandling Promises To do a task when the promise is fulfilled (resolved):\ndata.then((data) =\u0026gt; { console.log(data); }); To do a task when the promise is rejected:\ndata.catch((err) =\u0026gt; { console.log(\u0026#34;Promise rejected\u0026#34;, err); }); Handling Multiple Promises function promise1() { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { console.log(\u0026#34;Promise 1 resolved\u0026#34;); resolve(\u0026#34;Done 1\u0026#34;); }, 2000); }); } function promise2() { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { console.log(\u0026#34;Promise 2 resolved\u0026#34;); resolve(\u0026#34;Done 2\u0026#34;); }, 2000); }); } function promise3() { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { console.log(\u0026#34;Promise 3 resolved\u0026#34;); resolve(\u0026#34;Done 3\u0026#34;); }, 2000); }); } let data1 = promise1(); let data2 = promise2(); let data3 = promise3(); How Promises Work:\npromise1 is called. promise2 is called immediately. promise3 is called immediately, regardless of whether the previous promises are resolved. To execute promises one by one:\nlet data1 = promise1(); data1.then((data) =\u0026gt; { console.log(data); return promise2(); }).then((data) =\u0026gt; { console.log(data); return promise3(); }).then((data) =\u0026gt; { console.log(data); }).catch((err) =\u0026gt; { console.log(\u0026#34;Error\u0026#34;, err); }); Here, the first promise will run, then the second, then the third, and so on, one by one.\nAsync and Await Async functions always return a promise. await is used to wait for a promise to be resolved, such that the code below it will not run until the promise is resolved.\nTo use await, we need to use an async function:\nasync function main() { console.log(\u0026#34;Hello\u0026#34;); } main(); Example with await:\nlet promise = new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { resolve(\u0026#34;Done\u0026#34;); }, 2000); }); async function main() { console.log(\u0026#34;Hello\u0026#34;); await promise; console.log(\u0026#34;Hello again\u0026#34;); } main(); console.log(\u0026#34;Hi\u0026#34;); What happens here is the main function is called, it prints \u0026ldquo;Hello\u0026rdquo;, then waits for 2 seconds to resolve. During that time, it prints \u0026ldquo;Hi\u0026rdquo;. When the promise is resolved, it prints \u0026ldquo;Hello again\u0026rdquo;.\nWhen await is called, the function pauses its execution until the promise is resolved. Then it continues the execution of the function, such that code below await will not run until the promise is resolved, but the code outside the function will run.\nasync function main() { console.log(\u0026#34;Hello\u0026#34;); await promise; await promise; await promise; console.log(\u0026#34;Hello again\u0026#34;); } Here, the first promise is resolved, then the second is resolved, and so on.\n","permalink":"http://localhost:1313/posts/pages/js/asyncronous/","summary":"A complete guide to asynchronous programming in JavaScript, covering promises and async/await.","title":"Asynchronous Programming in JavaScript"},{"content":"Basics of Vim Vim is a powerful text editor, often used in the command line, that is known for its efficiency and speed once mastered. Here are the basic commands and modes that you need to get started.\nOpening a File To open a file in Vim, use the following command:\nvim filename Replace filename with the name of the file you wish to open.\nBasic Modes in Vim Vim operates in different modes, and understanding these modes is crucial for using Vim effectively:\nNormal Mode: This is the default mode when you open a file. In this mode, you can navigate, delete, copy, and paste text. To return to Normal Mode from other modes, press Esc.\nInsert Mode: This mode allows you to insert text into the file. To enter Insert Mode, press i. After you\u0026rsquo;re done typing, press Esc to go back to Normal Mode.\nCommon Commands Here are some essential commands for working with files in Vim:\nSave the current file:\n:w This writes (saves) changes to the file.\nQuit Vim:\n:q To quit Vim. If there are unsaved changes, Vim will warn you. You can force quit without saving using:\n:q! Save changes and quit:\n:wq or\n:x These commands save changes and then exit Vim.\nTips for Beginners Press Esc frequently to return to Normal Mode, as it helps you avoid unintended actions while in other modes. Practice using both Normal and Insert modes to become comfortable with the flow of editing and saving files in Vim. Vim can be intimidating at first, but with practice, it becomes an extremely efficient tool for editing text files, especially in programming and development environments. ","permalink":"http://localhost:1313/posts/pages/linux/vim_basics_guide/","summary":"Learn the basics of using Vim, including navigation, saving, and quitting.","title":"Basics of Vim"},{"content":"Docker Cheat Sheet: Commands and Concepts This guide covers essential Docker commands, from creating containers, managing images, building Dockerfiles, to working with volumes.\n🚀 Creating and Running Containers 1. Run a Container from an Image To create and run a container from an image:\ndocker run image 2. Run a Container in Interactive Mode To run a container and open its terminal:\ndocker run -it image After the container starts, you can interact with it directly in the terminal. 3. Name a Container To give a container a specific name:\ndocker run --name container_name image 4. Port Mapping To map a port from your computer to the container:\ndocker run -p computer_port:container_port image Incoming traffic to computer_port will be forwarded to container_port in the container. 5. Run a Container in the Background (Detached Mode) To run the container in the background:\ndocker run -d image 6. Passing Environment Variables to a Container To pass environment variables to a container:\ndocker run -e key=value image 🛠️ Managing Containers 7. Start a Container To start an existing container:\ndocker start container_id 8. Stop a Container To stop a running container:\ndocker stop container_id 9. Remove a Container To remove a container:\ndocker rm container_id Note: The container must be stopped before removal. 10. Execute a Command in a Running Container To start a terminal session inside a running container:\ndocker exec -it container_id bash 11. View Running Containers To list all currently running containers:\ndocker ps 12. View All Containers (Running and Stopped) To see all containers, including those that are stopped:\ndocker ps -a 🧱 Building Docker Images 13. Creating a Dockerfile A Dockerfile is a script used to build Docker images. Here’s an example of common Dockerfile commands:\n# Set the base image for your container FROM base_image # Run commands during the image build process RUN command # Copy files from your local machine to the container COPY source /path/in/container # Set environment variables ENV key=value # Expose a port for the container EXPOSE 8080 # Define the command to run when the container starts CMD [\u0026#34;executable\u0026#34;] # Optionally, run commands automatically when the container starts ENTRYPOINT [\u0026#34;/path/to/script\u0026#34;] # Set the working directory in the container WORKDIR /app # Copy all files from the local directory to the container, excluding files listed in .dockerignore COPY . . 14. Building a Docker Image To build a Docker image from a Dockerfile:\ndocker build -t image_name /path/to/Dockerfile 📂 Managing Docker Files 15. Using the .dockerignore File The .dockerignore file helps exclude unnecessary files from being copied into the Docker image, improving build speed and reducing image size:\nnode_modules/ .git/ 16. COPY Command in Dockerfile The COPY command copies files from your local system to the container:\nCopy all files from the current directory to the container: COPY . /path/in/container Copy a specific file: COPY ./filename.extension /path/in/container Copy an entire folder: COPY ./foldername /path/in/container Copy contents of a folder (not the folder itself): COPY ./foldername/ /path/in/container 📦 Working with Volumes 17. Mounting Volumes Volumes allow data to persist even if the container is deleted. To mount a folder from your host to the container:\ndocker run -it -v /path/on/host:/path/in/container image Example: docker run -it -v /home/user/backup:/app/data ubuntu This will map /home/user/backup on your host to /app/data inside the container. Use Cases for Volumes: Data Persistence: Preserve data even after the container is removed. Backups: Easily back up container data to the host. Shared Data: Share data between multiple containers or between host and container. 💾 Publishing Docker Images 18. Pushing an Image to Docker Hub To publish an image to Docker Hub:\nTag the image with your Docker Hub username: docker tag image_name username/image_name Log in to Docker Hub: docker login Push the image to your repository: docker push username/image_name This guide gives you the essentials for working with Docker. With these commands, you\u0026rsquo;ll be able to manage containers, build images, use volumes, and more effectively.\n","permalink":"http://localhost:1313/posts/pages/docker/docker_basics/","summary":"A guide to understanding Docker commands and concepts.","title":"Docker Basic: Commands and Concepts"},{"content":"Docker Compose Documentation Introduction Docker Compose is a tool for defining and running multi-container Docker applications. With Docker Compose, you can use a YAML file to configure your application\u0026rsquo;s services and create and start all the services from your configuration with a single command.\nBasic docker-compose.yml Structure The docker-compose.yml file is where you define the services that make up your app. A typical file might look like this:\nversion: \u0026#39;3.8\u0026#39; services: service_name: image: image_name:tag ports: - \u0026#34;host_port:container_port\u0026#34; environment: - ENV_VAR=value volumes: - \u0026#34;host_path:container_path\u0026#34; depends_on: - dependency_service Example Configurations Example 1: Basic Setup with PostgreSQL and Redis version: \u0026#39;3.8\u0026#39; services: postgres: image: postgres ports: - \u0026#34;5432:5432\u0026#34; environment: POSTGRES_USER: postgres POSTGRES_DB: review POSTGRES_PASSWORD: password redis: image: redis ports: - \u0026#34;80:80\u0026#34; Example 2: Real-World Application version: \u0026#39;3\u0026#39; services: pythonapp: image: your-python-image:tag ports: - \u0026#34;8000:8000\u0026#34; volumes: - /Users/data:/src/bin/data depends_on: - db - redis db: image: postgres environment: POSTGRES_DB: mydatabase POSTGRES_USER: myuser POSTGRES_PASSWORD: mypassword redis: image: redis volumes: - /path/to/local/directory:/data Example 3: Building from Dockerfile version: \u0026#39;3\u0026#39; services: pythonapp: build: context: . dockerfile: Dockerfile ports: - \u0026#34;8000:8000\u0026#34; volumes: - /Users/desktop:/src/bin/desktop depends_on: - db - redis db: image: postgres environment: POSTGRES_DB: mydatabase POSTGRES_USER: myuser POSTGRES_PASSWORD: mypassword redis: image: redis volumes: - /path/to/local/directory:/data Example 4: Django Application with PostgreSQL and Redis version: \u0026#39;3.8\u0026#39; services: django-app: container_name: django-app image: django-app:latest # Replace with your actual Django image name/tag ports: - \u0026#34;8000:8000\u0026#34; # Expose Django app on port 8000 environment: - DEBUG=1 # Set Django debug mode to 1 for development - POSTGRES_HOST=postgres # PostgreSQL host - POSTGRES_DB_NAME=nirajan # PostgreSQL database name - POSTGRES_DB_PASSWORD=nirajan@9845 # PostgreSQL database password - REDIS_URL=redis://redis:6379/0 # Redis URL depends_on: - postgres - redis volumes: - static_volume:/code/static # Volume for Django static files - media_volume:/code/media # Volume for Django media files postgres: container_name: postgres image: postgres:latest environment: POSTGRES_DB: nirajan # Database name POSTGRES_USER: nirajan # Database username POSTGRES_PASSWORD: nirajan@9845 # Database password volumes: - postgres_data:/var/lib/postgresql/data redis: container_name: redis image: redis:latest ports: - \u0026#34;6379:6379\u0026#34; Service Names as Hostnames In Docker Compose, the names of the services defined in the docker-compose.yml file are used as hostnames for inter-service communication.\nService Names as Hostnames Each service name in the docker-compose.yml file acts as a hostname for that service. For example, in the configuration above:\nThe django-app service can connect to the postgres service using POSTGRES_HOST=postgres. The django-app service can connect to the redis service using REDIS_URL=redis://redis:6379/0. Example In the django-app service:\nPostgreSQL Host: POSTGRES_HOST=postgres — The Django app connects to the PostgreSQL service using the hostname postgres, which matches the name of the PostgreSQL service defined in Docker Compose. Redis Host: REDIS_URL=redis://redis:6379/0 — The Django app connects to the Redis service using the hostname redis, which matches the name of the Redis service defined in Docker Compose. Note: In Docker, services within a Docker Compose setup are typically connected to the same network by default. This allows containers to communicate with each other using service names as hostnames.\nDocker Compose Commands To start the containers defined in docker-compose.yml:\nsudo docker compose up To stop and remove all containers, networks, and volumes created by docker-compose up:\nsudo docker compose down To run the containers in the background (detached mode):\nsudo docker compose up -d Tips Use depends_on to specify dependencies between services. This ensures that the dependent services start in the correct order. Use volumes to persist data outside of your containers, which is especially useful for databases. Use environment variables to configure your services and avoid hardcoding sensitive information. Conclusion Docker Compose simplifies the process of managing multi-container Docker applications. By defining your services in a docker-compose.yml file, you can easily spin up your entire application stack with a single command. This guide provides a solid starting point for using Docker Compose to manage multi-container applications effectively.\n","permalink":"http://localhost:1313/posts/pages/docker/docker_compose/","summary":"Learn how to define and manage services in Docker Compose.","title":"Docker Compose Documentation"},{"content":"Docker CPU and Memory Limits When you want to control the CPU and memory usage of Docker containers, you can use specific options in both Docker CLI commands and Docker Compose files. Here\u0026rsquo;s a detailed guide on how to use these options:\nDocker CLI Commands Setting CPU Limits:\nOption: --cpus Usage: Specifies the number of CPUs that the container can use. Example: docker run --cpus=\u0026#34;1.5\u0026#34; my-image The --cpus option limits the container to 1.5 CPU cores. Setting Memory Limits:\nOption: --memory or -m\nUsage: Sets the maximum amount of memory the container can use.\nExample:\ndocker run --memory=\u0026#34;500m\u0026#34; my-image This command limits the container to 500MB of RAM. If the limit is exceeded, the container will be throttled or terminated.\nNote: The options take a positive integer followed by suffixes such as b, k, m, or g to indicate bytes, kilobytes, megabytes, or gigabytes.\nSoft Memory Limits:\nOption: --memory-reservation Example: docker run --memory=\u0026#34;1g\u0026#34; --memory-reservation=\u0026#34;512m\u0026#34; nginx This reserves 512MB of memory while setting a hard limit of 1GB. Docker Compose Configuration In Docker Compose, you can define resource limits under the deploy section for version 3.x or directly under the services section for version 2.x.\nSetting CPU and Memory Limits in Docker Compose (Version 2.x):\nversion: \u0026#39;2\u0026#39; services: my-service: image: my-image deploy: resources: limits: cpus: \u0026#39;1.5\u0026#39; memory: 500M This limits the service to 1.5 CPUs and 500MB of memory.\nSetting CPU and Memory Limits in Docker Compose (Version 3.x and above):\nversion: \u0026#39;3.8\u0026#39; services: my-service: image: my-image deploy: resources: limits: cpus: \u0026#39;1.5\u0026#39; memory: \u0026#39;500M\u0026#39; This limits the service to 1.5 CPUs and 500MB of memory.\nNotes: Swap Memory: You can enable swap memory using the --memory-swap option in CLI. For example:\ndocker run --memory=\u0026#34;512m\u0026#34; --memory-swap=\u0026#34;1g\u0026#34; nginx CPU Shares: Set CPU priorities between containers using --cpu-shares, with 1024 being the default.\nBy using these options, you can ensure that your Docker containers use resources efficiently, preventing them from overwhelming the host machine.\n","permalink":"http://localhost:1313/posts/pages/docker/docker_cpu_memory_limits_guide/","summary":"Control the CPU and memory usage of Docker containers with CLI and Docker Compose configurations.","title":"Docker CPU and Memory Limits"},{"content":"Docker Networking and Port Access In Docker, containers are isolated by default, meaning:\nContainers cannot access the host machine\u0026rsquo;s ports directly. Containers cannot access the ports of other containers directly. Container ports are not accessible from outside the host machine unless configured. 🛠️ Accessing Container Ports from Outside To access a container\u0026rsquo;s port from outside (e.g., from the host or another machine), you can use port mapping:\n1. Port Mapping docker run -p host_port:container_port imagename This command maps a container\u0026rsquo;s port to a port on the host machine. 2. Host Network To share the host\u0026rsquo;s network namespace with the container:\ndocker run --network host imagename 🌐 Accessing Container Ports from Another Container To allow inter-container communication, you need to create and use a custom Docker network.\nSteps: 1. Create a Docker Network docker network create my_network 2. Run Containers in the Same Network docker run --network my_network --name container1 imagename docker run --network my_network --name container2 imagename 3. Access One Container from Another Use the container name and port to access one container from another:\ncontainer1:port Example Scenario Create a Network docker network create my_network Run First Container docker run --network my_network --name webserver -d nginx Run Second Container docker run --network my_network --name client -it alpine /bin/sh Access Web Server from Client Inside the client container, use the following commands to access the web server: wget -qO- http://webserver or\ncurl http://webserver 📝 Important Notes Container-to-Container Access: Containers in the same custom network can communicate using their names as hostnames. Host Machine Access: Containers cannot directly access the host machine\u0026rsquo;s ports. External Access: Use port mapping or host networking to access container ports from outside the host machine. List Docker Networks To list all available Docker networks and verify the existence of custom networks:\ndocker network ls ","permalink":"http://localhost:1313/posts/pages/docker/docker_networking_guide/","summary":"Understanding Docker networking and inter-container communication.","title":"Docker Networking and Port Access"},{"content":" 1. Configure Git To set up your Git username and email globally on your machine:\ngit config --global user.name \u0026#34;username\u0026#34; # Set your Git username git config --global user.email \u0026#34;email\u0026#34; # Set your Git email git config --list # Display the current Git configuration (username and email) 2. Git Status and Git Clone Clone a remote repository to your local machine:\ngit clone \u0026lt;url\u0026gt; # Copy repository to the local machine Check the status of your local repository:\ngit status # Show the current status of the repository Git Status Breakdown: untracked: A new file that has not been added or committed. unstaged: A file that has been added but not committed. unchanged: No changes have been made. changed: Changes have been made but not yet added or committed. 3. Git Add and Commit Add specific files or all changes and commit them:\ngit add \u0026lt;filename\u0026gt; # Add a specific file to the staging area git add . # Add all changes (modified and untracked files) git commit -m \u0026#34;Your commit message\u0026#34; # Commit the changes with a message 4. Push Local Repo to Remote To upload your local repository changes to the remote repository:\ngit push [alias] [branch] # Push changes to a specific alias and branch git remote add \u0026lt;alias\u0026gt; \u0026lt;url\u0026gt; # Add a remote alias (e.g., \u0026#39;origin\u0026#39;) git push -u [alias] [branch] # Save the alias and branch for future pushes 5. Git Initialization Initialize a new Git repository:\ngit init # Initialize a new Git repository 6. Git Branches Manage Git branches with the following commands:\ngit branch # List all local branches git branch -m \u0026lt;oldbranch\u0026gt; \u0026lt;newbranch\u0026gt; # Rename a branch git checkout \u0026lt;branchname\u0026gt; # Switch to another branch git checkout -b \u0026lt;branchname\u0026gt; # Create and switch to a new branch git branch -d \u0026lt;branchname\u0026gt; # Delete a branch (ensure you\u0026#39;re not on it) git diff \u0026lt;branchname\u0026gt; # Compare the current branch with another 7. Git Merge Merge changes from one branch into another:\ngit merge \u0026lt;branchname\u0026gt; # Merge changes from \u0026lt;branchname\u0026gt; into the current branch 8. Pull Request and Syncing Changes To pull updates from the remote repository to your local one:\ngit pull # Pull the latest changes from the remote repository git pull [alias] [branch] # Pull changes from a specific alias and branch 9. Undoing Changes If You Have Only Added Changes: git reset \u0026lt;filename\u0026gt; # Unstage a file from the staging area git reset # Unstage all files that have been added If You Have Committed Changes: git reset HEAD~1 # Undo the last commit (one step back) git reset \u0026lt;commit_hash\u0026gt; # Reset to a specific commit hash git reset --hard \u0026lt;commit_hash\u0026gt; # Hard reset to a commit and reflect changes in your editor git log # View all commit hashes and logs 10. Forking Repositories When contributing to open-source projects, you can fork a repository, which creates a copy of the repo under your GitHub account. Afterward, you can make changes and submit a pull request:\n# Fork a repository on GitHub and clone it locally git clone \u0026lt;forked_repo_url\u0026gt; # Clone your forked repository Make changes, commit them, and push to your fork. Finally, create a pull request on GitHub to merge your changes into the original repository.\nIF ANY CONCEPT IS LAGGING THEN: Watch this helpful video\n","permalink":"http://localhost:1313/posts/pages/git/git-cheetsheet/","summary":"A brief tutorial on github recipe and git command","title":"Git Commands and Configuration Guide"},{"content":"How to Create Content for Hugo Using Markdown Hugo, a static site generator, uses Markdown (.md) files to generate content. In this guide, we will explain how you can create content for Hugo using Markdown.\n1. Front Matter Every Markdown file in Hugo requires front matter, which is metadata placed at the top of the file. It helps Hugo understand how to process the file.\nExample:\n--- title: \u0026#34;My First Hugo Post\u0026#34; date: 2024-10-18 tags: [\u0026#34;Hugo\u0026#34;, \u0026#34;Markdown\u0026#34;] summary: \u0026#34;A brief summary of the post.\u0026#34; --- 2. Headers Headers are used to organize content. Use one # for an H1 header, two ## for H2, and so on.\nExample:\n# H1 Header ## H2 Header ### H3 Header Output:\nH3 Header 3. Text Formatting Markdown supports several text formatting options:\nExample:\n**Bold Text** *Italic Text* ~~Strikethrough~~ Output: Bold Text\nItalic Text\nStrikethrough\n4. Spacing and Line Breaks In Markdown, you can create paragraphs by leaving a blank line between lines of text.\nExample:\nThis is the first paragraph. This is the second paragraph. Output: This is the first paragraph.\nThis is the second paragraph.\n5. Horizontal Rules You can create horizontal lines (dividers) using three or more dashes (---), asterisks (***), or underscores (___).\nExample:\n--- Output:\n6. Lists Create unordered lists with - or *, and ordered lists with numbers followed by periods.\nExample:\n- Item 1 - Item 2 1. First item 2. Second item Output:\nItem 1 Item 2 First item Second item 7. Links and Images Add links and images with square brackets [] and parentheses ().\nExample:\n[Hugo Documentation](https://gohugo.io) ![Hugo Logo](/images/hugo.webp) Output: Hugo Documentation\n8. Code Blocks For inline code, use backticks. For block code, use triple backticks.\nExample:\nInline code: `print(\u0026#34;Hello World\u0026#34;)` Output: Inline code: print(\u0026quot;Hello World\u0026quot;)\nExample:\nBlock Code: def hello(): print(\u0026#34;Hello, Hugo!\u0026#34;) def hello(): print(\u0026#34;Hello, Hugo!\u0026#34;) 9. Blockquotes Use the greater than symbol (\u0026gt;) to create blockquotes.\nExample:\n\u0026gt; This is a blockquote in Hugo. Output:\nThis is a blockquote in Hugo.\n10. Tables You can create tables using pipes | and dashes -.\nExample:\n| Column 1 | Column 2 | |----------|----------| | Row 1 | Data 1 | | Row 2 | Data 2 | Output:\nColumn 1 Column 2 Row 1 Data 1 Row 2 Data 2 11. Task Lists Create task lists by using square brackets []. An x in the brackets [x] marks a task as completed.\nExample:\n- [ ] Task 1 - [x] Task 2 (Completed) Output:\nTask 1 Task 2 (Completed) 12. Syntax Highlighting Hugo supports syntax highlighting for various programming languages. You can specify the language after the triple backticks(```).\nExample: Output:\ndef greet(): print(\u0026#34;Hello, Hugo!\u0026#34;) 12. Task Lists Create task lists by using square brackets []. An x in the brackets [x] marks a task as completed.\nExample:\n- [ ] Task 1 - [ ] Sub-task 1 - [x] Sub-task 2 (Completed) - [x] Task 2 (Completed) Output:\nTask 1 Sub-task 1 Sub-task 2 (Completed) Task 2 (Completed) 13. Escaping Special Characters To use special characters like #, escape them using a backslash \\.\nExample:\n\\# This is not a header Output: # This is not a header\n14. Backtick To display backtick use four space before it as\n``` 15. Consistency It\u0026rsquo;s important to maintain consistent formatting throughout your Markdown files to ensure a clean and readable structure.\nBy following these steps, you can effectively create well-formatted content for your Hugo site using Markdown.\n","permalink":"http://localhost:1313/posts/pages/hugo/markdown_hugo_content_guide/","summary":"A tutorial on creating content with Markdown in Hugo.","title":"How to Create Content for Hugo"},{"content":"JavaScript Reference Behavior: Objects and Arrays Introduction In JavaScript, both objects and arrays are considered reference types. This means that when you assign an object or an array to another variable, you’re not creating a new copy of that object or array. Instead, the new variable holds a reference to the original object or array in memory. Understanding this concept is crucial because it directly affects how data is manipulated and shared within your code.\nObject Reference Behavior 1. Overview When you work with objects in JavaScript, it\u0026rsquo;s essential to recognize that assigning an object to a new variable does not create a new object. Instead, it creates a reference to the original object. This means that any changes made through the new reference will affect the original object.\n2. Example const person = { name: \u0026#34;Alice\u0026#34;, address: { city: \u0026#34;Wonderland\u0026#34; } }; const newPerson = person.address; // newPerson now references the same object as person.address newPerson.city = \u0026#34;New Wonderland\u0026#34;; // modifying newPerson affects the original object console.log(person); // Output: { name: \u0026#39;Alice\u0026#39;, address: { city: \u0026#39;New Wonderland\u0026#39; } } ## JavaScript Reference Behavior: Objects and Arrays ### Introduction In JavaScript, both objects and arrays are considered reference types. This means that when you assign an object or an array to another variable, you’re not creating a new copy of that object or array. Instead, the new variable holds a reference to the original object or array in memory. Understanding this concept is crucial because it directly affects how data is manipulated and shared within your code. ### Object Reference Behavior #### 1. Overview When you work with objects in JavaScript, it\u0026#39;s essential to recognize that assigning an object to a new variable does not create a new object. Instead, it creates a reference to the original object. This means that any changes made through the new reference will affect the original object. #### 2. Example ```javascript const person = { name: \u0026#34;Alice\u0026#34;, address: { city: \u0026#34;Wonderland\u0026#34; } }; const newPerson = person.address; // newPerson now references the same object as person.address newPerson.city = \u0026#34;New Wonderland\u0026#34;; // modifying newPerson affects the original object console.log(person); // Output: { name: \u0026#39;Alice\u0026#39;, address: { city: \u0026#39;New Wonderland\u0026#39; } } 3. Explanation Object Reference: When you create const newPerson = person.address;, you\u0026rsquo;re not making a copy of the address object. Instead, newPerson references the same address object that person.address references. Thus, when you update newPerson.city = \u0026quot;New Wonderland\u0026quot;;, it directly modifies the person.address object because both newPerson and person.address are pointing to the same location in memory. Output: The console logs the person object, which now reflects the change: { name: 'Alice', address: { city: 'New Wonderland' } }. Array Reference Behavior 1. Overview Arrays in JavaScript behave similarly to objects in terms of reference handling. When you assign an array to another variable, you create a reference to the original array. As a result, any modifications through this reference will affect the original array.\n2. Example const numbers = [1, 2, 3]; const moreNumbers = numbers; // moreNumbers now references the same array as numbers moreNumbers[0] = 99; // modifying moreNumbers affects the original array console.log(numbers); // Output: [99, 2, 3] 3. Explanation Array Reference: When you create const moreNumbers = numbers;, you\u0026rsquo;re not creating a new array. Instead, moreNumbers becomes a reference to the same array that numbers references. Any changes to moreNumbers, such as moreNumbers[0] = 99, directly modify the numbers array because both variables point to the same array in memory. Output: The console logs the numbers array, which now reflects the change: [99, 2, 3]. Key Takeaways Reference Types: Both objects and arrays are reference types in JavaScript, meaning that variables assigned to them hold references to the same data in memory. Shared Modifications: Changes made to an object or array through one reference will affect all other references to that same object or array. Memory Efficiency: This reference behavior allows for memory-efficient data management but requires careful handling to avoid unintended side effects. JavaScript References with filter() and find() In JavaScript, the way references work with methods like filter() and find() is different, leading to distinct behaviors. Understanding these differences is crucial for working effectively with arrays and avoiding unintended side effects.\nfilter(): Creating a New Array 1. Overview The filter() method in JavaScript creates a new array that contains only the elements that satisfy the provided condition. This means that a new array is returned, and it does not affect the original array. However, if the elements in the array are objects, the references to these objects are retained, meaning any modifications to the objects in the new array will also affect the original array.\n2. Example const originalArray = [ { id: 1, name: \u0026#34;Alice\u0026#34; }, { id: 2, name: \u0026#34;Bob\u0026#34; }, { id: 3, name: \u0026#34;Charlie\u0026#34; } ]; const filteredArray = originalArray.filter(item =\u0026gt; item.id !== 2); // Modify an object in the filtered array filteredArray[0].name = \u0026#34;Alicia\u0026#34;; console.log(originalArray); // Output: [{ id: 1, name: \u0026#39;Alicia\u0026#39; }, { id: 2, name: \u0026#39;Bob\u0026#39; }, { id: 3, name: \u0026#39;Charlie\u0026#39; }] console.log(filteredArray); // Output: [{ id: 1, name: \u0026#39;Alicia\u0026#39; }, { id: 3, name: \u0026#39;Charlie\u0026#39; }] 3. Explanation New Array Creation: The filter() method creates a new array (filteredArray) that includes all elements from originalArray except the one with id 2. However, the objects within the new array are still references to the original objects in originalArray. Shared References: When you modify the name property of the first object in filteredArray (filteredArray[0].name = \u0026quot;Alicia\u0026quot;;), it also changes in originalArray because both arrays reference the same object in memory. Output: The original array shows that the name of the first object has been changed to \u0026ldquo;Alicia\u0026rdquo;, indicating that the object references are shared. find(): Returning a Single Element Reference 1. Overview The find() method returns the first element in the array that satisfies the provided condition. This element is not a copy but a reference to the original element in the array. As a result, any modification to this element directly affects the original array.\n2. Example const originalArray = [ { id: 1, name: \u0026#34;Alice\u0026#34; }, { id: 2, name: \u0026#34;Bob\u0026#34; }, { id: 3, name: \u0026#34;Charlie\u0026#34; } ]; const foundItem = originalArray.find(item =\u0026gt; item.id === 2); // Modify the found item foundItem.name = \u0026#34;Robert\u0026#34;; console.log(originalArray); // Output: [{ id: 1, name: \u0026#39;Alice\u0026#39; }, { id: 2, name: \u0026#39;Robert\u0026#39; }, { id: 3, name: \u0026#39;Charlie\u0026#39; }] console.log(foundItem); // Output: { id: 2, name: \u0026#39;Robert\u0026#39; } 3. Explanation Element Reference: The find() method returns a reference to the first element that meets the condition (item.id === 2). In this case, foundItem references the same object in memory as the element in originalArray with id: 2. Direct Modification: When you modify the name property of foundItem (foundItem.name = \u0026quot;Robert\u0026quot;;), it directly alters the corresponding object in originalArray because they are the same object in memory. Output: The original array now shows that the name of the object with id: 2 has been changed to \u0026ldquo;Robert\u0026rdquo;, demonstrating that the reference was modified. Key Differences Between filter() and find() New Array vs. Single Element: filter(): Returns a new array containing references to elements that meet the condition. find(): Returns a reference to the first element that meets the condition. Impact on Original Array: filter(): The original array remains unchanged, but the objects within the new array are still references to the original objects. find(): The original array can be directly modified through the returned element. Use Cases: Use filter() when you need a subset of the original array without altering it directly. Use find() when you need to retrieve and possibly modify a specific element from the array. Conclusion Understanding how references work with methods like filter() and find() is crucial in JavaScript. While filter() returns a new array that retains references to the original objects, find() returns a direct reference to a single element. Being aware of these behaviors helps prevent unintended modifications to your data.\n","permalink":"http://localhost:1313/posts/pages/js/referencebehavious/","summary":"Learn about reference types in JavaScript, including objects and arrays, and how methods like filter() and find() handle references.","title":"JavaScript Reference Behavior: Objects and Arrays"},{"content":"JavaScript Reference Guide 1. Console.log() Method Purpose: Prints output to the console, useful for debugging. Syntax: console.log(value); Example: const name = \u0026#39;John\u0026#39;; console.log(name); // Output: John 2. Variables: let, const let: Block-scoped variable that can be updated but not accessed before declaration.\nlet x = 10; if (true) { let x = 20; // Block-scoped console.log(x); // 20 } console.log(x); // 10 const: Block-scoped variable that cannot be reassigned and must be initialized when declared.\nconst pi = 3.14; // pi = 3.1415; // Error: Cannot reassign 3. JavaScript Data Types String\nExplanation: Represents a sequence of characters. Can be enclosed in single quotes, double quotes, or backticks (for template literals). Syntax: const str = 'Hello, World!'; Example: const greeting = \u0026#34;Hello, \u0026#34; + \u0026#34;World!\u0026#34;; // Output: Hello, World! Number\nExplanation: Represents both integer and floating-point numbers. JavaScript numbers range from -(2^53 - 1) to 2^53 - 1. Syntax: const num = 123; Example: const amount = 25; // Output: 25 BigInt\nExplanation: Represents integers with arbitrary precision. Denoted by appending an n to the end of the number. Syntax: const bigNum = 1234567890123456789012345678901234567890n; Example: const bigNumber = 1234567890123456789012345678901234567890n; Boolean\nExplanation: Represents a value that is either true or false. Syntax: const isTrue = true; Example: const isActive = Boolean(1); // Output: true Null\nExplanation: Represents the intentional absence of any value. Syntax: const emptyValue = null; Example: const noValue = null; Undefined\nExplanation: Represents a variable that has been declared but not assigned a value. Syntax: let uninitialized; Example: let value; console.log(value); // Output: undefined For Checking Data Type We Use: typeof variableName; 4. Explicit Type Conversion To String: String(value) or value.toString()\nlet str = String(123); // \u0026#39;123\u0026#39; To Number: Number(value), parseInt(value), or parseFloat(value)\nlet num = Number(\u0026#39;456\u0026#39;); // 456 To Boolean: Boolean(value)\nlet bool = Boolean(\u0026#39;hello\u0026#39;); // true 5. JavaScript Operators i) Comparison Operators Greater than: a \u0026gt; b Less than: a \u0026lt; b Greater than or equal to: a \u0026gt;= b Less than or equal to: a \u0026lt;= b Not equal to: a != b Equal to: a == b Strictly equal to: a === b Examples:\nconsole.log(\u0026#34;2\u0026#34; == 2); // true console.log(\u0026#34;2\u0026#34; === 2); // false ii) Logical Operators AND: operand1 \u0026amp;\u0026amp; operand2 OR: operand1 || operand2 NOT: !operand Examples:\nconsole.log(true \u0026amp;\u0026amp; false); // false console.log(true || false); // true console.log(!true); // false iii) Arithmetic Operators Addition: operand1 + operand2 Subtraction: operand1 - operand2 Multiplication: operand1 * operand2 Division: operand1 / operand2 Modulo: operand1 % operand2 Increment: operand++ Decrement: operand-- Examples:\nconsole.log(5 + 3); // 8 console.log(5 - 3); // 2 console.log(5 * 3); // 15 console.log(6 / 3); // 2 console.log(5 % 3); // 2 6. String Methods and Operations 1. Concatenation Explanation: Combines two or more strings into one. Syntax: string1 + string2 Returns: A new string combining the original strings. Example: let a = \u0026#39; My name is nirajan \u0026#39;; let b = \u0026#34;nirajan\u0026#34;; console.log(a + b + \u0026#34;Khatiwada\u0026#34;); // Output: \u0026#39; My name is nirajan nirajanKhatiwada\u0026#39; 2. Simple Form (String Boilerplate) Explanation: Uses template literals to embed expressions within a string. Syntax: ${expression} Returns: A new string with evaluated expressions. Example: let a = \u0026#39; My name is nirajan \u0026#39;; let b = \u0026#34;nirajan\u0026#34;; console.log(`${a}${b}khatiwada`); // Output: \u0026#39; My name is nirajan nirajankhatiwada\u0026#39; 3. Accessing Element of String Explanation: Retrieves the character at a specified index. Syntax: string[index] Returns: The character at the given index (or undefined if out of range). Example: let a = \u0026#39; My name is nirajan \u0026#39;; console.log(a[0]); // Output: \u0026#39; \u0026#39; 4. Finding Length of String Explanation: Gets the number of characters in the string. Syntax: string.length Returns: The length of the string as a number. Example: let a = \u0026#39; My name is nirajan \u0026#39;; console.log(a.length); // Output: 21 5. To Uppercase Explanation: Converts all characters in the string to uppercase. Syntax: string.toUpperCase() Returns: A new string with all characters in uppercase. Example: let a = \u0026#39; My name is nirajan \u0026#39;; console.log(a.toUpperCase()); // Output: \u0026#39; MY NAME IS NIRAJAN \u0026#39; 6. To Lowercase Explanation: Converts all characters in the string to lowercase. Syntax: string.toLowerCase() Returns: A new string with all characters in lowercase. Example: let a = \u0026#39; My name is nirajan \u0026#39;; console.log(a.toLowerCase()); // Output: \u0026#39; my name is nirajan \u0026#39; 8. String Slicing Explanation: Extracts a section of the string based on start and end indices. Syntax: string.slice(start, end) Returns: A new string containing the extracted section. Example: let a = \u0026#39; My name is nirajan \u0026#39;; console.log(a.slice(0, 4)); // Output: \u0026#39; My\u0026#39; 9. Trim Explanation: Removes whitespace from both ends of the string. Syntax: string.trim() Returns: A new string with whitespace removed from both ends. Example: let a = \u0026#39; My name is nirajan \u0026#39;; console.log(a.trim()); // Output: \u0026#39;My name is nirajan\u0026#39; 10. Replace Explanation: Replaces the first occurrence of a specified substring or pattern with a new substring. Syntax: string.replace(search, replacement) Returns: A new string with the specified substring replaced. Example: let a = \u0026#39; My name is nirajan \u0026#39;; console.log(a.replace(\u0026#34;nirajan\u0026#34;, \u0026#34;kirajan\u0026#34;)); // Output: \u0026#39; My name is kirajan \u0026#39; 11. Split Explanation: Splits the string into an array of substrings based on a separator. Syntax: string.split(separator, limit) Returns: An array of substrings. Example: let a = \u0026#39; My name is nirajan \u0026#39;; console.log(a.split(\u0026#34; \u0026#34;)); // Output: [\u0026#39; My\u0026#39;, \u0026#39;name\u0026#39;, \u0026#39;is\u0026#39;, \u0026#39;nirajan\u0026#39;] 7. Number Methods 1. toFixed() Explanation: Formats a number using fixed-point notation with a specified number of decimal places. Syntax: number.toFixed(digits); Returns: A string representing the number with the specified number of decimal places. Example: let c = 10.001; console.log(c.toFixed(10)); // Output: \u0026#39;10.0010000000\u0026#39; 2. Math.ceil() Explanation: Rounds a number up to the nearest integer. Syntax: Math.ceil(number); Returns: The smallest integer greater than or equal to the given number. Example: let a = 1.1000; console.log(Math.ceil(a)); // Output: 2 3. Math.floor() Explanation: Rounds a number down to the nearest integer. Syntax: Math.floor(number); Returns: The largest integer less than or equal to the given number. Example: console.log(Math.floor(a)); // Output: 1 4. Math.round() Explanation: Rounds a number to the nearest integer. Syntax: Math.round(number); Returns: The value of the number rounded to the nearest integer. Example: console.log(Math.round(a)); // Output: 1 5. Math.random() Explanation: Returns a pseudo-random floating-point number between 0 (inclusive) and 1 (exclusive). Syntax: Math.random(); Returns: A floating-point number between 0 (inclusive) and 1 (exclusive). Example: console.log(Math.random()); // Output: A random number between 0 and 1 8. Non-Primitive Data Types in JavaScript 1. Object Explanation: Objects are collections of key-value pairs. Keys are usually strings (or symbols) and values can be any data type. Syntax: let objectName = { key1: value1, key2: value2, // more key-value pairs }; Example: let data = { \u0026#34;name\u0026#34;: \u0026#34;nirajan\u0026#34;, \u0026#34;age\u0026#34;: 20 }; 2. Array Explanation: Arrays are ordered collections of values. Values can be of any data type and are accessed by their index. Syntax: let arrayName = [value1, value2, value3, ...]; Example: let a = [\u0026#34;nirajan\u0026#34;, \u0026#34;kirajan\u0026#34;, \u0026#34;birajan\u0026#34;]; 3. Function Explanation: Functions are blocks of code designed to perform a particular task. They can be invoked (called) to execute their code. Syntax: function functionName(parameters) { // code to be executed } Example: function outer() { console.log(\u0026#34;hi\u0026#34;); } outer(); // Output: hi 9. Array Methods 1. Indexing in Array Accessing Elements: Description: Arrays are zero-indexed, so the first element is at index 0. Returns: Value of the element at the specified index. Example: console.log(a[0]); // Output: 1 console.log(a[3]); // Output: 4 2. Slicing in Array Slicing: Description: Extracts a section of the array and returns it as a new array. Syntax: array.slice(startIndex, endIndex) Returns: A new array containing the elements from startIndex up to, but not including, endIndex. Example: console.log(a.slice(0, 2)); // Output: [1, 2] 3. Length of Array Description: Returns the number of elements in the array. Returns: Integer (length of the array). Example: console.log(a.length); // Output: 4 4. Push Description: Adds one or more elements to the end of the array. Returns: The new length of the array. Example: a.push(5); console.log(a); // Output: [1, 2, 3, 4, 5] 5. Pop Description: Removes the last element from the array. Returns: The removed element. Example: a.pop(); console.log(a); // Output: [1, 2, 3, 4] 6. Shift Description: Removes the first element from the array. Returns: The removed element. Example: a.shift(); console.log(a); // Output: [2, 3, 4] 7. Unshift Description: Adds one or more elements to the beginning of the array. Returns: The new length of the array. Example: a.unshift(0); console.log(a); // Output: [0, 1, 2, 3, 4] 8. Join Description: Joins all elements of an array into a string, separated by a specified separator. Returns: A string representing the array elements joined by the specified separator. Example: let data = a.join(\u0026#34; \u0026#34;); console.log(data); // Output: \u0026#34;1 2 3 4\u0026#34; 9. Concatenation of Two Arrays Description: Merges two or more arrays into one. Returns: A new array containing the elements of the original arrays. Example: let a2 = [5, 4, 1, 3, 4]; console.log(a.concat(a2)); // Output: [1, 2, 3, 4, 5, 4, 1, 3, 4] 10. Sort Description: Sorts the elements of an array in place. Returns: The sorted array. Example: a2.sort(); console.log(a2); // Output: [1, 3, 4, 4, 5] 11. Reverse Description: Reverses the order of the elements in the array. Returns: The reversed array. Example: a2.reverse(); console.log(a2); // Output: [5, 4, 4, 3, 1] 12. Removing Elements from a Specific Position Description: Changes the contents of an array by removing or replacing existing elements. Syntax: array.splice(index, numberOfElementsToRemove) Returns: An array containing the removed elements. Example: let newData = [1, 2, 3, 4]; newData.splice(1, 2); // Removes 2 elements starting at index 1 console.log(newData); // Output: [1, 4] 13. Inserting Elements at a Specific Position Description: Inserts elements into the array. Syntax: array.splice(index, 0, element1, element2, ...) Returns: An array containing the removed elements (empty if no elements were removed). Example: let lasrData = [1, 4]; lasrData.splice(1, 0, 2, 3); // Inserts elements 2 and 3 at index 1 console.log(lasrData); // Output: [1, 2, 3, 4] 14. Spread Operator (\u0026hellip;) Description: Spreads out elements of an array into another array or function arguments. Returns: A new array containing the elements spread from the original arrays. Example: let finalData = [...newData, ...lasrData]; console.log(finalData); // Output: [1, 4, 1, 2, 3, 4] 15. Array Destructuring Description: Allows unpacking values from arrays into distinct variables in a concise and readable way. Basic Syntax: const [var1, var2, var3] = array; Example: const numbers = [1, 2, 3]; const [first, second, third] = numbers; console.log(first); // Output: 1 console.log(second); // Output: 2 console.log(third); // Output: 3 10. Object in Js i. Defining an Object An object in JavaScript is a collection of key-value pairs. Each key (also known as a property) is a unique identifier, and the value can be anything: a string, number, array, function, or even another object. Example:\nconst myObject = { name: \u0026#34;Nirajan\u0026#34;, // String property class: \u0026#34;Bachelor\u0026#34;, // String property is_topper: \u0026#34;No\u0026#34;, // Boolean property (as a string) greet: function (from) { // Method (function inside an object) console.log(`Welcome ${this.name}. From ${from}`); } }; ii. Accessing There are two common ways to access properties in an object:\nDot Notation: console.log(myObject.name); // Output: nirajan This is the most common and preferred method when you know the property name in advance. Bracket Notation: console.log(myObject[\u0026#39;name\u0026#39;]); // Output: nirajan Bracket notation is useful when the property name is stored in a variable or when it contains special characters or spaces. iii. Modifying Object Properties You can modify an object\u0026rsquo;s properties using dot or bracket notation:\nDot Notation: Use when you know the property name.\nmyObject.name = \u0026#34;Kirajan\u0026#34;; // Modifies the \u0026#39;name\u0026#39; property Bracket Notation: Use when the property name is dynamic or contains special characters.\nmyObject[\u0026#39;class\u0026#39;] = \u0026#34;Master\u0026#39;s\u0026#34;; // Modifies the \u0026#39;class\u0026#39; property iv. Adding New Properties You can dynamically add new key-value pairs to an object.\nmyObject.lol = \u0026#34;lol\u0026#34;; console.log(myObject.lol); // Output: lol v. Using the this Keyword The this keyword inside an object’s method refers to the object itself, allowing you to access its properties. Example:\nconst person = { name: \u0026#34;Kirajan\u0026#34;, greet: function() { console.log(`Hello, my name is ${this.name}`); } }; person.greet(); // Output: Hello, my name is Kirajan vi. Objects Inside Objects Objects can contain other objects, allowing you to create complex data structures. Example:\nconst a = { details: { name: \u0026#34;Nirajan\u0026#34;, age: 20 } }; console.log(a.details.name); // Output: Nirajan vii. Spread Operator (\u0026hellip;) The spread operator lets you copy, merge, or combine objects efficiently.\nCopying Properties: const original = { name: \u0026#34;Kirajan\u0026#34;, class: \u0026#34;Bachelor\u0026#34; }; const copy = { ...original }; console.log(copy); // Output: { name: \u0026#34;Kirajan\u0026#34;, class: \u0026#34;Bachelor\u0026#34; } Merging Objects: const info1 = { name: \u0026#34;Kirajan\u0026#34;, class: \u0026#34;Bachelor\u0026#34; }; const info2 = { age: 21, is_topper: true }; const combined = { ...info1, ...info2 }; console.log(combined); // Output: { name: \u0026#34;Kirajan\u0026#34;, class: \u0026#34;Bachelor\u0026#34;, age: 21, is_topper: true } viii. Object Destructuring Destructuring allows you to extract properties from an object and assign them to variables. Example:\nconst lol = { name: \u0026#34;Nirajan\u0026#34;, class: 12, rollno: \u0026#34;11\u0026#34; }; const { name, rollno } = lol; console.log(name); // Output: Nirajan console.log(rollno); // Output: 11 Also, Renaming in Destructuring: const lol = { name: \u0026#34;Nirajan\u0026#34;, class: 12, rollno: \u0026#34;11\u0026#34; }; const { name: studentName, rollno: studentRollNo } = lol; console.log(studentName); // Output: Nirajan console.log(studentRollNo); // Output: 11 ix. Object Methods Objects can have methods—functions that are properties of the object. These methods can perform actions using the object’s data. Example:\nconst calculator = { add: function(a, b) { return a + b; }, subtract: function(a, b) { return a - b; } }; console.log(calculator.add(5, 3)); // Output: 8 console.log(calculator.subtract(5, 3)); // Output: 2 11. JavaScript Functions Function Definitions: Function Expression: const add1 = function(a, b) { return a + b; }; Creates a function and assigns it to a variable. You call the function using the variable name. Arrow Function: const add2 = (a, b) =\u0026gt; { return a + b; }; Provides a shorter syntax and does not have its own this context. Function Declaration: function add3(a, b) { return a + b; } Defines a function with a name. It is hoisted, so it can be called before its declaration. Comparison: add3 has its own this context, while add1 and add2 do not. Using the Spread Operator: function add(...data) { let sum = 0; for (let i = 0; i \u0026lt; data.length; i++) { sum += data[i]; } return sum; } console.log(add(1, 2, 3)); // Output: 6 The ...data syntax lets the function accept any number of arguments as an array.\nImmediately Invoked Function Expression (IIFE): ( function add(a, b) { console.log(a + b); } )(2, 3); // Output: 5 An IIFE is a function that runs immediately after its definition, creating a local scope to avoid affecting the global scope.\n12. Control Flow in JavaScript Conditional Statements: if-else Statement: Executes code blocks based on a condition. let a = 2; if (a === 1) { console.log(1); } else if (a === 2) { console.log(2); } else { console.log(\u0026#34;None\u0026#34;); } Truthy and Falsy Values: Falsy Values: Values that evaluate to false in a boolean context. console.log(Boolean(false)); // false console.log(Boolean(0)); // false console.log(Boolean(-0)); // false console.log(Boolean(0n)); // false console.log(Boolean(\u0026#34;\u0026#34;)); // false console.log(Boolean(null)); // false console.log(Boolean(undefined)); // false console.log(Boolean(NaN)); // false Truthy Values: Any value that is not falsy. console.log(Boolean(true)); // true console.log(Boolean(1)); // true console.log(Boolean(-1)); // true console.log(Boolean(\u0026#34;hello\u0026#34;)); // true console.log(Boolean(\u0026#34; \u0026#34;)); // true console.log(Boolean({})); // true console.log(Boolean([])); // true console.log(Boolean(function() {})); // true console.log(Boolean(Symbol())); // true console.log(Boolean(1n)); // true Nullish Coalescing Operator (??): Provides a default value when dealing with null or undefined. let val1 = null; let val2 = val1 ?? 10; console.log(val2); // Output: 10 Ternary Operator (?:): A shorthand for the if-else statement. let c = 10; let b = 10; let largest = (c \u0026gt; b) ? c : b; console.log(largest); // Output: 10 13. Loops in JavaScript For Loop // Syntax: for(initialization; condition; increment/decrement) { ... } for (let i = 0; i \u0026lt; 10; i++) { console.log(i); } While Loop // Syntax: while(condition) { ... } let i = 0; while (i \u0026lt; 10) { console.log(i); i++; } Do-While Loop // Syntax: do { ... } while(condition); let i = 0; do { console.log(i); i++; } while (i \u0026lt; 10); For-Of Loop Usage: Iterates over arrays and strings const array = [1, 2, 3]; for (const x of array) { console.log(x); } For-In Loop Usage: Iterates over the properties of an object, indices of an array, or characters of a string const obj = { \u0026#34;name\u0026#34;: \u0026#34;nirajan\u0026#34;, \u0026#34;lol\u0026#34;: \u0026#34;lol\u0026#34; }; const arr = [\u0026#34;nirajan\u0026#34;, \u0026#34;lol\u0026#34;]; const str = \u0026#34;mynameisnirajan\u0026#34;; for (const key in obj) { console.log(key); // Prints the keys of the object } for (const index in arr) { console.log(arr[index]); // Prints the values of the array } for (const index in str) { console.log(str[index]); // Prints the characters of the string } For-Each Loop Usage: Iterates over array elements const array = [1, 2, 3]; array.forEach((data) =\u0026gt; { console.log(data); }); Break and Continue Statements break: Exits the loop continue: Skips the current iteration and continues with the next iteration 14. Map, Filter, and Reduce in JavaScript i. filter() Purpose: Creates a new array with elements that pass a test. Example: To get all odd numbers from an array: const a = [1, 2, 3, 4, 5, 6]; const filtered = a.filter(num =\u0026gt; num % 2); // [1, 3, 5] ii. map() Method Purpose: map() creates a new array populated with the results of calling a provided function on every element in the calling array. It’s used to transform each element in the array. Example: Create an array of squares from an existing array. const a = [1, 2, 3, 4, 5, 6]; const squares = a.map((num) =\u0026gt; num * num); console.log(squares); // Output: [1, 4, 9, 16, 25, 36] Here, the function num * num is applied to each element, resulting in a new array of squared numbers. iii. reduce() Method Purpose: reduce() executes a reducer function on each element of the array, resulting in a single output value. It’s used to accumulate or combine values from the array into a single result. Example: Sum up all the numbers in the array. const a = [1, 2, 3, 4, 5, 6]; const sum = a.reduce((accumulator, currentValue) =\u0026gt; accumulator + currentValue, 0); console.log(sum); // Output: 21 Here, accumulator starts at 0 and currentValue iterates over each element, summing them up. iv. Method Chaining Purpose: You can chain filter(), map(), and other array methods together to perform multiple operations in a single, readable statement. Example: Filter out odd numbers and then square them. const a = [1, 2, 3, 4, 5, 6]; const result = a.filter((num) =\u0026gt; num % 2) .map((num) =\u0026gt; num * num); console.log(result); // Output: [1, 9, 25] Here, filter() first selects the odd numbers, and then map() squares those numbers, producing a new array with the squared values of the odd numbers. Summary filter(): Selects elements that meet a specific condition. map(): Transforms elements based on a function. reduce(): Reduces the array to a single value based on a function. Method Chaining: Combines multiple array operations in a concise and readable manner. These methods are powerful tools for processing and transforming arrays in JavaScript. 15. Importing and Exporting in JavaScript Default Export Only one default export is allowed per module. Use for the primary function, class, or object in a module. // utils.js export default function primaryFunction() { console.log(\u0026#34;This is the primary function\u0026#34;); } // main.js import primaryFunction from \u0026#39;./utils.js\u0026#39;; primaryFunction(); // Output: This is the primary function Named Export Allows multiple exports per module. Use to export multiple functions, variables, or objects. // utils.js function function1() { console.log(\u0026#34;This is function1\u0026#34;); } function function2() { console.log(\u0026#34;This is function2\u0026#34;); } export { function1, function2 }; // main.js import { function1, function2 } from \u0026#39;./utils.js\u0026#39;; function1(); // Output: This is function1 function2(); // Output: This is function2 Summary Default Export: One per module, no curly braces during import. Named Export: Multiple per module, use curly braces during import. 16. Error Handling Try-catch blocks are used to handle errors gracefully.\ntry { // Code that might throw an error let result = nonExistentFunction(); } catch (error) { // Code to handle the error console.log(\u0026#39;An error occurred:\u0026#39;, error.message); } finally { // Code that always executes console.log(\u0026#39;This always executes\u0026#39;); } // Output: // \u0026#34;An error occurred: nonExistentFunction is not defined\u0026#34; // \u0026#34;This always executes\u0026#34; 16.1. Custom Error Throwing You can throw custom errors using the throw statement.\nfunction divide(a, b) { if (b === 0) { throw new Error(\u0026#39;Division by zero is not allowed\u0026#39;); } return a / b; } try { console.log(divide(4, 2)); console.log(divide(4, 0)); } catch (error) { console.log(\u0026#39;Error:\u0026#39;, error.message); } // Output: // 2 // \u0026#34;Error: Division by zero is not allowed\u0026#34; 17. Timers setTimeout Schedules a function to be executed after a specified delay (in milliseconds).\nconst timeoutId = setTimeout(() =\u0026gt; { console.log(\u0026#39;Executed after 1 second\u0026#39;); }, 1000); setInterval Repeatedly executes a function at specified intervals (in milliseconds).\nconst intervalId = setInterval((a, b) =\u0026gt; { console.log(a); // Output: hi console.log(b); // Output: oi }, 20, \u0026#34;hi\u0026#34;, \u0026#34;oi\u0026#34;); clearInterval Stops a function from being executed repeatedly by clearing the interval.\nclearInterval(intervalId); clearTimeout Cancels a timeout previously established by setTimeout.\nclearTimeout(timeoutId); 18. Local Storage Local storage is a way to store data in the browser that persists even after the browser is closed.\nStoring Data localStorage.setItem(\u0026#39;name\u0026#39;, \u0026#39;Nirajan\u0026#39;); Retrieving Data const name = localStorage.getItem(\u0026#39;name\u0026#39;); console.log(name); // Output: Nirajan 19. JSON JSON (JavaScript Object Notation) is a lightweight data interchange format that is easy for humans to read and write and easy for machines to parse and generate.\nConverting Objects to JSON const person = { name: \u0026#39;Nirajan\u0026#39;, age: 20 }; const json = JSON.stringify(person); console.log(json); // Output: {\u0026#34;name\u0026#34;:\u0026#34;Nirajan\u0026#34;,\u0026#34;age\u0026#34;:20} Converting JSON to Objects const json = \u0026#39;{\u0026#34;name\u0026#34;:\u0026#34;Nirajan\u0026#34;,\u0026#34;age\u0026#34;:20}\u0026#39;; const person = JSON.parse(json); console.log(person.name); // Output: Nirajan 20. Fetch API Fetch is used to make HTTP requests and returns a promise that resolves to the response of the request.\nBasic Usage fetch(\u0026#39;https://api.example.com/data\u0026#39;) .then(response =\u0026gt; response.json()) .then(data =\u0026gt; console.log(data)) .catch(error =\u0026gt; console.error(\u0026#39;Error:\u0026#39;, error)); ","permalink":"http://localhost:1313/posts/pages/js/javascript/","summary":"A complete reference guide for JavaScript including data types, functions, DOM manipulation, and modern ES6+ features","title":"JavaScript Reference Guide"},{"content":" Linux Commands and Directories Guide Important Directories Default Web Server Root Directory\nLocation: /var/www/html\nThis is the standard location for serving web content on Apache.\nDownloads Folder\nLocation: /home/username/Downloads\nThis is where files downloaded from the internet are usually saved by default.\nDocuments Folder\nLocation: /home/username/Documents\nA common directory for storing personal documents and files.\nDesktop Folder\nLocation: /home/username/Desktop\nThis is the location for files and shortcuts displayed on your desktop screen.\nCommon Commands cd Change the current directory to another one.\nUsage: cd [directory]\nExample: cd /var/www/html changes to the web server root directory.\nls List files and directories in the current location or specified path.\nUsage: ls [options] [path]\nExample: ls -l lists files in a detailed format.\npwd Print the path of the current working directory.\nUsage: pwd\nThis command shows where you are in the filesystem.\nsudo su Switch to the superuser (root) account, allowing you to perform administrative tasks.\nUsage: sudo su\nAfter entering your password, you\u0026rsquo;ll have root access.\nsudo Execute a command with elevated privileges.\nUsage: sudo [command]\nExample: sudo apt update runs the update command as an administrator.\nmkdir Create a new directory.\nUsage: mkdir [directory name]\nExample: mkdir new_folder creates a directory named \u0026ldquo;new_folder\u0026rdquo;.\ndir List files and directories, similar to ls.\nUsage: dir [options] [path]\nThis command can be used interchangeably with ls.\nmv Move or rename files and directories.\nUsage: mv [source] [destination]\nExample: mv /home/username/Downloads/file.txt /home/username/Documents/ moves the file to a different directory.\ncp Copy files or directories.\nUsage: cp [source] [destination]\nExample: cp /home/username/Downloads/file.txt /home/username/Documents/ copies the file.\nrm Remove files or directories.\nUsage: rm [options] [file/directory]\nExample: To remove a directory and its contents, use rm -r [directory].\ntouch Create an empty file or update the timestamp of an existing file.\nUsage: touch [filename]\nExample: touch newfile.txt creates an empty file named \u0026ldquo;newfile.txt\u0026rdquo;.\ncat Display the contents of a file in the terminal.\nUsage: cat [filename]\nExample: cat file.txt shows the content of \u0026ldquo;file.txt\u0026rdquo;.\ngedit Open the Gedit text editor to edit files.\nUsage: gedit [filename]\nExample: gedit notes.txt opens \u0026ldquo;notes.txt\u0026rdquo; for editing.\nkill Terminate a process using its process ID (PID).\nUsage: kill [PID]\nExample: kill 1234 stops the process with the ID 1234.\ntop Display real-time information about system processes and resource usage.\nUsage: top\nThis command helps monitor system performance.\napt-get update Update the package lists for upgrades and new package installations.\nUsage: apt-get update\nThis command fetches the latest package information.\napt install path_of_.deb_file Install a .deb file package.\nUsage: apt install ./filename.deb\nExample: apt install ./main.deb installs the specified Debian package.\napt-get upgrade Upgrade all installed packages to their latest versions.\nUsage: apt-get upgrade\nThis command updates your installed software.\napt-get install package Install a specific software package.\nUsage: apt-get install [package]\nExample: apt-get install vim installs the Vim text editor.\nman Display the manual page for a command, providing detailed information.\nUsage: man [command]\nExample: man ls shows the manual for the ls command.\nwhoami Show the currently logged-in user\u0026rsquo;s username.\nUsage: whoami\nThis command is useful for confirming your user identity.\nzip Compress a directory and its contents into a zip file.\nUsage: zip -r [filename.zip] [foldername]\nExample: zip -r archive.zip myfolder creates a zip file of \u0026ldquo;myfolder\u0026rdquo;.\nunzip Extract files from a zip archive.\nUsage: unzip [filename]\nExample: unzip archive.zip extracts files from \u0026ldquo;archive.zip\u0026rdquo;.\napt install apache2 Install the Apache web server.\nUsage: apt install apache2\nThis command sets up Apache on your system.\nservice apache2 start Start the Apache web server.\nUsage: service apache2 start\nUse this to begin serving web content.\nservice apache2 restart Restart the Apache web server.\nUsage: service apache2 restart\nThis is useful for applying configuration changes.\nservice apache2 stop Stop the Apache web server.\nUsage: service apache2 stop\nUse this command to halt the server.\napt install redis Install the Redis database server.\nUsage: apt install redis\nThis sets up Redis for use.\nservice redis start Start the Redis server.\nUsage: service redis start\nThis command activates the Redis service.\nservice redis restart Restart the Redis server.\nUsage: service redis restart\nUse this to refresh the Redis service.\nservice redis stop Stop the Redis server.\nUsage: service redis stop\nThis halts the Redis service.\napt install mysql-server Install the MySQL server.\nUsage: apt install mysql-server\nThis command installs the MySQL database management system.\nchmod Change file or directory permissions.\nUsage: chmod [permissions] [file/folder]\nExample: chmod +rwx file.txt grants read, write, and execute permissions.\nTo remove permissions, use chmod -r file.txt.\nImportant Notes Folder Names with Spaces:\nIf a folder name contains spaces, enclose it in double quotes.\nmkdir \u0026quot;New Folder\u0026quot; creates a single folder named \u0026ldquo;New Folder\u0026rdquo;. mkdir New Folder creates two separate folders named \u0026ldquo;New\u0026rdquo; and \u0026ldquo;Folder\u0026rdquo;. Using Wildcards for Operations:\nTo perform operations on:\nAll files/folders: use *. Files with a specific extension (e.g., .exe): use *.exe. Files/folders starting with \u0026ldquo;hello\u0026rdquo;: use hello*. Use Relative Paths:\nPrefer using relative paths whenever possible to simplify navigation.\nExample: mv /home/username/Downloads/index.html /var/www/html/index.html moves a file to the web server directory. ","permalink":"http://localhost:1313/posts/pages/linux/linux_cheatsheet/","summary":"A practical guide to navigating and managing files in Linux.","title":"Linux Commands and Directories Guide"},{"content":"Learning Journey Topics I Have Learned So Far Docker Linux Celery Django Channels Git Celery Python Django JavaScript React Basics HTML CSS Tailwind Css What I Plan to Learn In third Semester Django Rest Framework (DRF) Django ORM Deep Dive React Advanced Git Advanced Docker Advanced WebSOcket Deep Dive in Django Celery Deep Dive Plan to learn in future WebSocket Deep Dive in Django Celery Deep Dive Redis for Cache Kafka Basics + Advanced Docker Advanced + Kubernetes Message Brokers Django Rest Framework (DRF) Django ORM Deep Dive React Advanced Git Advanced Django Docs+Advance Like class based views Additional Topics for Future Learning Real-time WebSocket usage in Django. Kafka streaming for handling large data volumes. Implementing Kubernetes for containerized applications. ","permalink":"http://localhost:1313/posts/pages/readinglist/my_reading/","summary":"A detailed overview of my learning journey and future plans.","title":"Learning Journey"},{"content":"44. Optimizing Performance 44.1. memo memo is a higher-order function in React that optimizes functional components by preventing unnecessary re-renders. It returns a new component that behaves the same as the original one but only re-renders if its props change or internal state changes not every time the parent component re-renders.\nWhy Use memo? When a parent component re-renders, all its child components also re-render by default—even if their props remain unchanged. This behavior can lead to performance bottlenecks. Using memo, we can avoid these unnecessary re-renders for child components.\nExample:\nimport { memo } from \u0026#39;react\u0026#39;; const MyComponent = memo((props) =\u0026gt; { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;{props.title}\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ); }); export default MyComponent; In the above example, the MyComponent functional component is wrapped with the memo function. This ensures that the component will only re-render if its props have changed or if its satate has been change not every time the parent component re-renders.\nUse Case:\nBefore using memo: In this example, the Custom component re-renders unnecessarily whenever the parent component re-renders, even if its props haven\u0026rsquo;t changed or internal state hasn\u0026rsquo;t changed. Custom.js import { useState } from \u0026#39;react\u0026#39;; const Custom = ({ title }) =\u0026gt; { const [count, setCount] = useState(0); return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;{title}\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;{count}\u0026lt;/p\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;Increment\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); }; export default Custom; App.js\nimport { useState } from \u0026#39;react\u0026#39;; import Custom from \u0026#39;./Custom\u0026#39;; function App() { const [count, setCount] = useState(0); return ( \u0026lt;div\u0026gt; \u0026lt;Custom title=\u0026#34;Counter\u0026#34; /\u0026gt; \u0026lt;p\u0026gt;{count}\u0026lt;/p\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;Increment Parent Count\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; Problem: The Custom component re-renders whenever the count state in the App component changes, even though the title prop remains the same. This can cause unnecessary rendering and reduce performance.i.e child component re-renders even if the props are not changed when the parent component re-renders.\nAfter using memo: Using memo, we can optimize the Custom component to only re-render when its props change. Custom.jsx import { useState, memo } from \u0026#39;react\u0026#39;; const Custom = memo(({ title }) =\u0026gt; { const [count, setCount] = useState(0); return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;{title}\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;{count}\u0026lt;/p\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;Increment\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); }); export default Custom; App.js\nimport { useState } from \u0026#39;react\u0026#39;; import Custom from \u0026#39;./Custom\u0026#39;; function App() { const [count, setCount] = useState(0); return ( \u0026lt;div\u0026gt; \u0026lt;Custom title=\u0026#34;Counter\u0026#34; /\u0026gt; \u0026lt;p\u0026gt;{count}\u0026lt;/p\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;Increment Parent Count\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; After using memo the Custom component will only re-render when its props change or state change i.e when the title prop changes or the count state of the Custom component changes . It will not re-render when the count state of the App component changes, which optimizes performance in this scenario as that change does not affect the Custom component.\n44.2. useCallback In every rerender of a component, the functions defined inside the component are recreated. This can lead to performance issues, especially when passing functions as props to child components. useCallback is a hook in React that memoizes functions to prevent unnecessary re-creations.\nSyntax:\nuseCallback(fn, dependencies) fn: The function value that you want to cache. It can take any arguments and return any values. React will return (not call!) your function back to you during the initial render. On next renders, React will give you the same function again if the dependencies have not changed since the last render. Otherwise, it will give you the function that you have passed during the current render, and store it in case it can be reused later. React will not call your function. The function is returned to you so you can decide when and whether to call it. dependencies: An array of values that, when changed, will cause the function to be re-created. If the dependencies array is empty, the function will only be created once, and will not be re-created on subsequent renders. Whats the use of dependencies array in useCallback? just because dependency array the function is recreated with the new values of the dependencies.\nBefore using useCallback:\nimport { useState,memo } from \u0026#39;react\u0026#39;; const Child = memo(({ handleClick }) =\u0026gt; { return ( \u0026lt;button onClick={handleClick}\u0026gt;Click Me\u0026lt;/button\u0026gt; ); }); const Parent = () =\u0026gt; { const [count, setCount] = useState(0); const handleClick = () =\u0026gt; { setCount(count + 1); }; return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;{count}\u0026lt;/p\u0026gt; \u0026lt;Child handleClick={handleClick} /\u0026gt; \u0026lt;/div\u0026gt; ); }; In the above example, the handleClick function is re-created on every re-render of the Parent component. As a result, the reference to the handleClick function passed as a prop to the Child component changes on every re-render of the Parent component. This causes the Child component to re-render unnecessarily, even though the handleClick function remains logically the same After using useCallback:\nimport { useState, useCallback, memo } from \u0026#39;react\u0026#39;; const Child = memo(({ handleClick }) =\u0026gt; { return ( \u0026lt;button onClick={handleClick}\u0026gt;Click Me\u0026lt;/button\u0026gt; ); }); const Parent = () =\u0026gt; { const [count, setCount] = useState(0); const handleClick = useCallback(() =\u0026gt; { setCount(count + 1); }, [count]); return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;{count}\u0026lt;/p\u0026gt; \u0026lt;Child handleClick={handleClick} /\u0026gt; \u0026lt;/div\u0026gt; ); }; By using useCallback, the handleClick function is memoized and will only be re-created when the count state changes. The reference to the handleClick function remains the same across re-renders of the Parent component unless the dependencies specified in the dependency array (in this case, [count]) change. This ensures that the Child component only re-renders when the count state changes, and not when the handleClick function reference changes, thus improving performance.\n44.3. useMemo useMemo is a hook in React that memoizes the result of a function. It is similar to useCallback, but instead of memoizing a function, it memoizes the result of a function.\nSyntax:\nconst cachedValue = useMemo(calculateValue, dependencies) calculateValue: The function calculating the value that you want to cache. It should be pure, should take no arguments, and should return a value of any type. React will call your function during the initial render. On next renders, React will return the same value again if the dependencies have not changed since the last render. Otherwise, it will call calculateValue, return its result, and store it so it can be reused later. dependencies: An array of values that, when changed, will cause the function to be re-executed.\nreturn On the initial render, useMemo returns the result of calling calculateValue with no arguments.During next renders, it will either return an already stored value from the last render (if the dependencies haven’t changed), or call calculateValue again, and return the result that calculateValue has returned.\nBefore using useMemo:\nimport { useState, memo } from \u0026#39;react\u0026#39;; const fibonacci = (n) =\u0026gt; { if (n \u0026lt;= 1) { return n; } return fibonacci(n - 1) + fibonacci(n - 2); }; const Fib = ()=\u0026gt;{ const [count, setCount] = useState(1); const result = fibonacci(100000000000); return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;{result} and count is {count}\u0026lt;/p\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;Increase Count\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } In the above example, the fibonacci function is called on every re-render of the Fib component. This can lead to performance issues, especially when the function is computationally expensive. In this case, the fibonacci function is called with a large number, which can cause the component to freeze or crash.\nAfter using useMemo:\nimport { useState, useMemo } from \u0026#39;react\u0026#39;; const fibonacci = (n) =\u0026gt; { if (n \u0026lt;= 1) { return n; } return fibonacci(n - 1) + fibonacci(n - 2); }; const Fib = ()=\u0026gt;{ const [count, setCount] = useState(1); const result = useMemo(() =\u0026gt; fibonacci(100000000000), []); return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;{result} and count is {count}\u0026lt;/p\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;Increase Count\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } By using useMemo, the result of the fibonacci function is memoized and will only be re-calculated when the dependencies specified in the dependency array change. In this case, the fibonacci function is only called once during the initial render of the Fib component, and the result is stored and reused on subsequent renders. This optimizes performance by preventing unnecessary re-calculation of the fibonacci function on every re-render of the component.\n45.Key conside a scenarion where your base component state variable need to be initialized with the value of the props passed to the component. since the state variable is initialized with the props value, the state variable will not be updated when the props value changes as it is initialized only. to handle we can either use useEffect or we can use key prop.\nUsing useEffect:\nimport { useEffect, useState } from \u0026#39;react\u0026#39;; const Parent = () =\u0026gt; { const [value, setValue] = useState(0); return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={() =\u0026gt; setValue(value + 1)}\u0026gt;Increment\u0026lt;/button\u0026gt; \u0026lt;Child value={value} /\u0026gt; \u0026lt;/div\u0026gt; ); }; const Child = ({ value }) =\u0026gt; { const [stateValue, setStateValue] = useState(value); useEffect(() =\u0026gt; { setStateValue(value); }, [value]); return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;State Value: {stateValue}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Props Value: {value}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); }; stateValue is initialized with the value prop and const [stateValue, setStateValue] = useState(value); runs only once during initial render so useEffect is used to update the stateValue when the value prop changes.\nUsing key prop:\nimport { useState } from \u0026#39;react\u0026#39;; const Parent = () =\u0026gt; { const [value, setValue] = useState(0); return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={() =\u0026gt; setValue(value + 1)}\u0026gt;Increment\u0026lt;/button\u0026gt; \u0026lt;Child key={value} value={value} /\u0026gt; \u0026lt;/div\u0026gt; ); }; const Child = ({ value }) =\u0026gt; { const [stateValue, setStateValue] = useState(value); return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;State Value: {stateValue}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Props Value: {value}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); }; IN the above example,When a key changes between renders, React will create a new instance of the component. By using the key prop with the value prop, we ensure that a new instance of the Child component is created whenever the value prop changes. This allows the stateValue to be initialized with the new value prop on every render, without the need for useEffect.\nNote:The useState() hook us run only one time during the initial render of the component. If the state variable is initialized with a prop value, it will not be updated when the prop value changes. To handle this scenario, we can use the useEffect() hook to update the state variable when the prop value changes. Alternatively, we can use the key prop to create a new instance of the component whenever the prop value changes, allowing the state variable to be initialized with the new prop value on every render. Similar goes for useReducer() and useRef() hooks as well.\n","permalink":"http://localhost:1313/posts/pages/react/react10/","summary":"Learn how to optimize React applications using memo for component memoization, useCallback for function memoization, and useMemo for value memoization.","title":"React : 10"},{"content":"40. useEffect useEffect is a React hook that lets you perform side effects in functional components. Common use cases include:\nEstablishing a database connection when the DOM content loads. Updating the page title when the content changes. Note: The useEffect hook runs after the component has rendered.\n41. What to Put in useEffect Use useEffect for:\nNetwork requests Operations that take time to complete (e.g., fetching data, setting timers, etc.) 42. useEffect Syntax 42.1. Importing useEffect import React, { useEffect } from \u0026#39;react\u0026#39;; 42.2. useEffect Syntax useEffect(() =\u0026gt; { // code here return () =\u0026gt; { // cleanup code here }; }, [dependencies]); The first argument is a function containing the code to execute. The second argument is an array of dependencies. If any dependency changes, the function runs again. The return statement is optional and is used for cleanup tasks, such as removing event listeners or canceling subscriptions. This cleanup function is executed: Just before the the useEffect function runs again cause due to dependency change, with variables from the previous render. After the component unmounts (i.e., when removed from the DOM). Note: When your component is added to the DOM, React runs the setup function. After each re-render with changed dependencies, React first executes the cleanup function (if provided) with old values, then runs the setup function with new values.\nExample: useEffect(() =\u0026gt; { const id = setTimeout(() =\u0026gt; { console.log(count); }, 1000); return () =\u0026gt; { clearTimeout(id); }; }, [count]); In this example, the useEffect hook runs whenever the count variable changes. It sets a timeout to log the count value after 1 second, and the cleanup function clears the previous timeout before the next execution. Cleanup Function:\nUsed for tasks like removing event listeners or clearing timeouts. Ensures stale operations are cleared before new ones are executed. Executes when dependencies change or when the component unmounts. 43. Variations of useEffect 43.1. useEffect Without Dependencies Array useEffect(() =\u0026gt; { // code here }); The useEffect function runs after every re-render. 43.2. useEffect With Empty Dependencies Array useEffect(() =\u0026gt; { // code here }, []); The useEffect function runs only once after the initial render, making it ideal for tasks like loading local storage data. 43.3. useEffect With Multiple Dependencies useEffect(() =\u0026gt; { // code here }, [count, name]); The useEffect function runs when either count or name changes. Note: In all of the variation, useEffect always runs after the first render no matter what is passed in the dependencies array.\nExample: Loading Local Storage Data Correct Usage:\nimport React, { useState, useEffect } from \u0026#39;react\u0026#39;; const App = () =\u0026gt; { const [data, setData] = useState([]); useEffect(() =\u0026gt; { const data = localStorage.getItem(\u0026#39;data\u0026#39;); if (data) { setData(JSON.parse(data)); } }, []); return ( \u0026lt;div\u0026gt; {data.map((item, index) =\u0026gt; ( \u0026lt;p key={index}\u0026gt;{item}\u0026lt;/p\u0026gt; ))} \u0026lt;/div\u0026gt; ); }; Incorrect Usage:\nimport React, { useState } from \u0026#39;react\u0026#39;; const App = () =\u0026gt; { const [data, setData] = useState([]); const loadData = () =\u0026gt; { const data = localStorage.getItem(\u0026#39;data\u0026#39;); if (data) { setData(JSON.parse(data)); } }; loadData(); return ( \u0026lt;div\u0026gt; {data.map((item, index) =\u0026gt; ( \u0026lt;p key={index}\u0026gt;{item}\u0026lt;/p\u0026gt; ))} \u0026lt;/div\u0026gt; ); }; Problem: Calling loadData directly causes an infinite loop because it triggers a re-render, which calls loadData again. Solution: Use useEffect with an empty dependency array to ensure the function runs only once after the initial render. ","permalink":"http://localhost:1313/posts/pages/react/react9/","summary":"Learn how to use the useEffect hook in React for performing side effects in functional components.","title":"React : 9"},{"content":"38. Understanding the Concept of Prop Drilling Prop drilling refers to the process of passing data from a parent component to a deeply nested child component through all the intermediate components, even if those intermediate components don’t need the data themselves. Let’s break this down with an example.\nComponent Tree Imagine the following component hierarchy: Now, suppose we want to transfer some data from the Product component to the Cart component. Since Product and Cart are in separate branches of the component tree, they don’t have a direct connection.\nHow Prop Drilling Works To make this work, we need to store the shared state in a common ancestor, which is the App component in this case. Then, we have to pass the state down through all the intermediate components, even if those components don’t actually use the data.\nHere’s a visual representation of this:\nData flows from Product → Shop → App (common ancestor). The data then flows from App → Header → CardModel → Cart. This creates a lot of unnecessary overhead because the intermediate components (Shop, Header, and CardModel) don’t need the data but still have to handle it.\nProp drilling can quickly become cumbersome in large applications with deeply nested components. To solve this, we can use state management tools like Redux, Context API, or React Query, which allow us to manage and share state more effectively without passing it through every component.\n39. Introduction to React Context API Context API is a feature in React that allows you to share data between components without having to pass props down manually at every level. It provides a way to pass data through the component tree without having to pass props down manually at every level as shown in the image below.\nHow to use context API Create a context using the createContext function. import { createContext } from \u0026#39;react\u0026#39;; const CartContext = createContext(); export default CartContext; Wrap the parent component with the Provider component. Which Component to wrap? Wrap to the common ancestor of the components that need the context data. In the example below, we wrap the App component with the Provider component. For Example:\nimport CartContext from \u0026#39;./store/CartContext\u0026#39;; function App() { return ( \u0026lt;CartContext.Provider value={data}\u0026gt; \u0026lt;Header /\u0026gt; \u0026lt;Shop /\u0026gt; \u0026lt;/CartContext.Provider\u0026gt; ); } Explaination:Since we want to share the product Component data with the Cart Component SO in order to do that we wrap the first common ancestor of the Product and Cart Component i.e App Component with the Provider Component and pass the data to the value prop of the Provider Component.\nAccess the context data in the child component using the useContext hook. for example:\nimport { useContext } from \u0026#39;react\u0026#39;; import CartContext from \u0026#39;../store/CartContext\u0026#39;; function Cart() { const cartCtx = useContext(CartContext); return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Cart\u0026lt;/h1\u0026gt; {cartCtx.products.map(product =\u0026gt; ( \u0026lt;p key={product.id}\u0026gt;{product.name}\u0026lt;/p\u0026gt; ))} \u0026lt;/div\u0026gt; ); } What Whappen when the data is updated? When the data is updated in the Provider component, all the child components that are using the context data will be re-rendered automatically. Task: Design a simple application that has a component called App. App has two child components: Header and Shop. Header has one child, CartModel, and Shop has one child, Product. Pass the data from the Product component to the CartModel component using the Context API.\nStructure of the project\nsrc\r|_components\r|_App\r|_App.js\r|_Header\r|_Header.js\r|_CartModel.js\r|_Shop\r|_Shop.js\r|_Product.js\r|_store\r|_CartContext.js CartContext.js\nimport { createContext } from \u0026#39;react\u0026#39;; const CartContext = createContext(); export default CartContext; App.js\nimport CartContext from \u0026#39;../store/CartContext\u0026#39;; import Header from \u0026#39;../Header/Header\u0026#39;; import Shop from \u0026#39;../Shop/Shop\u0026#39;; import { useState } from \u0026#39;react\u0026#39;; function App() { const [cartProducts, setCartProducts] = useState([]); const addProductToCart = (product) =\u0026gt; { setCartProducts((prevProducts) =\u0026gt; [...prevProducts, product]); }; return ( \u0026lt;CartContext.Provider value={ { products: cartProducts, addProduct: addProductToCart } }\u0026gt; \u0026lt;Header /\u0026gt; \u0026lt;Shop /\u0026gt; \u0026lt;/CartContext.Provider\u0026gt; ); } export default App; Header.js\nimport CartModel from \u0026#39;./CartModel\u0026#39;; function Header() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Header\u0026lt;/h1\u0026gt; \u0026lt;CartModel /\u0026gt; \u0026lt;/div\u0026gt; ); } export default Header; CartModel.js\nimport { useContext } from \u0026#39;react\u0026#39;; import CartContext from \u0026#39;../../store/CartContext\u0026#39;; function CartModel() { const cartCtx = useContext(CartContext); return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;CartModel\u0026lt;/h1\u0026gt; {cartCtx.products.map(product =\u0026gt; ( \u0026lt;p key={product.id}\u0026gt;{product.name}\u0026lt;/p\u0026gt; ))} \u0026lt;/div\u0026gt; ); } export default CartModel; Shop.js\nimport Product from \u0026#39;./Product\u0026#39;; function Shop() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Shop\u0026lt;/h1\u0026gt; \u0026lt;Product /\u0026gt; \u0026lt;/div\u0026gt; ); } export default Shop; Product.js\nimport { useContext } from \u0026#39;react\u0026#39;; import CartContext from \u0026#39;../../store/CartContext\u0026#39;; function Product() { const cartCtx = useContext(CartContext); const product = { id: 1, name: \u0026#39;Laptop\u0026#39; }; return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Product\u0026lt;/h1\u0026gt; \u0026lt;button onClick={() =\u0026gt; cartCtx.addProduct(product)}\u0026gt;Add to Cart\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } export default Product; Outsoursing the Context Provider Since all the logic related to the context is in the App Component so we can outsource the context provider and its logic to a separate component in order to make the App Component more clean and readable.\nCartContext.js\nimport { createContext, useState } from \u0026#39;react\u0026#39;; const CartContext = createContext(); export const CartContextProvider = (props) =\u0026gt; { const [cartProducts, setCartProducts] = useState([]); const addProductToCart = (product) =\u0026gt; { setCartProducts((prevProducts) =\u0026gt; [...prevProducts, product]); }; const context = { products: cartProducts, addProduct: addProductToCart }; return ( \u0026lt;CartContext.Provider value={context}\u0026gt; {props.children} \u0026lt;/CartContext.Provider\u0026gt; ); }; App.js\nimport Header from \u0026#39;../Header/Header\u0026#39;; import Shop from \u0026#39;../Shop/Shop\u0026#39;; import { CartContextProvider } from \u0026#39;../store/CartContext\u0026#39;; function App() { return ( \u0026lt;CartContextProvider\u0026gt; \u0026lt;Header /\u0026gt; \u0026lt;Shop /\u0026gt; \u0026lt;/CartContextProvider\u0026gt; ); } export default App; Other Components remain the same.\n39.UseReducer Hook in React USe reducer is a hook that is used for state management in React. It is an alternative to useState. It is usually preferable when you have complex state logic that involves multiple sub-values or when the next state depends on the previous one.\nHow to use useReducer Hook Create a reducer function. A reducer function is a function that takes the current state and an action as arguments and returns a new state based on the action type.action . action:It contains the object that is sent by the dispatch function. For Example:\nconst counterReducer = (state, action) =\u0026gt; { if (action.type === \u0026#39;INCREMENT\u0026#39;) { return { counter: state.counter + 1 }; } if (action.type === \u0026#39;DECREMENT\u0026#39;) { return { counter: state.counter - 1 }; } return state; }; Here, the reducer function takes two arguments: state and action. It checks the action type and returns a new state based on the action type.\nUse the useReducer hook in the component. The useReducer hook takes two arguments: the reducer function and the initial state and returns the current state and a dispatch function as an array which is shown below. For Example: import { useReducer } from \u0026#39;react\u0026#39;; const [counterState, dispatchCounter] = useReducer(counterReducer, { counter: 0 }); Here, counterState is the current state and dispatchCounter is the dispatch function that is used to dispatch an action to the reducer function and { counter: 0 } is the initial state such that the counter is initialized to 0.\nDispatch an action to the reducer function. To dispatch an action to the reducer function, you need to call the dispatch function with an object that contains the action type and any additional data that is required by the reducer function. For Example: dispatchCounter({ type: \u0026#39;INCREMENT\u0026#39; }); To change the state, you need to call the dispatch function with an object that contains the action type.Here, the action type is \u0026lsquo;INCREMENT\u0026rsquo; which increments the counter by 1.\nTask: Design a simple counter application that has a component called Counter. The Counter component has two buttons: Increment and Decrement. Use the useReducer hook to manage the state of the counter.\nStructure of the project\nsrc\r|_components\r|_Counter\r|_Counter.js Counter.js\nimport { useReducer } from \u0026#39;react\u0026#39;; const counterReducer = (state, action) =\u0026gt; { if (action.type === \u0026#39;INCREMENT\u0026#39;) { return { counter: state.counter + 1 }; } if (action.type === \u0026#39;DECREMENT\u0026#39;) { return { counter: state.counter - 1 }; } return state; }; function Counter() { const [counterState, dispatchCounter] = useReducer(counterReducer, { counter: 0 }); const handleIncrement = () =\u0026gt; { dispatchCounter({ type: \u0026#39;INCREMENT\u0026#39; }); }; const handleDecrement = () =\u0026gt; { dispatchCounter({ type: \u0026#39;DECREMENT\u0026#39; }); }; return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Counter\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;{counterState.counter}\u0026lt;/p\u0026gt; \u0026lt;button onClick={handleIncrement}\u0026gt;Increment\u0026lt;/button\u0026gt; \u0026lt;button onClick={handleDecrement}\u0026gt;Decrement\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } If we use useState hook then the code will be like this:\nimport { useState } from \u0026#39;react\u0026#39;; function Counter() { const [counter, setCounter] = useState(0); const handleIncrement = () =\u0026gt; { setCounter(counter=\u0026gt;counter + 1); }; const handleDecrement = () =\u0026gt; { setCounter(counter=\u0026gt;counter - 1); }; return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Counter\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;{counter}\u0026lt;/p\u0026gt; \u0026lt;button onClick={handleIncrement}\u0026gt;Increment\u0026lt;/button\u0026gt; \u0026lt;button onClick={handleDecrement}\u0026gt;Decrement\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } What is the difference between useState and useReducer?\nuseState is a simple and straightforward way to manage state in React. It is suitable for managing simple state logic. useReducer is more powerful and flexible than useState. It is suitable for managing complex state logic that involves multiple sub-values or when the next state depends on the previous one. Looking the example case Scenario: Here using reducer we write all the logic in a single function and then we dispatch the action to the reducer function and then the reducer function returns the new state based on the action type. This makes the code more readable and maintainable.\nbut in the case of useState, we have to write the logic for each state change separately which makes the code more complex and difficult to maintain.\nNote: Always change in state variable will cause the re-rendering of the component.\n","permalink":"http://localhost:1313/posts/pages/react/react8/","summary":"Learn about prop drilling and how to use the Context API in React to manage and share state effectively.","title":"React : 8"},{"content":"1.1 When to use asyncio? Asyncio is a library to write concurrent code using the async/await syntax. It is a single-threaded, single-process design that is ideal for I/O-bound and high-level structured network code. It is not suitable for CPU-bound code, which is better handled by the multiprocessing module.It is used for :\n2.1 Coroutine Think of a coroutine like a regular Python function but with the superpower that it can pause its execution when it encounters an operation that could take a while to complete. When that long-running operation is complete, we can “wake up” our paused coroutine and finish executing any other code in that coroutine. While a paused coroutine is waiting for the operation it paused for to finish, we can run other code. This running of other code while waiting is what gives our application concur rency. We can also run several time-consuming operations concurrently, which can give our applications big performance improvements. To both create and pause a coroutine, we’ll need to learn to use Python’s async and await keywords. The async keyword will let us define a coroutine; the await key word will let us pause our coroutine when we have a long-running operation.\n2.2 Creating a coroutine with async creating a coroutine is straightforward and not much different from creating a nor mal Python function. The only difference is that, instead of using the def keyword, we use async def. The async keyword marks a function as a coroutine instead of a nor mal Python function.\nimport asyncio async def mero_coroutine(): print(\u0026#34;Hello From Asyncio\u0026#34;) The coroutine in the preceding listing does nothing yet other than print “Hello world!” It’s also worth noting that this coroutine does not perform any long-running operations; it just prints our message and returns. This means that, when we put the coroutine on the event loop, it will execute immediately because we don’t have any blocking I/O, and nothing is pausing execution yet. This syntax is simple, but we’re creating something very different from a plain Python function. To illustrate this, let’s create a function that adds one to an integer as well as a coroutine that does the same and compare the results of calling each. We’ll also use the type convenience function to look at the type returned by calling a corou tine as compared to calling our normal function.\ndef add_function(a,b): return a+b async def add_coroutine(a,b): return a+b function=add_function(1,2) coroutine=add_coroutine(1,2) print(type(function)) print(type(coroutine)) When we run this code, we’ll see output like the following\nMethod result is 3 and the type is \u0026lt;class \u0026#39;int\u0026#39;\u0026gt;\rCoroutine result is \u0026lt;coroutine object coroutine_add_one at 0x1071d6040\u0026gt; and the type is \u0026lt;class \u0026#39;coroutine\u0026#39;\u0026gt; Notice how when we call our normal add_one function it executes immediately and returns what we would expect, another integer. However, when we call coroutine_ add_one we don’t get our code in the coroutine executed at all. We get a coroutine object instead. This is an important point, as coroutines aren’t executed when we call them directly. Instead, we create a coroutine object that can be run later. To run a corou tine, we need to explicitly run it on an event loop. So how can we create an event loop and run our coroutine?\nIn versions of Python older than 3.7, we had to create an event loop if one did not already exist. However, the asyncio library has added several functions that abstract the event loop management. There is a convenience function, asyncio.run, we can use to run our coroutine. This is illustrated in the following listing.\nimport asyncio async def add_coroutine(a,b): return a+b res=asyncio.run(add_coroutine(1,2)) print(res) When we run this code, we’ll see output like the following:\n3 We’ve properly put our coroutine on the event loop, and we have executed it! asyncio.run is doing a few important things in this scenario. First, it creates a brand-new event. Once it successfully does so, it takes whichever coroutine we pass into it and runs it until it completes, returning the result. This function will also do some cleanup of anything that might be left running after the main coroutine fin ishes. Once everything has finished, it shuts down and closes the event loop. Possibly the most important thing about asyncio.run is that it is intended to be the main entry point into the asyncio application we have created. It only executes one coroutine, and that coroutine should launch all other aspects of our application. As we progress further, we will use this function as the entry point into nearly all our applications. The coroutine that asyncio.run executes will create and run other coroutines that will allow us to utilize the concurrent nature of asyncio.\n2.3 Pausing execution with the await keyword The example we saw in block 2.2 did not need to be a coroutine, as it executed only non-blocking Python code. The real benefit of asyncio is being able to pause execu tion to let the event loop run other tasks during a long-running operation. To pause execution, we use the await keyword. The await keyword is usually followed by a call to a coroutine (more specifically, an object known as an awaitable, which is not always a coroutine; we’ll learn more about awaitables later in the chapter). Using the await keyword will cause the coroutine following it to be run, unlike calling a coroutine directly, which produces a coroutine object. The await expression will also pause the coroutine where it is contained in until the coroutine we awaited finishes and returns a result. When the coroutine we awaited finishes, we’ll have access to the result it returned, and the containing coroutine will “wake up” to handle the result. We can use the await keyword by putting it in front of a coroutine call. Expanding on our earlier program, we can write a program where we call the add_coroutine function inside of a “main” async function and get the result\nimport asyncio async def add_one(number: int) -\u0026gt; int: return number + 1 async def main() -\u0026gt; None: one_plus_one = await add_one(1) # Pause, and wait for the result of add_one(1). two_plus_one = await add_one(2) # Pause, and wait for the result of add_one(2). print(one_plus_one) print(two_plus_one) asyncio.run(main()) Note: Coroutine will only run when we use await keyword. If we call the coroutine directly it will return a coroutine object.\nIn above code we pause execution twice. We first await the call to add_one(1). Once we have the result, the main function will be “unpaused,” and we will assign the return value from add_one(1) to the variable one_plus_one, which in this case will be two. We then do the same for add_one(2) and then print the results.We can visualize the execution flow of our application, as shown in figure\nAs it stands now, this code does not operate differently from normal, sequential code. We are, in effect, mimicking a normal call stack. Next, let’s look at a simple example of how to run other code by introducing a dummy sleep operation while we’re waiting.\n2.4 Introducing long-running coroutines with sleep Our previous examples did not use any slow operations and were used to help us learn the basic syntax of coroutines. To fully see the benefits and show how we can run mul tiple events simultaneously, we’ll need to introduce some long-running operations. Instead of making web API or database queries right away, which are nondeterministic as to how much time they will take, we’ll simulate long-running operations by specify ing how long we want to wait. We’ll do this with the asyncio.sleep function. We can use asyncio.sleep to make a coroutine “sleep” for a given number of sec onds. This will pause our coroutine for the time we give it, simulating what would hap pen if we had a long-running call to a database or web API. asyncio.sleep is itself a coroutine, so we must use it with the await keyword. If we call it just by itself, we’ll get a coroutine object. Since asyncio.sleep is a coroutine, this means that when a coroutine awaits it, other code will be able to run. Let’s examine a simple example, shown in the following listing, that sleeps for 1 sec ond and then prints a \u0026lsquo;Hello World!\u0026rsquo; message.\nimport asyncio async def hello_world_message(): await asyncio.sleep(1) print(\u0026#34;Hello World\u0026#34;) asyncio.run(hello_world_message()) When we run this application, our program will wait 1 second before printing our \u0026lsquo;Hello World!\u0026rsquo; message. Since hello_world_message is a coroutine and we pause it for 1 second with asyncio.sleep, we now have 1 second where we could be running other code concurrently.\nWe’ll be using sleep a lot in the next few examples, so let’s invest the time to cre ate a reusable coroutine that sleeps for us and prints out some useful information. We’ll call this coroutine delay. This is shown in the following listing\nimport asyncio async def delay(delaysecond): print(f\u0026#39;Sleeping for delay seconds : {delaysecond}\u0026#39;) await asyncio.sleep(delaysecond) print(f\u0026#39;finished sleeping for {delay_seconds} second(s)\u0026#39;) return delay_seconds delay will take in an integer of the duration in seconds that we’d like the function to sleep and will return that integer to the caller once it has finished sleeping. We’ll also print when sleep begins and ends. This will help us see what other code, if any, is run ning concurrently while our coroutines are paused.\nTo make referencing this utility function easier in future code listings, we’ll create a module that we’ll import in the remainder of this book when needed. We’ll also add to this module as we create additional reusable functions. We’ll call this module util, and we’ll put our delay function in a file called delay_functions.py. We’ll also add an init.py file with the following line, so we can nicely import the timer\nfrom util.delay_functions import delay From now on in this book, we’ll use from util import delay whenever we need to use the delay function. Now that we have a reusable delay coroutine, let’s combine it with the earlier coroutine add_one to see if we can get our simple addition to run concur rently while hello_world_message is paused.\nimport asyncio from util.delay_functions import delay async def add_one(number): return number + 1 async def hello_world_message(): await delay(1) print(\u0026#34;Hello World\u0026#34;) async def main() -\u0026gt; None: message = await hello_world_message() #pause until hello_world_message is finished one_plus_one = await add_one(1) #pause until add_one is finished print(one_plus_one) print(message) asyncio.run(main()) When we run this, 1 second passes before the results of both function calls are printed. What we really want is the value of add_one(1) to be printed immediately while hello_world_message()runs concurrently. So why isn’t this happening with this code? The answer is that await pauses our current coroutine and won’t execute any other code inside that coroutine until the await expression gives us a value. Since it will take 1 second for our hello_world_message function to give us a value, the main coroutine will be paused for 1 second. Our code behaves as if it were sequential in this case. This behavior is illustrated in figure\nWe can see that the main coroutine is paused for 1 second while hello_world_\nBoth main and hello_world paused while we wait for delay(1) to finish. After it has finished, main resumes and can execute add_one. We’d like to move away from this sequential model and run add_one concurrently with hello_world. To achieve this, we’ll need to introduce a concept called tasks.\n2.5 Running concurrently with task In Python\u0026rsquo;s asyncio, you can create tasks to run code concurrently. This is done using the asyncio.create_task function. When you create a task, it starts running in the background immediately, allowing your program to do other things while waiting for the task to finish.\nKey Points: Creating a Task:\nUse asyncio.create_task() with a coroutine function as its input. It returns a task object instantly. Awaiting a Task:\nYou can use await with the task object to pause your program until the task is done and get its result. Why Use Tasks?\nTasks allow other parts of your program to run without waiting for one operation to finish. Code Example: Creating and Using a Task import asyncio from util import delay # A custom function that simulates a delay async def main(): # Create a task that takes 3 seconds to complete sleep_for_three = asyncio.create_task(delay(3)) # Immediately print the type of the task object print(f\u0026#34;Task type: {type(sleep_for_three)}\u0026#34;) # Wait for the task to finish and get the result result = await sleep_for_three print(f\u0026#34;Task result: {result}\u0026#34;) # Run the main coroutine asyncio.run(main()) What’s Happening in the Code: Task Creation:\nasyncio.create_task(delay(3)) creates a task to run the delay(3) coroutine in the background. The task is of type \u0026lt;class '_asyncio.Task'\u0026gt;, which is different from a regular coroutine. Running Concurrently:\nAfter creating the task, the program does not wait for the task to finish. The print() statement runs immediately after the task is created. Waiting for the Task:\nThe await sleep_for_three line pauses the main coroutine until the task finishes. Once the task is complete, it returns its result, which is printed. Why Await is Important: If you don’t use await on a task, it might not get enough time to finish. When the asyncio.run function exits, the event loop stops, and any unfinished tasks are “cleaned up” without completing. Using await ensures the task has a chance to finish.\nNote : When we create task using asyncio.create_task it run the task immediately in the background. It does not wait for the task to finish and immediately return a task object such that our program can do other things while waiting for the task to finish.We can use await later on to pause the program until the task is done and get its result.\n2.6 Running multiple tasks concurrently Given that tasks are created instantly and are scheduled to run as soon as possible, this allows us to run many long-running tasks concurrently. We can do this by sequentially starting multiple tasks with our long-running coroutine.\nimport asyncio from util.delay_functions import delay async def main(): # Create two tasks that take 3 seconds to complete sleep_for_three=asyncio.create_task(delay(3)) sleep_again=asyncio.create_task(delay(3)) sleep_once_more=asyncio.create_task(delay(3)) await sleep_for_three await sleep_again await sleep_once_more asyncio.run(main()) In this code, we create three tasks that each sleep for 3 seconds. We then await each task in sequence. This will cause each task to run concurrently, and the total time to complete will be around 3 seconds, not 9 seconds. This is because we are not waiting for each task to finish before starting the next one. Lets breakdown\nStarting Three Tasks:\nThe program begins by creating three tasks, each of which takes 3 seconds to complete. The create_task function starts the tasks immediately but doesn\u0026rsquo;t wait for them to finish—it just sets them up to run in the background. The First Await Statement:\nWhen the code reaches the await sleep_for_three line, it pauses and gives control to the event loop. This pause allows the event loop to check for any tasks waiting to run and starts them “as soon as possible.” Tasks Run Simultaneously:\nAll three tasks begin running their sleep operations at the same time because the event loop handles them concurrently. This concurrency allows the program to complete the work in 3 seconds instead of 9. Concurrency in Action:\nWhile the sleep operations run concurrently, any other code in the tasks (like print statements) runs one at a time, not simultaneously. This means only the parts of the tasks that involve waiting (like sleeping) are parallelized. Time Saved:\nIf the tasks were executed one after another, the program would take 9 seconds (3 seconds × 3 tasks). By running the tasks concurrently, the program finishes in just 3 seconds, saving a lot of time. This is illustrated in figure NOTE This benefit compounds as we add more tasks; if we had launched 10 of these tasks, we would still take roughly 3 seconds, giving us a 10-fold speedup. This is the power of concurrency in asyncio.\nasyncio.gather function Gather function is a quick way to run multiple tasks concurrently and wait for all of them to complete. It takes in an iterable of awaitables and returns a single awaitable that will yield results in the order they were created. This is useful when we want to run multiple tasks concurrently and wait for all of them to finish before proceeding.\nimport asyncio from util.delay_functions import delay async def main(): # Create three tasks that take 3 seconds to complete and handel using asyncio.gather results = await asyncio.gather( delay(3), delay(3), delay(3) ) print(results) asyncio.run(main()) Note : For understanding You can use this logic . There is a task queue and event loop. When we only await coroutine there is only one task in the task queue and event loop .\ncoroutine need to await for running the task i.e keep in the task queue and eventloop if we directly run coroutine it will just give us coroutine object.\nWhen we use asyncio.createtask() there are as much task in the task queue as the number of tasks created and event loop will run all the tasks concurrently also when we await new coroutine it will be added to the task queue and event loop will run it concurrently.\nIt return a task object instantly and run all the task concurrently i.e keep in the task queue and event loop without awaiting but does not wait for the task to finish it need to be awaited to get the proper result.\nWhen we use asyncio.gather() it will run all the tasks concurrently and wait for all of them to finish before proceeding.\nIt need to be awaited to keep all the task in the task queue and event loop and wait for all of them to finish before proceeding.After finishing all the task it will return the result in the order they were created and jump to the next line of code of the main coroutine.\n3. Synchronization Premitives Locks Semaphores 3.1 Locks Locks are a synchronization primitive that allows us to limit access to a shared resource to only one coroutine at a time. This is useful when we have a resource that can only be accessed by one coroutine at a time, like a file or a database connection. Locks are created using the asyncio.Lock class and can be acquired using the acquire method and released using the release method.\n#basic example of lock\nimport asyncio async def locking(lock): print(\u0026#39;Waiting for the lock\u0026#39;) async with lock: print(\u0026#39;Acquired the lock\u0026#39;) await asyncio.sleep(2) print(\u0026#39;Released the lock\u0026#39;) async def main(): lock = asyncio.Lock() await asyncio.gather( locking(lock), locking(lock), locking(lock) ) asyncio.run(main()) Output:\nWaiting for the lock\rAcquired the lock\rWaiting for the lock\rWaiting for the lock\rReleased the lock\rAcquired the lock\rReleased the lock\rAcquired the lock\rReleased the lock In this example, we create a lock using asyncio.Lock and pass it to the locking coroutine. We then use the async with statement to acquire the lock and release it when we are done. When we run the program, we can see that only one coroutine can acquire the lock at a time, and the other coroutines have to wait until the lock is released.\n3.2 Semaphores Semaphores are a synchronization primitive that allows us to limit access to a shared resource to a fixed number of coroutines at a time. This is useful when we have a resource that can be accessed by a limited number of coroutines, like a connection pool or a web API. Semaphores are created using the asyncio.Semaphore class and can be acquired using the acquire method and released using the release method.\n#basic example of semaphore\nimport asyncio async def semaphoring(semaphore): async with semaphore: print(\u0026#39;Acquired the semaphore\u0026#39;) await asyncio.sleep(2) print(\u0026#39;Released the semaphore\u0026#39;) async def main(): semaphore = asyncio.Semaphore(2) await asyncio.gather( semaphoring(semaphore), semaphoring(semaphore), semaphoring(semaphore), semaphoring(semaphore) ) asyncio.run(main()) Output:\nAcquired the semaphore\rAcquired the semaphore\rAcquired the semaphore\rReleased the semaphore\rReleased the semaphore\rReleased the semaphore\rAcquired the semaphore\rReleased the semaphore In this example, we create a semaphore with a limit of 2 using asyncio.Semaphore and pass it to the semaphoring coroutine. We then use the async with statement to acquire the semaphore and release it when we are done. When we run the program, we can see that only two coroutines can acquire the semaphore at a time, and the other coroutines have to wait until the semaphore is released.\nSome popular asyncio libraries aiohttp: An HTTP client and server library for asyncio. fastapi: A modern web framework for building APIs with Python 3.6+ based on standard Python type hints. aiofiles: A file operations library for asyncio. ","permalink":"http://localhost:1313/posts/pages/asyncio/asyncio2/","summary":"how to write programs using this single-threaded concurrency model with asyncio","title":"Async io : Asyncio Basics (Day 2)"},{"content":"36. useRef Hook in React useRef is a hook that is specially designed to work with DOM elements. It allows you to create a reference to a DOM element and access it directly in your components so you can modify it or read its properties as needed.\nAnother important distinction is that useRef holds the same reference across re-renders of the component Similarly, useState also retains its value between renders. However, updating a state value with useState will always trigger a re-render, whereas updating the value of a useRef does not. Its explained in the below example in ## 2. Advanvced Usage\n1. Basic Usage 1. Import useRef import { useRef } from \u0026#39;react\u0026#39;; 2. Create a Reference const myRef = useRef(); 3. Attach to DOM Elements function MyComponent() { const myRef = useRef(); return ( \u0026lt;div ref={myRef}\u0026gt; \u0026lt;h1\u0026gt;useRef Example\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ); } 4. Accessing the Reference // Access the DOM element using .current const element = myRef.current; use myRef.current.value for input elements. use myRef.current.checked for checkbox elements. use myRef.current.focus() to focus on an element. use myRef.current.style to access the style object of an element.\nNote: While you can access DOM elements directly with useRef, it\u0026rsquo;s recommended to avoid manipulating them directly unless necessary.\nPractical Example: Form Input Here\u0026rsquo;s a complete example showing how to use useRef with form inputs:\nimport { useRef, useState } from \u0026#39;react\u0026#39;; function InputExample() { const inputRef = useRef(); const [inputValue, setInputValue] = useState(\u0026#39;\u0026#39;); const handleClick = () =\u0026gt; { setInputValue(inputRef.current.value); inputRef.current.value = \u0026#39;\u0026#39;; // Clear input after reading }; return ( \u0026lt;div\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; ref={inputRef} placeholder=\u0026#34;Type something...\u0026#34; /\u0026gt; \u0026lt;button onClick={handleClick}\u0026gt;Save Input\u0026lt;/button\u0026gt; \u0026lt;p\u0026gt;Saved value: {inputValue}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } Explanation:\nWe create a reference to the input element using useRef. When the button is clicked, we read the input value using inputRef.current.value and update the state. We clear the input field by setting inputRef.current.value to an empty string. 2. Advanced Usage of useRef and useState useRef and useState are both hooks used in React. Both hooks help us store values, but they behave differently: useState: The value is persistent across re-renders, but updating it triggers a re-render. useRef: The value is also persistent across re-renders, but updating it does not trigger a re-render. 2.1. Managing Previous Values in a Stopwatch Here’s an example of how to use useRef and useState to build a simple stopwatch in React:\nimport { useRef, useState } from \u0026#39;react\u0026#39;; function Stopwatch() { const timerRef = useRef(0); // To store the timer ID const [time, setTime] = useState(0); // To store the current time const [isRunning, setIsRunning] = useState(false); // To track if the stopwatch is running // Start the timer when the Start button is clicked const startTimer = () =\u0026gt; { if (!isRunning) { timerRef.current = setInterval(() =\u0026gt; { setTime((time) =\u0026gt; time + 1); // Increment the time every second }, 1000); setIsRunning(true); // Set the timer as running } }; // Stop the timer when the Stop button is clicked const stopTimer = () =\u0026gt; { clearInterval(timerRef.current); // Clear the interval to stop the timer setIsRunning(false); // Set the timer as not running }; // Reset the timer when the Reset button is clicked const resetTimer = () =\u0026gt; { clearInterval(timerRef.current); // Clear the interval to stop the timer setIsRunning(false); // Set the timer as not running setTime(0); // Reset the time to 0 }; return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Stopwatch\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;Time: {time} seconds\u0026lt;/p\u0026gt; \u0026lt;button onClick={startTimer}\u0026gt;Start\u0026lt;/button\u0026gt; \u0026lt;button onClick={stopTimer}\u0026gt;Stop\u0026lt;/button\u0026gt; \u0026lt;button onClick={resetTimer}\u0026gt;Reset\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } Explanation Creating useRef and useState variables:\ntimerRef: This holds the timer ID (returned by setInterval). We use useRef here because we don’t need the component to re-render when the timer ID changes. time: This stores the current time value of the stopwatch, and we use useState for this because we want the component to re-render whenever the time updates. isRunning: This tracks whether the stopwatch is running or not. Starting the timer (Start Button):\nWhen the \u0026ldquo;Start\u0026rdquo; button is clicked, we check if the timer is already running. If it isn’t, we start it by calling setInterval, which increments the time value every second. setInterval returns an interval ID that we store in timerRef.current. This ID will be used to stop the timer later. Stopping the timer (Stop Button):\nWhen the \u0026ldquo;Stop\u0026rdquo; button is clicked, we clear the interval using clearInterval(timerRef.current) to stop the timer. We also set isRunning to false to indicate that the timer is no longer running. Resetting the timer (Reset Button):\nWhen the \u0026ldquo;Reset\u0026rdquo; button is clicked, we clear the interval to stop the timer, set isRunning to false, and reset the time back to 0. Why useRef? Why not just use a regular variable?\nA regular variable inside the component would reset every time the component re-renders. Since the timer is being updated every second, this would cause issues because the value would be reset each time, and the timer wouldn’t function correctly. Why useRef over useState for the timer ID?\nWe use useRef to store the timer ID because updating it with useState would trigger a re-render every time the timer ID changes. Since the timer is running independently, we don’t need a re-render, so useRef is more efficient here. Key Takeaways useRef is useful for storing values that don’t require the component to re-render when they change. useState is used for values that should trigger a re-render when updated, like the time value in our stopwatch. useRef does not cause a re-render when its value changes, making it ideal for holding values like the interval ID that don’t need to affect the UI. Common Use Cases Storing previous values Managing focus, text selection, or media playback Integrating with third-party DOM libraries Accessing underlying DOM elements Isolation in Components: Any variable that is declared inside a component is isolated to that component. It is not shared with other components unless explicitly passed as props. This isolation helps maintain the encapsulation and modularity of components in React.\n37.Forwarding Refs in React Forwarding refs is a technique in React that allows you to pass a ref from a parent component to a child component. This is useful when you want to access the DOM element of a child component from a parent component.\n1. Basic Usage 1.Import useRef import { useRef } from \u0026#39;react\u0026#39;; 2. Create a Ref in the Parent Component const myRef= useRef(); 3. Pass the Ref to the Child Component \u0026lt;MyChildComponent ref={myRef} /\u0026gt; 4.Import forward ref in child component import React, { forwardRef } from \u0026#39;react\u0026#39;; 5. Using forwardRef to Forward the Ref const MyChildComponent = forwardRef((props, ref) =\u0026gt; { return \u0026lt;input ref={ref} /\u0026gt;; }); 6. Accessing the Ref in the Parent Component const element = myRef.current.value; Practical Example: Input Focus to take input from user and focus on the input field of the child component from the parent component.\nimport React, { useRef } from \u0026#39;react\u0026#39;; const InputComponent = forwardRef(({title}, ref) =\u0026gt; { return\u0026lt;\u0026gt; \u0026lt;h1\u0026gt;{title}\u0026lt;/h1\u0026gt; \u0026lt;input ref={ref}/\u0026gt; \u0026lt;/\u0026gt; }); function ParentComponent() { const inputRef = useRef(); const handleClick = () =\u0026gt; { inputRef.current.focus(); console.log(inputRef.current.value); }; return ( \u0026lt;div\u0026gt; \u0026lt;InputComponent ref={inputRef} title=\u0026#34;ENter the Input\u0026#34;/\u0026gt; \u0026lt;button onClick={handleClick}\u0026gt;Focus Input\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 38.useImperativeHandle in React In large-scale applications, we generally avoid using refs directly to access child components. Instead, we use the useImperativeHandle hook to expose specific methods from the child component to the parent component. This approach allows the developer working on the parent component to interact with the child component\u0026rsquo;s methods without needing to understand its internal implementation. Additionally, this separation enables the developer of the child component to modify or update the child component independently, without affecting the parent component. Since only the exposed methods are used by the parent, changes to the internal structure of the child component do not disrupt the parent-child interaction.This is specially used in forwardRef to expose methods of child component to parent component.\nBasic Usage 1.Pass a Ref to the Child Component import {useRef} from \u0026#39;react\u0026#39;; function App() { const childRef = useRef(); return \u0026lt;ChildComponent ref={childRef} /\u0026gt;; } =\u0026gt; Here, we create a ref using useRef and pass it to the ChildComponent using the ref prop.\n2. Use useImperativeHandle in the Child Component with forwardRef to expose methods import { useImperativeHandle, forwardRef } from \u0026#39;react\u0026#39;; const ChildComponent = forwardRef((props, ref) =\u0026gt; { useImperativeHandle(ref, () =\u0026gt; ({ focus: () =\u0026gt; { // Focus on the input element }, reset: () =\u0026gt; { // Reset the input element }, inputValue:\u0026#39;vaule\u0026#39; }),[dependencies]); return \u0026lt;input /\u0026gt;; }); In the ChildComponent, we use the useImperativeHandle hook to expose the focus and reset methods to the parent component. The ref object is passed as the first argument, and the second argument is a function that returns an object containing the methods to be exposed. dependencies is an optional array of values that, when changed, will trigger the re-evaluation of the function that returns the methods. If the dependencies array is not provided, the function will be called on every render and empty array will call only once in entire lifecycle.\n3. Access the Exposed Methods in the Parent Component function App() { const childRef = useRef(); const handleClick = () =\u0026gt; { childRef.current.focus(); }; const resetClick = () =\u0026gt; { childRef.current.reset(); }; return ( \u0026lt;\u0026gt; \u0026lt;ChildComponent ref={childRef} /\u0026gt; \u0026lt;button onClick={handleClick}\u0026gt;Focus Input\u0026lt;/button\u0026gt; \u0026lt;button onClick={resetClick}\u0026gt;Reset Input\u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; ); } In the parent component, we can access the exposed methods using the current property of the ref object. In this example, we call the focus method when the \u0026ldquo;Focus Input\u0026rdquo; button is clicked.\nPractical Example: Use forwardRef and useImperativeHandle to Expose Methods for reset the input field and get the value of the input field. import {useRef} from \u0026#39;react\u0026#39;; function App(){ const childRef = useRef(); const handleClick = () =\u0026gt; { childRef.current.focus(); }; const resetClick = () =\u0026gt; { childRef.current.reset(); }; const getValue = () =\u0026gt; { console.log(childRef.current.value); }; return ( \u0026lt;\u0026gt; \u0026lt;ChildComponent ref={childRef} /\u0026gt; \u0026lt;button onClick={handleClick}\u0026gt;Focus Input\u0026lt;/button\u0026gt; \u0026lt;button onClick={resetClick}\u0026gt;Reset Input\u0026lt;/button\u0026gt; \u0026lt;button onClick={getValue}\u0026gt;Get Value\u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; ); } export default App; import { useImperativeHandle, forwardRef,useRef } from \u0026#39;react\u0026#39;; const ChildComponent = forwardRef((props, ref) =\u0026gt; { const inputRef = useRef(); useImperativeHandle(ref, () =\u0026gt; ({ focus: () =\u0026gt; { inputRef.current.focus(); }, reset: () =\u0026gt; { inputRef.current.value = \u0026#39;\u0026#39;; }, value: inputRef.current.value }),[]); return \u0026lt;input ref={inputRef} /\u0026gt;; }); export default ChildComponent; =\u0026gt; By using useImperativeHandle, we can expose specific methods from the child component to the parent component, allowing for more controlled interactions between the components such as focusing on the input field, resetting the input field, and getting the value of the input field in this example. =\u0026gt; By using this approach, we can maintain a clear separation of concerns between the parent and child components, making it easier to manage and update the components independently.\n37. Portals in React Portals in React provide a way to render children components outside the DOM hierarchy of the parent component. This allows you to render a child component at a different location in the DOM, such as at the root level or inside a specific container, without affecting the parent\u0026rsquo;s layout or styles.\nImporting portal from react-dom import { createPortal } from \u0026#39;react-dom\u0026#39;; using createPortal const MyPortal = ({title}) =\u0026gt; { return createPortal( \u0026lt;\u0026gt; \u0026lt;h1\u0026gt;{title}\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;This is a portal\u0026lt;/p\u0026gt; \u0026lt;\u0026gt;, document.getElementById(\u0026#39;portal-root\u0026#39;)); }; =\u0026gt;When the MyPortal component is rendered, the content will be rendered inside the element with the id \u0026lsquo;portal-root\u0026rsquo;, which can be located anywhere in the DOM.\n","permalink":"http://localhost:1313/posts/pages/react/react7/","summary":"Learn about useRef hook, ref forwarding, useImperativeHandle and Portals in React for DOM manipulation and component interactions.","title":"React : Day 7"},{"content":"1. Some Important Concepts 1.1 Parallism vs Concurrency Parallism: Running multiple tasks at the same time. There are multiple Threads or Processes running at the same time. Concurrency: Switching between multiple tasks. When one task is waiting for I/O, another task can run. There is only one Thread or Process running at a time. 1.2 Synchronous vs Asynchronous Synchronous: Code is executed in sequence. Previous task/line must be completed before the next task/line execution starts. Asynchronous: Code is executed in parallel. Tasks can run concurrently. The next task can start before the previous task is completed. 1.3 Blocking vs Non-Blocking Blocking: The execution of the code is blocked until the task is completed. The next task can\u0026rsquo;t start until the previous task is completed. import time def task1(): print(\u0026#34;Task 1 started\u0026#34;) time.sleep(2) print(\u0026#34;Task 1 completed\u0026#34;) def task2(): print(\u0026#34;Task 2 started\u0026#34;) time.sleep(2) print(\u0026#34;Task 2 completed\u0026#34;) task1() task2() Non-Blocking: The excecution of the code is not blocked. The next task can start before the previous task is completed. import asyncio async def task1(): print(\u0026#34;Task 1 started\u0026#34;) await asyncio.sleep(2) print(\u0026#34;Task 1 completed\u0026#34;) async def task2(): print(\u0026#34;Task 2 started\u0026#34;) await asyncio.sleep(2) print(\u0026#34;Task 2 completed\u0026#34;) async def main(): await asyncio.gather(task1(), task2()) asyncio.run(main()) 1.4 I/O Bound vs CPU Bound I/O Bound: The program is waiting for input/output operations to complete. The program is not using the CPU much. CPU Bound: The program is using the CPU a lot. The program is not waiting for input/output operations to complete. import request response = request.get(\u0026#34;https://www.google.com\u0026#34;) # I/O Bound items = response.headers.items() # CPU Bound headers = [f\u0026#39;{key}: {header}\u0026#39; for key, header in items] # CPU Bound formatted_headers = \u0026#39;\\n\u0026#39;.join(headers) # CPU Bound with open(\u0026#39;headers.txt\u0026#39;, \u0026#39;w\u0026#39;) as file: # I/O Bound file.write(formatted_headers) # I/O Bound 2. How Concurrency is Achieved in Os level To better understand this, we’ll need to dive into how sockets work and, in particular, how non-blocking sockets work.\n2.1 Sockets A socket is a low-level abstraction for sending and receiving data over a network. It is the basis for how data is transferred to and from servers. Sockets support two main operations: sending bytes and receiving bytes. We write bytes to a socket, which will then get sent to a remote address, typically some type of server. Once we’ve sent those bytes, we wait for the server to write its response back to our socket. Once these bytes have been sent back to our socket, we can then read the result.\nIn the case of getting the contents from example.com as we saw earlier, we open a socket that connects to example.com’s server. We then write a request to get the contents to that socket and wait for the server to reply with the result: in this case, the HTML of the web page. We can visualize the flow of bytes to and from the server in figure 1.7\nSockets are blocking by default. Simply put, this means that when we are waiting for a server to reply with data, we halt our application or block it until we get data to read. Thus, our application stops running any other tasks until we get data from the server, an error happens, or there is a timeout. At the operating system level, we don’t need to do this blocking. Sockets can operate in non-blocking mode. In non-blocking mode, when we write bytes to a socket, we can just fire and forget the write or read, and our application can go on to perform other tasks. Later, we can have the operating system tell us that we received bytes and deal with it at that time. This lets the application do any number of things while we wait for bytes to come back to us. Instead of blocking and waiting for data to come to us, we become more reactive, letting the operating system inform us when there is data for us to act on. In the background, this is performed by a few different event notification systems, depending on which operating system we’re running. asyncio is abstracted enough that it switches between the different notification systems, depending on which one our operating system supports. The following are the event notification systems used by specific operating systems:\nkqueue—FreeBSD and MacOS epoll—Linux IOCP (I/O completion port)—Windows These systems keep track of our non-blocking sockets and notify us when they are ready for us to do something with them. This notification system is the basis of how asyncio can achieve concurrency.\nBut how do we keep track of multiple tasks that are waiting for data to come back to them? This is where the event loop comes in.\n2.2 Event Loop The event loop is the core of every asyncio application. In asyncio, the event loop keeps a queue of tasks.\n2.2.1 How the Event Loop Works The event loop works by keeping a queue of tasks instead of messages. Each task is a coroutine. When a task is added to the event loop, it will execute until it encounters an I/O operation (such as a web request). When a task hits an I/O-bound operation, it pauses and allows the event loop to run other tasks that are not waiting for I/O operations to complete. 2.2.2 Understanding Event Loops in Asynchronous Programming When working with event loops in asynchronous programming, the process can be understood as a sequence of steps that efficiently handle tasks without blocking the execution. Here\u0026rsquo;s a breakdown of how it works:\n2.2.2.1 Creating the Event Loop When an event loop is created, an empty queue of tasks is initialized. This queue will hold all the tasks that need to be executed.\n2.2.2.2 Adding Tasks to the Queue We add tasks to the event loop’s queue. These tasks are executed one at a time, based on their order in the queue.\n2.2.2.3 Processing Tasks Iteratively Each iteration of the event loop checks for tasks that need to be executed. It processes tasks sequentially, running them one by one.\n2.2.2.4 Handling I/O Operations If a task encounters an I/O operation (like reading from a file or making a network request), it cannot proceed immediately. In this case, the task is paused and put on hold.\n2.2.2.5 Pausing and Waiting for I/O Completion When a task is paused, the event loop instructs the operating system to monitor any associated sockets or resources for I/O completion. During this time, the event loop continues checking for and executing other tasks.\n2.2.2.6 Waking Up Paused Tasks On each iteration of the event loop, we check if any of the I/O operations have completed. If they have:\nThe paused task is woken up. The task resumes execution and completes its process. 2.2.2.7. Conclusion This cycle of pausing, waiting for I/O, and resuming tasks allows the event loop to run multiple tasks concurrently, making it an efficient way to handle asynchronous operations without blocking the program.\nBy continuously iterating and checking for completed I/O tasks, the event loop ensures that no task is left idle while waiting for I/O operations, enabling a smooth and efficient workflow.\nVisualizing the Event Loop with Asynchronous Tasks We can visualize how the event loop works with asynchronous tasks as shown in Figure 1.9: the main thread submits tasks to the event loop, which then runs them. When a task encounters an I/O operation, it pauses and allows other tasks to run. Once the I/O operation is complete, the paused task is resumed.\nExample: Submitting Multiple Asynchronous Tasks Let\u0026rsquo;s consider three tasks that each make an asynchronous web request. These tasks consist of:\nCPU-bound setup: Some code that prepares data for the web request. I/O-bound web request: The asynchronous part where we send the web request. CPU-bound post-processing: After the web request completes, we do some more CPU-intensive work. Now, let\u0026rsquo;s submit these tasks to the event loop simultaneously. Here’s how we can write this in pseudocode:\ndef make_request(): cpu_bound_setup() io_bound_web_request() cpu_bound_postprocess() task_one = make_request() task_two = make_request() task_three = make_request() First task starts executing code, and the other two are left waiting to run. Once the CPU-bound setup work is finished in Task 1, it hits an I/O-bound operation and will pause itself to say, “I’m waiting for I/O; any other tasks waiting to run can run.” Once this happens, Task 2 can begin executing. Task 2 starts its CPU-bound code and then pauses, waiting for I/O. At this time both Task 1 and Task 2 are waiting concurrently for their network request to complete. Since Tasks 1 and 2 are both paused waiting for I/O, we start running Task 3. Now imagine once Task 3 pauses to wait for its I/O to complete, the web request for Task 1 has finished. We’re now alerted by our operating system’s event notification system that this I/O has finished. We can now resume executing Task 1 while both Task 2 and Task 3 are waiting for their I/O to finish. In figure 1.10, we show the execution flow of the pseudocode we just described. If we look at any vertical slice of this diagram, we can see that only one CPU-bound piece of work is running at any given time; however, we have up to two I/O-bound operations happening concurrently. This overlapping of waiting for I/O per each task is where the real time savings of asyncio comes in.\n","permalink":"http://localhost:1313/posts/pages/asyncio/asyncio1/","summary":"An introduction to asynchronous programming in Python using asyncio.","title":"Async io : Async io Intro (Day 1)"},{"content":"34.Styling in CSS 34.1 Setting Inline Styles =\u0026gt; In react for inline styles we use the style attribute and pass an object with camelCase properties.\nimport React from \u0026#39;react\u0026#39;; const myStyle = { color: \u0026#39;blue\u0026#39;, backgroundColor: \u0026#39;yellow\u0026#39; } const MyComponent = () =\u0026gt; { return ( \u0026lt;div style={myStyle}\u0026gt; \u0026lt;h1\u0026gt;Inline Styles\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ) } or we can use the style attribute directly in the element.\nimport React from \u0026#39;react\u0026#39;; const MyComponent = () =\u0026gt; { return ( \u0026lt;div style={{color: \u0026#39;blue\u0026#39;, backgroundColor: \u0026#39;yellow\u0026#39;}}\u0026gt; \u0026lt;h1\u0026gt;Inline Styles\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ) } 34.2 Setting External Styles =\u0026gt; We can also use external CSS files in react. We can import the CSS file in the component file and use the class name in the\nimport React from \u0026#39;react\u0026#39;; import \u0026#39;./MyComponent.css\u0026#39;; const MyComponent = () =\u0026gt; { return ( \u0026lt;div className=\u0026#34;myStyle\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;External Styles\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ) } 34.3 Setting Inline Dynamic Styles =\u0026gt;You can also set the inline styles dynamically by using the state.\nimport React,{useState} from \u0026#39;react\u0026#39;; const App=()=\u0026gt;{ const [valid,setValid]=useState(true); function changeStyle(){ setValid(!valid); } const myStyle={ color:valid?\u0026#39;blue\u0026#39;:\u0026#39;red\u0026#39;, backgroundColor:valid?\u0026#39;yellow\u0026#39;:\u0026#39;green\u0026#39; } return( \u0026lt;div\u0026gt; \u0026lt;button onClick={changeStyle}\u0026gt;Change Style\u0026lt;/button\u0026gt; \u0026lt;div style={myStyle}\u0026gt; \u0026lt;h1\u0026gt;Inline Dynamic Styles\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) } export default App; or we can use the style attribute directly in the element.\nimport React,{useState} from \u0026#39;react\u0026#39;; const App=()=\u0026gt;{ const [valid,setValid]=useState(true); function changeStyle(){ setValid(!valid); } return( \u0026lt;div\u0026gt; \u0026lt;button onClick={changeStyle}\u0026gt;Change Style\u0026lt;/button\u0026gt; \u0026lt;div style={{color:valid?\u0026#39;blue\u0026#39;:\u0026#39;red\u0026#39;,backgroundColor:valid?\u0026#39;yellow\u0026#39;:\u0026#39;green\u0026#39;}}\u0026gt; \u0026lt;h1\u0026gt;Inline Dynamic Styles\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) } export default App; 34.4 Setting Css Classes Dynamically =\u0026gt; We can also set the CSS classes dynamically by using the state.\nimport React,{useState} from \u0026#39;react\u0026#39;; import \u0026#39;./MyComponent.css\u0026#39;; const App=()=\u0026gt;{ const [valid,setValid]=useState(true); const [active,setActive]=useState(true); function changeStyle(){ setValid(!valid); setActive(!active); } return( \u0026lt;div\u0026gt; \u0026lt;button onClick={changeStyle}\u0026gt;Change Style\u0026lt;/button\u0026gt; \u0026lt;div className={`div-control ${valid?\u0026#39;right\u0026#39;:\u0026#39;wrong\u0026#39;} ${active?\u0026#39;active\u0026#39;:\u0026#39;inactive\u0026#39;}`}\u0026gt; \u0026lt;h1\u0026gt;Setting Css Classes Dynamically\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) } export default App; 34.5 Css modules =\u0026gt; Every time we import Css file in react component they are regarded as global styles i.e One component style can affect another component style =\u0026gt;So, to avoid this we can use CSS modules. CSS modules are local by default. We can use CSS modules by naming the CSS file as filename.module.css. =\u0026gt; The CSS file is imported in the component file and the class name is used as an object.\nProblem1 =\u0026gt; Imagine that you have two components with the same class name. The styles of one component can affect the styles of another component.which is not good for the application to solve this problem we can use CSS modules.\nStructure of the project\nsrc\r|_components\r|_MyComponent\r|_MyComponent.js\r|_MyComponent.module.css Step 1: Create a CSS file with the name MyComponent.module.css\n.myStyle{ color: blue; background-color: yellow; } .right{ text-align: right; } Step 2: Import the CSS file in the component file as shown below.\nimport React from \u0026#39;react\u0026#39;; import styles from \u0026#39;./MyComponent.module.css\u0026#39;; step 3: Use the class name as shown below.\nconst MyComponent = () =\u0026gt; { return ( \u0026lt;div className={styles.myStyle}\u0026gt; \u0026lt;h1\u0026gt;CSS Modules\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ) } Combined code\nimport React from \u0026#39;react\u0026#39;; import styles from \u0026#39;./MyComponent.module.css\u0026#39;; const MyComponent = () =\u0026gt; { return ( \u0026lt;div className={styles.myStyle}\u0026gt; \u0026lt;h1\u0026gt;CSS Modules\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ) } export default MyComponent; 34.5.1 Combining multiple classes import React from \u0026#39;react\u0026#39;; import styles from \u0026#39;./MyComponent.module.css\u0026#39;; const MyComponent = () =\u0026gt; { return ( \u0026lt;div className={`${styles.myStyle} ${styles.right}`}\u0026gt; \u0026lt;h1\u0026gt;CSS Modules\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ) } export default MyComponent; 34.6 Dynamic CSS Modules =\u0026gt; We can also set the CSS classes dynamically by using the state.\nimport React,{useState} from \u0026#39;react\u0026#39;; import styles from \u0026#39;./MyComponent.module.css\u0026#39;; const MyComponent = () =\u0026gt; { const [valid,setValid]=useState(true); const [active,setActive]=useState(true); function changeStyle(){ setValid(!valid); setActive(!active); } return ( \u0026lt;div className={`${styles.myStyle} ${valid?styles.right:styles.wrong} ${active?styles.active:styles.inactive}`}\u0026gt; \u0026lt;h1\u0026gt;CSS Modules\u0026lt;/h1\u0026gt; \u0026lt;button onClick={changeStyle}\u0026gt;Change Style\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } export default MyComponent; ","permalink":"http://localhost:1313/posts/pages/react/react5/","summary":"Learn various methods to style React components including inline styles, external styles, dynamic styles, and CSS modules.","title":"React : Day 5"},{"content":"35. Debugging in react 35.1 Using console.log import React from \u0026#39;react\u0026#39;; const MyComponent = () =\u0026gt; { const name = \u0026#39;John Doe\u0026#39;; console.log(name); return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Debugging in React\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ) } export default MyComponent; 35.2 Strict Mode =\u0026gt; In Strict Mode,React will render components twice. It helps to idenify the issues in the code.\nimport React,{StrictMode} from \u0026#39;react\u0026#39;; const MyComponent = () =\u0026gt; { const name = \u0026#39;John Doe\u0026#39;; console.log(name); return ( \u0026lt;StrictMode\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Debugging in React\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/StrictMode\u0026gt; ) } export default MyComponent; You can wrap any component in StrictMode.Just difference is that it will render the component twice.\n=\u0026gt; We can wrap the entire application in StrictMode in the index.js file.\nimport React,{StrictMode} from \u0026#39;react\u0026#39;; import ReactDOM from \u0026#39;react-dom\u0026#39;; import App from \u0026#39;./App\u0026#39;; ReactDOM.render( \u0026lt;StrictMode\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/StrictMode\u0026gt;, document.getElementById(\u0026#39;root\u0026#39;) ); 35.3 React Developer Tools React Developer Tools is a Chrome extension that allows you to inspect the React component hierarchy in the Chrome Developer Tools. Videos\n","permalink":"http://localhost:1313/posts/pages/react/react6/","summary":"Learn how to debug React applications using console.log, Strict Mode, and React Developer Tools.","title":"React : Day 6"},{"content":"Python Fundamentals: A Beginner\u0026rsquo;s Guide (Part 1) 1. Virtual Environment A virtual environment is a feature in Python that allows you to install the same package with different versions on the same system. This enables you to work on multiple projects using different versions of the same package.\n1.1. Installing venv The venv module is included in the Python standard library, so you don\u0026rsquo;t need to install it separately. However, if you are using an older version of Python (before 3.3), you can install virtualenv using pip:\npip install virtualenv 1.2. Creating a Virtual Environment To create a virtual environment, you can use the venv module, which is included in the Python standard library. Here\u0026rsquo;s how you can create a virtual environment named myenv:\npython -m venv myenv This command creates a new directory named myenv that contains the necessary files for the virtual environment.\n1.3. Activating a Virtual Environment To activate the virtual environment, you may run the following command:\n# For Linux/Mac: source myenv/bin/activate # For Windows: myenv\\Scripts\\activate 2. Python Packages 2.1. List All the Python Packages To list or save all the installed packages in the current environment, you can use the following command using freeze:\npip freeze # To list all the installed packages pip freeze \u0026gt; requirements.txt # To save all the installed packages in a file 2.2. Installing Python Packages To install a Python package, you can use the pip install command followed by the package name. For example, to install the requests package, you can run:\npip install requests 2.3. Uninstalling Python Packages To uninstall a Python package, you can use the pip uninstall command followed by the package name. For example, to uninstall the requests package, you can run:\npip uninstall requests 2.4. Run Python Package/Script To run a python package or script, you can use the following command:\npython -m package_name 3. Python Basics 3.1. Running a Python Script To run a Python script, you can use the following command:\npython script.py 3.2. Python Indentation In Python, the code block (body of the function, loop, etc.) starts with a colon (:) and the line following the colon should be indented.\nif 5 \u0026gt; 2: print(\u0026#34;Five is greater than two!\u0026#34;) # Indented block 3.3. Python Comments There are two types of comments in Python:\n# This is a single line comment \u0026#34;\u0026#34;\u0026#34; This is a multiline comment This is a multiline comment This is a multiline comment This is a multiline comment \u0026#34;\u0026#34;\u0026#34; 3.4. Print Statement The print() function is used to display the output on the console. For example:\nprint(\u0026#34;Hello, World!\u0026#34;) 3.5. Data Types Python has the following data types:\nint float str bool list tuple set dict None a = 10 # int b = 10.5 # float c = \u0026#34;Hello\u0026#34; # str d = True # bool e = [1,2,3] # list f = (1,2,3) # tuple g = {1,2,3} # set h = {\u0026#34;name\u0026#34;:\u0026#34;John\u0026#34;,\u0026#34;age\u0026#34;:30} # dict i = None # None print(type(a)) # \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; Note:Use type() function to check the data type of a variable.As it return the class of the variable.\n3.6. Rules of Variable Declaration A variable name must start with a letter or the underscore character. A variable name cannot start with a number. A variable name can only contain alpha-numeric characters and underscores (A-z, 0-9, and _ ). Variable names are case-sensitive (age, Age, and AGE are three different variables). 3.7. Type Conversion You can convert one data type to another using the following functions:\nint(): To convert to an integer float(): To convert to a float str(): To convert to a string bool(): To convert to a boolean list(): To convert to a list tuple(): To convert to a tuple set(): To convert to a set dict(): To convert to a dictionary a = 10 #a=10 b = float(a) #b=10.0 c = str(a) #c=\u0026#39;10\u0026#39; d = bool(a) #d=True e = list(c) #e=[\u0026#39;1\u0026#39;,\u0026#39;0\u0026#39;] f = tuple(c) #f=(\u0026#39;1\u0026#39;,\u0026#39;0\u0026#39;) g = set(c) #g={\u0026#39;1\u0026#39;,\u0026#39;0\u0026#39;} h = dict(name=\u0026#34;John\u0026#34;,age=30) or dict([(\u0026#34;name\u0026#34;,\u0026#34;John\u0026#34;),(\u0026#34;age\u0026#34;,30)]) #h={\u0026#39;name\u0026#39;:\u0026#39;John\u0026#39;,\u0026#39;age\u0026#39;:30} Note: Python is dynamically typed, which means a variable\u0026rsquo;s data type can be changed.\n4. Operators 4.1. Arithmetic Operators +: Addition -: Subtraction *: Multiplication /: Division %: Modulus **: Power //: Floor Division a = 10 b = 3 print(a + b) # 13 print(a - b) # 7 print(a * b) # 30 print(a / b) # 3.3333333333333335 print(a % b) # 1 print(a ** b) # 1000 print(a // b) # 3 4.2. Assignment Operators =: Assign value +=: Add and assign -=: Subtract and assign *=: Multiply and assign /=: Divide and assign %=: Modulus and assign **=: Power and assign //=: Floor Division and assign a = 10 a += 5 # a = a + 5 a -= 5 # a = a - 5 a *= 5 # a = a * 5 a /= 5 # a = a / 5 a %= 5 # a = a % 5 a **= 5 # a = a ** 5 a //= 5 # a = a // 5 4.3. Comparison Operators ==: Equal to !=: Not equal to \u0026gt;: Greater than \u0026lt;: Less than \u0026gt;=: Greater than or equal to \u0026lt;=: Less than or equal to a = 10 b = 20 print(a == b) # False print(a != b) # True print(a \u0026gt; b) # False print(a \u0026lt; b) # True print(a \u0026gt;= b) # False print(a \u0026lt;= b) # True 4.4. Logical Operators and: Returns True if both statements are true or: Returns True if one of the statements is true not: Reverse the result, returns False if the result is true a = 10 b = 20 c = 30 print(a \u0026lt; b and b \u0026lt; c) # True print(a \u0026lt; b or b \u0026gt; c) # True print(not(a \u0026lt; b and b \u0026lt; c)) # False 4.5. Identity Operators is: Returns True if both variables are the same object is not: Returns True if both variables are not the same object a = [1,2,3] b = [1,2,3] print(a is b) # False print(a is not b) # True 4.6. Membership Operators in: Returns True if a sequence with the specified value is present in the object not in: Returns True if a sequence with the specified value is not present in the object a = [1,2,3] #Can be used in list , tuple , set , dict, string print(1 in a) # True print(4 not in a) # True 4.7. Bitwise Operators \u0026amp;: AND |: OR ^: XOR ~: NOT \u0026lt;\u0026lt;: Left Shift \u0026gt;\u0026gt;: Right Shift a = 10 b = 4 print(a \u0026amp; b) # 0 print(a | b) # 14 print(a ^ b) # 14 print(~a) # -11 print(a \u0026lt;\u0026lt; 2) # 40 print(a \u0026gt;\u0026gt; 2) # 2 Note: is vs ==\nis is used to compare the memory location of two objects. == is used to compare the values of two objects. # For Mutable objects (list, dict, set): a = [1,2,3] b = [1,2,3] print(a == b) # True print(a is b) # False # For immutable objects (int, float, string, tuple, None): a = 10 b = 10 print(a == b) # True print(a is b) # True c = None d = None print(c == d) # True print(c is d) # True 5.Taking User Input In Python, you can take user input using the input() function. Here\u0026rsquo;s an example:\nname = input(\u0026#34;Enter your name: \u0026#34;) print(\u0026#34;Hello, \u0026#34; + name) Note: The input() function always returns a string. If you want to convert it to another data type, you can use type conversion functions like int(), float(), etc.\n","permalink":"http://localhost:1313/posts/pages/python/python_basics/","summary":"A comprehensive guide to Python programming fundamentals covering core concepts for beginners","title":"Python Fundamentals: A Beginner's Guide (Part 1)"},{"content":"30. Sharing State Between React Components: Lifting State Up In React, components are the building blocks of a user interface. Each component can have its own state, but there are situations where multiple components need to share the same state. In such cases, the concept of \u0026ldquo;lifting state up\u0026rdquo; is used to manage the shared state in a common ancestor component.\u0026ldquo;Lifting state up\u0026rdquo; is a common pattern in React used when two or more components need to share data or state. Instead of managing the state in one of the components and creating a dependency between them, the state is \u0026ldquo;lifted up\u0026rdquo; to the closest common ancestor of the components that need the state.\nKey Concept When multiple components need to interact with the same state:\nThe closest common ancestor is identified. The state is moved to this common ancestor. This ancestor manages the state and passes it down to the child components as props. If any child needs to modify the state, the ancestor provides a function (passed as a prop) to handle the state update. Step-by-Step Procedure and Syntax Identify the Closest Common Ancestor:\nDetermine which component is the nearest common parent of all components that need to share the state. Lift the State Up:\nMove the state to the identified ancestor component. Use the useState hook (or class component state) to manage the state. const [state, setState] = useState(initialValue); Pass State Down as Props:\nPass the state to child components that need it via props. \u0026lt;ChildComponent state={state} /\u0026gt; Create State-Modifier Functions:\nDefine functions in the ancestor component to modify the state. const modifyStateHandler = (newData) =\u0026gt; { setState((prev) =\u0026gt; ({ ...prev, newData })); }; Pass Modifier Functions to Children:\nPass these functions to the child components as props so they can trigger state updates. \u0026lt;ChildComponent onModifyState={modifyStateHandler} /\u0026gt; Use Props in Child Components:\nAccess and use the state and modifier functions passed as props in the child components. function ChildComponent({ state, onModifyState }) { return ( \u0026lt;button onClick={() =\u0026gt; onModifyState(\u0026#34;new data\u0026#34;)}\u0026gt;Modify State\u0026lt;/button\u0026gt; ); } Example (Sharing State/Data Between Two Child Component) Parent Component (App.js) The parent component will hold the shared state and provide functions for updating it. It will pass the state and update functions as props to the child components.\nimport React, { useState } from \u0026#34;react\u0026#34;; import ChildOne from \u0026#34;./ChildOne\u0026#34;; import ChildTwo from \u0026#34;./ChildTwo\u0026#34;; const App = () =\u0026gt; { // Shared state const [sharedState, setSharedState] = useState(\u0026#34;Initial State\u0026#34;); // Function to update the state const updateState = (newState) =\u0026gt; { setSharedState(newState); }; return ( \u0026lt;div style={{ padding: \u0026#34;20px\u0026#34;, fontFamily: \u0026#34;Arial\u0026#34; }}\u0026gt; \u0026lt;h1\u0026gt;Parent Component\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;Shared State: {sharedState}\u0026lt;/p\u0026gt; \u0026lt;hr /\u0026gt; \u0026lt;ChildOne sharedState={sharedState} updateState={updateState} /\u0026gt; \u0026lt;hr /\u0026gt; \u0026lt;ChildTwo sharedState={sharedState} updateState={updateState} /\u0026gt; \u0026lt;/div\u0026gt; ); }; export default App; Child Component 1 (ChildOne.js) This component will display the shared state and allow the user to modify it through an input field.\nimport React from \u0026#34;react\u0026#34;; const ChildOne = ({ sharedState, updateState }) =\u0026gt; { const handleChange = (e) =\u0026gt; { updateState(e.target.value); }; return ( \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;Child Component One\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;Shared State: {sharedState}\u0026lt;/p\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; value={sharedState} onChange={handleChange} placeholder=\u0026#34;Update State\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; ); }; export default ChildOne; Child Component 2 (ChildTwo.js) This component will display the shared state and provide a button to reset it.\nimport React from \u0026#34;react\u0026#34;; import React from \u0026#34;react\u0026#34;; const ChildTwo = ({ sharedState, updateState }) =\u0026gt; { const handleReset = () =\u0026gt; { updateState(\u0026#34;Initial State\u0026#34;); }; return ( \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;Child Component Two\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;Shared State: {sharedState}\u0026lt;/p\u0026gt; \u0026lt;button onClick={handleReset}\u0026gt;Reset State\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); }; export default ChildTwo; Folder Structure src/ ├── App.js ├── ChildOne.js ├── ChildTwo.js ├── index.js Explanation:\nThe App component is the parent component that holds the shared state and passes it down to ChildOne and ChildTwo. ChildOne and ChildTwo are child components that receive the shared state and update functions as props. ChildOne allows the user to update the shared state through an input field, while ChildTwo provides a button to reset the state. Note: We cant directly pass data from one child component to another child component. We need to pass the data to the parent component and then pass it to the other child component. This is called lifting state up.\nExample (Sharing State/Data Between Two Sibling Components) Parent Component (App.js) import {usState} from \u0026#39;react\u0026#39;; import Expenses from \u0026#39;./Expenses\u0026#39;; import NewExpense from \u0026#39;./NewExpense\u0026#39;; const App=()=\u0026gt;{ const [expenses,setExpenses]=useState([ {id:1,title:\u0026#39;Car Insurance\u0026#39;,amount:294.67,date:new Date(2021,2,28)}, {id:2,title:\u0026#39;Health Insurance\u0026#39;,amount:394.67,date:new Date(2021,3,28)}, {id:3,title:\u0026#39;Home Insurance\u0026#39;,amount:494.67,date:new Date(2021,4,28)}, ]); const addExpenseHandler=(expense)=\u0026gt;{ setExpenses((prevExpenses)=\u0026gt;{ return [expense,...prevExpenses]; }); }; return ( \u0026lt;div\u0026gt; \u0026lt;NewExpense onAddExpense={addExpenseHandler}/\u0026gt; \u0026lt;Expenses items={expenses}/\u0026gt; \u0026lt;/div\u0026gt; ); }; export default App; NewExpense Component import ExpenseForm from \u0026#39;./ExpenseForm\u0026#39;; const NewExpense=(props)=\u0026gt;{ const saveExpenseDataHandler=(enteredExpenseData)=\u0026gt;{ const expenseData={ ...enteredExpenseData, id:Math.random().toString() }; props.onAddExpense(expenseData); }; return ( \u0026lt;div\u0026gt; \u0026lt;ExpenseForm onSaveExpenseData={saveExpenseDataHandler}/\u0026gt; \u0026lt;/div\u0026gt; ); }; export default NewExpense; Expenses function Expenses({iteam}){ return ( \u0026lt;\u0026gt; {items.map((expense)=\u0026gt;( \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;{expense.title}\u0026lt;/h2\u0026gt; \u0026lt;div\u0026gt;{expense.amount}\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;{expense.date.toISOString()}\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ))} \u0026lt;/div\u0026gt; ) } 31. Dynamically setting object keys In JavaScript, object keys are usually set statically, but there are situations where you may need to set object keys dynamically based on some conditions or variables. This can be achieved using the square bracket notation ([]) to set object keys dynamically.\nfor example:\nconst data=\u0026#34;name\u0026#34;; const person={ [data]:\u0026#39;John\u0026#39; }; console.log(person); // {name:\u0026#39;John\u0026#39;} If we dont use square bracket notation, then the key will be set as \u0026lsquo;data\u0026rsquo; instead of \u0026rsquo;name\u0026rsquo;.\nconst data=\u0026#34;name\u0026#34;; const person={ data:\u0026#39;John\u0026#39; }; console.log(person); // {data:\u0026#39;John\u0026#39;} 32.Using SAme State Variable to store multiple values =\u0026gt; We can use the same state variable to store multiple values by using an object.\nconst [userInput,setUserInput]=useState({ enteredTitle:\u0026#39;\u0026#39;, enteredAmount:\u0026#39;\u0026#39;, enteredDate:\u0026#39;\u0026#39; }); const titleChangeHandler=(event)=\u0026gt;{ setUserInput({ ...userInput, enteredTitle:event.target.value }); }; const amountChangeHandler=(event)=\u0026gt;{ setUserInput({ ...userInput, enteredAmount:event.target.value }); }; const dateChangeHandler=(event)=\u0026gt;{ setUserInput({ ...userInput, enteredDate:event.target.value }); }; return ( \u0026lt;div\u0026gt; Title:\u0026lt;input type=\u0026#34;text\u0026#34; value={userInput.enteredTitle} onChange={titleChangeHandler}/\u0026gt; Amount:\u0026lt;input type=\u0026#34;number\u0026#34; value={userInput.enteredAmount} onChange={amountChangeHandler}/\u0026gt; Date:\u0026lt;input type=\u0026#34;date\u0026#34; value={userInput.enteredDate} onChange={dateChangeHandler}/\u0026gt; The entered title is {userInput.enteredTitle} The entered amount is {userInput.enteredAmount} The entered date is {userInput.enteredDate} \u0026lt;/div\u0026gt; ); =\u0026gt; In the above code, we are using the same state variable userInput to store multiple values. We are using an object to store the values. We are using the spread operator to copy the existing values of the object and then updating the required value.\n33.Handeling page reloads when a form is submitted When a form is submitted, the page reloads by default. This is not what we want in a single page application. We want to stay on the same page and update the content of the page. We can do this by using the preventDefault() method on the event object. The preventDefault() method prevents the default behavior of the event object. In this case, it prevents the page from reloading when the form is submitted. const submitHandler=(event)=\u0026gt;{ event.preventDefault(); // code to handle form submission }; ","permalink":"http://localhost:1313/posts/pages/react/react4/","summary":"Learn how to share state between React components by lifting state up to a common ancestor.","title":"React : Day 4"},{"content":"1. Python Manupulation of Data Types We have already discussed the basic concepts of Python programming in the previous part of this series. In this part, we will dive deeper into operations and manipulations of different data types in Python.\n1.1.Numeric Operations 1.1.1. abs() Function The abs() function returns the absolute value of a number. For example:\nnum = -10 print(abs(num)) # Output: 10 1.1.2. round() Function The round() function rounds a number to the nearest integer. For example:\nnum = 3.14159 print(round(num)) # Output: 3 1.1.3. ord() Function The ord() function returns the Unicode code point of a character. For example:\nchar = \u0026#39;A\u0026#39; print(ord(char)) # Output: 65 1.2. String Operations String is a sequence of characters enclosed within single, double, or triple quotes. In Python, strings are immutable, meaning they cannot be changed once created. Here are some common string operations:\n1.2.1. Declaring a String we can declare a string using single, double, or triple quotes. For example:\nstr1 = \u0026#39;Hello, World!\u0026#39; #for single line string str2 = \u0026#34;Hello, World!\u0026#34; #for single line string str3 = \u0026#39;\u0026#39;\u0026#39;Hello, World! This is a multiline string.\u0026#39;\u0026#39;\u0026#39;#for multiline string 1.2.2. Text Decorators There are many text decorators available in Python to format strings among them we use \\n for a new line, \\t for a tab. For example:\nstr1 = \u0026#39;Hello, \\nWorld!\u0026#39; #for new line str2 = \u0026#34;Hello, \\tWorld!\u0026#34; #for tab 1.2.3. String Indexing The indexing of a string starts from 0 to n-1, where n is the length of the string. For example: for example: a=\u0026ldquo;hello\u0026rdquo;\na = H e l l o 0 1 2 3 4 0 -4 -3 -2 -1 1.2.4. Ascessing Characters in a String We can access characters in a string using the index using []. For example:\nstr = \u0026#34;Hello, World!\u0026#34; print(str[0]) # Output: H print(str[-1]) # Output: ! 1.2.5. String Concatenation We can concatenate two strings using the + operator and * operator . For example:\nstr1 = \u0026#34;Hello\u0026#34; str2 = \u0026#34;World\u0026#34; print(str1 + str2) # Output: HelloWorld print(str1 * 3) # Output: HelloHelloHello 1.2.6. String Slicing We can slice a string using the syntax variable[start:end:step] to get a substring.\nNote: The substring contains characters from index start to end-1, meaning the character at the end index is not included but character at the start index is included . The step refers to the increment or jump of the index\nFor example:\na = \u0026#34;hello\u0026#34; # Slice from index 1 to the end of the string print(a[1:]) # ello (Characters from index 1 to the end) # Slice from the beginning of the string to index 4 (doesn\u0026#39;t contain character at index 4) print(a[:4]) # hell (Characters from index 0 to 3) # Slice from index 1 to index 4 (doesn\u0026#39;t contain character at index 4) print(a[1:4]) # ell (Characters from index 1 to 3) # Full slice of the string with default values print(a[::]) # hello (Default start is 0, end is the string length, step is 1) # Defining a step value in slicing # Slice with a step of 2 print(a[::2]) # hlo (Start from index 0 to the end, select every 2nd character) # Reverse the string using a negative step print(a[::-1]) # olleh (Reverse the string by stepping backward) # Combining start, end, and step print(a[1:4:2]) # el #(Start from index 1 to 4 (doesn\u0026#39;t contain character at index 4), with a step of 2) 1.2.7. String Methods Python provides various built-in methods to manipulate strings. Some of the commonly used string methods are:\nlen() : Returns the length of the string. str = \u0026#34;Hello, World!\u0026#34; print(len(str)) # Output: 13 replace() : Replaces a substring with another substring. str = \u0026#34;Hello, World!\u0026#34; print(str.replace(\u0026#34;World\u0026#34;, \u0026#34;Universe\u0026#34;)) # Output: Hello, Universe! upper() : Converts the string to uppercase. str = \u0026#34;Hello, World!\u0026#34; print(str.upper()) # Output: HELLO, WORLD! lower() : Converts the string to lowercase. str = \u0026#34;Hello, World!\u0026#34; print(str.lower()) # Output: hello, world! split() : Splits the string into a list based on the delimiter. str = \u0026#34;Hello, World!\u0026#34; print(str.split(\u0026#34;,\u0026#34;)) # Output: [\u0026#39;Hello\u0026#39;, \u0026#39; World!\u0026#39;] capitalize() : Converts the first character of the string to uppercase.\nstr = \u0026#34;hello, world!\u0026#34; print(str.capitalize()) # Output: Hello, world! -find() : Returns the index of the first occurrence of a substring.\nstr = \u0026#34;Hello, World!\u0026#34; print(str.find(\u0026#34;World\u0026#34;)) # Output: 7 print(str.find(\u0026#34;e\u0026#34;)) # Output: 1 print(str.find(\u0026#34;Universe\u0026#34;)) # Output: -1 count() : Returns the number of occurrences of a substring. str = \u0026#34;Hello, World!\u0026#34; print(str.count(\u0026#34;l\u0026#34;)) # Output: 3 startswith() : Returns True if the string starts with a specified substring. str = \u0026#34;Hello, World!\u0026#34; print(str.startswith(\u0026#34;Hello\u0026#34;)) # Output: True endswith() : Returns True if the string ends with a specified substring. str = \u0026#34;Hello, World!\u0026#34; print(str.endswith(\u0026#34;World!\u0026#34;)) # Output: True strip() : Removes leading and trailing whitespaces from the string. We can also specify the characters to be removed. str = \u0026#34; Hello, World! \u0026#34; print(str.strip()) # Output: Hello, World! str = \u0026#34;!!!!!!!!Hello, World!!!!!\u0026#34; print(str.strip(\u0026#34;!\u0026#34;)) # Output: Hello, World! lstrip() : Removes leading whitespaces from the string.we can also specify the characters to be removed. str = \u0026#34; Hello, World! \u0026#34; print(str.lstrip()) # Output: Hello, World! str = \u0026#34;!!!!!!!!Hello, World!!!!!\u0026#34; print(str.lstrip(\u0026#34;!\u0026#34;)) # Output: Hello, World!!!!! rstrip() : Removes trailing whitespaces from the string.We can also specify the characters to be removed. str = \u0026#34; Hello, World! \u0026#34; print(str.rstrip()) # Output: Hello, World! str = \u0026#34;!!!!!!!!Hello, World!!!!!\u0026#34; print(str.rstrip(\u0026#34;!\u0026#34;)) # Output: !!!!!!!!Hello, World 1.2.8. f-Strings f-strings are a convenient way to format strings in Python. They allow you to embed expressions inside string literals, using curly braces {}. For example:\nname = \u0026#34;Alice\u0026#34; age = 30 print(f\u0026#34;My name is {name} and I am {age} years old.\u0026#34;) # Output: My name is Alice and I am 30 years old. 1.2.9. Raw Strings Raw strings are used to ignore escape characters in a string. They are prefixed with an r or R. For example:\npath=\u0026#34;C:\\Users\\Alice\\Documents\u0026#34; print(path) # Output: C:UsersAliceDocuments path = r\u0026#34;C:\\Users\\Alice\\Documents\u0026#34; print(path) # Output: C:\\Users\\Alice\\Documents Note:String is immutable in python.\na = \u0026#34;Hello\u0026#34; a[0] = \u0026#34;h\u0026#34; # Error: \u0026#39;str\u0026#39; object does not support item assignment #Instead To change the string value we can use the following method a=\u0026#39;k\u0026#39;+a[1::] # Output: \u0026#39;kello\u0026#39; 1.3. List Operations A list is a collection of items enclosed within square brackets []. Lists are mutable, meaning they can be changed after creation. Here are some common list operations: Key Points:\nList is mutable in python. List support indexing and slicing like string 1.3.1. Declaring a List We can declare a list by enclosing items within square brackets []. For example:\nlist1 = [1, 2, 3, 4, 5] list2 = [\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;] list3 = [1, \u0026#34;apple\u0026#34;, True, 3.14] 1.3.2 List Concatenation We can concatenate two or more lists using the + operator. For example:\nlist1 = [1, 2, 3] list2 = [4, 5, 6] print(list1 + list2) # Output: [1, 2, 3, 4, 5, 6] 1.3.3. Mutable property of List List is mutable in python and its example is shown below:\n#for string a = \u0026#34;Hello\u0026#34; a[0] = \u0026#34;h\u0026#34; # Error: \u0026#39;str\u0026#39; object does not support item assignment #for list list1 = [1, 2, 3] list1[0] = 10 print(list1) # Output: [10, 2, 3] 1.3.4. Built-in List Methods Python provides various built-in methods to manipulate lists. Some of the commonly used list methods are:\nlen() : Returns the length of the list. list1 = [1, 2, 3, 4, 5] print(len(list1)) # Output: 5 append() : Adds an element to the end of the list /Change orginal list does not return anything. list1 = [1, 2, 3] list1.append(4) print(list1) # Output: [1, 2, 3, 4] insert() : Inserts an element at a specified position in the list /Change orginal list does not return anything. list1 = [1, 2, 3] list1.insert(1, 4) print(list1) # Output: [1, 4, 2, 3] pop() : Removes the element at the specified position in the list and returns it. If no index is specified, it removes and returns the last element. list1 = [1, 2, 3] print(list1.pop(1)) # Output: 2 print(list1) # Output: [1, 3] print(list1.pop()) # Output: 3 print(list1) # Output: [1] remove() : Removes the first occurrence of the specified element from the list. list1 = [1, 2, 3, 2] list1.remove(2) print(list1) # Output: [1, 3, 2] -sort() : Sorts the list in ascending order.Does not return anything but change the original list.\nlist1 = [3, 1, 2] list1.sort() print(list1) # Output: [1, 2, 3] -reverse() : Reverses the order of the list. Does not return anything but change the original list.\nlist1 = [1, 2, 3] list1.reverse() print(list1) # Output: [3, 2, 1] -count() : Returns the number of occurrences of a specified element in the list.\nlist1 = [1, 2, 3, 2] print(list1.count(2)) # Output: 2 -index() : Returns the index of the first occurrence of the specified element in the list.\nlist1 = [1, 2, 3, 2] print(list1.index(2)) # Output: 1 1.3.5. List Comprehension List comprehension is a concise way to create lists from existing lists. There are 3 type of syntax.\nNot using if list1=[variable for variable in iterable] Using if only list1 = [variable for variable in iterable if condition] Using if else list1 = [variable if condition else variable for variable in iterable] Traditional way of creating list\nlist1 = [] for i in range(5): list1.append(i) print(list1) # Output: [0, 1, 2, 3, 4] Using list comprehension\nlist1 = [i for i in range(5)] print(list1) # Output: [0, 1, 2, 3, 4] list1 = [i for i in range(5) if i%2==0] print(list1) # Output: [0, 2, 4] list1 = [i if i%2==0 else i**2 for i in range(5)] print(list1) # Output: [0, 1, 2, 9, 4] Note: When you attempt to access an index that is out of range, Python will raise an IndexError so put it in try-except block to handle the error.\nNote: The indexing and slicing of list are similar to string.\n1.4 Dictionary Operations A dictionary is a collection of key-value pairs enclosed within curly braces {}. Dictionaries are mutable and unordered. Here are some common dictionary operations:\n1.4.1. Declaring a Dictionary We can declare a dictionary by specifying key-value pairs within curly braces {}. For example:\ndict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} dict2 = {1: \u0026#34;apple\u0026#34;, 2: \u0026#34;banana\u0026#34;, 3: \u0026#34;cherry\u0026#34;} dict3 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;, \u0026#34;hobbies\u0026#34;: [\u0026#34;reading\u0026#34;, \u0026#34;painting\u0026#34;]} 1.4.2. Accessing Dictionary Elements We can access dictionary elements using keys. For example:\ndict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} print(dict1[\u0026#34;name\u0026#34;]) # Output: Alice 1.4.3 Adding Dictionary Elements We can add new key-value pairs to a dictionary by specifying the key and value. For example:\ndict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30} dict1[\u0026#34;city\u0026#34;] = \u0026#34;New York\u0026#34; print(dict1) # Output: {\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 30, \u0026#39;city\u0026#39;: \u0026#39;New York\u0026#39;} 1.4.4. Updating Dictionary Elements We can update the value of an existing key in a dictionary. For example:\ndict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} dict1[\u0026#34;age\u0026#34;] = 35 print(dict1) # Output: {\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 35, \u0026#39;city\u0026#39;: \u0026#39;New York\u0026#39;} 1.4.5 Dictionary Methods Python provides various built-in methods to manipulate dictionaries. Some of the commonly used dictionary methods are:\nlen() : Returns the number of key-value pairs in the dictionary. dict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} print(len(dict1)) # Output: 3 keys() : Returns a list of all the keys in the dictionary. dict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} print(dict1.keys()) # Output: dict_keys([\u0026#39;name\u0026#39;, \u0026#39;age\u0026#39;, \u0026#39;city\u0026#39;]) values() : Returns a list of all the values in the dictionary. dict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} print(dict1.values()) # Output: dict_values([\u0026#39;Alice\u0026#39;, 30, \u0026#39;New York\u0026#39;]) items() : Returns a list of key-value pairs in the dictionary. dict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} print(dict1.items()) # Output: dict_items([(\u0026#39;name\u0026#39;, \u0026#39;Alice\u0026#39;), (\u0026#39;age\u0026#39;, 30), (\u0026#39;city\u0026#39;, \u0026#39;New York\u0026#39;)]) -pop() : Removes the element with the specified key and returns its value.\ndict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} print(dict1.pop(\u0026#34;age\u0026#34;)) # Output: 30 print(dict1) # Output: {\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;city\u0026#39;: \u0026#39;New York\u0026#39;} -get() : Returns the value of the specified key. If the key does not exist, it returns the specified default value.\ndict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} print(dict1.get(\u0026#34;age\u0026#34;)) # Output: 30 print(dict) # Output: {\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 30, \u0026#39;city\u0026#39;: \u0026#39;New York\u0026#39;} Note: When you attempt to access a key that does not exist in the dictionary, Python will raise a KeyError so put it in try-except block to handle the error or use get() method to avoid the error.\n1.4.6. Nested Dictionaries A dictionary can contain another dictionary as a value. This is known as a nested dictionary. For example:\ndict1 = { \u0026#34;person1\u0026#34;: {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30}, \u0026#34;person2\u0026#34;: {\u0026#34;name\u0026#34;: \u0026#34;Bob\u0026#34;, \u0026#34;age\u0026#34;: 25} } print(dict1[\u0026#34;person1\u0026#34;][\u0026#34;name\u0026#34;]) # Output: Alice 1.4.7. Dictionary Comprehension Dictionary comprehension is a concise way to create dictionaries. For example:\ndict1 = {x: x**2 for x in range(5)} # Output: {0: 0, 1: 1, 2: 4, 3: 9, 4: 16} #using if only dict1 = {x: x**2 for x in range(5) if x%2==0} # Output: {0: 0, 2: 4, 4: 16} #using if else dict1 = {x: x**2 if x%2==0 else x**3 for x in range(5)} # Output: {0: 0, 1: 1, 2: 4, 3: 27, 4: 16} 1.5. Tuple Operations A tuple is a collection of items enclosed within parentheses (). Tuples are immutable, meaning they similar to python as they cant be changed using indexing as a[0]=10 will give an error.\n1.5.1. Declaring a Tuple We can declare a tuple by enclosing items within parentheses (). For example:\ntuple1 = (1, 2, 3) tuple2 = (\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;) tuple3 = (1, \u0026#34;apple\u0026#34;, True, 3.14) 1.5.2. Accessing Tuple Elements We can access tuple elements using indexing . For example:\ntuple1 = (1, 2, 3) print(tuple1[0]) # Output: 1 1.5.3. Slice Tuple We can slice a tuple using the syntax variable[start:end:step] to get a sub-tuple. For example:\ntuple1 = (1, 2, 3, 4, 5) print(tuple1[1:4]) # Output: (2, 3, 4) 1.5.4. Tuple Methods Python provides various built-in methods to manipulate tuples. Some of the commonly used tuple methods are:\ncount() : Returns the number of occurrences of a specified element in the tuple. tuple1 = (1, 2, 3, 2) print(tuple1.count(2)) # Output: 2 index() : Returns the index of the first occurrence of the specified element in the tuple. tuple1 = (1, 2, 3, 2) print(tuple1.index(2)) # Output: 1 len() : Returns the length of the tuple. tuple1 = (1, 2, 3, 2) print(len(tuple1)) # Output: 4 1.5.5 concatenation of tuple We can concatenate two or more tuples using the + operator. For example:\ntuple1 = (1, 2, 3) tuple2 = (4, 5, 6) print(tuple1 + tuple2) # Output: (1, 2, 3, 4, 5, 6) 1.5.6. Tuple Unpacking Tuple unpacking allows us to assign multiple variables at once. For example:\ntuple1 = (1, 2, 3) a, b, c = tuple1 d,*e = tuple1 print(a) # Output: 1 print(b) # Output: 2 print(c) # Output: 3 print(d) # Output: 1 print(e) # Output: [2, 3] tuple1 = (1, 2, 3, 4, 5) a, *b, c = tuple1 print(a) # Output: 1 print(b) # Output: [2, 3, 4] print(c) # Output: 5 Note:Ascessing and slicing of tuple is similar to list and string.\n1.6. Boolean Operations Boolean is a data type that represents one of two values: True or False. Boolean values are used to evaluate conditions in programming. Here are some common boolean operations:\n1.6.1. Condition when variable is True When a variable has a non-zero value, it is considered True. a = 10 if a: print(\u0026#34;The value of a is True\u0026#34;) When a string is not empty, it is considered True. a = \u0026#34;Hello\u0026#34; if a: print(\u0026#34;The value of a is True\u0026#34;) When a list is not empty, it is considered True. a = [1, 2, 3] if a: print(\u0026#34;The value of a is True\u0026#34;) When a dictionary is not empty, it is considered True. a = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30} if a: print(\u0026#34;The value of a is True\u0026#34;) When a tuple is not empty, it is considered True. a = (1, 2, 3) if a: print(\u0026#34;The value of a is True\u0026#34;) When a set is not empty, it is considered True. a = {1, 2, 3} if a: print(\u0026#34;The value of a is True\u0026#34;) When a variable is explicitly set to True, it is considered True. a = True if a: print(\u0026#34;The value of a is True\u0026#34;) 1.6.2. Condition when variable is False Those which are not in the above condition are considered as False.\n1.7. Set Operations A set is a collection of unique items enclosed within curly braces {}. Main Uses of set are:\nTo remove duplicate elements from a list. To perform mathematical set operations like union, intersection, difference, etc. 1.7.1. Declaring a Set We can declare a set by enclosing items within curly braces {} or set(). For example:\nset1 = {1, 2, 3} set2 = {\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;} set3 = {1, \u0026#34;apple\u0026#34;, True, 3.14} #using set() set4 = set([1, 2, 3]) set5=set() 1.7.2. Set Methods Python provides various built-in methods to manipulate sets. Some of the commonly used set methods are:\n-len() : Returns the number of elements in the set.\nset1 = {1, 2, 3} print(len(set1)) # Output: 3 -add() : Adds an element to the set.Doesn\u0026rsquo;t return anything.\nset1 = {1, 2, 3} set1.add(4) print(set1) # Output: {1, 2, 3, 4} -clear() : Removes all elements from the set.Doesn\u0026rsquo;t return anything.\nset1 = {1, 2, 3} set1.clear() print(set1) # Output: set() -remove() : Removes the specified element from the set. If the element is not present, it raises an error.\nset1 = {1, 2, 3} set1.remove(2) print(set1) # Output: {1, 3} discard() : Removes the specified element from the set. If the element is not present, it does not raise an error.\nset1 = {1, 2, 3} set1.discard(2) print(set1) # Output: {1, 3} -union() : Returns a set containing the union of two sets.\nset1 = {1, 2, 3} set2 = {3, 4, 5} print(set1.union(set2)) # Output: {1, 2, 3, 4, 5} -intersection() : Returns a set containing the intersection of two sets.\nset1 = {1, 2, 3} set2 = {3, 4, 5} print(set1.intersection(set2)) # Output: {3} -difference() : Returns a set containing the difference between two sets.\nset1 = {1, 2, 3} set2 = {3, 4, 5} print(set1.difference(set2)) # Output: {1, 2} -symmetric_difference() : Returns a set containing the symmetric difference between two sets.\nset1 = {1, 2, 3} set2 = {3, 4, 5} print(set1.symmetric_difference(set2)) # Output: {1, 2, 4, 5} -issubset() : Returns True if all elements of a set are present in another set.\nset1 = {1, 2, 3} set2 = {1, 2, 3, 4, 5} print(set1.issubset(set2)) # Output: True 1.8 Used in All iterable 1.8.1. in Operator The in operator is used to check if an element is present in an iterable. For example:\n# in string str = \u0026#34;Hello, World!\u0026#34; print(\u0026#34;Hello\u0026#34; in str) # Output: True # in list list1 = [1, 2, 3, 4, 5] print(3 in list1) # Output: True # in tuple tuple1 = (1, 2, 3, 4, 5) print(6 in tuple1) # Output: False # in set set1 = {1, 2, 3, 4, 5} print(5 in set1) # Output: True # in dictionary dict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30} print(\u0026#34;name\u0026#34; in dict1) # Output: True 1.8.2. not in Operator The not in operator is used to check if an element is not present in an iterable. For example:\n# not in string str = \u0026#34;Hello, World!\u0026#34; print(\u0026#34;Alice\u0026#34; not in str) # Output: True # not in list list1 = [1, 2, 3, 4, 5] print(6 not in list1) # Output: True # not in tuple tuple1 = (1, 2, 3, 4, 5) print(5 not in tuple1) # Output: False # not in set set1 = {1, 2, 3, 4, 5} print(5 not in set1) # Output: False # not in dictionary dict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30} print(\u0026#34;name\u0026#34; not in dict1) # Output: False 1.8.3. len() Function The len() function is used to get the length of an iterable. For example:\n# for string str = \u0026#34;Hello, World!\u0026#34; print(len(str)) # Output: 13 # for list list1 = [1, 2, 3, 4, 5] print(len(list1)) # Output: 5 # for tuple tuple1 = (1, 2, 3, 4, 5) print(len(tuple1)) # Output: 5 # for set set1 = {1, 2, 3, 4, 5} print(len(set1)) # Output: 5 # for dictionary dict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30} print(len(dict1)) # Output: 2 1.8.4. max() and min() Functions The max() function is used to get the maximum value from an iterable, and the min() function is used to get the minimum value for list,string,set and tuples only. for dictionary you can use .keys() or .values() and use it. For example:\n# for list list1 = [1, 2, 3, 4, 5] print(max(list1)) # Output: 5 print(min(list1)) # Output: 1 # for tuple tuple1 = (1, 2, 3, 4, 5) print(max(tuple1)) # Output: 5 print(min(tuple1)) # Output: 1 # for string string = \u0026#34;Hello, World!\u0026#34; print(max(string)) # Output: r print(min(string)) # Output: \u0026#39; \u0026#39; # for set set1 = {1, 2, 3, 4, 5} print(max(set1)) # Output: 5 print(min(set1)) # Output: 1 1.8.5. join() Function The join() function is used to concatenate elements of an iterable with a separator. For example:\n# for list list1 = [\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;] print(\u0026#34;, \u0026#34;.join(list1)) # Output: apple, banana, cherry # for tuple tuple1 = (\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;) print(\u0026#34;, \u0026#34;.join(tuple1)) # Output: apple, banana, cherry # for set set1 = {\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;} print(\u0026#34;, \u0026#34;.join(set1)) # Output: apple, banana, cherry # for string string = \u0026#34;Hello, World!\u0026#34; print(\u0026#34;, \u0026#34;.join(string)) # Output: H, e, l, l, o, ,, , W, o, r, l, d, ! ","permalink":"http://localhost:1313/posts/pages/python/python_datatype_operations/","summary":"An in-depth look at Python data types, exploring their usage and importance in programming.","title":"Python Fundamentals: Understanding Data Types (Part 2)"},{"content":"22. Fragments in React Fragments are a way to group multiple elements in React without adding extra nodes to the DOM. Fragments are useful when you want to return multiple elements from a component, but you don\u0026rsquo;t want to add an extra div or span element to the DOM.\nFragments are represented by the \u0026lt;Fragment\u0026gt; tag or the shorthand syntax \u0026lt;\u0026gt;. You can use fragments to return multiple elements from a component without adding extra nodes to the DOM.\nWithout using fragments:\nfunction App() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Hello, World!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;Welcome to React\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } Here, the App component returns two elements, but they are wrapped in a div element. If you don\u0026rsquo;t want to add an extra div element to the DOM, you can use fragments.\nUsing fragments:\nfunction App() { return ( \u0026lt;\u0026gt; or \u0026lt;Fragment\u0026gt; \u0026lt;h1\u0026gt;Hello, World!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;Welcome to React\u0026lt;/p\u0026gt; \u0026lt;/\u0026gt; or \u0026lt;/Fragment\u0026gt; ); } 23. Passing jsx as props In React, you can pass JSX as props to other components. This allows you to create reusable components that can be used in different parts of your application.\nPassing JSX as props: function App() { const heading = \u0026lt;div\u0026gt;\u0026lt;h1\u0026gt;Hello, World!\u0026lt;/h1\u0026gt;\u0026lt;p\u0026gt;My name is nirajan Khatiwada\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;; return \u0026lt;Greeting message={heading} /\u0026gt;; } or function App() { return \u0026lt;Greeting message={\u0026lt;div\u0026gt;\u0026lt;h1\u0026gt;Hello, World!\u0026lt;/h1\u0026gt;\u0026lt;p\u0026gt;My name is nirajan Khatiwada\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;} /\u0026gt;; } Using props in the Greeting component: function Greeting(props) { return \u0026lt;div\u0026gt;{props.message}\u0026lt;/div\u0026gt;; } Passing built-in components as props: function App() { return \u0026lt;Greeting element=\u0026#34;button\u0026#34; /\u0026gt;; } 24. Isolation of Component in React Isolation of components is a key concept in React that allows you to create reusable components that are independent of each other. This means that each component should be self-contained and not rely on external data or state.\nfor example:\nfunction Button(props){ const [showText, setShowText] = useState(false); return ( \u0026lt;button onClick={() =\u0026gt; setShowText(!showText)}\u0026gt; {showText ? \u0026#39;Hide Text\u0026#39; : \u0026#39;Show Text\u0026#39;} \u0026lt;/button\u0026gt; ); } function App(){ return ( \u0026lt;div\u0026gt; \u0026lt;Button /\u0026gt; \u0026lt;Button /\u0026gt; \u0026lt;/div\u0026gt; ); } Here The component Button is isolated means one state of the component does not affect the other component. Each component is self-contained and does not rely on external data or state. for example, the showText state in one Button component does not affect the showText state in the other Button component.\n25. Taking User Input in React Using onChange event: function App() { const [name, setName] = useState(\u0026#39;\u0026#39;); const handleChange = (e) =\u0026gt; { setName(e.target.value); }; return ( \u0026lt;div\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; value={name} onChange={handleChange} /\u0026gt; \u0026lt;p\u0026gt;Hello, {name}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } Whats Happen Here\nHere, we have an input element that takes user input. When the user types in the input field,the onChange event is triggered for ervy keypress. The handleChange function is called with the event object as an argument for every keypress. The setName function is called with value of user input and it rerender the component with the updated value for every keypress. The value of the input field is set to the name state, and the name is displayed below the input field. Note: use onChange event to take user input in React and update the state accordingly to reflect the changes in the UI. If you use value as a prop in the input field, you must also provide an onChange event handler to update the state. Use this method if you want to update in real-time as the user types in the input field.\nOther method will be discussed in upcoming posts. 26.Rendering 2D Arrays in React In React, you can render 2D arrays by using nested map functions to iterate over the rows and columns of the array. This allows you to display tabular data or grid-like structures in your application.\nRendering a 2D array: function App() { const data = [ [\u0026#39;John\u0026#39;, \u0026#39;Doe\u0026#39;, 30], [\u0026#39;Jane\u0026#39;, \u0026#39;Smith\u0026#39;, 25], [\u0026#39;Alice\u0026#39;, \u0026#39;Brown\u0026#39;, 35], ]; return ( \u0026lt;table\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;First Name\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Last Name\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Age\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; {data.map((row, index) =\u0026gt; ( \u0026lt;tr key={index}\u0026gt; {row.map((cell, index) =\u0026gt; ( \u0026lt;td key={index}\u0026gt;{cell}\u0026lt;/td\u0026gt; ))} \u0026lt;/tr\u0026gt; ))} \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; ); } 27. Immutable update patterns in React In react while changing the state we shouldnot change the orginal state directly Instead, we should create a new copy of the state and update the copy with the new values. This is known as immutable update pattern.speciaaly when working with arrays and objects.\nThe Wrong way to update state: function App() { const [items, setItems] = useState([\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;cherry\u0026#39;]); const removeItem = (index) =\u0026gt; { items.splice(index, 1); setItems(items); }; return ( \u0026lt;div\u0026gt; \u0026lt;ul\u0026gt; {items.map((item, index) =\u0026gt; ( \u0026lt;li key={index}\u0026gt; {item} \u0026lt;button onClick={() =\u0026gt; removeItem(index)}\u0026gt;Remove\u0026lt;/button\u0026gt; \u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ); } The Correct way to update state: function App() { const [items, setItems] = useState([\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;cherry\u0026#39;]); const removeItem = (index) =\u0026gt; { const newItems = [...items]; newItems.splice(index, 1); setItems(newItems); }; return ( \u0026lt;div\u0026gt; \u0026lt;ul\u0026gt; {items.map((item, index) =\u0026gt; ( \u0026lt;li key={index}\u0026gt; {item} \u0026lt;button onClick={() =\u0026gt; removeItem(index)}\u0026gt;Remove\u0026lt;/button\u0026gt; \u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt;x x \u0026lt;/div\u0026gt; ); } Note: Always create a new copy of the state when updating arrays or objects in React. This ensures that the state is updated correctly and prevents unexpected behavior in your application. 28. Common Pattern for update,delete and add in React In React, you can use common patterns to update, delete, and add items to an array. These patterns involve creating new copies of the array and updating the state with the new values.\nAdd an item to an array: function App() { const [items, setItems] = useState([\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;cherry\u0026#39;]); const addItem = (item) =\u0026gt; { setItems([...items, item]); // or // const newItems = [...items]; // newItems.push(item); // setItems(newItems); }; return ( \u0026lt;div\u0026gt; \u0026lt;ul\u0026gt; {items.map((item, index) =\u0026gt; ( \u0026lt;li key={index}\u0026gt;{item}\u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;button onClick={() =\u0026gt; addItem(\u0026#39;orange\u0026#39;)}\u0026gt;Add Item\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } Deleting an item from an array: function App() { const [items, setItems] = useState([\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;cherry\u0026#39;]); const removeItem = (index) =\u0026gt; { const newItems = items.filter((item, i) =\u0026gt; i !== index); setItems(newItems); }; return ( \u0026lt;div\u0026gt; \u0026lt;ul\u0026gt; {items.map((item, index) =\u0026gt; ( \u0026lt;li key={index}\u0026gt; {item} \u0026lt;button onClick={() =\u0026gt; removeItem(index)}\u0026gt;Remove\u0026lt;/button\u0026gt; \u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ); } Updating an data of an array using map: function App() { const [items, setItems] = useState([ { id: 1, name: \u0026#39;apple\u0026#39;, price: 1 }, { id: 2, name: \u0026#39;banana\u0026#39;, price: 2 }, { id: 3, name: \u0026#39;cherry\u0026#39;, price: 3 }, ]); const updateItem = (id, price) =\u0026gt; { const newItems = items.map((item) =\u0026gt; item.id === id ? { ...item, price: price } : item ); setItems(newItems); }; return ( \u0026lt;div\u0026gt; \u0026lt;ul\u0026gt; {items.map((item) =\u0026gt; ( \u0026lt;li key={item.id}\u0026gt; {item.name} - ${item.price}{\u0026#39; \u0026#39;} \u0026lt;button onClick={() =\u0026gt; updateItem(item.id, item.price + 1)}\u0026gt; Increase Price \u0026lt;/button\u0026gt; \u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ); } Updating an data of an array using find: function App() { const [items, setItems] = useState([ { id: 1, name: \u0026#39;apple\u0026#39;, price: 1 }, { id: 2, name: \u0026#39;banana\u0026#39;, price: 2 }, { id: 3, name: \u0026#39;cherry\u0026#39;, price: 3 }, ]); const updateItem = (id, price) =\u0026gt; { const newItems= [...items]; const newItem = newItems.find((item) =\u0026gt; item.id === id); if (newItem) { newItem.price = price; setItems(newItems); } }; return ( \u0026lt;div\u0026gt; \u0026lt;ul\u0026gt; {items.map((item) =\u0026gt; ( \u0026lt;li key={item.id}\u0026gt; {item.name} - ${item.price}{\u0026#39; \u0026#39;} \u0026lt;button onClick={() =\u0026gt; updateItem(item.id, item.price + 1)}\u0026gt; Increase Price \u0026lt;/button\u0026gt; \u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ); } Note: Always prefer map over find when updating an array of objects in React. This ensures that the state is updated correctly and prevents unexpected behavior in your application.\n29.Updating object in react In React, you can update an object in state by creating a new copy of the object and updating the copy with the new values. This ensures that the state is updated correctly and prevents unexpected behavior in your application.\nUpdating an object in state: function App() { const [person, setPerson] = useState({ name: \u0026#39;John\u0026#39;, age: 30 }); const updatePerson = () =\u0026gt; { setPerson({ ...person, age: person.age + 1 }); }; return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;Name: {person.name}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Age: {person.age}\u0026lt;/p\u0026gt; \u0026lt;button onClick={updatePerson}\u0026gt;Increase Age\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } use list if you want to show the list of items and use object if you want to show the details of the item to identify which one is clicked or update you can pass the index or id of the item to the function. Or you can hardcode the value to update the object or list.\n","permalink":"http://localhost:1313/posts/pages/react/react3/","summary":"A comprehensive guide covering React\u0026rsquo;s advanced concepts including Fragments, JSX Props, Component Isolation, and proper state management patterns","title":"React : Day 3"},{"content":"Python Control Structures: Mastering Loops and Conditionals In Python programming, control structures are essential for managing the flow of execution in your code. They allow you to make decisions, repeat tasks, and create complex algorithms. In this guide, we will explore two fundamental control structures in Python: loops and conditionals.\n1. Conditional Statements Conditional statements in Python allow you to execute specific blocks of code based on certain conditions. The most common conditional statements are if, elif, and else.\n1.1. The if Statement The if statement is used to check a condition and execute a block of code if the condition is true.\nExample:\nx = 10 if x \u0026gt; 5: print(\u0026#34;x is greater than 5\u0026#34;) Output:\nx is greater than 5 1.2. The elif Statement The elif statement allows you to check multiple conditions after the initial if statement. If the previous conditions are false, the elif block is evaluated.\nExample:\nx = 5 if x \u0026gt; 5: print(\u0026#34;x is greater than 5\u0026#34;) elif x == 5: print(\u0026#34;x is equal to 5\u0026#34;) Output:\nx is equal to 5 1.3. The else Statement The else statement is used to execute a block of code when all the previous conditions are false.\nExample:\nx = 3 if x \u0026gt; 5: print(\u0026#34;x is greater than 5\u0026#34;) elif x == 5: print(\u0026#34;x is equal to 5\u0026#34;) else: print(\u0026#34;x is less than 5\u0026#34;) Output:\nx is less than 5 2. Loops Loops in Python allow you to execute a block of code repeatedly. There are two main types of loops in Python: for loops and while loops.\n2.1. The while Loop The while loop executes a block of code as long as a specified condition is true.\nSyntax:\nwhile condition: # Code block else: # Optional else block Example:\ncount = 0 while count \u0026lt; 5: print(count) count += 1 else: print(\u0026#34;Loop completed\u0026#34;) 2.2. The for Loop The for loop is used to iterate over a sequence (such as a list, tuple, or string) and execute a block of code for each item in the sequence.\nSyntax:\nfor item in sequence: # Code block else: # Optional else block Example:\nfruits = [\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;] for fruit in fruits: print(fruit) else: print(\u0026#34;No more fruits\u0026#34;) 2.3 Using For Loops with different data types 2.3.1. For Loop with Strings Example:\nfor char in \u0026#34;Python\u0026#34;: print(char) Output:\np\ry\rt\rh\ro\rn 2.3.2. For Loop with Lists Example:\nnumbers = [1, 2, 3, 4, 5] for num in numbers: print(num) Output:\n1\r2\r3\r4\r5 2.3.3. For Loop with tuples Example:\nfruits = (\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;) for fruit in fruits: print(fruit) Output:\napple\rbanana\rcherry Tuple unpacking can also be used in for loops to iterate over multiple values in a tuple.\ncoordinates = [(1, 2), (3, 4), (5, 6)] for x, y in coordinates: print(f\u0026#34;X: {x}, Y: {y}\u0026#34;) Output:\nX: 1, Y: 2\rX: 3, Y: 4\rX: 5, Y: 6 2.3.4. For Loop with Sets Example:\ncolors = {\u0026#34;red\u0026#34;, \u0026#34;green\u0026#34;, \u0026#34;blue\u0026#34;} for color in colors: print(color) Output:\nred\rgreen\rblue 2.3.5. For Loop with Dictionaries Example:\nperson = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} for key, value in person.items(): print(f\u0026#34;{key}: {value}\u0026#34;) Output:\nname: Alice\rage: 30\rcity: New York 2.4. break , pass and continue statements in loops 2.4.1. The break Statement The break statement is used to exit a loop prematurely. It terminates the current loop and resumes execution at the next statement after the loop.\nExample:\nfor num in [1, 2, 3, 4, 5]: if num == 3: break print(num) Output:\n1\r2 2.4.2. The continue Statement The continue statement is used to skip the rest of the code inside a loop for the current iteration and jump to the next iteration.\nExample:\nfor num in [1, 2, 3, 4, 5]: if num == 3: continue print(num) Output:\n1\r2\r4\r5 2.4.3. The pass Statement The pass statement is a null operation that does nothing. It is used when a statement is required syntactically but you do not want any code to execute.\nExample:\nfor num in [1, 2, 3, 4, 5]: pass ","permalink":"http://localhost:1313/posts/pages/python/python_control_structure/","summary":"A detailed examination of Python\u0026rsquo;s control structures, focusing on loops and conditionals to enhance your programming skills.","title":"Python Fundamentals: Mastering Control Structures (Part 3)"},{"content":"17. Hooks in React Anythong that start with prefix use is considered as a hook in react\n17.1. Rules of Hooks Only Call Hook inside a component function correct:\nfunction App() { const [val, setVal] = useState(0); } Incorrect:\nconst [val, setVal] = useState(0); function App() { } Only Call Hooks at the Top Level Hook must not be called inside code statement (e.g., inside an if statement, loop, or nested function). correct: function App() { const [val, setVal] = useState(0); } incorrect:\nfunction App() { if (true) { const [val, setVal] = useState(0); } } 3.Hook can be used inside other custom hooks too\n18. useState Hook useState is a React hook that allows you to manage component-specific state. It provides a way to declare state variables in functional components and ensure that changes to these variables cause the component or child component to re-render while the parent component remains unaffected from where the component whose set state is triggered.\nfor example:\nfunction App() { return ( \u0026lt;div\u0026gt; \u0026lt;MemoComp /\u0026gt; \u0026lt;/div\u0026gt; ); } function MemoComp() { const [data, setData] = useState(\u0026#34;No data\u0026#34;); function handle() { setData(\u0026#34;data\u0026#34;); } return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;{data}\u0026lt;/p\u0026gt; \u0026lt;button onClick={handle}\u0026gt;Click me\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } When button is clicked the handle function is called and the setData function is called which updates the data state variable. This cause the MemoComp and its child component to re-render with a new value of data.\n18.1. Syntax const [state, setState] = useState(initialState); 18.2. Managing State State management in React involves handling data and telling React to re-execute a function using the useState hook. This ensures that state updates lead to new state values. Example:\nconst [countes, setcountes] = useState(0); countes is the state variable that holds the current state value. setcountes is the function that updates the state variable. useState(0) is the initial state value. How it works: Initially, the state variable countes is set to 0. When the setcountes function is called, it updates the state variable to a new value. This triggers a re-render of the component, updating the UI with the new state value.\n18.3 Updating State Based on Previous State Suppose the age is 42. The handler calls setAge(age + 1) three times.\nfunction handleClick() { setAge(age + 1); // setAge(42 + 1) setAge(age + 1); // setAge(42 + 1) setAge(age + 1); // setAge(42 + 1) } if the initial age is 42, after calling this function, the age will be 43, not 45.\nTo solve this problem, we use an updater function to pass setAge calls.\nfunction handleClick() { setAge(a =\u0026gt; a + 1); // setAge(42 =\u0026gt; 43) setAge(a =\u0026gt; a + 1); // setAge(43 =\u0026gt; 44) setAge(a =\u0026gt; a + 1); // setAge(44 =\u0026gt; 45) } After this age will be 45 so use updater function when you want to update value based on previous value \u0026amp; it\u0026rsquo;s always recommended to use updater function in.\nIt is mostly used in:\nCounters Toggles Incrementing or decrementing a value 18.4. Pitfalls in useState In React state updates are asynchronous meaning they don\u0026rsquo;t immediately reflect in the current execution cycle. When you call a state setter function like setSelectedValue, React schedules the state update for the next render. This can lead to unexpected behavior if you try to access the updated state immediately after setting it.\nExample: function clickHandler(data) { setSelectedValue(`${data} is being clicked`); console.log(selectedTopic); // logs the old state, not updated one } Why It Happens State updates are asynchronous: React batches state updates and applies them during the next render cycle to optimize performance. Therefore, the state change you request won’t be immediately reflected in the current execution.\nLogging state immediately: Since the update happens after the current execution cycle, logging the state/selected topic immediately after calling setSelectedValue will show the old value (before the update).\nThis can be fixed using useEffect which is read later.\nNote: Always use the state variable when you want to reflect the changes in the UI.\n19. An Example demostrating useState Hook import {useState} from \u0026#39;react\u0026#39;; function App(){ const [count,setCount] = useState(0); return(){ \u0026lt;div\u0026gt; {count} \u0026lt;/div\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;Increment\u0026lt;/button\u0026gt; } } export default App; In the above example, we have a functional component App that uses the useState hook to manage the state of the count variable. The initial value of count is set to 0 using useState(0). The setCount function is used to update the value of count when the button is clicked. The count value is displayed in the UI, and clicking the button increments the count value by 1.\n20.Conditional Rendering in React Conditional rendering is a technique used to render different components or elements based on certain conditions. In React, conditional rendering can be achieved using ternary operators, and logical operators like \u0026amp;\u0026amp; .\n20.1. Ternary Operator The ternary operator is a concise way to write conditional statements in JavaScript. It consists of a condition followed by a question mark ?, an expression to execute if the condition is true, a colon :, and an expression to execute if the condition is false.\nExample:\nfunction App() { const isLoggedIn = true; return ( \u0026lt;div\u0026gt; {isLoggedIn ? \u0026lt;p\u0026gt;Welcome, User!\u0026lt;/p\u0026gt; : \u0026lt;p\u0026gt;Please log in\u0026lt;/p\u0026gt;} \u0026lt;/div\u0026gt; ); } Also We can write jsx code in variable and use it in return statement\nfunction App() { const isLoggedIn = true; const welcomeMessage=\u0026lt;p\u0026gt;Welcome, User!\u0026lt;/p\u0026gt;; const loginMessage=\u0026lt;p\u0026gt;Please log in\u0026lt;/p\u0026gt;; return ( \u0026lt;div\u0026gt; {isLoggedIn ? welcomeMessage : loginMessage} \u0026lt;/div\u0026gt; ); } 20.2. Logical \u0026amp;\u0026amp; Operator The logical \u0026amp;\u0026amp; operator is another way to conditionally render elements in React. The \u0026amp;\u0026amp; operator works by evaluating the expression on the left side of the \u0026amp;\u0026amp; operator. If the expression is true, the expression on the right side of the \u0026amp;\u0026amp; operator is executed. If the expression is false, the right side is not executed.\nExample:\nfunction App() { const isLoggedIn = true; return ( \u0026lt;div\u0026gt; {isLoggedIn \u0026amp;\u0026amp; \u0026lt;p\u0026gt;Welcome, User!\u0026lt;/p\u0026gt;} {isLoggedIn \u0026amp;\u0026amp; \u0026lt;button\u0026gt;Logout\u0026lt;/button\u0026gt;} {!isLoggedIn \u0026amp;\u0026amp; \u0026lt;p\u0026gt;Please log in\u0026lt;/p\u0026gt;} \u0026lt;/div\u0026gt; ); } Also We can write jsx code in variable and use it in return statement\nfunction App() { const isLoggedIn = true; const welcomeMessage=\u0026lt;p\u0026gt;Welcome, User!\u0026lt;/p\u0026gt;; const logoutButton=\u0026lt;button\u0026gt;Logout\u0026lt;/button\u0026gt;; const loginMessage=\u0026lt;p\u0026gt;Please log in\u0026lt;/p\u0026gt;; return ( \u0026lt;div\u0026gt; {isLoggedIn \u0026amp;\u0026amp; welcomeMessage} {isLoggedIn \u0026amp;\u0026amp; logoutButton} {!isLoggedIn \u0026amp;\u0026amp; loginMessage} \u0026lt;/div\u0026gt; ); } 21.Outputting list data dynamically In react we use map function to output list data dynamically as using map.\n21.1. Have a list of data You typically store the list in an array, which might come from a state, props, or external data source like an API\nconst data = [ { id: 1, name: \u0026#34;John\u0026#34; }, { id: 2, name: \u0026#34;Doe\u0026#34; }, { id: 3, name: \u0026#34;Jane\u0026#34; }, ]; 21.2 Using map function to output list data const listItems = data.map((item) =\u0026gt; \u0026lt;li key={item.id}\u0026gt;{item.name}\u0026lt;/li\u0026gt;); Key is used to uniquely identify each element in the list. It helps React identify which items have changed, are added, or are removed.It can be number or string.\n21.3. Rendering the list Use {} to embed the transformed list inside your component’s JSX.\n\u0026lt;ul\u0026gt;{listItems}\u0026lt;/ul\u0026gt;; 21.4. Putting it all together function App() { const data = [ { id: 1, name: \u0026#34;John\u0026#34; }, { id: 2, name: \u0026#34;Doe\u0026#34; }, { id: 3, name: \u0026#34;Jane\u0026#34; }, ]; const listItems = data.map((item) =\u0026gt; \u0026lt;li key={item.id}\u0026gt;{item.name}\u0026lt;/li\u0026gt;); return \u0026lt;ul\u0026gt;{listItems}\u0026lt;/ul\u0026gt;; } 21.5 Another form function App() { const data = [ { id: 1, name: \u0026#34;John\u0026#34; }, { id: 2, name: \u0026#34;Doe\u0026#34; }, { id: 3, name: \u0026#34;Jane\u0026#34; }, ]; return \u0026lt;ul\u0026gt;{data.map((item) =\u0026gt; \u0026lt;li key={item.id}\u0026gt;{item.name}\u0026lt;/li\u0026gt;); }\u0026lt;/ul\u0026gt;; } When will Rerender Occur?\nWhen state varaible or props value changes ","permalink":"http://localhost:1313/posts/pages/react/react1/","summary":"A detailed guide to help you understand and use hooks in React effectively.","title":"React : Day 2"},{"content":"Python Fundamentals: Exploring Advanced Operations (Part 4) In Python programming, advanced operations allow you to perform complex tasks efficiently. These operations include working with ranges, enumerations, zip functions, and more. In this guide, we will explore various advanced operations in Python to enhance your programming skills.\n1. Ranges Ranges in Python are used to generate a sequence of numbers. They are commonly used in loops to iterate over a specific range of values. Ranges can be created using the range() function.\n1.1. Creating a Range To create a range of numbers, you can use the range() function with the desired start, stop, and step values where start number is in inclusive and stop number is exclusive.\nExample:\n# Generate a range of numbers from 0 to 9 for i in range(10): print(i) Output:\n0\r1\r2\r3\r4\r5\r6\r7\r8\r9 Example:\n# Generate a range of numbers from 1 to 10 with a step of 2 for i in range(0, 10,2): print(i) Output:\n0\r2\r4\r6\r8 1.2 Enumerate Function The enumerate() function in Python is used to iterate over a sequence while keeping track of the index and value of each item. It returns a tuple containing the index and the value of the item.\nExample:\n# Enumerate a list of fruits fruits = [\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;cherry\u0026#39;] for index, fruit in enumerate(fruits): print(index, fruit) Output:\n0 apple\r1 banana\r2 cherry Example:\na=\u0026#34;nirajan\u0026#34; for index, char in enumerate(a): print(index, char) Output:\n0 n\r1 i\r2 r\r3 a\r4 j\r5 a\r6 n 1.3. Zip Function The zip() function in Python is used to combine multiple iterables (such as lists) element-wise. It returns an iterator of tuples where the i-th tuple contains the i-th element from each of the input iterables.\nExample:\n# Zip two lists together names = [\u0026#39;Alice\u0026#39;, \u0026#39;Bob\u0026#39;, \u0026#39;Charlie\u0026#39;] ages = [25, 30, 35] for name, age in zip(names, ages): print(name, age) Output:\nAlice 25\rBob 30\rCharlie 35 Example:\na=[1,2,3] b=[4,5,6] c=[7,8,9] print(list(zip(a,b,c))) Output:\n[(1, 4, 7), (2, 5, 8), (3, 6, 9)] 1.5 Sorted Function The sorted() function in Python is used to sort a list of elements. It returns a new sorted list without modifying the original list.The main feature of the sorted() function is that it can take a key argument that specifies a function to be called on each list element prior to making comparisons.\nExample:\n# Sort a list of numbers numbers = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5] sorted_numbers = sorted(numbers) print(sorted_numbers) Output:\n[1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] Example:\n# Sort a list of strings based on the length of the string fruits = [\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;cherry\u0026#39;, \u0026#39;date\u0026#39;] sorted_fruits = sorted(fruits, key=len) print(sorted_fruits) Output:\n[\u0026#39;date\u0026#39;, \u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;cherry\u0026#39;] Example:\n#Sort an dictionary based on the value d = {\u0026#39;apple\u0026#39;: 10, \u0026#39;banana\u0026#39;: 5, \u0026#39;cherry\u0026#39;: 15} sorted_d = sorted(d.items(), key=lambda x: x[1]) print(sorted_d) Output:\n[(\u0026#39;banana\u0026#39;, 5), (\u0026#39;apple\u0026#39;, 10), (\u0026#39;cherry\u0026#39;, 15)] Example:\n#Sort a list of tuples based on the second element t = [(1, 2), (3, 1), (5, 6)] sorted_t = sorted(t, key=lambda x: x[1]) print(sorted_t) Output:\n[(3, 1), (1, 2), (5, 6)] #2. Import in Python In Python, the import statement is used to import modules or packages into your script. It allows you to use functions, classes, and variables defined in other modules in your code.\n2.1. Importing Modules To import a module in Python, you can use the import keyword followed by the module name. You can then access the functions, classes, and variables defined in the module using dot notation.\nExample:\n# Import the math module import math # Calculate the square root of a number x = 16 print(math.sqrt(x)) Output:\n4.0 Example:\n# Import the datetime module import datetime # Get the current date and time now = datetime.datetime.now() print(now) Output:\n2024-11-17 10:30:00 2.2. Importing Specific Functions You can import specific functions or variables from a module using the from keyword. This allows you to use the imported functions directly without using the module name.\nExample:\n# Import the pi constant from the math module from math import pi # Print the value of pi print(pi) Output:\n3.141592653589793 Example:\n# Import the date class from the datetime module from datetime import date # Get the current date today = date.today() print(today) Output:\n2024-11-17 2.3. Aliasing Modules You can alias a module or package by using the as keyword. This allows you to refer to the module by a different name in your code.\nExample:\n# Import the math module and alias it as m import math as m # Calculate the square root of a number x = 25 print(m.sqrt(x)) Output:\n5.0 Example:\n# Import the datetime module using import and from and alias it as dt from datetime import datetime as dt now = dt.now() print(now) Output:\n2024-11-17 10:30:00 2.4. Importing All Functions You can import all functions and variables from a module using the * operator. This imports all the functions and variables defined in the module.\nExample:\n# Import all functions from the math module from math import * # Calculate the square root of a number x = 36 print(sqrt(x)) Output:\n6.0 The General Syntax is\nfrom module_name.submodule_name.submodule_name... import funtion_name or variable_name or filename as alias_name\nrandom module The random module in Python is used to generate random numbers. It provides various functions to generate random integers, floating-point numbers, and sequences.\n1. Generating Random Numbers The random module provides functions to generate random numbers within a specified range which can contain both integers starting and ending number.\nExample:\nfrom random import randint # Generate a random integer between 1 and 10 random_number = randint(1, 10) print(random_number) Output:\n5 2.Shuffling a List The random module provides a function to shuffle the elements of a list randomly. It modifies the original list in place.\nExample:\nfrom random import shuffle # Shuffle a list of numbers numbers = [1, 2, 3, 4, 5] shuffle(numbers) print(numbers) Output:\n[3, 1, 5, 2, 4] ","permalink":"http://localhost:1313/posts/pages/python/python_advanced_operations/","summary":"An in-depth exploration of advanced Python operations to enhance your programming skills.","title":"Python Fundamentals: Exploring Advanced Operations (Part 4)"},{"content":"Python Fundamentals: Understanding Functions In Python programming, functions are essential building blocks that allow you to organize and reuse code effectively. Functions help break down complex problems into smaller, manageable tasks, making your code more readable and maintainable. In this guide, we will explore the fundamentals of Python functions, including their syntax, parameters, return values, and more.\n1. Defining Functions A function in Python is defined using the def keyword followed by the function name and parentheses. You can also specify parameters inside the parentheses if the function requires input values.\nSyntax:\ndef function_name(parameters): # Function body # Statements Example:\ndef greet(): print(\u0026#34;Hello, World!\u0026#34;) 2. Calling Functions To call a function in Python, you simply write the function name followed by parentheses. If the function requires input values, you can pass them inside the parentheses.\nSyntax:\nfunction_name(arguments) Example:\ngreet() 3. return Statement The return statement in Python is used to exit a function and return a value to the caller. You can use the return statement to send a result back to the calling code.\nSyntax:\ndef function_name(parameters): # Function body return value Demostration using all:\ndef add_numbers(a, b): return a + b result = add_numbers(5, 3) print(result) 4. Args , Default Args and Kwargs 4.1. Args Using Args you can pass any number of arguments to a function. The arguments are passed as a tuple.\nSyntax:\ndef function_name(*args): # Function body Example:\ndef display_args(*args): print(args) display_args(1, 2, 3, 4, 5) Output:\n(1, 2, 3, 4, 5) 4.2. Default Args Default arguments are used when you do not pass a value for an argument in the function call. If a value is not provided, the default value is used.\nSyntax:\ndef function_name(arg=value): # Function body Example:\ndef add(a,b,c=0): return a+b+c result = add(5,3) print(result) result = add(5,3,2) print(result) Output:\n8\r10 4.3. Kwargs Using Kwargs you can pass any number of keyword arguments to a function. The arguments are passed as a dictionary.\nSyntax:\ndef function_name(**kwargs): # Function body Example:\ndef display_kwargs(**kwargs): print(kwargs) display_kwargs(name=\u0026#34;Alice\u0026#34;, age=30, city=\u0026#34;New York\u0026#34;) Output:\n{\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 30, \u0026#39;city\u0026#39;: \u0026#39;New York\u0026#39;} 4.4. Combination of Args and Kwargs Example:\ndef display_args_kwargs(*args, **kwargs): print(args) print(kwargs) display_args_kwargs(1, 2, 3, name=\u0026#34;Alice\u0026#34;, age=30) Output:\n(1, 2, 3)\r{\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 30} 4.5. Unpacking Args and Kwargs Example:\ndef display_args_kwargs(*args, **kwargs): print(args) print(kwargs) args = (1, 2, 3) kwargs = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30} display_args_kwargs(*args, **kwargs) Output:\n(1, 2, 3)\r{\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 30} 5. Lambda Functions Lambda functions, also known as anonymous functions, are small, single-expression functions that do not require a name. They are defined using the lambda keyword.\nSyntax:\nlambda arguments: expression Example:\nadd = lambda a, b: a + b result = add(5, 3) print(result) Output:\n8 6.Map and filter functions 6.1. Map Function The map() function in Python applies a given function to each item of an iterable (such as a list, tuple, or set) and returns a new iterable with the results.\nSyntax:\nmap(function, iterable) Example:\nnumbers = [1, 2, 3, 4, 5] squared = map(lambda x: x ** 2, numbers) print(list(squared)) Output:\n[1, 4, 9, 16, 25] 6.2. Filter Function The filter() function in Python filters elements from an iterable based on a given function. It returns an iterator with the elements that satisfy the condition.\nSyntax:\nfilter(function, iterable) Example:\nnumbers = [1, 2, 3, 4, 5] even = filter(lambda x: x % 2 == 0, numbers) print(list(even)) Output:\n[2, 4] 7.Local and Global Variables 7.1. Local Variables Local variables are defined within a function and are only accessible within that function. They are created when the function is called and destroyed when the function exits.\nExample:\ndef display(): message = \u0026#34;Hello, World!\u0026#34; print(message) display() # Trying to access the local variable outside the function will result in an error print(message) # NameError: name \u0026#39;message\u0026#39; is not defined 7.2. Global Variables Global variables are defined outside any function and can be accessed from any part of the code. You can use the global keyword to modify a global variable inside a function.\nExample:\nmessage = \u0026#34;Hello, World!\u0026#34; def display(): print(message) display() # Modifying a global variable inside a function def change_message(): global message message = \u0026#34;Hello, Python!\u0026#34; change_message() print(message) Output:\nHello, World!\rHello, Python! 7.3. Local vs. Global Variables If a local variable has the same name as a global variable, the local variable takes precedence within the function scope.\nExample:\nmessage = \u0026#34;Hello, World!\u0026#34; def display(): message = \u0026#34;Hello, Python!\u0026#34; print(message) display() print(message) Output:\nHello, Python!\rHello, World! ","permalink":"http://localhost:1313/posts/pages/python/python_function/","summary":"An in-depth exploration of Python functions, their usage, and importance in programming.","title":"Python Fundamentals: Understanding Functions (Part 5)"},{"content":"1. Create A React Project To create a React app we use Vite and its command is:\nnpm create vite@latest 2. Component In a React application, one page is broken down into multiple components. Components allow:\nReusability: For example, we can create one component for cards and use it to create multiple cards with different data. Related code lives together: Related items (JS code) are stored together. Separation of logic: Different components handle different data and logic. Diagram 3. Folder Structure my-app/\r├─ node_modules/\r├─ public/\r│ ├─ index.html\r│ ├─ image.png\r│ └─ favicon.ico\r├─ src/\r│ ├─ index.js\r│ ├─ App.js\r│ ├─ App.css\r│ └─ index.css\r├─ package.json\r└─ README.md node_module: Contains all the files of installed packages.\npublic: All static files are kept in this folder. For example, if image.png is in public, we can access it in the browser as 127.0.0.1:8000/image.png.\nindex.html: It is the page that is served to us and its content is managed by React using the DOM.Modify this file if you want to change the title or favicon.\npackage.json: Contains all the configuration of the project, package list, versions, and all related information.\nsrc: This is the folder where all the code is written.\nsrc/index.js React runs this file first.Code of index.js\nThe DOM selects the element of index.html whose id is root because of this code: document.getElementById('root') Then render() renders the \u0026lt;App/\u0026gt; component so that the root element will contain the data of the \u0026lt;App/\u0026gt; component. All changes are done in the index.html root element using the DOM. Remember that we never edit this file (code). src/App.js : This is where we will write all the SPA code. We start coding from App.jsx and link components as required.\nsrc/index.css : This CSS file is used by main.jsx, so it applies to the whole page. You can remove it if needed by removing its import in main.jsx.\n*** src/App.css:*** This CSS file is used by App.jsx, so it applies to all App components.\nRemember: Component functions must follow two rules:\nThe name should start with an uppercase letter (e.g., Head, MyHead). The function must return renderable content. The function must return a value that can be rendered (displayed on screen) by React. In most cases, return JSX. Example of a simple component:\nfunction App() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Hello world\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ); } As we know, App.jsx is provided by default when we create a React app. We can modify it and tailor it to our requirements\n4. Making Custom Components function FunctionName() { return ( \u0026lt;tagname\u0026gt; content \u0026lt;/tagname\u0026gt; ); } Important Note:\nTags that don\u0026rsquo;t have ending tags, such as \u0026lt;br\u0026gt; and \u0026lt;hr\u0026gt;, should be written as \u0026lt;br/\u0026gt; and \u0026lt;hr/\u0026gt;. class is replaced by className. For example, \u0026lt;body class=\u0026quot;data\u0026quot;\u0026gt; is written as \u0026lt;body className=\u0026quot;data\u0026quot;\u0026gt;. During a return in React, we cannot return multiple elements directly. Instead, we need to wrap them inside a single parent element like \u0026lt;div\u0026gt;, \u0026lt;\u0026gt;\u0026lt;/\u0026gt;. For Example :\nWrong Way: function component1() { return ( \u0026lt;div\u0026gt; Hi \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; Hello \u0026lt;/div\u0026gt; ); } right way: function component1() { return ( \u0026lt;div\u0026gt; {/* or \u0026lt;\u0026gt; */} \u0026lt;div\u0026gt; Hi \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; Hello \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; {/* or \u0026lt;/\u0026gt; */} ); } 5.Using One Component Inside Another Component To use one component inside another in React, follow the steps\nCreate a component. function Comp1() { return \u0026lt;div\u0026gt; Component \u0026lt;/div\u0026gt; } Use the component inside another component. function Comp2() { return ( \u0026lt;div\u0026gt; \u0026lt;Comp1 /\u0026gt; or \u0026lt;Comp1\u0026gt; \u0026lt;Comp1 /\u0026gt; content \u0026lt;/div\u0026gt; ) } Here, Comp1 is used inside Comp2.We can use Comp1 multiple times inside Comp2 as needed. Note: For proper management, create a components folder, create one file for each component, and export from there. Then, import and use it in another component.\nExample structure:\nsrc/\r├─ Assets/\r├─ App.jsx\r└─ Components/\r├─ Comp1.jsx\r└─ Comp2.jsx Task: Break Down a Component into Multiple Components\nfunction App() { return ( \u0026lt;\u0026gt; \u0026lt;header\u0026gt; I am header \u0026lt;/header\u0026gt; \u0026lt;main\u0026gt; I am main content \u0026lt;/main\u0026gt; \u0026lt;footer\u0026gt; I am footer \u0026lt;/footer\u0026gt; \u0026lt;/\u0026gt; ); } Solution: components/Header.jsx\nfunction Header() { return ( \u0026lt;header\u0026gt; I am header \u0026lt;/header\u0026gt; ); } export default Header; components/Footer.jsx\nfunction Footer() { return ( \u0026lt;footer\u0026gt; I am footer \u0026lt;/footer\u0026gt; ); } export default Footer; Finally, App.jsx\nimport Header from \u0026#39;./components/Header\u0026#39;; import Footer from \u0026#39;./components/Footer\u0026#39;; function App() { return ( \u0026lt;\u0026gt; \u0026lt;Header /\u0026gt; \u0026lt;main\u0026gt; I am main content \u0026lt;/main\u0026gt; \u0026lt;Footer /\u0026gt; \u0026lt;/\u0026gt; ); } export default App; structure:\nsrc/\r├─ Assets/\r├─ App.jsx\r└─ components/\r├─ Header.jsx\r└─ Footer.jsx Note: You Can Always break down a component as many times as you want. The main goal is to make the code more readable and maintainable.\n6. Some Component Hierarchies Examples THis is the simple example of a component hierarchy. 7. Embedding JavaScript code in JSX In JSX, we can embed JavaScript code using curly braces {}. We can write any JavaScript code inside the curly braces. For example, we can write a variable, function, or any JavaScript expression but of single line.\nfunction componentName() { return ( \u0026lt;div\u0026gt; { JavaScript code } \u0026lt;/div\u0026gt; ); } Example:\nfunction App() { const name = \u0026#39;John Doe\u0026#39;; return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt; Hello, {name} \u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ); } Where To Write Javascript Logic?\nWe can write JavaScript logic inside the component function. We can write JavaScript logic outside the component function and use it inside the component function. 7.1 Using JavaScript Logic Outside Component Function syntax:\n// Multiple lines of JavaScript code function ComponentName() { return ( \u0026lt;div\u0026gt; {/* JSX code */} \u0026lt;/div\u0026gt; ); } 7.2 Using JavaScript Logic Inside Component Function syntax:\nfunction ComponentName() { // Multiple lines of JavaScript code return ( \u0026lt;div\u0026gt; {/* JSX code */} \u0026lt;/div\u0026gt; ); } When to use Inside Component Function Outside Component Function Use Case When the logic is specific to the component and not used anywhere else. When the logic is used in multiple components. Advantages Logic is specific to the component. Logic can be reused in multiple components. Disadvantages Logic cannot be reused in other components. Logic is not specific to the component. Combined Example Task1: Create a component that generate random number between 1 to 10 and display in every page reload\nfunction RandomNumber(){ return \u0026lt;\u0026gt; \u0026lt;h1\u0026gt;Random Number: {Math.floor(Math.random() * 10) + 1}\u0026lt;/h1\u0026gt; } export default RandomNumber; This can be done in another ways which is more readable and maintainable\nfunction RandomNumber(){ const randomNumber = Math.floor(Math.random() * 10) + 1; return \u0026lt;h1\u0026gt;Random Number: {randomNumber}\u0026lt;/h1\u0026gt; } export default RandomNumber; Task2 : Create a component that generate random element from an array and display on each page reload\nconst elements = [\u0026#39;Earth\u0026#39;, \u0026#39;Water\u0026#39;, \u0026#39;Fire\u0026#39;, \u0026#39;Air\u0026#39;]; function generateRandomElement(){ return elements[Math.floor(Math.random() * elements.length)]; } function RandomElement(){ const randomElement = generateRandomElement(); return \u0026lt;h1\u0026gt;Random Element: {randomElement}\u0026lt;/h1\u0026gt; } export default RandomElement; This can be done by putting the logic inside the component function\nconst elements = [\u0026#39;Earth\u0026#39;, \u0026#39;Water\u0026#39;, \u0026#39;Fire\u0026#39;, \u0026#39;Air\u0026#39;]; function generateRandomElement(){ return elements[Math.floor(Math.random() * elements.length)]; } function RandomElement(){ const randomElement = elements[Math.floor(Math.random() * elements.length)]; return \u0026lt;h1\u0026gt;Random Element: {randomElement}\u0026lt;/h1\u0026gt; } export default RandomElement; The most optimal way is using this\nconst elements = [\u0026#39;Earth\u0026#39;, \u0026#39;Water\u0026#39;, \u0026#39;Fire\u0026#39;, \u0026#39;Air\u0026#39;]; function RandomElement(){ const randomElement = elements[Math.floor(Math.random() * elements.length)]; return \u0026lt;h1\u0026gt;Random Element: {randomElement}\u0026lt;/h1\u0026gt; } export default RandomElement; 8.Loading Images in React step 1: put the images in assets folder that need to be loaded step 2: import the image in the component where it is needed as shown below import imageName from Location Note: Location is the path of the image from the current file location and imageName can be set to any name\nstep 3: use the image in the component as shown below \u0026lt;img src={imageName} alt=\u0026#34;description\u0026#34; /\u0026gt; Note: imageName is the location of the image as src/Assets/logo.png\nTask: Load an image in a Header component with the image name logo.png and description logo. structure:\nsrc/\r├─ Assets/\r└─ logo.png\r├─ App.jsx\r└─ components/\r├─ Header.jsx import logo from \u0026#39;../Assets/logo.png\u0026#39;; function Header() { return ( \u0026lt;header\u0026gt; \u0026lt;img src={logo} alt=\u0026#34;logo\u0026#34; /\u0026gt; \u0026lt;/header\u0026gt; ); } 9.Importing CSS in React step 1: create a css file in the src folder step 2: import the css file in the component where it is needed as shown below import cssfileLocation Note: style.css is the name of the css file\nfor example:\nimport \u0026#39;./style.css\u0026#39; function App() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt; Hello world \u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ); } 9.1 Managing CSS in React Create css file in same directory as of your component src/ ├─ App.jsx └─ components/ ├─ Header.jsx └─ Header.css -Import the css file in the component where it is needed as shown below\r```jsx\rimport \u0026#39;./Header.css\u0026#39; 10.Props in React Props are used to pass data from parent component to child component. It is used to reuse the same component with different data. Props are passed as attributes to the component. Prop accept any type of value like string, number, array, object, function,compenent,jsx bool etc. 10.1 Passing Props from Parent to Child Component Parent Component function ParentComponent() { return ( \u0026lt;ChildComponent prop1={value1} prop2={value2} /\u0026gt; ); } 10.2 Receiving Props in Child Component Child Component function ChildComponent(props) { console.log(props); // will print object of props {prop1: value1, prop2:value2} return ( \u0026lt;\u0026gt; {props.prop1} {props.prop2} \u0026lt;/\u0026gt; ); } This approach is not recommended because it is not clear what props are being passed to the component. Instead, we can destructure the props as shown below.\n10.3 Destructuring Props Child Component function ChildComponent({prop1, prop2}) { return ( \u0026lt;\u0026gt; {prop1} {prop2} \u0026lt;/\u0026gt; ); } Task: Create a card cmponent and use multiple cards in the App component to make card section\nfunction Card({title, description, image}) { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;{title}\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;{description}\u0026lt;/p\u0026gt; \u0026lt;img src={image} alt=\u0026#34;description\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; ); } export default Card; import Card from \u0026#39;./components/Card\u0026#39;; function App() { return ( \u0026lt;div\u0026gt; \u0026lt;Card title=\u0026#34;Card 1\u0026#34; description=\u0026#34;This is card 1\u0026#34; image={image1} /\u0026gt; \u0026lt;Card title=\u0026#34;Card 2\u0026#34; description=\u0026#34;This is card 2\u0026#34; image={image2} /\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; 11. Children Props in React Children props are used to pass data between opening and closing tags of a component. 11.1 Passing Children Props Parent Component function ParentComponent() { return ( \u0026lt;ChildComponent\u0026gt; \u0026lt;h1\u0026gt; Hello \u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt; World \u0026lt;/p\u0026gt; \u0026lt;/ChildComponent\u0026gt; ); } 11.2 Receiving Children Props Child Component function ChildComponent({ children }) { return ( \u0026lt;div\u0026gt; {children} \u0026lt;/div\u0026gt; ); } 11.3 Output \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt; Hello \u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt; World \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; 12.Using Props and Children Props Together Task: Create a card component that accepts title, description, and children props. Use the card component in the App component to make a card section.\nfunction Card({ title, description, children }) { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;{title}\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;{description}\u0026lt;/p\u0026gt; {children} \u0026lt;/div\u0026gt; ); } export default Card; import Card from \u0026#39;./components/Card\u0026#39;; function App() { return ( \u0026lt;div\u0026gt; \u0026lt;Card title=\u0026#34;Card 1\u0026#34; description=\u0026#34;This is card 1\u0026#34;\u0026gt; \u0026lt;h1\u0026gt; Hello \u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt; World \u0026lt;/p\u0026gt; \u0026lt;/Card\u0026gt; \u0026lt;Card title=\u0026#34;Card 2\u0026#34; description=\u0026#34;This is card 2\u0026#34;\u0026gt; \u0026lt;h1\u0026gt; Hello \u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt; World \u0026lt;/p\u0026gt; \u0026lt;/Card\u0026gt; \u0026lt;/div\u0026gt; ); } 13. Making a Button Component 13.1 Using Props function App() { return ( \u0026lt;div\u0026gt; \u0026lt;Button text=\u0026#34;Click me\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; ); } function Button({ text}) { return ( \u0026lt;button\u0026gt; {text} \u0026lt;/button\u0026gt; ); } export default Button; 13.2 Using Children Props function App() { return ( \u0026lt;div\u0026gt; \u0026lt;Button\u0026gt;Click me\u0026lt;/Button\u0026gt; \u0026lt;/div\u0026gt; ); } function Button({ children }) { return ( \u0026lt;button\u0026gt; {children} \u0026lt;/button\u0026gt; ); } export default Button; 14. Reacting to Events In React, we can add event listeners like onClick, onMouseOver, onMouseOut, etc to buildin components lie button, div, etc using syntax \u0026lt;InbuiltComponent eventlistener={functionName} /\u0026gt; Note: functionName is the name of the function that will be called when the event is triggered.\nThere are Many eventlisteners that can be used in React like onClick, onMouseOver, onMouseOut etc.\nYou can check the full list of event listeners in the React documentation also note that the event listener will always start with on followed by the event name.\nWe can call the handle function in two ways:\n14.1 The First Way function App() { function handleClick() { console.log(\u0026#39;Button clicked\u0026#39;); } return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={handleClick}\u0026gt;Click me\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 14.2 The Second Way function App() { return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={() =\u0026gt; {console.log(\u0026#39;Button clicked\u0026#39;)}}\u0026gt;Click me\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 15. Event Listeners in Custom Components since by default when we add event listeners to custom component it doesnot work just because it is passed as prop but on simple tweaking we can make it work\nDesign Pattern for applying event listeners in custom components\nfunction App(){ function handleClick(){ console.log(\u0026#39;Button clicked\u0026#39;); } return ( \u0026lt;div\u0026gt; \u0026lt;Button onClick={handleClick} /\u0026gt; \u0026lt;/div\u0026gt; ); } The onclick method is passed as a prop to the button component and then used in the button component as shown below\nfunction Button({onClick}){ return ( \u0026lt;button onClick={onClick}\u0026gt;Click me\u0026lt;/button\u0026gt; ); } 16. Passing Arguments to Event Functions To pass Custom arguments to event functions, we can use the arrow function syntax as shown below \u0026lt;inbuildComponent eventListener={() =\u0026gt; functionName(argument)} /\u0026gt; Example function App() { function handleClick(name) { console.log(\u0026#39;Button clicked by\u0026#39;, name); } return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={() =\u0026gt; handleClick(\u0026#39;John\u0026#39;)}\u0026gt;Click me\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } ","permalink":"http://localhost:1313/posts/pages/react/react/","summary":"A detailed reference guide to help you quickly set up and manage React projects, components, and folder structures.","title":"React : Day 1"},{"content":"Python Fundamentals: Understanding Error Handling In Python programming, error handling is an essential concept that allows you to gracefully manage exceptions and errors that may occur during program execution. By handling errors effectively, you can prevent your program from crashing and provide meaningful feedback to users. In this guide, we will explore the fundamentals of error handling in Python, including exceptions, try-except blocks, and best practices.\n1. Exceptions In Python, exceptions are events that occur during the execution of a program that disrupt the normal flow of code. When an exception occurs, the interpreter raises an exception object that can be caught and handled by the program. Exceptions can be caused by various reasons, such as invalid input, file not found, or division by zero.\n2.What May Cause Exceptions Exceptions can be caused by various reasons, such as:\nDivision by zero Invalid input File not found Syntax errors Out of Index of list, tuple , String Key Error in dictionary 3.Types of Exceptions Commonly used exceptions in Python include:\nZeroDivisionError: Raised when division or modulo by zero occurs. ValueError: Raised when a function receives an argument of the correct type but an inappropriate value. TypeError: Raised when an operation or function is applied to an object of an inappropriate type. IndexError: Raised when a sequence subscript is out of range. KeyError: Raised when a dictionary key is not found. SyntaxError: Raised when the parser encounters a syntax error. Note: All exceptions in Python are subclasses of the Exception class.\n3.Handling Exceptions To handle exceptions in Python, you can use the try-except block, which allows you to catch and handle exceptions gracefully. The try block contains the code that may raise an exception, and the except block handles the exception if it occurs.The program control will transfer the control to the except block if any exception occurs in the try block but if there is not exception then the control will not transfer to the except block.\n4.1. Using try-except Block Here\u0026rsquo;s an example of using the try-except block to handle exceptions in Python:\nsyntax:\ntry: # Code that may raise an exception except ExceptionType as e: # Handle the exception Example:\ntry: x = 10 / 0 except Exception as e: print(\u0026#34;Error: Division by zero\u0026#34;) Output:\nError: Division by zero Note: if you don\u0026rsquo;t know the type of exception you can use Exception to catch all exceptions.\nIf you dont handel exception then it will show error and stop the program.\n4.2. Finally Block The finally block is used to execute code that should always run, regardless of whether an exception occurs or not. The finally block is typically used to release resources or clean up operations that need to be performed after the try block, regardless of the outcome Any how the finally block will run. if yout return from the try block then also the finally block will run.\nsyntax:\ntry: # Code that may raise an exception except ExceptionType as e: # Handle the exception finally: # Code that always runs Example:\ntry: x = 10 / 0 except Exception as e: print(\u0026#34;Error: Division by zero\u0026#34;) finally: print(\u0026#34;Cleanup code\u0026#34;) Output:\nError: Division by zero\rCleanup code 3.5. Raising Exceptions You can raise exceptions in Python using the raise statement. This allows you to create custom exceptions and raise them when needed. You can also raise built-in exceptions to indicate errors or exceptional conditions.\nsyntax:\nraise ExceptionType(\u0026#34;Error message\u0026#34;) Example:\nx = -1 if x \u0026lt; 0: raise ValueError(\u0026#34;Value cannot be negative\u0026#34;) Output:\nValueError: Value cannot be negative 3.6. Multiple except Blocks You can use multiple except blocks to handle different types of exceptions in Python. This allows you to catch and handle specific exceptions based on their type.\nsyntax:\ntry: # Code that may raise an exception except ExceptionType1 as e: # Handle ExceptionType1 except ExceptionType2 as e: # Handle ExceptionType2 Example:\ntry: x = 10 / 0 except ZeroDivisionError as e: print(\u0026#34;Error: Division by zero\u0026#34;) except ValueError as e: print(\u0026#34;Error: Invalid value\u0026#34;) Output:\nError: Division by zero 3.7. Custom Exceptions You can create custom exceptions in Python by defining a new exception class that inherits from the Exception class. Custom exceptions allow you to define specific error conditions for your application and raise them when needed.\nsyntax:\nclass CustomException(Exception): pass Example:\n#Will read about class in oop section class CustomError(Exception): def __init__(self,message,value): self.message=message self.value=value def __str__(self): return f\u0026#34;{self.message}\\nError code:{self.value}\u0026#34; try: x = -1 if x \u0026lt; 0: raise CustomError(\u0026#34;Value cannot be negative\u0026#34;,1001) except CustomError as e: print(e) Note: Custom exceptions should inherit from the Exception class or one of its subclasses. You can simply use:\ntry: #code except: #code try: #code except Exception as e: #code try: #code except Exception: #code try: #code except: #code finally: #code ","permalink":"http://localhost:1313/posts/pages/python/python_error_handeling/","summary":"An in-depth exploration of Python error handling, exceptions, and best practices.","title":"Python Fundamentals: Understanding Error Handling (Part 6)"},{"content":"Python Fundamentals: Packages, Generators, and Decorators In this guide, we will explore advanced Python topics including packages, generators, and decorators. These concepts are essential for writing efficient and maintainable Python code. Let\u0026rsquo;s dive in!\n1. Python Packages Python packages are a way of organizing and structuring your code into reusable modules. Packages allow you to group related modules together, making it easier to manage and maintain your codebase. In this section, we will explore how to create and use Python packages.\n1.1. Creating a Package To create a Python package, you need to organize your code into a directory structure with a special file called __init__.py. This file tells Python that the directory is a package and allows you to import modules from the package.\nExample directory structure:\nmy_package/\r│\r├── __init__.py\r├── module1.py\r└── module2.py 1.2. Using a Package To use a Python package, you can import modules from the package using the import statement. You can import specific modules or the entire package.\nExample:\n# Importing a specific module from my_package import module1 # Using a function from the imported module module1.my_function() # Importing the entire package import my_package # Using a function from a module within the package my_package.module2.another_function() #Importing Function from a module from my_package.module1 import my_function my_function() Note : init.py file can be empty or contain initialization code for the package. It will automatically run when the package is imported.\n1.3 Creating a Subpackage You can create subpackages within a package to further organize your code. Subpackages are simply packages within packages, allowing you to create a hierarchical structure for your codebase.\nExample directory structure:\nmy_package/\r│\r├── __init__.py\r├── module1.py\r└── subpackage/\r├── __init__.py\r├── module3.py\r└── module4.py 1.4. Using a Subpackage To use a subpackage, you can import modules from the subpackage using the dot notation.\nExample:\n# Importing a module from a subpackage from my_package.subpackage import module3 # Using a function from the imported module module3.another_function() # Importing the entire subpackage import my_package.subpackage # Using a function from a module within the subpackage my_package.subpackage.module4.some_function() #Importing Function from a module from my_package.subpackage.module3 import another_function another_function() 1.5. name == \u0026ldquo;main\u0026rdquo; We use the __name__ variable to check if a script is being run as the main program or being imported as a module. When a script is run as the main program, __name__ is set to \u0026quot;__main__\u0026quot;. This allows you to include code that should only run when the script is executed directly.\nFor Example:\nStructure:\nMain Directory/\r├── main.py\r└── package/\r├── __init__.py\r└── module1.py module1.py:\ndef my_function(): print(\u0026#34;Hello from module1\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: my_function() When you run module1.py directly, the my_function() will be executed. However, if you import module1 into another script, the my_function() will not be executed.\nFor Example:\nfrom package import module1 print(\u0026#34;Imported module1\u0026#34;) Output:\nImported module1 When use Dont use if __name__ == \u0026quot;__main__\u0026quot;: in module1.py:\ndef my_function(): print(\u0026#34;Hello from module1\u0026#34;) my_function() also,\nfrom package import module1 print(\u0026#34;Imported module1\u0026#34;) Output:\nHello from module1\rImported module1 2. Python Generators Using generator we can instantly return all the values using the yield keyword without storing them in memory. This is useful when working with large datasets or infinite sequences.\n2.1. Creating a Generator To create a generator in Python, you can use a function with the yield keyword. When a function contains the yield keyword, it becomes a generator function. The yield keyword suspends the function\u0026rsquo;s execution and returns a value to the caller.\nExample:\ndef my_generator(): yield 1 yield 2 yield 3 # Using the generator gen = my_generator() print(next(gen)) # Output: 1 print(next(gen)) # Output: 2 print(next(gen)) # Output: 3 Example:\n#using generator in loop def generate(n): for i in range(n): yield i for i in generate(10): print(i) 3. Python Decorators Decorators are a powerful feature in Python that allows you to modify or extend the behavior of functions or methods. Decorators are functions that take another function as an argument and return a new function that extends the behavior of the original function.\n3.1. Creating a Decorator To create a decorator in Python, you can define a function that takes another function as an argument and returns a new function that extends the behavior of the original function.\nSyntax:\ndef my_decorator(func): def wrapper(): # Code to execute before calling the decorated function func() # Code to execute after return wrapper Example:\ndef my_decorator(func): def wrapper(): print(\u0026#34;Before function call\u0026#34;) func() print(\u0026#34;After function call\u0026#34;) return wrapper @my_decorator def say_hello(): print(\u0026#34;Hello!\u0026#34;) say_hello() #call to my_decorator(say_hello)() just because we use @my_decorator Output:\nBefore function call\rHello!\rAfter function call Example For decorator :\ndef Add_Wrapper(func): def wrapper(a,b,c): print(\u0026#34;Status code is\u0026#34;,c) return func(a,b) return wrapper @Add_Wrapper def add(a,b): return a+b print(add(2,3,200)) Output:\nStatus code is 200\r5 3.2. Decorator with Arguments You can also create decorators that accept arguments by defining a decorator function that takes arguments and returns a decorator function.\nSyntax:\ndef my_decorator_with_args(arg1, arg2): def decorator(func): def wrapper(): # Code to execute before calling the decorated function func() # Code to execute after return wrapper return decorator Example:\ndef my_decorator_with_args(arg1, arg2): def decorator(func): def wrapper(): print(f\u0026#34;Decorator arguments: {arg1}, {arg2}\u0026#34;) func() return wrapper return decorator @my_decorator_with_args(\u0026#34;arg1\u0026#34;, \u0026#34;arg2\u0026#34;) def say_hello(): print(\u0026#34;Hello!\u0026#34;) say_hello() Output:\nDecorator arguments: arg1, arg2\rHello! ","permalink":"http://localhost:1313/posts/pages/python/python_advanced_topics/","summary":"An in-depth exploration of Python packages, generators, and decorators.","title":"Python Fundamentals: Packages, Generators, and Decorators (Part 7)"},{"content":"Python Fundamentals: Understanding request In this guide, we will explore request package in python. This package is used to make HTTP requests in python. Let\u0026rsquo;s dive in!\n1. Python request Python request is a simple and elegant HTTP library for Python. It provides methods for sending HTTP requests and handling the responses. The requests library allows you to send HTTP requests using a simple and intuitive API, and it also provides support for handling cookies, sessions, and authentication.\n1.1. Installing requests To use the requests library in your Python project, you need to install it using pip. You can install the requests library by running the following command in your terminal:\npip install requests 1.2. Types of requests The requests library supports various types of HTTP requests, including GET, POST, PUT, DELETE, and more. You can use these methods to interact with web services and APIs.\nExample:\nimport requests # Send a GET request response = requests.get(\u0026#39;https://api.github.com\u0026#39;) # Send a POST request response = requests.post(\u0026#39;https://httpbin.org/post\u0026#39;) # Send a PUT request response = requests.put(\u0026#39;https://httpbin.org/put\u0026#39;) # Send a DELETE request response = requests.delete(\u0026#39;https://httpbin.org/delete\u0026#39;) 1.3 Parameters for requests The requests library allows you to pass various parameters when making HTTP requests. These parameters include headers, query parameters, request body, and more.\nHeaders: You can pass custom headers in your request using the headers parameter. Example: import requests # Send a GET request with custom headers headers = {\u0026#39;User-Agent\u0026#39;: \u0026#39;Mozilla/5.0\u0026#39;} response = requests.get(\u0026#39;https://api.github.com\u0026#39;, headers=headers) # Send a POST request with custom headers response = requests.post(\u0026#39;https://httpbin.org/post\u0026#39;, headers=headers) #similarly for PUT and DELETE cookie: You can pass cookies in your request using the cookies parameter. Example: import requests # Send a GET request with cookies cookies = {\u0026#39;session_id\u0026#39;: \u0026#39;12345\u0026#39;} response = requests.get(\u0026#39;https://api.github.com\u0026#39;, cookies=cookies) # Send a POST request with cookies response = requests.post(\u0026#39;https://httpbin.org/post\u0026#39;, cookies=cookies) #similarly for PUT and DELETE file: You can upload files in your request using the files parameter. Example: import requests # Upload a file in a POST request files = {\u0026#39;file\u0026#39;: open(\u0026#39;file.txt\u0026#39;, \u0026#39;rb\u0026#39;)} response = requests.post(\u0026#39;https://httpbin.org/post\u0026#39;, files=files) #similarly for PUT and DELETE params: You can pass query parameters in your request using the params parameter. Example: import requests # Send a GET request with query parameters params = {\u0026#39;key1\u0026#39;: \u0026#39;value1\u0026#39;, \u0026#39;key2\u0026#39;: \u0026#39;value2\u0026#39;} response = requests.get(\u0026#39;https://api.github.com\u0026#39;, params=params) # Send a POST request with query parameters response = requests.post(\u0026#39;https://httpbin.org/post\u0026#39;, params=params) #similarly for PUT and DELETE data: You can pass data in your request body using the data parameter. Example: import requests # Send a POST request with data data = {\u0026#39;key1\u0026#39;: \u0026#39;value1\u0026#39;, \u0026#39;key2\u0026#39;: \u0026#39;value2\u0026#39;} response = requests.post(\u0026#39;https://httpbin.org/post\u0026#39;, data=data) #similarly for PUT and DELETE json: You can pass JSON data in your request body using the json parameter. Example: import requests # Send a POST request with JSON data data = {\u0026#39;key1\u0026#39;: \u0026#39;value1\u0026#39;, \u0026#39;key2\u0026#39;: \u0026#39;value2\u0026#39;} response = requests.post(\u0026#39;https://httpbin.org/post\u0026#39;, json=data) #similarly for PUT and DELETE Note: The requests library provides a wide range of parameters and options for making HTTP requests. You can refer to the official documentation for more details.\n** Note ** : While using json it will automatically set the content type to application/json and dump the data to json format but while using data it will set the content type to application/x-www-form-urlencoded and encode the data to urlencoded format.\n1.4. Handling responses The requests library provides methods for handling the responses returned by HTTP requests. You can access the response content, status code, headers, and more.\nResponse content: You can access the response content using the text attribute. Example: import requests # Send a GET request response = requests.get(\u0026#39;https://api.github.com\u0026#39;) # Get the response content content = response.text print(content) Response Content in bytes: You can access the response content in bytes using the content attribute. Example: import requests # Send a GET request response = requests.get(\u0026#39;https://api.github.com\u0026#39;) # Get the response content in bytes content = response.content print(content) json: You can access the response content as JSON using the json method. Example:\nimport requests # Send a GET request response = requests.get(\u0026#39;https://api.github.com\u0026#39;) # Get the response content as JSON data = response.json() print(data) Status code: You can access the response status code using the status_code attribute. Example: import requests # Send a GET request response = requests.get(\u0026#39;https://api.github.com\u0026#39;) # Get the response status code status_code = response.status_code print(status_code) Headers: You can access the response headers using the headers attribute. Example: import requests # Send a GET request response = requests.get(\u0026#39;https://api.github.com\u0026#39;) # Get the response headers headers = response.headers print(headers) Cookies: You can access the response cookies using the cookies attribute. Example: import requests # Send a GET request response = requests.get(\u0026#39;https://api.github.com\u0026#39;) # Get the response cookies cookies = response.cookies print(cookies) ","permalink":"http://localhost:1313/posts/pages/python/python_request/","summary":"An in-depth exploration of Python request.","title":"Python Fundamentals: Understanding request (Part 8)"},{"content":"Python Fundamentals: Understanding File Handeling In Python programming, file handling is an essential operation that allows you to read, write, and manipulate files on your system. Files are used to store data permanently, and Python provides various functions and methods to work with files efficiently. In this guide, we will explore the basics of file handling in Python, including opening, reading, writing, and closing files.\n1.Context Manager Python provides a built-in way to manage resources and ensure that they are properly released when they are no longer needed. This is done using the with statement and is known as a context manager. When working with files, it is recommended to use the with statement to ensure that the file is properly closed after use.\n1.1. Using the with Statement The with statement in Python is used to create a context manager that automatically takes care of resource management. When working with files, the with statement ensures that the file is properly closed after use, even if an error occurs during file operations.\nExample:\nwith open(\u0026#34;example.txt\u0026#34;, \u0026#34;r\u0026#34;) as file: data = file.read() print(data) 2. Opening a File Before you can read or write to a file, you need to open it using the open() function. The open() function takes two arguments: the file path and the mode in which you want to open the file.\n2.1. Modes for Opening Files Python supports various modes for opening files, depending on the operations you want to perform. Some common modes include:\nr: Read mode. Opens the file for reading. The file must exist. w: Write mode. Opens the file for writing. If the file exists, it will be truncated. If the file does not exist, a new file will be created. a: Append mode. Opens the file for writing. If the file exists, the data will be appended to the end. If the file does not exist, a new file will be created. b: Binary mode. Opens the file in binary mode.use for image,video,etc as it will not convert the data to text .You can add b to any mode to open the file in binary mode like rb,wb,ab. t: Text mode. Opens the file in text mode (default). 2.2. Opening a File To open a file, you can use the open() function with the desired file path and mode. You can also specify additional parameters such as encoding, buffering, and newline characters.\nExample:\n# Open a file in read mode with open(\u0026#34;example.txt\u0026#34;, \u0026#34;r\u0026#34;) as file: data = file.read() print(data) 3. Reading from a File Once you have opened a file, you can read its contents using various methods provided by Python. The most common methods for reading from a file is read().\n# Open a file in read mode with open(\u0026#34;example.txt\u0026#34;, \u0026#34;r\u0026#34;) as file: data = file.read() print(data) 4. Writing to a File To write data to a file, you can use the write() method provided by Python. You can write text data to a file using the write() method.\nUsing w mode: # Open a file in write mode with open(\u0026#34;example.txt\u0026#34;, \u0026#34;w\u0026#34;) as file: file.write(\u0026#34;Hello, World!\u0026#34;) Using a mode: # Open a file in append mode with open(\u0026#34;example.txt\u0026#34;, \u0026#34;a\u0026#34;) as file: file.write(\u0026#34;Hello, World!\u0026#34;) 5.Context Manager Reference\nUse of Context Manager: In any programming language, the usage of resources like file operations or database connections is very common. But these resources are limited in supply. Therefore, the main problem lies in making sure to release these resources after usage. If they are not released then it will lead to resource leakage and may cause the system to either slow down or crash. It would be very helpful if users have a mechanism for the automatic setup and teardown of resources. In Python, it can be achieved by the usage of context managers which facilitate the proper handling of resources.\nWhat is happened When the with statement is executed, it will automatically call the __enter__ before entering the code block, and __exit__ after exiting the code block.\nHow to create a context manager To create a context manager, you need to define a class that implements the __enter__ and __exit__ methods. The __enter__ method is called when the with statement is executed, and the __exit__ method is called after the code block is executed.\nSyntax:\nclass MyContextManager: def __init__(self,params): # Code to initialize resources def __enter__(self): # Code to setup resources return self def __exit__(self, exc_type, exc_value, traceback): # Code to release resources Example:\n#implementatio of own file handeling context manager class MeroHandle: def __init__(self,filename,mode): self.filename = filename self.mode = mode def __enter__(self): self.file = open(self.filename,self.mode) return self.file def __exit__(self,exc_type,exc_value,traceback): self.file.close() #using the context manager with MeroHandle(\u0026#34;example.txt\u0026#34;,\u0026#34;r\u0026#34;) as file: data = file.read() print(data) Normal way of file handeling try: file = open(\u0026#34;example.txt\u0026#34;,\u0026#34;r\u0026#34;) data = file.read() print(data) file.close() except: print(\u0026#34;Error Occured\u0026#34;) Advantage of context manager Over normal code When we use normal code shown above then when error occured in try block before file.close() then it will not close the file(i.e file will not be closed) and it will lead to resource leakage . But when we use context manager then it will automatically close the file just because __exit__ method is called after the code block is executed whether error occured or not. but in normal code we can manage this by using finally block but it is not recommended as it is not pythonic way of doing things. try: file = open(\u0026#34;example.txt\u0026#34;,\u0026#34;r\u0026#34;) data = file.read() print(data) except: print(\u0026#34;Error Occured\u0026#34;) finally: file.close() This will work but it is not pythonic way of doing things.Just because we have to write whole try,except,finally block for just opening and closing the file. which make code more complex and lengthy.\n","permalink":"http://localhost:1313/posts/pages/python/python_filehandeling/","summary":"An in-depth look at File Handeling.","title":"Python Fundamentals: Understanding File Handeling (Part 9)"},{"content":"Python Fundamentals: Some Important Package to Know In Python programming, packages are collections of modules that provide additional functionality to your programs. Python has a rich ecosystem of packages that can help you perform a wide range of tasks, from data analysis and visualization to web development and machine learning. In this guide, we will explore some of the most important packages in Python that you should be familiar with.\n1.json The json package in Python provides functions for encoding and decoding JSON data. JSON (JavaScript Object Notation) is a lightweight data interchange format that is easy for humans to read and write and easy for machines to parse and generate. The json package allows you to work with JSON data in Python by converting Python objects to JSON strings and vice versa.\nConversion of Python dictionary to JSON string We can convert a Python dictionary to a JSON string using the json.dumps() function. This function takes a Python object as input and returns a JSON string representation of the object. Example:\nimport json # Create a Python dictionary data = { \u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34; } # Convert the dictionary to a JSON string json_string = json.dumps(data) print(json_string) Conversion of JSON string to Python dictionary We can convert a JSON string to a Python dictionary using the json.loads() function. This function takes a JSON string as input and returns a Python object (usually a dictionary) representing the JSON data. Example:\nimport json # JSON string json_string = \u0026#39;{\u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;}\u0026#39; # Convert the JSON string to a Python dictionary data = json.loads(json_string) print(data) 2.os The os package in Python provides functions for interacting with the operating system.You can get indepth knowladge of os using its own documentation.but the most common methods are:\nos.path.join(\u0026quot;C:\u0026quot;,\u0026quot;users\u0026quot;,\u0026quot;bin\u0026quot;): Join one or more path components intelligently. os.rename(\u0026quot;old\u0026quot;,\u0026quot;new\u0026quot;): Rename a file or directory. 3.time The time package in Python provides functions for working with time-related tasks. You can use the time package to get the current time, sleep for a specified duration, and measure the execution time of your code.\ntime.time(): Returns the current time in seconds since the epoch. time.sleep(seconds): Suspends the execution of the current thread for the given number of seconds. 4.uuid The uuid package in Python provides functions for generating and working with UUIDs (Universally Unique Identifiers). UUIDs are unique identifiers that are used to identify objects in a distributed computing environment. The uuid package allows you to generate UUIDs based on various algorithms and formats.\nGenerating a UUID You can generate a UUID using the uuid.uuid4() function, which generates a random UUID. Example:\nimport uuid # Generate a random UUID uuid_value = uuid.uuid4() print(uuid_value) 5.Datetime The datetime package in Python provides classes for working with dates and times. You can use the datetime package to create, manipulate, and format dates and times in your Python programs.\nCreating a datetime object You can create a datetime object using the datetime.datetime() constructor, which takes the year, month, day, hour, minute, second, and microsecond as input. Example:\nimport datetime # Create a datetime object dt = datetime.datetime(2022, 11, 27, 10, 30, 0) print(dt) Output:\n2022-11-27 10:30:00 get current date and time You can get the current date and time using the datetime.now() method. Example:\nimport datetime # Get the current date and time now = datetime.datetime.now() print(now) Output:\n2022-11-27 10:30:00 Formatting a datetime object some Properties of datetime object:\nyear: The year of the datetime object month: The month of the datetime object (1-12) day: The day of the datetime object (1-31) hour: The hour of the datetime object (0-23) minute: The minute of the datetime object (0-59) second: The second of the datetime object (0-59) import datetime # Create a datetime object dt = datetime.datetime.now() # Format the datetime object print(dt.month()) print(dt.day()) print(dt.year()) print(dt.hour()) print(dt.minute()) print(dt.second()) Output:\n11\r27\r2022\r10\r30\r0 ","permalink":"http://localhost:1313/posts/pages/python/python_extrapackage/","summary":"An in-depth look at frequently used important package.","title":"Python Fundamentals: Some Important Package to Know (Part 10)"},{"content":"Shared References in Python: How Changes Propagate Across Variables In Python, variables are references to objects in memory. When you assign a value to a variable, you are creating a reference to the object that holds that value. In some cases, multiple variables can refer to the same object in memory. This is known as a shared reference.\nMutability and Shared References in Python: How Changes Propagate Across Variables List Lists are mutable, so if two variables reference the same list, changes through one variable will affect the other.\n# Create a list list1 = [1, 2, 3] # Create a reference to the list list2 = list1 # Modify the list through one reference list2.append(4) # Check the original list print(list1) # Output: [1, 2, 3, 4] Dictionary Dictionaries are mutable as well. If two variables point to the same dictionary, any change made through one will reflect in the other.\n# Create a dictionary dict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30} # Create a reference to the dictionary dict2 = dict1 # Modify the dictionary through one reference dict2[\u0026#34;age\u0026#34;] = 31 # Check the original dictionary print(dict1) # Output: {\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 31} Set Sets are mutable, so changes made through one reference will affect the other if two variables point to the same set.\n# Create a set set1 = {1, 2, 3} # Create a reference to the set set2 = set1 # Modify the set through one reference set2.add(4) # Check the original set print(set1) # Output: {1, 2, 3, 4} Custom Objects\nclass Person: def __init__(self, name, age): self.name = name self.age = age # Create an instance of the Person class person1 = Person(\u0026#34;Alice\u0026#34;, 30) # Create a reference to the instance person2 = person1 # Modify the instance through one reference person2.age = 31 # Check the original instance print(person1.age) # Output: 31 Note: Mutable objects like lists, dictionaries, sets, and custom objects allow changes to propagate across variables that reference the same object. Immutable objects like integers, strings, and tuples do not exhibit this behavior.\n","permalink":"http://localhost:1313/posts/pages/python/python_shared_references/","summary":"An in-depth look at shared references in Python.","title":"Python Fundamentals : Shared References in Python (part 11)"},{"content":"Object oriented programming in python Object oriented programming is a programming paradigm that provides a means of structuring programs so that properties and behaviors are bundled into individual objects.\n1. Class and Object Class is a blueprint for creating objects (a particular data structure), providing initial values for state (member variables or attributes), and implementations of behavior (member functions or methods).\nObject is an instance of a class. When class is defined, only the description for the object is defined. Therefore, no memory or storage is allocated.\n1.1 Creating a class We can create a class using the class keyword followed by the class name. The class definition can contain class variables, instance variables, methods, and constructors.\nSyntax:\nclass ClassName: #code block Example:\nclass Person: name=\u0026#34;Nirajan\u0026#34; age=20 classes=\u0026#34;Bachelor\u0026#34; 1.2 Creating an object To create an object of a class, we use the class name followed by parentheses. This calls the constructor method of the class and returns an object.\nSyntax:\nobject_name = ClassName() Example:\nperson1 = Person() 1.3 Accessing class attributes We can access the attributes of a class using the dot operator (.) followed by the attribute name.\nSyntax:\nobject_name.attribute_name Example:\nprint(person1.name) # Output: Nirajan print(person1.age) # Output: 20 print(person1.classes) # Output: Bachelor 1.4 Modifying class attributes We can modify the attributes of a class using the dot operator (.) followed by the attribute name.\nSyntax:\nobject_name.attribute_name = new_value Example:\nperson1.age = 21 print(person1.age) # Output: 21 1.5 Creating a member function We can create a member function (method) inside a class using the def keyword followed by the function name. The first parameter of the method should be self, which refers to the current instance of the class.we will see about self in next part.\nSyntax:\nclass ClassName: def method_name(self, parameters): #code block Example:\nclass Person: name=\u0026#34;Nirajan\u0026#34; age=20 classes=\u0026#34;Bachelor\u0026#34; def display(self): print(f\u0026#34;Name: {self.name}\u0026#34;) print(f\u0026#34;Age: {self.age}\u0026#34;) print(f\u0026#34;Class: {self.classes}\u0026#34;) 1.6 Calling a member function We can call a member function of a class using the dot operator (.) followed by the function name and parentheses.\nSyntax:\nobject_name.method_name(arguments) Example:\nperson1.display() 1.7 Nested member function We can call a member function from another member function of the same class using the self keyword.\nSyntax:\nclass ClassName: def method1(self): #code block self.method2() def method2(self): #code block Example:\nclass Person: name=\u0026#34;Nirajan\u0026#34; age=20 classes=\u0026#34;Bachelor\u0026#34; def display(self): print(f\u0026#34;Name: {self.name}\u0026#34;) print(f\u0026#34;Age: {self.age}\u0026#34;) print(f\u0026#34;Class: {self.classes}\u0026#34;) self.greet() def greet(self): print(\u0026#34;Hello, Welcome to the class\u0026#34;) 1.8 self parameter The self parameter is a reference to the current instance of the class, and is used to access variables and methods of the class. It is the first parameter of any method in a class.\nSyntax:\nclass ClassName: def method_name(self, parameters): #code block Example:\nclass Person: name=\u0026#34;Nirajan\u0026#34; age=20 classes=\u0026#34;Bachelor\u0026#34; def display(self): print(f\u0026#34;Name: {self.name}\u0026#34;) print(f\u0026#34;Age: {self.age}\u0026#34;) print(f\u0026#34;Class: {self.classes}\u0026#34;) self.greet() def greet(self): print(\u0026#34;Hello, Welcome to the class\u0026#34;) 2. Constructor in Python A constructor is a special type of method (function) which is used to initialize the instance members of the class. It is called when an object of the class is created.\n2.1 Creating a constructor In Python, the constructor method is called __init__. It is a special method that is automatically called when an object is created.\nSyntax:\nclass ClassName: def __init__(self, parameters): #code block Example:\nclass Person: def __init__(self, name, age, classes): self.name = name self.age = age self.classes = classes def display(self): print(f\u0026#34;Name: {self.name}\u0026#34;) print(f\u0026#34;Age: {self.age}\u0026#34;) print(f\u0026#34;Class: {self.classes}\u0026#34;) 2.2 Creating an object with constructor When an object is created, the constructor method is automatically called with the arguments passed to the class.\nSyntax:\nobject_name = ClassName(arguments) Example:\nperson1 = Person(\u0026#34;Nirajan\u0026#34;, 20, \u0026#34;Bachelor\u0026#34;) 3. Getters and Setters in Python 3.1. Getters Getters are methods is implementes by using the @property decorator. They are specially used\nto act as an value ie data instead of a method. to access the value of a private attribute without directly accessing it. Syntax:\nclass ClassName: @property def method_name(self): #code block Example:\nclass Person: def __init__(self, name, age): self._name = name self._age = age @property def display(self): return f\u0026#34;Name: {self._name}, Age: {self._age}\u0026#34; person1 = Person(\u0026#34;Nirajan\u0026#34;, 20) print(person1.display) # Output: Name: Nirajan, Age: 20 3.2. Setters Setters are methods is implementes by using the @method_name.setter decorator. They are specially used\nto set the value of a private attribute without directly setting it. to perform validation before setting the value of an attribute. Syntax:\nclass ClassName: @method_name.setter def method_name(self, value): #code block Example:\nclass Person: def __init__(self, name, age): self._name = name self._age = age @property def display(self): return f\u0026#34;Name: {self._name}, Age: {self._age}\u0026#34; @display.setter def display(self, value): self._name, self._age = value.split(\u0026#34;,\u0026#34;) self._age = int(self._age) person1 = Person(\u0026#34;Nirajan\u0026#34;, 20) print(person1.display) # Output: Name: Nirajan, Age: 20 person1.display = \u0026#34;Alice, 30\u0026#34; print(person1.display) # Output: Name: Alice, Age: 30 4. Inheritance in Python Inheritance is a mechanism in which one class acquires the properties and behavior of another class. The class which inherits the properties and behavior is known as the child class, and the class whose properties and behavior are inherited is known as the parent class.\n4.1. Creating a child class To create a child class that inherits from a parent class, we specify the parent class in parentheses after the child class name.\nSyntax:\nclass ChildClassName(ParentClassName): #code block Example:\nclass Employee: def __init__(self,name,age,id): self.name=name self.age=age self.id=id def display(self): print(f\u0026#34;Name: {self.name}\u0026#34;) print(f\u0026#34;Age: {self.age}\u0026#34;) print(f\u0026#34;ID: {self.id}\u0026#34;) class Manager(Employee):# it has all the properties of Employee class so we can access the # properties of Employee class also its method using object of Manager class def task(self): self.display() print(\u0026#34;Assigning tasks to employees\u0026#34;) class Developer(Employee): # it has all the properties of Employee class so we can access # the properties of Employee class also its method using object of Developer class def task(self): self.display() print(\u0026#34;Developing software applications\u0026#34;) manager1 = Manager(\u0026#34;Alice\u0026#34;, 30, 101) manager1.task() developer1 = Developer(\u0026#34;Bob\u0026#34;, 25, 102) developer1.task() Note : Only public and protected members are inherited by the child class. Private members are not inherited by the child class.\n5.Ascess Specifiers in Python 5.1. Public members Public members are accessible from outside the class. They can be accessed using the dot operator (.) from outside the class.\nExample:\nclass Person: name = \u0026#34;Alice\u0026#34; # Public member person1 = Person() print(person1.name) # Output: Alice 5.2. Protected members Protected members are accessible within the class and its subclasses. They are denoted by a single underscore (_) before the member name.\nExample:\nclass Person: _age = 30 # Protected member class Student(Person): def display(self): print(self._age) # Accessing protected member student1 = Student() student1.display() # Output: 30 Example of protected variable and method\nclass Person: _name = \u0026#34;Alice\u0026#34; # Protected variable def _display(self): # Protected method print(f\u0026#34;Name: {self._name}\u0026#34;) class Student(Person): def display(self): self._display() # Accessing protected metho student1 = Student() student1.display() # Output: Name: Alice 5.3. Private members Private members are accessible only within the class. They are denoted by a double underscore (__) before the member name.\nExample:\nclass Person: __city = \u0026#34;New York\u0026#34; # Private member person1 = Person() print(person1.__city) # Error: \u0026#39;Person\u0026#39; object has no attribute \u0026#39;__city\u0026#39; Example of private variable and method\nclass Person: __name = \u0026#34;Alice\u0026#34; # Private variable def __display(self): # Private method print(f\u0026#34;Name: {self.__name}\u0026#34;) person1 = Person() print(person1.__name) # Error: \u0026#39;Person\u0026#39; object has no attribute \u0026#39;__name\u0026#39; person1.__display() # Error: \u0026#39;Person\u0026#39; object has no attribute \u0026#39;__display\u0026#39; Table of Access Specifiers in Python:\nAccess Specifier Accessible from class Accessible from subclass Accessible from outside class Public Yes Yes Yes Protected Yes Yes No Private Yes No No Static Method in Python Static Method is those method that can be called without creating an object of the class. They are defined using the @staticmethod decorator. They can be called using the class name . Syntax: class ClassName: @staticmethod def method_name(parameters): #code block Example:\nclass Calculator: @staticmethod def add(a, b): return a + b result = Calculator.add(5, 3) print(result) # Output: 8 #Can call using object also calculator = Calculator() result = calculator.add(5, 3) print(result) # Output: 8 #this is also valid but it is not recommended Class Method in Python They are defined using the @classmethod decorator.The useage of class method is to access the class variable and change class variable. ie when we change variable using class method it will change for all the object of the class.THey can be called using the class name. Syntax:\nclass ClassName: @classmethod def method_name(cls, parameters): #code block Example:\nclass copany : copany=\u0026#34;Google\u0026#34; @classmethod def change_company(cls,new_company): cls.copany=new_company print(copany.copany) #Output: Google copany.change_company(\u0026#34;Microsoft\u0026#34;) print(copany.copany) #Output: Microsoft c1=copany() print(c1.copany) #Output: Microsoft c1.change_company(\u0026#34;Apple\u0026#34;) c2=copany() print(c2.copany) #Output: Applex Dir and dict method in Python dir() method is used to return a list of attributes and methods of any object. It returns a list of valid attributes and methods of the object. Syntax:\ndir(object) Example:\nclass Person: name = \u0026#34;Alice\u0026#34; age = 30 person1 = Person() print(dir(person1)) # Output: [\u0026#39;__class__\u0026#39;, \u0026#39;__delattr__\u0026#39;, \u0026#39;__dict__\u0026#39;, \u0026#39;__dir__\u0026#39;, \u0026#39;__doc__\u0026#39;, \u0026#39;__eq__\u0026#39;, \u0026#39;__format__\u0026#39;, \u0026#39;__ge__\u0026#39;, \u0026#39;__getattribute__\u0026#39;, \u0026#39;__gt__\u0026#39;, \u0026#39;__hash__\u0026#39;, \u0026#39;__init__\u0026#39;, \u0026#39;__init_subclass__\u0026#39;, \u0026#39;__le__\u0026#39;, \u0026#39;__lt__\u0026#39;, \u0026#39;__module__\u0026#39;, \u0026#39;__ne__\u0026#39;, \u0026#39;__new__\u0026#39;, \u0026#39;__reduce__\u0026#39;, \u0026#39;__reduce_ex__\u0026#39;, \u0026#39;__repr__\u0026#39;, \u0026#39;__setattr__\u0026#39;, \u0026#39;__sizeof__\u0026#39;, \u0026#39;__str__\u0026#39;, \u0026#39;__subclasshook__\u0026#39;, \u0026#39;__weakref__\u0026#39;, \u0026#39;age\u0026#39;, \u0026#39;name\u0026#39;] Example:\nl=[1,2,3] print(dir(l)) # Output: [\u0026#39;__add__\u0026#39;, \u0026#39;__class__\u0026#39;, \u0026#39;__class_getitem__\u0026#39;, \u0026#39;__contains__\u0026#39;, \u0026#39;__delattr__\u0026#39;, \u0026#39;__delitem__\u0026#39;, \u0026#39;__dir__\u0026#39;, \u0026#39;__doc__\u0026#39;, \u0026#39;__eq__\u0026#39;, \u0026#39;__format__\u0026#39;, \u0026#39;__ge__\u0026#39;, \u0026#39;__getattribute__\u0026#39;, \u0026#39;__getitem__\u0026#39;, \u0026#39;__getstate__\u0026#39;, \u0026#39;__gt__\u0026#39;, \u0026#39;__hash__\u0026#39;, \u0026#39;__iadd__\u0026#39;, \u0026#39;__imul__\u0026#39;, \u0026#39;__init__\u0026#39;, \u0026#39;__init_subclass__\u0026#39;, \u0026#39;__iter__\u0026#39;, \u0026#39;__le__\u0026#39;, \u0026#39;__len__\u0026#39;, \u0026#39;__lt__\u0026#39;, \u0026#39;__mul__\u0026#39;, \u0026#39;__ne__\u0026#39;, \u0026#39;__new__\u0026#39;, \u0026#39;__reduce__\u0026#39;, \u0026#39;__reduce_ex__\u0026#39;, \u0026#39;__repr__\u0026#39;, \u0026#39;__reversed__\u0026#39;, \u0026#39;__rmul__\u0026#39;, \u0026#39;__setattr__\u0026#39;, \u0026#39;__setitem__\u0026#39;, \u0026#39;__sizeof__\u0026#39;, \u0026#39;__str__\u0026#39;, \u0026#39;__subclasshook__\u0026#39;, \u0026#39;append\u0026#39;, \u0026#39;clear\u0026#39;, \u0026#39;copy\u0026#39;, \u0026#39;count\u0026#39;, \u0026#39;extend\u0026#39;, \u0026#39;index\u0026#39;, \u0026#39;insert\u0026#39;, \u0026#39;pop\u0026#39;, \u0026#39;remove\u0026#39;, \u0026#39;reverse\u0026#39;, \u0026#39;sort\u0026#39;] __dict__ method is used to return a dictionary containing the attributes of an object. It returns a dictionary containing the attributes of the object.\nSyntax:\nobject.__dict__ Example:\nclass Person: name = \u0026#34;Alice\u0026#34; age = 30 person1 = Person() print(person1.__dict__) # Output: {\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 30} 9.super() method in Python When a parent class and a child class define a method with the same name, and we create an object of the child class, invoking the method on the child class object will execute the method defined in the child class, not the one in the parent class. To explicitly call the parent class\u0026rsquo;s method, we can use the super() function.\nTo explicitly invoke the parent class\u0026rsquo;s version of the method, the super() function is used. This is especially useful when the child class\u0026rsquo;s method needs to build upon or extend the functionality of the parent class\u0026rsquo;s method.\nSyntax:\nsuper().method_name() Example:\nclass Person: def display(self): print(\u0026#34;Person class\u0026#34;) class Student(Person): def display(self): super().display() print(\u0026#34;Student class\u0026#34;) student1 = Student() student1.display() # Output: # Person class # Student class Example:\nclass Person: def __init__(self,name,age): self.name=name self.age=age class Student(Person): def __init__(self,name,age,roll): super().__init__(name,age) self.roll=roll def display(self): print(f\u0026#34;Name: {self.name}\u0026#34;) print(f\u0026#34;Age: {self.age}\u0026#34;) print(f\u0026#34;Roll: {self.roll}\u0026#34;) student1 = Student(\u0026#34;Alice\u0026#34;, 30, 101) student1.display() # Output: # Name: Alice # Age: 30 # Roll: 101 Note: Use super for single inheritance only. For multiple inheritance, use the class name directly.\nMagic/dunder methods in Python Magic methods are special methods that have double underscores at the beginning and end of their names. They are also known as dunder methods (short for \u0026ldquo;double underscore\u0026rdquo;). Magic methods are used to define the behavior of objects. They are automatically called when certain operations are performed on objects. Some of the commonly used magic methods are:\n__init__: Constructor method, called when an object is created. __str__: Called by the str() built-in function to return a string representation of an object. __repr__: Called by the repr() built-in function to return an unambiguous string representation of an object. __add__: Called by the + operator to perform addition. __len__: Called by the len() built-in function to return the length of an object. __call__: Called when an object is called as a function. Note : All magic method can be seen using dir(objectname) method and we can override the magic method in our class.\nexample of all method:\nclass Person: def __init__(self, name, age): self.name = name self.age = age def __str__(self): return f\u0026#34;Name: {self.name}, Age: {self.age}\u0026#34; def __repr__(self): return f\u0026#34;Person(\u0026#39;{self.name}\u0026#39;, {self.age})\u0026#34; def __add__(self, other): return self.age + other.age def __len__(self): return len(self.name) def __call__(self): return f\u0026#34;Name: {self.name}, Age: {self.age}\u0026#34; person1 = Person(\u0026#34;Alice\u0026#34;, 30) person2 = Person(\u0026#34;Bob\u0026#34;, 25) print(person1) # Output: Name: Alice, Age: 30 print(repr(person1)) # Output: Person(\u0026#39;Alice\u0026#39;, 30) print(person1 + person2) # Output: 55 print(len(person1)) # Output: 5 print(person1()) # Output: Name: Alice, Age: 30 Method Overriding Method overriding is a feature of object-oriented programming that allows a subclass to provide a specific implementation of a method that is already provided by its parent class. When a method in a subclass has the same name, same parameters or signature, and same return type as a method in its parent class, then the method in the subclass is said to override the method in the parent class. Example:\nclass Person: def display(self): print(\u0026#34;Person class\u0026#34;) class Student(Person): def display(self): print(\u0026#34;Student class\u0026#34;) student1 = Student() student1.display() # Output: Student class We can also call the parent class\u0026rsquo;s method from the overridden method using the super() function.\nExample:\nclass Person: def display(self): print(\u0026#34;Person class\u0026#34;) class Student(Person): def display(self): super().display() #Or Person.display(self) print(\u0026#34;Student class\u0026#34;) student1 = Student() student1.display() # Output: # Person class # Student class Operator overloading in Python Operator overloading is a feature of object-oriented programming that allows us to define the behavior of operators for user-defined objects. It allows us to define the behavior of operators such as +, -, *, /, ==, !=, etc., for objects of a class. To overload an operator, we need to define a special method in the class that corresponds to the operator. These special methods are called magic methods or dunder methods.\nExample:\nclass Point: def __init__(self, x, y): self.x = x self.y = y def __add__(self, other): x = self.x + other.x y = self.y + other.y return Point(x, y) def __str__(self): return f\u0026#34;({self.x}, {self.y})\u0026#34; point1 = Point(1, 2) point2 = Point(3, 4) point3 = point1 + point2 print(point3) # Output: (4, 6) Types of Inheritance in Python Inheritance is a mechanism in which one class acquires the properties and behavior of another class. There are different types of inheritance in Python: Single Inheritance: In single inheritance, a class inherits from only one parent class. The pictorial representation of single inheritance is:\nA\r|\rB Syntax:\nclass ParentClass: #code block class ChildClass(ParentClass): #code block Example:\nclass Person: def __init__(self, name, age): self.name = name self.age = age def display(self): return f\u0026#34;Name: {self.name}, Age: {self.age}\u0026#34; def __str__(self): return f\u0026#34;Name: {self.name}, Age: {self.age}\u0026#34; def __repr__(self): return f\u0026#34;Person(\u0026#39;{self.name}\u0026#39;, {self.age})\u0026#34; def __call__(self): return f\u0026#34;Name: {self.name}, Age: {self.age}\u0026#34; class Student(Person): def __init__(self,naem,age,id): super().__init__(name,age) #or Person.__init__(self,name,age) self.id=id def display(self): print(f\u0026#34;ID: {self.id}\u0026#34;,super().display()) #or Person.display(self) student1 = Student(\u0026#34;Alice\u0026#34;, 30, 101) student1.display() # Output: # ID: 101 # Name: Alice, Age: 30 Multiple Inheritance: In multiple inheritance, a class inherits from more than one parent class. The pictorial representation of multiple inheritance is:\nA B\r\\ /\rC Syntax:\nclass ParentClass1: #code block class ParentClass2: #code block class ChildClass(ParentClass1, ParentClass2): #code block Example:\nclass Person: def __init__(self, name, age): self.name = name self.age = age def display(self): return f\u0026#34;Name: {self.name}, Age: {self.age}\u0026#34; class Address: def __init__(self,city,state): self.city=city self.state=state def display(self): return f\u0026#34;City: {self.city}, State: {self.state}\u0026#34; class Student(Person,Address): def __init__(self,name,age,id,city,state): Person.__init__(self,name,age) Address.__init__(self,city,state) self.id=id def display(self): print(f\u0026#34;ID: {self.id}\u0026#34;,Person.display(self),Address.display(self)) student1 = Student(\u0026#34;Alice\u0026#34;, 30, 101,\u0026#34;New York\u0026#34;,\u0026#34;New York\u0026#34;) student1.display() # Output: # ID: 101 # Name: Alice, Age: 30 # City: New York, State: New York Multilevel Inheritance: In multilevel inheritance, a class inherits from a parent class, and another class inherits from the child class. The pictorial representation of multilevel inheritance is:\nA\r|\rB\r|\rC Syntax:\nclass ParentClass: #code block class ChildClass(ParentClass): #code block class GrandChildClass(ChildClass): #code block Example:\nclass Person: def __init__(self, name, age): self.name = name self.age = age def display(self): return f\u0026#34;Name: {self.name}, Age: {self.age}\u0026#34; class Student(Person): def __init__(self,name,age,id): super().__init__(name,age) # or Person.__init__(self,name,age) self.id=id def display(self): print(f\u0026#34;ID: {self.id}\u0026#34;,super().display()) # print(f\u0026#34;ID: {self.id}\u0026#34;,Person.display(self)) class CollegeStudent(Student): def __init__(self,name,age,id,classes): super().__init__(name,age,id) #or Student.__init__(self,name,age,id) self.classes=classes def display(self): print(f\u0026#34;Class: {self.classes}\u0026#34;,super().display()) #or print(f\u0026#34;Class: {self.classes}\u0026#34;,Student.display(self)) student1 = CollegeStudent(\u0026#34;Alice\u0026#34;, 30, 101,\u0026#34;Bachelor\u0026#34;) student1.display() # Output: # Class: Bachelor # ID: 101 # Name: Alice, Age: 30 Hierarchical Inheritance: In hierarchical inheritance, more than one class inherits from a single parent class. The pictorial representation of hierarchical inheritance is:\nA\r/ \\\rB C Syntax:\nclass ParentClass: #code block class ChildClass1(ParentClass): #code block class ChildClass2(ParentClass): #code block Example:\nclass Person: def __init__(self, name, age): self.name = name self.age = age def display(self): return f\u0026#34;Name: {self.name}, Age: {self.age}\u0026#34; class Student(Person): def __init__(self,name,age,id): super().__init__(name,age) #or Person.__init__(self,name,age) self.id=id def display(self): print(f\u0026#34;ID: {self.id}\u0026#34;,super().display()) #or print(f\u0026#34;ID: {self.id}\u0026#34;,Person.display(self)) class Employee(Person): def __init__(self,name,age,emp_id): super().__init__(name,age) #or Person.__init__(self,name,age) self.emp_id=emp_id def display(self): print(f\u0026#34;Emp ID: {self.emp_id}\u0026#34;,super().display()) #or print(f\u0026#34;Emp ID: {self.emp_id}\u0026#34;,Person.display(self)) student1 = Student(\u0026#34;Alice\u0026#34;, 30, 101) student1.display() employee1 = Employee(\u0026#34;Bob\u0026#34;, 25, 201) employee1.display() # Output: # ID: 101 # Name: Alice, Age: 30 # Emp ID: 201 # Name: Bob, Age: 25 Note: Hybrid inheritance is a combination of two or more types of inheritance.\n14. MRO (Method Resolution Order) in Python Method Resolution Order (MRO) is the order in which methods are resolved in the inheritance hierarchy. It defines the order in which the base classes are searched when executing a method.\nfor example:\nclass C: f=\u0026#34;dirajan\u0026#34; class A(C): f=\u0026#34;nirajan\u0026#34; class B(C): f=\u0026#34;kirajan\u0026#34; class D(A,B): pass def display(self): print(self.f) d=D() print(D.__mro__) d.display() Output:\n(\u0026lt;class \u0026#39;__main__.D\u0026#39;\u0026gt;, \u0026lt;class \u0026#39;__main__.A\u0026#39;\u0026gt;, \u0026lt;class \u0026#39;__main__.B\u0026#39;\u0026gt;, \u0026lt;class \u0026#39;__main__.C\u0026#39;\u0026gt;, \u0026lt;class \u0026#39;object\u0026#39;\u0026gt;)\rnirajan It means it will search for the method in the order of D-\u0026gt;A-\u0026gt;B-\u0026gt;C-\u0026gt;object if the method is not found in the D it will search in A and so on. but if the method is found in the D it will not search in the A,B,C and object.\n15.Class Inside a Class in Python A class can be defined inside another class. The class inside the class is known as nested class. The nested class can access the attributes and methods of the outer class.\nSyntax:\nclass OuterClass: class InnerClass: #code block Example:\nclass OuterClass: def __init__(self): self.name = \u0026#34;Alice\u0026#34; self.age = 30 class InnerClass: def display(self, outer): print(f\u0026#34;Name: {outer.name}\u0026#34;) print(f\u0026#34;Age: {outer.age}\u0026#34;) outer1 = OuterClass() inner1 = outer1.InnerClass() inner1.display(outer1) # Output: # Name: Alice # Age: 30 16. Nested class in Python A class can be defined inside another class. The class inside the class is known as nested class. The nested class can access the attributes and methods of the outer class.\nSyntax:\nclass OuterClass: class InnerClass: #code block Creating an object of the nested class: Syntax:\nouter_object = OuterClass() inner_object = outer_object.InnerClass() Example:\nclass OuterClass: def __init__(self): self.name = \u0026#34;Alice\u0026#34; self.age = 30 class InnerClass: def display(self, outer): print(f\u0026#34;Name: {outer.name}\u0026#34;) print(f\u0026#34;Age: {outer.age}\u0026#34;) outer1 = OuterClass() inner1 = outer1.InnerClass() inner1.display(outer1) # Output: # Name: Alice # Age: 30 creating an object of the nested class inside the outer class:\nclass OuterClass: def __init__(self): self.name = \u0026#34;Alice\u0026#34; self.age = 30 self.inner = self.InnerClass() class InnerClass: def display(self, outer): print(f\u0026#34;Name: {outer.name}\u0026#34;) print(f\u0026#34;Age: {outer.age}\u0026#34;) outer1 = OuterClass() outer1.inner.display(outer1) # Output: # Name: Alice # Age: 30 ","permalink":"http://localhost:1313/posts/pages/python/python_object_oriented1/","summary":"This is the first part of series of Object Oriented Programming in Python","title":"Python Fundamentals: Exploring OOP (Part 12)"},{"content":"DOM (Document Object Model) Theory The DOM is a programming interface for HTML and XML documents. It represents the document as a tree structure where each node is an object representing a part of the document. This allows programming languages to interact with the document structure, style, and content.\n1. DOM Selection Methods a) document.getElementById() Selects an element by its ID attribute.\n\u0026lt;!-- HTML --\u0026gt; \u0026lt;div id=\u0026#34;myDiv\u0026#34;\u0026gt;Hello\u0026lt;/div\u0026gt; // JavaScript const element = document.getElementById(\u0026#39;myDiv\u0026#39;); console.log(element.innerText); // Output: // \u0026#34;Hello\u0026#34; b) document.getElementsByClassName() Returns a collection of elements with the specified class name.\n\u0026lt;!-- HTML --\u0026gt; \u0026lt;div class=\u0026#34;myClass\u0026#34;\u0026gt;Item 1\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;myClass\u0026#34;\u0026gt;Item 2\u0026lt;/div\u0026gt; // JavaScript const elements = document.getElementsByClassName(\u0026#39;myClass\u0026#39;); for (let i = 0; i \u0026lt; elements.length; i++) { console.log(elements[i].innerText); } // Output: // \u0026#34;Item 1\u0026#34; // \u0026#34;Item 2\u0026#34; c) document.getElementsByTagName() Returns a collection of elements with the specified tag name.\n\u0026lt;!-- HTML --\u0026gt; \u0026lt;p\u0026gt;Paragraph 1\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Paragraph 2\u0026lt;/p\u0026gt; // JavaScript const paragraphs = document.getElementsByTagName(\u0026#39;p\u0026#39;); for (let i = 0; i \u0026lt; paragraphs.length; i++) { console.log(paragraphs[i].innerText); // Output: // \u0026#34;Paragraph 1\u0026#34; // \u0026#34;Paragraph 2\u0026#34; d) document.querySelector() Returns the first element that matches the CSS selector.\n\u0026lt;!-- HTML --\u0026gt; \u0026lt;div class=\u0026#34;myClass\u0026#34;\u0026gt;First Element\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;myClass\u0026#34;\u0026gt;Second Element\u0026lt;/div\u0026gt; // JavaScript const firstElement = document.querySelector(\u0026#39;.myClass\u0026#39;); console.log(firstElement.innerText); // Output: // \u0026#34;First Element\u0026#34; e) document.querySelectorAll() Returns all elements that match the CSS selector.\n\u0026lt;!-- HTML --\u0026gt; \u0026lt;div class=\u0026#34;myClass\u0026#34;\u0026gt;First Element\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;myClass\u0026#34;\u0026gt;Second Element\u0026lt;/div\u0026gt; // JavaScript const allElements = document.querySelectorAll(\u0026#39;.myClass\u0026#39;); allElements.forEach(el =\u0026gt; console.log(el.innerText)); // Output: // \u0026#34;First Element\u0026#34; // \u0026#34;Second Element\u0026#34; 2. DOM Properties a) innerText Gets or sets the text content of an element.\n\u0026lt;!-- HTML --\u0026gt; \u0026lt;div id=\u0026#34;textElement\u0026#34;\u0026gt;Original Text\u0026lt;/div\u0026gt; // JavaScript const element = document.getElementById(\u0026#39;textElement\u0026#39;); element.innerText = \u0026#39;Hello World\u0026#39;; console.log(element.innerText); // Output: // \u0026#34;Hello World\u0026#34; b) innerHTML Gets or sets the HTML content of an element.\n\u0026lt;!-- HTML --\u0026gt; \u0026lt;div id=\u0026#34;htmlElement\u0026#34;\u0026gt;Original Content\u0026lt;/div\u0026gt; // JavaScript const element = document.getElementById(\u0026#39;htmlElement\u0026#39;); element.innerHTML = \u0026#39;\u0026lt;span\u0026gt;Hello World\u0026lt;/span\u0026gt;\u0026#39;; console.log(element.innerHTML); // Output: // \u0026#34;\u0026lt;span\u0026gt;Hello World\u0026lt;/span\u0026gt;\u0026#34; c) textContent Gets or sets the text content of a node and its descendants.\n\u0026lt;!-- HTML --\u0026gt; \u0026lt;div id=\u0026#34;contentElement\u0026#34;\u0026gt;Original Content\u0026lt;/div\u0026gt; // JavaScript const element = document.getElementById(\u0026#39;contentElement\u0026#39;); element.textContent = \u0026#39;Hello World\u0026#39;; console.log(element.textContent); // Output: // \u0026#34;Hello World\u0026#34; d) style Gets or sets inline styles of an element.\n\u0026lt;!-- HTML --\u0026gt; \u0026lt;div id=\u0026#34;styledElement\u0026#34;\u0026gt;Style Me\u0026lt;/div\u0026gt; // JavaScript const element = document.getElementById(\u0026#39;styledElement\u0026#39;); element.style.backgroundColor = \u0026#39;red\u0026#39;; element.style.fontSize = \u0026#39;16px\u0026#39;; // Result: Element with red background and font size of 16px 3. Events in JavaScript Events are actions that occur in a web page that can be detected by JavaScript.\nClick Event Example \u0026lt;!-- HTML --\u0026gt; \u0026lt;button id=\u0026#34;clickButton\u0026#34;\u0026gt;Click Me\u0026lt;/button\u0026gt; // JavaScript const button = document.getElementById(\u0026#39;clickButton\u0026#39;); button.addEventListener(\u0026#39;click\u0026#39;, function(e) { console.log(\u0026#39;Clicked!\u0026#39;); }); // Output when clicked: // \u0026#34;Clicked!\u0026#34; Mouse Over Event Example \u0026lt;!-- HTML --\u0026gt; \u0026lt;div id=\u0026#34;hoverElement\u0026#34;\u0026gt;Hover Over Me\u0026lt;/div\u0026gt; // JavaScript const element = document.getElementById(\u0026#39;hoverElement\u0026#39;); element.addEventListener(\u0026#39;mouseover\u0026#39;, function(e) { console.log(\u0026#39;Mouse over!\u0026#39;); }); // Output when hovered: // \u0026#34;Mouse over!\u0026#34; ","permalink":"http://localhost:1313/posts/pages/js/domevents/","summary":"A complete reference guide for DOM manipulation and Events","title":"Javascript : Dom and Events"},{"content":"Asynchronous Programming in JavaScript Asynchronous programming allows a program to perform multiple tasks simultaneously. It enables non-blocking operations, making it possible to execute long-running tasks without freezing the main program.\nFor example:\nconsole.log(\u0026#39;Start\u0026#39;); setTimeout(() =\u0026gt; { console.log(\u0026#39;This message is delayed by 2 seconds\u0026#39;); }, 2000); console.log(\u0026#39;End\u0026#39;); When you run this code, the output will be:\nStart\rEnd\rThis message is delayed by 2 seconds Explanation:\nconsole.log('Start'); is executed, and \u0026ldquo;Start\u0026rdquo; is printed. setTimeout() sets up a callback function to run after 2000 milliseconds (2 seconds) but does not block the next line. console.log('End'); is executed immediately after, and \u0026ldquo;End\u0026rdquo; is printed. After 2 seconds, the callback function in setTimeout() is executed, and \u0026ldquo;This message is delayed by 2 seconds\u0026rdquo; is printed. This demonstrates how asynchronous functions like setTimeout() work without blocking the execution of subsequent code.\nPromises Promises are a way to handle asynchronous operations in JavaScript. They represent a value that may be available now, in the future, or never. Promises can be in one of three states: pending, fulfilled, or rejected. They allow us to run code when the promise is fulfilled or rejected using the .then() and .catch() methods.\nSyntax to create a new Promise:\nconst promise = new Promise((resolve, reject) =\u0026gt; { // Perform an asynchronous operation // If successful, call resolve(value) // If an error occurs, call reject(error) }); Why We Use Promises Consider the following code:\nfunction main() { setTimeout(() =\u0026gt; { console.log(\u0026#34;Hello\u0026#34;); }, 1000); } main(); main(); main(); This code waits for 1 second and then logs \u0026ldquo;Hello\u0026rdquo; three times instantly. But what if we want to wait for the first to be completed before the second?\nThis can be solved using promises:\nfunction promise() { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { console.log(\u0026#34;Hello\u0026#34;); resolve(\u0026#34;Done\u0026#34;); }, 2000); }); } let data = promise(); When a promise is called, it returns a promise object instantly in a pending state. When the asynchronous operation completes, the promise is either fulfilled or rejected.\nHandling Promises To do a task when the promise is fulfilled (resolved):\ndata.then((data) =\u0026gt; { console.log(data); }); To do a task when the promise is rejected:\ndata.catch((err) =\u0026gt; { console.log(\u0026#34;Promise rejected\u0026#34;, err); }); Handling Multiple Promises function promise1() { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { console.log(\u0026#34;Promise 1 resolved\u0026#34;); resolve(\u0026#34;Done 1\u0026#34;); }, 2000); }); } function promise2() { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { console.log(\u0026#34;Promise 2 resolved\u0026#34;); resolve(\u0026#34;Done 2\u0026#34;); }, 2000); }); } function promise3() { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { console.log(\u0026#34;Promise 3 resolved\u0026#34;); resolve(\u0026#34;Done 3\u0026#34;); }, 2000); }); } let data1 = promise1(); let data2 = promise2(); let data3 = promise3(); How Promises Work:\npromise1 is called. promise2 is called immediately. promise3 is called immediately, regardless of whether the previous promises are resolved. To execute promises one by one:\nlet data1 = promise1(); data1.then((data) =\u0026gt; { console.log(data); return promise2(); }).then((data) =\u0026gt; { console.log(data); return promise3(); }).then((data) =\u0026gt; { console.log(data); }).catch((err) =\u0026gt; { console.log(\u0026#34;Error\u0026#34;, err); }); Here, the first promise will run, then the second, then the third, and so on, one by one.\nAsync and Await Async functions always return a promise. await is used to wait for a promise to be resolved, such that the code below it will not run until the promise is resolved.\nTo use await, we need to use an async function:\nasync function main() { console.log(\u0026#34;Hello\u0026#34;); } main(); Example with await:\nlet promise = new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { resolve(\u0026#34;Done\u0026#34;); }, 2000); }); async function main() { console.log(\u0026#34;Hello\u0026#34;); await promise; console.log(\u0026#34;Hello again\u0026#34;); } main(); console.log(\u0026#34;Hi\u0026#34;); What happens here is the main function is called, it prints \u0026ldquo;Hello\u0026rdquo;, then waits for 2 seconds to resolve. During that time, it prints \u0026ldquo;Hi\u0026rdquo;. When the promise is resolved, it prints \u0026ldquo;Hello again\u0026rdquo;.\nWhen await is called, the function pauses its execution until the promise is resolved. Then it continues the execution of the function, such that code below await will not run until the promise is resolved, but the code outside the function will run.\nasync function main() { console.log(\u0026#34;Hello\u0026#34;); await promise; await promise; await promise; console.log(\u0026#34;Hello again\u0026#34;); } Here, the first promise is resolved, then the second is resolved, and so on.\n","permalink":"http://localhost:1313/posts/pages/js/asyncronous/","summary":"A complete guide to asynchronous programming in JavaScript, covering promises and async/await.","title":"Asynchronous Programming in JavaScript"},{"content":"Basics of Vim Vim is a powerful text editor, often used in the command line, that is known for its efficiency and speed once mastered. Here are the basic commands and modes that you need to get started.\nOpening a File To open a file in Vim, use the following command:\nvim filename Replace filename with the name of the file you wish to open.\nBasic Modes in Vim Vim operates in different modes, and understanding these modes is crucial for using Vim effectively:\nNormal Mode: This is the default mode when you open a file. In this mode, you can navigate, delete, copy, and paste text. To return to Normal Mode from other modes, press Esc.\nInsert Mode: This mode allows you to insert text into the file. To enter Insert Mode, press i. After you\u0026rsquo;re done typing, press Esc to go back to Normal Mode.\nCommon Commands Here are some essential commands for working with files in Vim:\nSave the current file:\n:w This writes (saves) changes to the file.\nQuit Vim:\n:q To quit Vim. If there are unsaved changes, Vim will warn you. You can force quit without saving using:\n:q! Save changes and quit:\n:wq or\n:x These commands save changes and then exit Vim.\nTips for Beginners Press Esc frequently to return to Normal Mode, as it helps you avoid unintended actions while in other modes. Practice using both Normal and Insert modes to become comfortable with the flow of editing and saving files in Vim. Vim can be intimidating at first, but with practice, it becomes an extremely efficient tool for editing text files, especially in programming and development environments. ","permalink":"http://localhost:1313/posts/pages/linux/vim_basics_guide/","summary":"Learn the basics of using Vim, including navigation, saving, and quitting.","title":"Basics of Vim"},{"content":"Docker Cheat Sheet: Commands and Concepts This guide covers essential Docker commands, from creating containers, managing images, building Dockerfiles, to working with volumes.\n🚀 Creating and Running Containers 1. Run a Container from an Image To create and run a container from an image:\ndocker run image 2. Run a Container in Interactive Mode To run a container and open its terminal:\ndocker run -it image After the container starts, you can interact with it directly in the terminal. 3. Name a Container To give a container a specific name:\ndocker run --name container_name image 4. Port Mapping To map a port from your computer to the container:\ndocker run -p computer_port:container_port image Incoming traffic to computer_port will be forwarded to container_port in the container. 5. Run a Container in the Background (Detached Mode) To run the container in the background:\ndocker run -d image 6. Passing Environment Variables to a Container To pass environment variables to a container:\ndocker run -e key=value image 🛠️ Managing Containers 7. Start a Container To start an existing container:\ndocker start container_id 8. Stop a Container To stop a running container:\ndocker stop container_id 9. Remove a Container To remove a container:\ndocker rm container_id Note: The container must be stopped before removal. 10. Execute a Command in a Running Container To start a terminal session inside a running container:\ndocker exec -it container_id bash 11. View Running Containers To list all currently running containers:\ndocker ps 12. View All Containers (Running and Stopped) To see all containers, including those that are stopped:\ndocker ps -a 🧱 Building Docker Images 13. Creating a Dockerfile A Dockerfile is a script used to build Docker images. Here’s an example of common Dockerfile commands:\n# Set the base image for your container FROM base_image # Run commands during the image build process RUN command # Copy files from your local machine to the container COPY source /path/in/container # Set environment variables ENV key=value # Expose a port for the container EXPOSE 8080 # Define the command to run when the container starts CMD [\u0026#34;executable\u0026#34;] # Optionally, run commands automatically when the container starts ENTRYPOINT [\u0026#34;/path/to/script\u0026#34;] # Set the working directory in the container WORKDIR /app # Copy all files from the local directory to the container, excluding files listed in .dockerignore COPY . . 14. Building a Docker Image To build a Docker image from a Dockerfile:\ndocker build -t image_name /path/to/Dockerfile 📂 Managing Docker Files 15. Using the .dockerignore File The .dockerignore file helps exclude unnecessary files from being copied into the Docker image, improving build speed and reducing image size:\nnode_modules/ .git/ 16. COPY Command in Dockerfile The COPY command copies files from your local system to the container:\nCopy all files from the current directory to the container: COPY . /path/in/container Copy a specific file: COPY ./filename.extension /path/in/container Copy an entire folder: COPY ./foldername /path/in/container Copy contents of a folder (not the folder itself): COPY ./foldername/ /path/in/container 📦 Working with Volumes 17. Mounting Volumes Volumes allow data to persist even if the container is deleted. To mount a folder from your host to the container:\ndocker run -it -v /path/on/host:/path/in/container image Example: docker run -it -v /home/user/backup:/app/data ubuntu This will map /home/user/backup on your host to /app/data inside the container. Use Cases for Volumes: Data Persistence: Preserve data even after the container is removed. Backups: Easily back up container data to the host. Shared Data: Share data between multiple containers or between host and container. 💾 Publishing Docker Images 18. Pushing an Image to Docker Hub To publish an image to Docker Hub:\nTag the image with your Docker Hub username: docker tag image_name username/image_name Log in to Docker Hub: docker login Push the image to your repository: docker push username/image_name This guide gives you the essentials for working with Docker. With these commands, you\u0026rsquo;ll be able to manage containers, build images, use volumes, and more effectively.\n","permalink":"http://localhost:1313/posts/pages/docker/docker_basics/","summary":"A guide to understanding Docker commands and concepts.","title":"Docker Basic: Commands and Concepts"},{"content":"Docker Compose Documentation Introduction Docker Compose is a tool for defining and running multi-container Docker applications. With Docker Compose, you can use a YAML file to configure your application\u0026rsquo;s services and create and start all the services from your configuration with a single command.\nBasic docker-compose.yml Structure The docker-compose.yml file is where you define the services that make up your app. A typical file might look like this:\nversion: \u0026#39;3.8\u0026#39; services: service_name: image: image_name:tag ports: - \u0026#34;host_port:container_port\u0026#34; environment: - ENV_VAR=value volumes: - \u0026#34;host_path:container_path\u0026#34; depends_on: - dependency_service Example Configurations Example 1: Basic Setup with PostgreSQL and Redis version: \u0026#39;3.8\u0026#39; services: postgres: image: postgres ports: - \u0026#34;5432:5432\u0026#34; environment: POSTGRES_USER: postgres POSTGRES_DB: review POSTGRES_PASSWORD: password redis: image: redis ports: - \u0026#34;80:80\u0026#34; Example 2: Real-World Application version: \u0026#39;3\u0026#39; services: pythonapp: image: your-python-image:tag ports: - \u0026#34;8000:8000\u0026#34; volumes: - /Users/data:/src/bin/data depends_on: - db - redis db: image: postgres environment: POSTGRES_DB: mydatabase POSTGRES_USER: myuser POSTGRES_PASSWORD: mypassword redis: image: redis volumes: - /path/to/local/directory:/data Example 3: Building from Dockerfile version: \u0026#39;3\u0026#39; services: pythonapp: build: context: . dockerfile: Dockerfile ports: - \u0026#34;8000:8000\u0026#34; volumes: - /Users/desktop:/src/bin/desktop depends_on: - db - redis db: image: postgres environment: POSTGRES_DB: mydatabase POSTGRES_USER: myuser POSTGRES_PASSWORD: mypassword redis: image: redis volumes: - /path/to/local/directory:/data Example 4: Django Application with PostgreSQL and Redis version: \u0026#39;3.8\u0026#39; services: django-app: container_name: django-app image: django-app:latest # Replace with your actual Django image name/tag ports: - \u0026#34;8000:8000\u0026#34; # Expose Django app on port 8000 environment: - DEBUG=1 # Set Django debug mode to 1 for development - POSTGRES_HOST=postgres # PostgreSQL host - POSTGRES_DB_NAME=nirajan # PostgreSQL database name - POSTGRES_DB_PASSWORD=nirajan@9845 # PostgreSQL database password - REDIS_URL=redis://redis:6379/0 # Redis URL depends_on: - postgres - redis volumes: - static_volume:/code/static # Volume for Django static files - media_volume:/code/media # Volume for Django media files postgres: container_name: postgres image: postgres:latest environment: POSTGRES_DB: nirajan # Database name POSTGRES_USER: nirajan # Database username POSTGRES_PASSWORD: nirajan@9845 # Database password volumes: - postgres_data:/var/lib/postgresql/data redis: container_name: redis image: redis:latest ports: - \u0026#34;6379:6379\u0026#34; Service Names as Hostnames In Docker Compose, the names of the services defined in the docker-compose.yml file are used as hostnames for inter-service communication.\nService Names as Hostnames Each service name in the docker-compose.yml file acts as a hostname for that service. For example, in the configuration above:\nThe django-app service can connect to the postgres service using POSTGRES_HOST=postgres. The django-app service can connect to the redis service using REDIS_URL=redis://redis:6379/0. Example In the django-app service:\nPostgreSQL Host: POSTGRES_HOST=postgres — The Django app connects to the PostgreSQL service using the hostname postgres, which matches the name of the PostgreSQL service defined in Docker Compose. Redis Host: REDIS_URL=redis://redis:6379/0 — The Django app connects to the Redis service using the hostname redis, which matches the name of the Redis service defined in Docker Compose. Note: In Docker, services within a Docker Compose setup are typically connected to the same network by default. This allows containers to communicate with each other using service names as hostnames.\nDocker Compose Commands To start the containers defined in docker-compose.yml:\nsudo docker compose up To stop and remove all containers, networks, and volumes created by docker-compose up:\nsudo docker compose down To run the containers in the background (detached mode):\nsudo docker compose up -d Tips Use depends_on to specify dependencies between services. This ensures that the dependent services start in the correct order. Use volumes to persist data outside of your containers, which is especially useful for databases. Use environment variables to configure your services and avoid hardcoding sensitive information. Conclusion Docker Compose simplifies the process of managing multi-container Docker applications. By defining your services in a docker-compose.yml file, you can easily spin up your entire application stack with a single command. This guide provides a solid starting point for using Docker Compose to manage multi-container applications effectively.\n","permalink":"http://localhost:1313/posts/pages/docker/docker_compose/","summary":"Learn how to define and manage services in Docker Compose.","title":"Docker Compose Documentation"},{"content":"Docker CPU and Memory Limits When you want to control the CPU and memory usage of Docker containers, you can use specific options in both Docker CLI commands and Docker Compose files. Here\u0026rsquo;s a detailed guide on how to use these options:\nDocker CLI Commands Setting CPU Limits:\nOption: --cpus Usage: Specifies the number of CPUs that the container can use. Example: docker run --cpus=\u0026#34;1.5\u0026#34; my-image The --cpus option limits the container to 1.5 CPU cores. Setting Memory Limits:\nOption: --memory or -m\nUsage: Sets the maximum amount of memory the container can use.\nExample:\ndocker run --memory=\u0026#34;500m\u0026#34; my-image This command limits the container to 500MB of RAM. If the limit is exceeded, the container will be throttled or terminated.\nNote: The options take a positive integer followed by suffixes such as b, k, m, or g to indicate bytes, kilobytes, megabytes, or gigabytes.\nSoft Memory Limits:\nOption: --memory-reservation Example: docker run --memory=\u0026#34;1g\u0026#34; --memory-reservation=\u0026#34;512m\u0026#34; nginx This reserves 512MB of memory while setting a hard limit of 1GB. Docker Compose Configuration In Docker Compose, you can define resource limits under the deploy section for version 3.x or directly under the services section for version 2.x.\nSetting CPU and Memory Limits in Docker Compose (Version 2.x):\nversion: \u0026#39;2\u0026#39; services: my-service: image: my-image deploy: resources: limits: cpus: \u0026#39;1.5\u0026#39; memory: 500M This limits the service to 1.5 CPUs and 500MB of memory.\nSetting CPU and Memory Limits in Docker Compose (Version 3.x and above):\nversion: \u0026#39;3.8\u0026#39; services: my-service: image: my-image deploy: resources: limits: cpus: \u0026#39;1.5\u0026#39; memory: \u0026#39;500M\u0026#39; This limits the service to 1.5 CPUs and 500MB of memory.\nNotes: Swap Memory: You can enable swap memory using the --memory-swap option in CLI. For example:\ndocker run --memory=\u0026#34;512m\u0026#34; --memory-swap=\u0026#34;1g\u0026#34; nginx CPU Shares: Set CPU priorities between containers using --cpu-shares, with 1024 being the default.\nBy using these options, you can ensure that your Docker containers use resources efficiently, preventing them from overwhelming the host machine.\n","permalink":"http://localhost:1313/posts/pages/docker/docker_cpu_memory_limits_guide/","summary":"Control the CPU and memory usage of Docker containers with CLI and Docker Compose configurations.","title":"Docker CPU and Memory Limits"},{"content":"Docker Networking and Port Access In Docker, containers are isolated by default, meaning:\nContainers cannot access the host machine\u0026rsquo;s ports directly. Containers cannot access the ports of other containers directly. Container ports are not accessible from outside the host machine unless configured. 🛠️ Accessing Container Ports from Outside To access a container\u0026rsquo;s port from outside (e.g., from the host or another machine), you can use port mapping:\n1. Port Mapping docker run -p host_port:container_port imagename This command maps a container\u0026rsquo;s port to a port on the host machine. 2. Host Network To share the host\u0026rsquo;s network namespace with the container:\ndocker run --network host imagename 🌐 Accessing Container Ports from Another Container To allow inter-container communication, you need to create and use a custom Docker network.\nSteps: 1. Create a Docker Network docker network create my_network 2. Run Containers in the Same Network docker run --network my_network --name container1 imagename docker run --network my_network --name container2 imagename 3. Access One Container from Another Use the container name and port to access one container from another:\ncontainer1:port Example Scenario Create a Network docker network create my_network Run First Container docker run --network my_network --name webserver -d nginx Run Second Container docker run --network my_network --name client -it alpine /bin/sh Access Web Server from Client Inside the client container, use the following commands to access the web server: wget -qO- http://webserver or\ncurl http://webserver 📝 Important Notes Container-to-Container Access: Containers in the same custom network can communicate using their names as hostnames. Host Machine Access: Containers cannot directly access the host machine\u0026rsquo;s ports. External Access: Use port mapping or host networking to access container ports from outside the host machine. List Docker Networks To list all available Docker networks and verify the existence of custom networks:\ndocker network ls ","permalink":"http://localhost:1313/posts/pages/docker/docker_networking_guide/","summary":"Understanding Docker networking and inter-container communication.","title":"Docker Networking and Port Access"},{"content":" 1. Configure Git To set up your Git username and email globally on your machine:\ngit config --global user.name \u0026#34;username\u0026#34; # Set your Git username git config --global user.email \u0026#34;email\u0026#34; # Set your Git email git config --list # Display the current Git configuration (username and email) 2. Git Status and Git Clone Clone a remote repository to your local machine:\ngit clone \u0026lt;url\u0026gt; # Copy repository to the local machine Check the status of your local repository:\ngit status # Show the current status of the repository Git Status Breakdown: untracked: A new file that has not been added or committed. unstaged: A file that has been added but not committed. unchanged: No changes have been made. changed: Changes have been made but not yet added or committed. 3. Git Add and Commit Add specific files or all changes and commit them:\ngit add \u0026lt;filename\u0026gt; # Add a specific file to the staging area git add . # Add all changes (modified and untracked files) git commit -m \u0026#34;Your commit message\u0026#34; # Commit the changes with a message 4. Push Local Repo to Remote To upload your local repository changes to the remote repository:\ngit push [alias] [branch] # Push changes to a specific alias and branch git remote add \u0026lt;alias\u0026gt; \u0026lt;url\u0026gt; # Add a remote alias (e.g., \u0026#39;origin\u0026#39;) git push -u [alias] [branch] # Save the alias and branch for future pushes 5. Git Initialization Initialize a new Git repository:\ngit init # Initialize a new Git repository 6. Git Branches Manage Git branches with the following commands:\ngit branch # List all local branches git branch -m \u0026lt;oldbranch\u0026gt; \u0026lt;newbranch\u0026gt; # Rename a branch git checkout \u0026lt;branchname\u0026gt; # Switch to another branch git checkout -b \u0026lt;branchname\u0026gt; # Create and switch to a new branch git branch -d \u0026lt;branchname\u0026gt; # Delete a branch (ensure you\u0026#39;re not on it) git diff \u0026lt;branchname\u0026gt; # Compare the current branch with another 7. Git Merge Merge changes from one branch into another:\ngit merge \u0026lt;branchname\u0026gt; # Merge changes from \u0026lt;branchname\u0026gt; into the current branch 8. Pull Request and Syncing Changes To pull updates from the remote repository to your local one:\ngit pull # Pull the latest changes from the remote repository git pull [alias] [branch] # Pull changes from a specific alias and branch 9. Undoing Changes If You Have Only Added Changes: git reset \u0026lt;filename\u0026gt; # Unstage a file from the staging area git reset # Unstage all files that have been added If You Have Committed Changes: git reset HEAD~1 # Undo the last commit (one step back) git reset \u0026lt;commit_hash\u0026gt; # Reset to a specific commit hash git reset --hard \u0026lt;commit_hash\u0026gt; # Hard reset to a commit and reflect changes in your editor git log # View all commit hashes and logs 10. Forking Repositories When contributing to open-source projects, you can fork a repository, which creates a copy of the repo under your GitHub account. Afterward, you can make changes and submit a pull request:\n# Fork a repository on GitHub and clone it locally git clone \u0026lt;forked_repo_url\u0026gt; # Clone your forked repository Make changes, commit them, and push to your fork. Finally, create a pull request on GitHub to merge your changes into the original repository.\nIF ANY CONCEPT IS LAGGING THEN: Watch this helpful video\n","permalink":"http://localhost:1313/posts/pages/git/git-cheetsheet/","summary":"A brief tutorial on github recipe and git command","title":"Git Commands and Configuration Guide"},{"content":"How to Create Content for Hugo Using Markdown Hugo, a static site generator, uses Markdown (.md) files to generate content. In this guide, we will explain how you can create content for Hugo using Markdown.\n1. Front Matter Every Markdown file in Hugo requires front matter, which is metadata placed at the top of the file. It helps Hugo understand how to process the file.\nExample:\n--- title: \u0026#34;My First Hugo Post\u0026#34; date: 2024-10-18 tags: [\u0026#34;Hugo\u0026#34;, \u0026#34;Markdown\u0026#34;] summary: \u0026#34;A brief summary of the post.\u0026#34; --- 2. Headers Headers are used to organize content. Use one # for an H1 header, two ## for H2, and so on.\nExample:\n# H1 Header ## H2 Header ### H3 Header Output:\nH3 Header 3. Text Formatting Markdown supports several text formatting options:\nExample:\n**Bold Text** *Italic Text* ~~Strikethrough~~ Output: Bold Text\nItalic Text\nStrikethrough\n4. Spacing and Line Breaks In Markdown, you can create paragraphs by leaving a blank line between lines of text.\nExample:\nThis is the first paragraph. This is the second paragraph. Output: This is the first paragraph.\nThis is the second paragraph.\n5. Horizontal Rules You can create horizontal lines (dividers) using three or more dashes (---), asterisks (***), or underscores (___).\nExample:\n--- Output:\n6. Lists Create unordered lists with - or *, and ordered lists with numbers followed by periods.\nExample:\n- Item 1 - Item 2 1. First item 2. Second item Output:\nItem 1 Item 2 First item Second item 7. Links and Images Add links and images with square brackets [] and parentheses ().\nExample:\n[Hugo Documentation](https://gohugo.io) ![Hugo Logo](/images/hugo.webp) Output: Hugo Documentation\n8. Code Blocks For inline code, use backticks. For block code, use triple backticks.\nExample:\nInline code: `print(\u0026#34;Hello World\u0026#34;)` Output: Inline code: print(\u0026quot;Hello World\u0026quot;)\nExample:\nBlock Code: def hello(): print(\u0026#34;Hello, Hugo!\u0026#34;) def hello(): print(\u0026#34;Hello, Hugo!\u0026#34;) 9. Blockquotes Use the greater than symbol (\u0026gt;) to create blockquotes.\nExample:\n\u0026gt; This is a blockquote in Hugo. Output:\nThis is a blockquote in Hugo.\n10. Tables You can create tables using pipes | and dashes -.\nExample:\n| Column 1 | Column 2 | |----------|----------| | Row 1 | Data 1 | | Row 2 | Data 2 | Output:\nColumn 1 Column 2 Row 1 Data 1 Row 2 Data 2 11. Task Lists Create task lists by using square brackets []. An x in the brackets [x] marks a task as completed.\nExample:\n- [ ] Task 1 - [x] Task 2 (Completed) Output:\nTask 1 Task 2 (Completed) 12. Syntax Highlighting Hugo supports syntax highlighting for various programming languages. You can specify the language after the triple backticks(```).\nExample: Output:\ndef greet(): print(\u0026#34;Hello, Hugo!\u0026#34;) 12. Task Lists Create task lists by using square brackets []. An x in the brackets [x] marks a task as completed.\nExample:\n- [ ] Task 1 - [ ] Sub-task 1 - [x] Sub-task 2 (Completed) - [x] Task 2 (Completed) Output:\nTask 1 Sub-task 1 Sub-task 2 (Completed) Task 2 (Completed) 13. Escaping Special Characters To use special characters like #, escape them using a backslash \\.\nExample:\n\\# This is not a header Output: # This is not a header\n14. Backtick To display backtick use four space before it as\n``` 15. Consistency It\u0026rsquo;s important to maintain consistent formatting throughout your Markdown files to ensure a clean and readable structure.\nBy following these steps, you can effectively create well-formatted content for your Hugo site using Markdown.\n","permalink":"http://localhost:1313/posts/pages/hugo/markdown_hugo_content_guide/","summary":"A tutorial on creating content with Markdown in Hugo.","title":"How to Create Content for Hugo"},{"content":"JavaScript Reference Behavior: Objects and Arrays Introduction In JavaScript, both objects and arrays are considered reference types. This means that when you assign an object or an array to another variable, you’re not creating a new copy of that object or array. Instead, the new variable holds a reference to the original object or array in memory. Understanding this concept is crucial because it directly affects how data is manipulated and shared within your code.\nObject Reference Behavior 1. Overview When you work with objects in JavaScript, it\u0026rsquo;s essential to recognize that assigning an object to a new variable does not create a new object. Instead, it creates a reference to the original object. This means that any changes made through the new reference will affect the original object.\n2. Example const person = { name: \u0026#34;Alice\u0026#34;, address: { city: \u0026#34;Wonderland\u0026#34; } }; const newPerson = person.address; // newPerson now references the same object as person.address newPerson.city = \u0026#34;New Wonderland\u0026#34;; // modifying newPerson affects the original object console.log(person); // Output: { name: \u0026#39;Alice\u0026#39;, address: { city: \u0026#39;New Wonderland\u0026#39; } } ## JavaScript Reference Behavior: Objects and Arrays ### Introduction In JavaScript, both objects and arrays are considered reference types. This means that when you assign an object or an array to another variable, you’re not creating a new copy of that object or array. Instead, the new variable holds a reference to the original object or array in memory. Understanding this concept is crucial because it directly affects how data is manipulated and shared within your code. ### Object Reference Behavior #### 1. Overview When you work with objects in JavaScript, it\u0026#39;s essential to recognize that assigning an object to a new variable does not create a new object. Instead, it creates a reference to the original object. This means that any changes made through the new reference will affect the original object. #### 2. Example ```javascript const person = { name: \u0026#34;Alice\u0026#34;, address: { city: \u0026#34;Wonderland\u0026#34; } }; const newPerson = person.address; // newPerson now references the same object as person.address newPerson.city = \u0026#34;New Wonderland\u0026#34;; // modifying newPerson affects the original object console.log(person); // Output: { name: \u0026#39;Alice\u0026#39;, address: { city: \u0026#39;New Wonderland\u0026#39; } } 3. Explanation Object Reference: When you create const newPerson = person.address;, you\u0026rsquo;re not making a copy of the address object. Instead, newPerson references the same address object that person.address references. Thus, when you update newPerson.city = \u0026quot;New Wonderland\u0026quot;;, it directly modifies the person.address object because both newPerson and person.address are pointing to the same location in memory. Output: The console logs the person object, which now reflects the change: { name: 'Alice', address: { city: 'New Wonderland' } }. Array Reference Behavior 1. Overview Arrays in JavaScript behave similarly to objects in terms of reference handling. When you assign an array to another variable, you create a reference to the original array. As a result, any modifications through this reference will affect the original array.\n2. Example const numbers = [1, 2, 3]; const moreNumbers = numbers; // moreNumbers now references the same array as numbers moreNumbers[0] = 99; // modifying moreNumbers affects the original array console.log(numbers); // Output: [99, 2, 3] 3. Explanation Array Reference: When you create const moreNumbers = numbers;, you\u0026rsquo;re not creating a new array. Instead, moreNumbers becomes a reference to the same array that numbers references. Any changes to moreNumbers, such as moreNumbers[0] = 99, directly modify the numbers array because both variables point to the same array in memory. Output: The console logs the numbers array, which now reflects the change: [99, 2, 3]. Key Takeaways Reference Types: Both objects and arrays are reference types in JavaScript, meaning that variables assigned to them hold references to the same data in memory. Shared Modifications: Changes made to an object or array through one reference will affect all other references to that same object or array. Memory Efficiency: This reference behavior allows for memory-efficient data management but requires careful handling to avoid unintended side effects. JavaScript References with filter() and find() In JavaScript, the way references work with methods like filter() and find() is different, leading to distinct behaviors. Understanding these differences is crucial for working effectively with arrays and avoiding unintended side effects.\nfilter(): Creating a New Array 1. Overview The filter() method in JavaScript creates a new array that contains only the elements that satisfy the provided condition. This means that a new array is returned, and it does not affect the original array. However, if the elements in the array are objects, the references to these objects are retained, meaning any modifications to the objects in the new array will also affect the original array.\n2. Example const originalArray = [ { id: 1, name: \u0026#34;Alice\u0026#34; }, { id: 2, name: \u0026#34;Bob\u0026#34; }, { id: 3, name: \u0026#34;Charlie\u0026#34; } ]; const filteredArray = originalArray.filter(item =\u0026gt; item.id !== 2); // Modify an object in the filtered array filteredArray[0].name = \u0026#34;Alicia\u0026#34;; console.log(originalArray); // Output: [{ id: 1, name: \u0026#39;Alicia\u0026#39; }, { id: 2, name: \u0026#39;Bob\u0026#39; }, { id: 3, name: \u0026#39;Charlie\u0026#39; }] console.log(filteredArray); // Output: [{ id: 1, name: \u0026#39;Alicia\u0026#39; }, { id: 3, name: \u0026#39;Charlie\u0026#39; }] 3. Explanation New Array Creation: The filter() method creates a new array (filteredArray) that includes all elements from originalArray except the one with id 2. However, the objects within the new array are still references to the original objects in originalArray. Shared References: When you modify the name property of the first object in filteredArray (filteredArray[0].name = \u0026quot;Alicia\u0026quot;;), it also changes in originalArray because both arrays reference the same object in memory. Output: The original array shows that the name of the first object has been changed to \u0026ldquo;Alicia\u0026rdquo;, indicating that the object references are shared. find(): Returning a Single Element Reference 1. Overview The find() method returns the first element in the array that satisfies the provided condition. This element is not a copy but a reference to the original element in the array. As a result, any modification to this element directly affects the original array.\n2. Example const originalArray = [ { id: 1, name: \u0026#34;Alice\u0026#34; }, { id: 2, name: \u0026#34;Bob\u0026#34; }, { id: 3, name: \u0026#34;Charlie\u0026#34; } ]; const foundItem = originalArray.find(item =\u0026gt; item.id === 2); // Modify the found item foundItem.name = \u0026#34;Robert\u0026#34;; console.log(originalArray); // Output: [{ id: 1, name: \u0026#39;Alice\u0026#39; }, { id: 2, name: \u0026#39;Robert\u0026#39; }, { id: 3, name: \u0026#39;Charlie\u0026#39; }] console.log(foundItem); // Output: { id: 2, name: \u0026#39;Robert\u0026#39; } 3. Explanation Element Reference: The find() method returns a reference to the first element that meets the condition (item.id === 2). In this case, foundItem references the same object in memory as the element in originalArray with id: 2. Direct Modification: When you modify the name property of foundItem (foundItem.name = \u0026quot;Robert\u0026quot;;), it directly alters the corresponding object in originalArray because they are the same object in memory. Output: The original array now shows that the name of the object with id: 2 has been changed to \u0026ldquo;Robert\u0026rdquo;, demonstrating that the reference was modified. Key Differences Between filter() and find() New Array vs. Single Element: filter(): Returns a new array containing references to elements that meet the condition. find(): Returns a reference to the first element that meets the condition. Impact on Original Array: filter(): The original array remains unchanged, but the objects within the new array are still references to the original objects. find(): The original array can be directly modified through the returned element. Use Cases: Use filter() when you need a subset of the original array without altering it directly. Use find() when you need to retrieve and possibly modify a specific element from the array. Conclusion Understanding how references work with methods like filter() and find() is crucial in JavaScript. While filter() returns a new array that retains references to the original objects, find() returns a direct reference to a single element. Being aware of these behaviors helps prevent unintended modifications to your data.\n","permalink":"http://localhost:1313/posts/pages/js/referencebehavious/","summary":"Learn about reference types in JavaScript, including objects and arrays, and how methods like filter() and find() handle references.","title":"JavaScript Reference Behavior: Objects and Arrays"},{"content":"JavaScript Reference Guide 1. Console.log() Method Purpose: Prints output to the console, useful for debugging. Syntax: console.log(value); Example: const name = \u0026#39;John\u0026#39;; console.log(name); // Output: John 2. Variables: let, const let: Block-scoped variable that can be updated but not accessed before declaration.\nlet x = 10; if (true) { let x = 20; // Block-scoped console.log(x); // 20 } console.log(x); // 10 const: Block-scoped variable that cannot be reassigned and must be initialized when declared.\nconst pi = 3.14; // pi = 3.1415; // Error: Cannot reassign 3. JavaScript Data Types String\nExplanation: Represents a sequence of characters. Can be enclosed in single quotes, double quotes, or backticks (for template literals). Syntax: const str = 'Hello, World!'; Example: const greeting = \u0026#34;Hello, \u0026#34; + \u0026#34;World!\u0026#34;; // Output: Hello, World! Number\nExplanation: Represents both integer and floating-point numbers. JavaScript numbers range from -(2^53 - 1) to 2^53 - 1. Syntax: const num = 123; Example: const amount = 25; // Output: 25 BigInt\nExplanation: Represents integers with arbitrary precision. Denoted by appending an n to the end of the number. Syntax: const bigNum = 1234567890123456789012345678901234567890n; Example: const bigNumber = 1234567890123456789012345678901234567890n; Boolean\nExplanation: Represents a value that is either true or false. Syntax: const isTrue = true; Example: const isActive = Boolean(1); // Output: true Null\nExplanation: Represents the intentional absence of any value. Syntax: const emptyValue = null; Example: const noValue = null; Undefined\nExplanation: Represents a variable that has been declared but not assigned a value. Syntax: let uninitialized; Example: let value; console.log(value); // Output: undefined For Checking Data Type We Use: typeof variableName; 4. Explicit Type Conversion To String: String(value) or value.toString()\nlet str = String(123); // \u0026#39;123\u0026#39; To Number: Number(value), parseInt(value), or parseFloat(value)\nlet num = Number(\u0026#39;456\u0026#39;); // 456 To Boolean: Boolean(value)\nlet bool = Boolean(\u0026#39;hello\u0026#39;); // true 5. JavaScript Operators i) Comparison Operators Greater than: a \u0026gt; b Less than: a \u0026lt; b Greater than or equal to: a \u0026gt;= b Less than or equal to: a \u0026lt;= b Not equal to: a != b Equal to: a == b Strictly equal to: a === b Examples:\nconsole.log(\u0026#34;2\u0026#34; == 2); // true console.log(\u0026#34;2\u0026#34; === 2); // false ii) Logical Operators AND: operand1 \u0026amp;\u0026amp; operand2 OR: operand1 || operand2 NOT: !operand Examples:\nconsole.log(true \u0026amp;\u0026amp; false); // false console.log(true || false); // true console.log(!true); // false iii) Arithmetic Operators Addition: operand1 + operand2 Subtraction: operand1 - operand2 Multiplication: operand1 * operand2 Division: operand1 / operand2 Modulo: operand1 % operand2 Increment: operand++ Decrement: operand-- Examples:\nconsole.log(5 + 3); // 8 console.log(5 - 3); // 2 console.log(5 * 3); // 15 console.log(6 / 3); // 2 console.log(5 % 3); // 2 6. String Methods and Operations 1. Concatenation Explanation: Combines two or more strings into one. Syntax: string1 + string2 Returns: A new string combining the original strings. Example: let a = \u0026#39; My name is nirajan \u0026#39;; let b = \u0026#34;nirajan\u0026#34;; console.log(a + b + \u0026#34;Khatiwada\u0026#34;); // Output: \u0026#39; My name is nirajan nirajanKhatiwada\u0026#39; 2. Simple Form (String Boilerplate) Explanation: Uses template literals to embed expressions within a string. Syntax: ${expression} Returns: A new string with evaluated expressions. Example: let a = \u0026#39; My name is nirajan \u0026#39;; let b = \u0026#34;nirajan\u0026#34;; console.log(`${a}${b}khatiwada`); // Output: \u0026#39; My name is nirajan nirajankhatiwada\u0026#39; 3. Accessing Element of String Explanation: Retrieves the character at a specified index. Syntax: string[index] Returns: The character at the given index (or undefined if out of range). Example: let a = \u0026#39; My name is nirajan \u0026#39;; console.log(a[0]); // Output: \u0026#39; \u0026#39; 4. Finding Length of String Explanation: Gets the number of characters in the string. Syntax: string.length Returns: The length of the string as a number. Example: let a = \u0026#39; My name is nirajan \u0026#39;; console.log(a.length); // Output: 21 5. To Uppercase Explanation: Converts all characters in the string to uppercase. Syntax: string.toUpperCase() Returns: A new string with all characters in uppercase. Example: let a = \u0026#39; My name is nirajan \u0026#39;; console.log(a.toUpperCase()); // Output: \u0026#39; MY NAME IS NIRAJAN \u0026#39; 6. To Lowercase Explanation: Converts all characters in the string to lowercase. Syntax: string.toLowerCase() Returns: A new string with all characters in lowercase. Example: let a = \u0026#39; My name is nirajan \u0026#39;; console.log(a.toLowerCase()); // Output: \u0026#39; my name is nirajan \u0026#39; 8. String Slicing Explanation: Extracts a section of the string based on start and end indices. Syntax: string.slice(start, end) Returns: A new string containing the extracted section. Example: let a = \u0026#39; My name is nirajan \u0026#39;; console.log(a.slice(0, 4)); // Output: \u0026#39; My\u0026#39; 9. Trim Explanation: Removes whitespace from both ends of the string. Syntax: string.trim() Returns: A new string with whitespace removed from both ends. Example: let a = \u0026#39; My name is nirajan \u0026#39;; console.log(a.trim()); // Output: \u0026#39;My name is nirajan\u0026#39; 10. Replace Explanation: Replaces the first occurrence of a specified substring or pattern with a new substring. Syntax: string.replace(search, replacement) Returns: A new string with the specified substring replaced. Example: let a = \u0026#39; My name is nirajan \u0026#39;; console.log(a.replace(\u0026#34;nirajan\u0026#34;, \u0026#34;kirajan\u0026#34;)); // Output: \u0026#39; My name is kirajan \u0026#39; 11. Split Explanation: Splits the string into an array of substrings based on a separator. Syntax: string.split(separator, limit) Returns: An array of substrings. Example: let a = \u0026#39; My name is nirajan \u0026#39;; console.log(a.split(\u0026#34; \u0026#34;)); // Output: [\u0026#39; My\u0026#39;, \u0026#39;name\u0026#39;, \u0026#39;is\u0026#39;, \u0026#39;nirajan\u0026#39;] 7. Number Methods 1. toFixed() Explanation: Formats a number using fixed-point notation with a specified number of decimal places. Syntax: number.toFixed(digits); Returns: A string representing the number with the specified number of decimal places. Example: let c = 10.001; console.log(c.toFixed(10)); // Output: \u0026#39;10.0010000000\u0026#39; 2. Math.ceil() Explanation: Rounds a number up to the nearest integer. Syntax: Math.ceil(number); Returns: The smallest integer greater than or equal to the given number. Example: let a = 1.1000; console.log(Math.ceil(a)); // Output: 2 3. Math.floor() Explanation: Rounds a number down to the nearest integer. Syntax: Math.floor(number); Returns: The largest integer less than or equal to the given number. Example: console.log(Math.floor(a)); // Output: 1 4. Math.round() Explanation: Rounds a number to the nearest integer. Syntax: Math.round(number); Returns: The value of the number rounded to the nearest integer. Example: console.log(Math.round(a)); // Output: 1 5. Math.random() Explanation: Returns a pseudo-random floating-point number between 0 (inclusive) and 1 (exclusive). Syntax: Math.random(); Returns: A floating-point number between 0 (inclusive) and 1 (exclusive). Example: console.log(Math.random()); // Output: A random number between 0 and 1 8. Non-Primitive Data Types in JavaScript 1. Object Explanation: Objects are collections of key-value pairs. Keys are usually strings (or symbols) and values can be any data type. Syntax: let objectName = { key1: value1, key2: value2, // more key-value pairs }; Example: let data = { \u0026#34;name\u0026#34;: \u0026#34;nirajan\u0026#34;, \u0026#34;age\u0026#34;: 20 }; 2. Array Explanation: Arrays are ordered collections of values. Values can be of any data type and are accessed by their index. Syntax: let arrayName = [value1, value2, value3, ...]; Example: let a = [\u0026#34;nirajan\u0026#34;, \u0026#34;kirajan\u0026#34;, \u0026#34;birajan\u0026#34;]; 3. Function Explanation: Functions are blocks of code designed to perform a particular task. They can be invoked (called) to execute their code. Syntax: function functionName(parameters) { // code to be executed } Example: function outer() { console.log(\u0026#34;hi\u0026#34;); } outer(); // Output: hi 9. Array Methods 1. Indexing in Array Accessing Elements: Description: Arrays are zero-indexed, so the first element is at index 0. Returns: Value of the element at the specified index. Example: console.log(a[0]); // Output: 1 console.log(a[3]); // Output: 4 2. Slicing in Array Slicing: Description: Extracts a section of the array and returns it as a new array. Syntax: array.slice(startIndex, endIndex) Returns: A new array containing the elements from startIndex up to, but not including, endIndex. Example: console.log(a.slice(0, 2)); // Output: [1, 2] 3. Length of Array Description: Returns the number of elements in the array. Returns: Integer (length of the array). Example: console.log(a.length); // Output: 4 4. Push Description: Adds one or more elements to the end of the array. Returns: The new length of the array. Example: a.push(5); console.log(a); // Output: [1, 2, 3, 4, 5] 5. Pop Description: Removes the last element from the array. Returns: The removed element. Example: a.pop(); console.log(a); // Output: [1, 2, 3, 4] 6. Shift Description: Removes the first element from the array. Returns: The removed element. Example: a.shift(); console.log(a); // Output: [2, 3, 4] 7. Unshift Description: Adds one or more elements to the beginning of the array. Returns: The new length of the array. Example: a.unshift(0); console.log(a); // Output: [0, 1, 2, 3, 4] 8. Join Description: Joins all elements of an array into a string, separated by a specified separator. Returns: A string representing the array elements joined by the specified separator. Example: let data = a.join(\u0026#34; \u0026#34;); console.log(data); // Output: \u0026#34;1 2 3 4\u0026#34; 9. Concatenation of Two Arrays Description: Merges two or more arrays into one. Returns: A new array containing the elements of the original arrays. Example: let a2 = [5, 4, 1, 3, 4]; console.log(a.concat(a2)); // Output: [1, 2, 3, 4, 5, 4, 1, 3, 4] 10. Sort Description: Sorts the elements of an array in place. Returns: The sorted array. Example: a2.sort(); console.log(a2); // Output: [1, 3, 4, 4, 5] 11. Reverse Description: Reverses the order of the elements in the array. Returns: The reversed array. Example: a2.reverse(); console.log(a2); // Output: [5, 4, 4, 3, 1] 12. Removing Elements from a Specific Position Description: Changes the contents of an array by removing or replacing existing elements. Syntax: array.splice(index, numberOfElementsToRemove) Returns: An array containing the removed elements. Example: let newData = [1, 2, 3, 4]; newData.splice(1, 2); // Removes 2 elements starting at index 1 console.log(newData); // Output: [1, 4] 13. Inserting Elements at a Specific Position Description: Inserts elements into the array. Syntax: array.splice(index, 0, element1, element2, ...) Returns: An array containing the removed elements (empty if no elements were removed). Example: let lasrData = [1, 4]; lasrData.splice(1, 0, 2, 3); // Inserts elements 2 and 3 at index 1 console.log(lasrData); // Output: [1, 2, 3, 4] 14. Spread Operator (\u0026hellip;) Description: Spreads out elements of an array into another array or function arguments. Returns: A new array containing the elements spread from the original arrays. Example: let finalData = [...newData, ...lasrData]; console.log(finalData); // Output: [1, 4, 1, 2, 3, 4] 15. Array Destructuring Description: Allows unpacking values from arrays into distinct variables in a concise and readable way. Basic Syntax: const [var1, var2, var3] = array; Example: const numbers = [1, 2, 3]; const [first, second, third] = numbers; console.log(first); // Output: 1 console.log(second); // Output: 2 console.log(third); // Output: 3 10. Object in Js i. Defining an Object An object in JavaScript is a collection of key-value pairs. Each key (also known as a property) is a unique identifier, and the value can be anything: a string, number, array, function, or even another object. Example:\nconst myObject = { name: \u0026#34;Nirajan\u0026#34;, // String property class: \u0026#34;Bachelor\u0026#34;, // String property is_topper: \u0026#34;No\u0026#34;, // Boolean property (as a string) greet: function (from) { // Method (function inside an object) console.log(`Welcome ${this.name}. From ${from}`); } }; ii. Accessing There are two common ways to access properties in an object:\nDot Notation: console.log(myObject.name); // Output: nirajan This is the most common and preferred method when you know the property name in advance. Bracket Notation: console.log(myObject[\u0026#39;name\u0026#39;]); // Output: nirajan Bracket notation is useful when the property name is stored in a variable or when it contains special characters or spaces. iii. Modifying Object Properties You can modify an object\u0026rsquo;s properties using dot or bracket notation:\nDot Notation: Use when you know the property name.\nmyObject.name = \u0026#34;Kirajan\u0026#34;; // Modifies the \u0026#39;name\u0026#39; property Bracket Notation: Use when the property name is dynamic or contains special characters.\nmyObject[\u0026#39;class\u0026#39;] = \u0026#34;Master\u0026#39;s\u0026#34;; // Modifies the \u0026#39;class\u0026#39; property iv. Adding New Properties You can dynamically add new key-value pairs to an object.\nmyObject.lol = \u0026#34;lol\u0026#34;; console.log(myObject.lol); // Output: lol v. Using the this Keyword The this keyword inside an object’s method refers to the object itself, allowing you to access its properties. Example:\nconst person = { name: \u0026#34;Kirajan\u0026#34;, greet: function() { console.log(`Hello, my name is ${this.name}`); } }; person.greet(); // Output: Hello, my name is Kirajan vi. Objects Inside Objects Objects can contain other objects, allowing you to create complex data structures. Example:\nconst a = { details: { name: \u0026#34;Nirajan\u0026#34;, age: 20 } }; console.log(a.details.name); // Output: Nirajan vii. Spread Operator (\u0026hellip;) The spread operator lets you copy, merge, or combine objects efficiently.\nCopying Properties: const original = { name: \u0026#34;Kirajan\u0026#34;, class: \u0026#34;Bachelor\u0026#34; }; const copy = { ...original }; console.log(copy); // Output: { name: \u0026#34;Kirajan\u0026#34;, class: \u0026#34;Bachelor\u0026#34; } Merging Objects: const info1 = { name: \u0026#34;Kirajan\u0026#34;, class: \u0026#34;Bachelor\u0026#34; }; const info2 = { age: 21, is_topper: true }; const combined = { ...info1, ...info2 }; console.log(combined); // Output: { name: \u0026#34;Kirajan\u0026#34;, class: \u0026#34;Bachelor\u0026#34;, age: 21, is_topper: true } viii. Object Destructuring Destructuring allows you to extract properties from an object and assign them to variables. Example:\nconst lol = { name: \u0026#34;Nirajan\u0026#34;, class: 12, rollno: \u0026#34;11\u0026#34; }; const { name, rollno } = lol; console.log(name); // Output: Nirajan console.log(rollno); // Output: 11 Also, Renaming in Destructuring: const lol = { name: \u0026#34;Nirajan\u0026#34;, class: 12, rollno: \u0026#34;11\u0026#34; }; const { name: studentName, rollno: studentRollNo } = lol; console.log(studentName); // Output: Nirajan console.log(studentRollNo); // Output: 11 ix. Object Methods Objects can have methods—functions that are properties of the object. These methods can perform actions using the object’s data. Example:\nconst calculator = { add: function(a, b) { return a + b; }, subtract: function(a, b) { return a - b; } }; console.log(calculator.add(5, 3)); // Output: 8 console.log(calculator.subtract(5, 3)); // Output: 2 11. JavaScript Functions Function Definitions: Function Expression: const add1 = function(a, b) { return a + b; }; Creates a function and assigns it to a variable. You call the function using the variable name. Arrow Function: const add2 = (a, b) =\u0026gt; { return a + b; }; Provides a shorter syntax and does not have its own this context. Function Declaration: function add3(a, b) { return a + b; } Defines a function with a name. It is hoisted, so it can be called before its declaration. Comparison: add3 has its own this context, while add1 and add2 do not. Using the Spread Operator: function add(...data) { let sum = 0; for (let i = 0; i \u0026lt; data.length; i++) { sum += data[i]; } return sum; } console.log(add(1, 2, 3)); // Output: 6 The ...data syntax lets the function accept any number of arguments as an array.\nImmediately Invoked Function Expression (IIFE): ( function add(a, b) { console.log(a + b); } )(2, 3); // Output: 5 An IIFE is a function that runs immediately after its definition, creating a local scope to avoid affecting the global scope.\n12. Control Flow in JavaScript Conditional Statements: if-else Statement: Executes code blocks based on a condition. let a = 2; if (a === 1) { console.log(1); } else if (a === 2) { console.log(2); } else { console.log(\u0026#34;None\u0026#34;); } Truthy and Falsy Values: Falsy Values: Values that evaluate to false in a boolean context. console.log(Boolean(false)); // false console.log(Boolean(0)); // false console.log(Boolean(-0)); // false console.log(Boolean(0n)); // false console.log(Boolean(\u0026#34;\u0026#34;)); // false console.log(Boolean(null)); // false console.log(Boolean(undefined)); // false console.log(Boolean(NaN)); // false Truthy Values: Any value that is not falsy. console.log(Boolean(true)); // true console.log(Boolean(1)); // true console.log(Boolean(-1)); // true console.log(Boolean(\u0026#34;hello\u0026#34;)); // true console.log(Boolean(\u0026#34; \u0026#34;)); // true console.log(Boolean({})); // true console.log(Boolean([])); // true console.log(Boolean(function() {})); // true console.log(Boolean(Symbol())); // true console.log(Boolean(1n)); // true Nullish Coalescing Operator (??): Provides a default value when dealing with null or undefined. let val1 = null; let val2 = val1 ?? 10; console.log(val2); // Output: 10 Ternary Operator (?:): A shorthand for the if-else statement. let c = 10; let b = 10; let largest = (c \u0026gt; b) ? c : b; console.log(largest); // Output: 10 13. Loops in JavaScript For Loop // Syntax: for(initialization; condition; increment/decrement) { ... } for (let i = 0; i \u0026lt; 10; i++) { console.log(i); } While Loop // Syntax: while(condition) { ... } let i = 0; while (i \u0026lt; 10) { console.log(i); i++; } Do-While Loop // Syntax: do { ... } while(condition); let i = 0; do { console.log(i); i++; } while (i \u0026lt; 10); For-Of Loop Usage: Iterates over arrays and strings const array = [1, 2, 3]; for (const x of array) { console.log(x); } For-In Loop Usage: Iterates over the properties of an object, indices of an array, or characters of a string const obj = { \u0026#34;name\u0026#34;: \u0026#34;nirajan\u0026#34;, \u0026#34;lol\u0026#34;: \u0026#34;lol\u0026#34; }; const arr = [\u0026#34;nirajan\u0026#34;, \u0026#34;lol\u0026#34;]; const str = \u0026#34;mynameisnirajan\u0026#34;; for (const key in obj) { console.log(key); // Prints the keys of the object } for (const index in arr) { console.log(arr[index]); // Prints the values of the array } for (const index in str) { console.log(str[index]); // Prints the characters of the string } For-Each Loop Usage: Iterates over array elements const array = [1, 2, 3]; array.forEach((data) =\u0026gt; { console.log(data); }); Break and Continue Statements break: Exits the loop continue: Skips the current iteration and continues with the next iteration 14. Map, Filter, and Reduce in JavaScript i. filter() Purpose: Creates a new array with elements that pass a test. Example: To get all odd numbers from an array: const a = [1, 2, 3, 4, 5, 6]; const filtered = a.filter(num =\u0026gt; num % 2); // [1, 3, 5] ii. map() Method Purpose: map() creates a new array populated with the results of calling a provided function on every element in the calling array. It’s used to transform each element in the array. Example: Create an array of squares from an existing array. const a = [1, 2, 3, 4, 5, 6]; const squares = a.map((num) =\u0026gt; num * num); console.log(squares); // Output: [1, 4, 9, 16, 25, 36] Here, the function num * num is applied to each element, resulting in a new array of squared numbers. iii. reduce() Method Purpose: reduce() executes a reducer function on each element of the array, resulting in a single output value. It’s used to accumulate or combine values from the array into a single result. Example: Sum up all the numbers in the array. const a = [1, 2, 3, 4, 5, 6]; const sum = a.reduce((accumulator, currentValue) =\u0026gt; accumulator + currentValue, 0); console.log(sum); // Output: 21 Here, accumulator starts at 0 and currentValue iterates over each element, summing them up. iv. Method Chaining Purpose: You can chain filter(), map(), and other array methods together to perform multiple operations in a single, readable statement. Example: Filter out odd numbers and then square them. const a = [1, 2, 3, 4, 5, 6]; const result = a.filter((num) =\u0026gt; num % 2) .map((num) =\u0026gt; num * num); console.log(result); // Output: [1, 9, 25] Here, filter() first selects the odd numbers, and then map() squares those numbers, producing a new array with the squared values of the odd numbers. Summary filter(): Selects elements that meet a specific condition. map(): Transforms elements based on a function. reduce(): Reduces the array to a single value based on a function. Method Chaining: Combines multiple array operations in a concise and readable manner. These methods are powerful tools for processing and transforming arrays in JavaScript. 15. Importing and Exporting in JavaScript Default Export Only one default export is allowed per module. Use for the primary function, class, or object in a module. // utils.js export default function primaryFunction() { console.log(\u0026#34;This is the primary function\u0026#34;); } // main.js import primaryFunction from \u0026#39;./utils.js\u0026#39;; primaryFunction(); // Output: This is the primary function Named Export Allows multiple exports per module. Use to export multiple functions, variables, or objects. // utils.js function function1() { console.log(\u0026#34;This is function1\u0026#34;); } function function2() { console.log(\u0026#34;This is function2\u0026#34;); } export { function1, function2 }; // main.js import { function1, function2 } from \u0026#39;./utils.js\u0026#39;; function1(); // Output: This is function1 function2(); // Output: This is function2 Summary Default Export: One per module, no curly braces during import. Named Export: Multiple per module, use curly braces during import. 16. Error Handling Try-catch blocks are used to handle errors gracefully.\ntry { // Code that might throw an error let result = nonExistentFunction(); } catch (error) { // Code to handle the error console.log(\u0026#39;An error occurred:\u0026#39;, error.message); } finally { // Code that always executes console.log(\u0026#39;This always executes\u0026#39;); } // Output: // \u0026#34;An error occurred: nonExistentFunction is not defined\u0026#34; // \u0026#34;This always executes\u0026#34; 16.1. Custom Error Throwing You can throw custom errors using the throw statement.\nfunction divide(a, b) { if (b === 0) { throw new Error(\u0026#39;Division by zero is not allowed\u0026#39;); } return a / b; } try { console.log(divide(4, 2)); console.log(divide(4, 0)); } catch (error) { console.log(\u0026#39;Error:\u0026#39;, error.message); } // Output: // 2 // \u0026#34;Error: Division by zero is not allowed\u0026#34; 17. Timers setTimeout Schedules a function to be executed after a specified delay (in milliseconds).\nconst timeoutId = setTimeout(() =\u0026gt; { console.log(\u0026#39;Executed after 1 second\u0026#39;); }, 1000); setInterval Repeatedly executes a function at specified intervals (in milliseconds).\nconst intervalId = setInterval((a, b) =\u0026gt; { console.log(a); // Output: hi console.log(b); // Output: oi }, 20, \u0026#34;hi\u0026#34;, \u0026#34;oi\u0026#34;); clearInterval Stops a function from being executed repeatedly by clearing the interval.\nclearInterval(intervalId); clearTimeout Cancels a timeout previously established by setTimeout.\nclearTimeout(timeoutId); 18. Local Storage Local storage is a way to store data in the browser that persists even after the browser is closed.\nStoring Data localStorage.setItem(\u0026#39;name\u0026#39;, \u0026#39;Nirajan\u0026#39;); Retrieving Data const name = localStorage.getItem(\u0026#39;name\u0026#39;); console.log(name); // Output: Nirajan 19. JSON JSON (JavaScript Object Notation) is a lightweight data interchange format that is easy for humans to read and write and easy for machines to parse and generate.\nConverting Objects to JSON const person = { name: \u0026#39;Nirajan\u0026#39;, age: 20 }; const json = JSON.stringify(person); console.log(json); // Output: {\u0026#34;name\u0026#34;:\u0026#34;Nirajan\u0026#34;,\u0026#34;age\u0026#34;:20} Converting JSON to Objects const json = \u0026#39;{\u0026#34;name\u0026#34;:\u0026#34;Nirajan\u0026#34;,\u0026#34;age\u0026#34;:20}\u0026#39;; const person = JSON.parse(json); console.log(person.name); // Output: Nirajan 20. Fetch API Fetch is used to make HTTP requests and returns a promise that resolves to the response of the request.\nBasic Usage fetch(\u0026#39;https://api.example.com/data\u0026#39;) .then(response =\u0026gt; response.json()) .then(data =\u0026gt; console.log(data)) .catch(error =\u0026gt; console.error(\u0026#39;Error:\u0026#39;, error)); ","permalink":"http://localhost:1313/posts/pages/js/javascript/","summary":"A complete reference guide for JavaScript including data types, functions, DOM manipulation, and modern ES6+ features","title":"JavaScript Reference Guide"},{"content":" Linux Commands and Directories Guide Important Directories Default Web Server Root Directory\nLocation: /var/www/html\nThis is the standard location for serving web content on Apache.\nDownloads Folder\nLocation: /home/username/Downloads\nThis is where files downloaded from the internet are usually saved by default.\nDocuments Folder\nLocation: /home/username/Documents\nA common directory for storing personal documents and files.\nDesktop Folder\nLocation: /home/username/Desktop\nThis is the location for files and shortcuts displayed on your desktop screen.\nCommon Commands cd Change the current directory to another one.\nUsage: cd [directory]\nExample: cd /var/www/html changes to the web server root directory.\nls List files and directories in the current location or specified path.\nUsage: ls [options] [path]\nExample: ls -l lists files in a detailed format.\npwd Print the path of the current working directory.\nUsage: pwd\nThis command shows where you are in the filesystem.\nsudo su Switch to the superuser (root) account, allowing you to perform administrative tasks.\nUsage: sudo su\nAfter entering your password, you\u0026rsquo;ll have root access.\nsudo Execute a command with elevated privileges.\nUsage: sudo [command]\nExample: sudo apt update runs the update command as an administrator.\nmkdir Create a new directory.\nUsage: mkdir [directory name]\nExample: mkdir new_folder creates a directory named \u0026ldquo;new_folder\u0026rdquo;.\ndir List files and directories, similar to ls.\nUsage: dir [options] [path]\nThis command can be used interchangeably with ls.\nmv Move or rename files and directories.\nUsage: mv [source] [destination]\nExample: mv /home/username/Downloads/file.txt /home/username/Documents/ moves the file to a different directory.\ncp Copy files or directories.\nUsage: cp [source] [destination]\nExample: cp /home/username/Downloads/file.txt /home/username/Documents/ copies the file.\nrm Remove files or directories.\nUsage: rm [options] [file/directory]\nExample: To remove a directory and its contents, use rm -r [directory].\ntouch Create an empty file or update the timestamp of an existing file.\nUsage: touch [filename]\nExample: touch newfile.txt creates an empty file named \u0026ldquo;newfile.txt\u0026rdquo;.\ncat Display the contents of a file in the terminal.\nUsage: cat [filename]\nExample: cat file.txt shows the content of \u0026ldquo;file.txt\u0026rdquo;.\ngedit Open the Gedit text editor to edit files.\nUsage: gedit [filename]\nExample: gedit notes.txt opens \u0026ldquo;notes.txt\u0026rdquo; for editing.\nkill Terminate a process using its process ID (PID).\nUsage: kill [PID]\nExample: kill 1234 stops the process with the ID 1234.\ntop Display real-time information about system processes and resource usage.\nUsage: top\nThis command helps monitor system performance.\napt-get update Update the package lists for upgrades and new package installations.\nUsage: apt-get update\nThis command fetches the latest package information.\napt install path_of_.deb_file Install a .deb file package.\nUsage: apt install ./filename.deb\nExample: apt install ./main.deb installs the specified Debian package.\napt-get upgrade Upgrade all installed packages to their latest versions.\nUsage: apt-get upgrade\nThis command updates your installed software.\napt-get install package Install a specific software package.\nUsage: apt-get install [package]\nExample: apt-get install vim installs the Vim text editor.\nman Display the manual page for a command, providing detailed information.\nUsage: man [command]\nExample: man ls shows the manual for the ls command.\nwhoami Show the currently logged-in user\u0026rsquo;s username.\nUsage: whoami\nThis command is useful for confirming your user identity.\nzip Compress a directory and its contents into a zip file.\nUsage: zip -r [filename.zip] [foldername]\nExample: zip -r archive.zip myfolder creates a zip file of \u0026ldquo;myfolder\u0026rdquo;.\nunzip Extract files from a zip archive.\nUsage: unzip [filename]\nExample: unzip archive.zip extracts files from \u0026ldquo;archive.zip\u0026rdquo;.\napt install apache2 Install the Apache web server.\nUsage: apt install apache2\nThis command sets up Apache on your system.\nservice apache2 start Start the Apache web server.\nUsage: service apache2 start\nUse this to begin serving web content.\nservice apache2 restart Restart the Apache web server.\nUsage: service apache2 restart\nThis is useful for applying configuration changes.\nservice apache2 stop Stop the Apache web server.\nUsage: service apache2 stop\nUse this command to halt the server.\napt install redis Install the Redis database server.\nUsage: apt install redis\nThis sets up Redis for use.\nservice redis start Start the Redis server.\nUsage: service redis start\nThis command activates the Redis service.\nservice redis restart Restart the Redis server.\nUsage: service redis restart\nUse this to refresh the Redis service.\nservice redis stop Stop the Redis server.\nUsage: service redis stop\nThis halts the Redis service.\napt install mysql-server Install the MySQL server.\nUsage: apt install mysql-server\nThis command installs the MySQL database management system.\nchmod Change file or directory permissions.\nUsage: chmod [permissions] [file/folder]\nExample: chmod +rwx file.txt grants read, write, and execute permissions.\nTo remove permissions, use chmod -r file.txt.\nImportant Notes Folder Names with Spaces:\nIf a folder name contains spaces, enclose it in double quotes.\nmkdir \u0026quot;New Folder\u0026quot; creates a single folder named \u0026ldquo;New Folder\u0026rdquo;. mkdir New Folder creates two separate folders named \u0026ldquo;New\u0026rdquo; and \u0026ldquo;Folder\u0026rdquo;. Using Wildcards for Operations:\nTo perform operations on:\nAll files/folders: use *. Files with a specific extension (e.g., .exe): use *.exe. Files/folders starting with \u0026ldquo;hello\u0026rdquo;: use hello*. Use Relative Paths:\nPrefer using relative paths whenever possible to simplify navigation.\nExample: mv /home/username/Downloads/index.html /var/www/html/index.html moves a file to the web server directory. ","permalink":"http://localhost:1313/posts/pages/linux/linux_cheatsheet/","summary":"A practical guide to navigating and managing files in Linux.","title":"Linux Commands and Directories Guide"},{"content":"Learning Journey Topics I Have Learned So Far Docker Linux Celery Django Channels Git Celery Python Django JavaScript React Basics HTML CSS Tailwind Css What I Plan to Learn In third Semester Django Rest Framework (DRF) Django ORM Deep Dive React Advanced Git Advanced Docker Advanced WebSOcket Deep Dive in Django Celery Deep Dive Plan to learn in future WebSocket Deep Dive in Django Celery Deep Dive Redis for Cache Kafka Basics + Advanced Docker Advanced + Kubernetes Message Brokers Django Rest Framework (DRF) Django ORM Deep Dive React Advanced Git Advanced Django Docs+Advance Like class based views Additional Topics for Future Learning Real-time WebSocket usage in Django. Kafka streaming for handling large data volumes. Implementing Kubernetes for containerized applications. ","permalink":"http://localhost:1313/posts/pages/readinglist/my_reading/","summary":"A detailed overview of my learning journey and future plans.","title":"Learning Journey"},{"content":"","permalink":"http://localhost:1313/posts/pages/react/react11/","summary":"","title":""},{"content":"44. Optimizing Performance 44.1. memo memo is a higher-order function in React that optimizes functional components by preventing unnecessary re-renders. It returns a new component that behaves the same as the original one but only re-renders if its props change or internal state changes not every time the parent component re-renders.\nWhy Use memo? When a parent component re-renders, all its child components also re-render by default—even if their props remain unchanged. This behavior can lead to performance bottlenecks. Using memo, we can avoid these unnecessary re-renders for child components.\nExample:\nimport { memo } from \u0026#39;react\u0026#39;; const MyComponent = memo((props) =\u0026gt; { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;{props.title}\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ); }); export default MyComponent; In the above example, the MyComponent functional component is wrapped with the memo function. This ensures that the component will only re-render if its props have changed or if its satate has been change not every time the parent component re-renders.\nUse Case:\nBefore using memo: In this example, the Custom component re-renders unnecessarily whenever the parent component re-renders, even if its props haven\u0026rsquo;t changed or internal state hasn\u0026rsquo;t changed. Custom.js import { useState } from \u0026#39;react\u0026#39;; const Custom = ({ title }) =\u0026gt; { const [count, setCount] = useState(0); return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;{title}\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;{count}\u0026lt;/p\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;Increment\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); }; export default Custom; App.js\nimport { useState } from \u0026#39;react\u0026#39;; import Custom from \u0026#39;./Custom\u0026#39;; function App() { const [count, setCount] = useState(0); return ( \u0026lt;div\u0026gt; \u0026lt;Custom title=\u0026#34;Counter\u0026#34; /\u0026gt; \u0026lt;p\u0026gt;{count}\u0026lt;/p\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;Increment Parent Count\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; Problem: The Custom component re-renders whenever the count state in the App component changes, even though the title prop remains the same. This can cause unnecessary rendering and reduce performance.i.e child component re-renders even if the props are not changed when the parent component re-renders.\nAfter using memo: Using memo, we can optimize the Custom component to only re-render when its props change. Custom.jsx import { useState, memo } from \u0026#39;react\u0026#39;; const Custom = memo(({ title }) =\u0026gt; { const [count, setCount] = useState(0); return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;{title}\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;{count}\u0026lt;/p\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;Increment\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); }); export default Custom; App.js\nimport { useState } from \u0026#39;react\u0026#39;; import Custom from \u0026#39;./Custom\u0026#39;; function App() { const [count, setCount] = useState(0); return ( \u0026lt;div\u0026gt; \u0026lt;Custom title=\u0026#34;Counter\u0026#34; /\u0026gt; \u0026lt;p\u0026gt;{count}\u0026lt;/p\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;Increment Parent Count\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; After using memo the Custom component will only re-render when its props change or state change i.e when the title prop changes or the count state of the Custom component changes . It will not re-render when the count state of the App component changes, which optimizes performance in this scenario as that change does not affect the Custom component.\n44.2. useCallback In every rerender of a component, the functions defined inside the component are recreated. This can lead to performance issues, especially when passing functions as props to child components. useCallback is a hook in React that memoizes functions to prevent unnecessary re-creations.\nSyntax:\nuseCallback(fn, dependencies) fn: The function value that you want to cache. It can take any arguments and return any values. React will return (not call!) your function back to you during the initial render. On next renders, React will give you the same function again if the dependencies have not changed since the last render. Otherwise, it will give you the function that you have passed during the current render, and store it in case it can be reused later. React will not call your function. The function is returned to you so you can decide when and whether to call it. dependencies: An array of values that, when changed, will cause the function to be re-created. If the dependencies array is empty, the function will only be created once, and will not be re-created on subsequent renders. Whats the use of dependencies array in useCallback? just because dependency array the function is recreated with the new values of the dependencies.\nBefore using useCallback:\nimport { useState,memo } from \u0026#39;react\u0026#39;; const Child = memo(({ handleClick }) =\u0026gt; { return ( \u0026lt;button onClick={handleClick}\u0026gt;Click Me\u0026lt;/button\u0026gt; ); }); const Parent = () =\u0026gt; { const [count, setCount] = useState(0); const handleClick = () =\u0026gt; { setCount(count + 1); }; return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;{count}\u0026lt;/p\u0026gt; \u0026lt;Child handleClick={handleClick} /\u0026gt; \u0026lt;/div\u0026gt; ); }; In the above example, the handleClick function is re-created on every re-render of the Parent component. As a result, the reference to the handleClick function passed as a prop to the Child component changes on every re-render of the Parent component. This causes the Child component to re-render unnecessarily, even though the handleClick function remains logically the same After using useCallback:\nimport { useState, useCallback, memo } from \u0026#39;react\u0026#39;; const Child = memo(({ handleClick }) =\u0026gt; { return ( \u0026lt;button onClick={handleClick}\u0026gt;Click Me\u0026lt;/button\u0026gt; ); }); const Parent = () =\u0026gt; { const [count, setCount] = useState(0); const handleClick = useCallback(() =\u0026gt; { setCount(count + 1); }, [count]); return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;{count}\u0026lt;/p\u0026gt; \u0026lt;Child handleClick={handleClick} /\u0026gt; \u0026lt;/div\u0026gt; ); }; By using useCallback, the handleClick function is memoized and will only be re-created when the count state changes. The reference to the handleClick function remains the same across re-renders of the Parent component unless the dependencies specified in the dependency array (in this case, [count]) change. This ensures that the Child component only re-renders when the count state changes, and not when the handleClick function reference changes, thus improving performance.\n44.3. useMemo useMemo is a hook in React that memoizes the result of a function. It is similar to useCallback, but instead of memoizing a function, it memoizes the result of a function.\nSyntax:\nconst cachedValue = useMemo(calculateValue, dependencies) calculateValue: The function calculating the value that you want to cache. It should be pure, should take no arguments, and should return a value of any type. React will call your function during the initial render. On next renders, React will return the same value again if the dependencies have not changed since the last render. Otherwise, it will call calculateValue, return its result, and store it so it can be reused later. dependencies: An array of values that, when changed, will cause the function to be re-executed.\nreturn On the initial render, useMemo returns the result of calling calculateValue with no arguments.During next renders, it will either return an already stored value from the last render (if the dependencies haven’t changed), or call calculateValue again, and return the result that calculateValue has returned.\nBefore using useMemo:\nimport { useState, memo } from \u0026#39;react\u0026#39;; const fibonacci = (n) =\u0026gt; { if (n \u0026lt;= 1) { return n; } return fibonacci(n - 1) + fibonacci(n - 2); }; const Fib = ()=\u0026gt;{ const [count, setCount] = useState(1); const result = fibonacci(100000000000); return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;{result} and count is {count}\u0026lt;/p\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;Increase Count\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } In the above example, the fibonacci function is called on every re-render of the Fib component. This can lead to performance issues, especially when the function is computationally expensive. In this case, the fibonacci function is called with a large number, which can cause the component to freeze or crash.\nAfter using useMemo:\nimport { useState, useMemo } from \u0026#39;react\u0026#39;; const fibonacci = (n) =\u0026gt; { if (n \u0026lt;= 1) { return n; } return fibonacci(n - 1) + fibonacci(n - 2); }; const Fib = ()=\u0026gt;{ const [count, setCount] = useState(1); const result = useMemo(() =\u0026gt; fibonacci(100000000000), []); return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;{result} and count is {count}\u0026lt;/p\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;Increase Count\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } By using useMemo, the result of the fibonacci function is memoized and will only be re-calculated when the dependencies specified in the dependency array change. In this case, the fibonacci function is only called once during the initial render of the Fib component, and the result is stored and reused on subsequent renders. This optimizes performance by preventing unnecessary re-calculation of the fibonacci function on every re-render of the component.\n45.Key conside a scenarion where your base component state variable need to be initialized with the value of the props passed to the component. since the state variable is initialized with the props value, the state variable will not be updated when the props value changes as it is initialized only. to handle we can either use useEffect or we can use key prop.\nUsing useEffect:\nimport { useEffect, useState } from \u0026#39;react\u0026#39;; const Parent = () =\u0026gt; { const [value, setValue] = useState(0); return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={() =\u0026gt; setValue(value + 1)}\u0026gt;Increment\u0026lt;/button\u0026gt; \u0026lt;Child value={value} /\u0026gt; \u0026lt;/div\u0026gt; ); }; const Child = ({ value }) =\u0026gt; { const [stateValue, setStateValue] = useState(value); useEffect(() =\u0026gt; { setStateValue(value); }, [value]); return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;State Value: {stateValue}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Props Value: {value}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); }; stateValue is initialized with the value prop and const [stateValue, setStateValue] = useState(value); runs only once during initial render so useEffect is used to update the stateValue when the value prop changes.\nUsing key prop:\nimport { useState } from \u0026#39;react\u0026#39;; const Parent = () =\u0026gt; { const [value, setValue] = useState(0); return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={() =\u0026gt; setValue(value + 1)}\u0026gt;Increment\u0026lt;/button\u0026gt; \u0026lt;Child key={value} value={value} /\u0026gt; \u0026lt;/div\u0026gt; ); }; const Child = ({ value }) =\u0026gt; { const [stateValue, setStateValue] = useState(value); return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;State Value: {stateValue}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Props Value: {value}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); }; IN the above example,When a key changes between renders, React will create a new instance of the component. By using the key prop with the value prop, we ensure that a new instance of the Child component is created whenever the value prop changes. This allows the stateValue to be initialized with the new value prop on every render, without the need for useEffect.\nNote:The useState() hook us run only one time during the initial render of the component. If the state variable is initialized with a prop value, it will not be updated when the prop value changes. To handle this scenario, we can use the useEffect() hook to update the state variable when the prop value changes. Alternatively, we can use the key prop to create a new instance of the component whenever the prop value changes, allowing the state variable to be initialized with the new prop value on every render. Similar goes for useReducer() and useRef() hooks as well.\n","permalink":"http://localhost:1313/posts/pages/react/react10/","summary":"Learn how to optimize React applications using memo for component memoization, useCallback for function memoization, and useMemo for value memoization.","title":"React : 10"},{"content":"40. useEffect useEffect is a React hook that lets you perform side effects in functional components. Common use cases include:\nEstablishing a database connection when the DOM content loads. Updating the page title when the content changes. Note: The useEffect hook runs after the component has rendered.\n41. What to Put in useEffect Use useEffect for:\nNetwork requests Operations that take time to complete (e.g., fetching data, setting timers, etc.) 42. useEffect Syntax 42.1. Importing useEffect import React, { useEffect } from \u0026#39;react\u0026#39;; 42.2. useEffect Syntax useEffect(() =\u0026gt; { // code here return () =\u0026gt; { // cleanup code here }; }, [dependencies]); The first argument is a function containing the code to execute. The second argument is an array of dependencies. If any dependency changes, the function runs again. The return statement is optional and is used for cleanup tasks, such as removing event listeners or canceling subscriptions. This cleanup function is executed: Just before the the useEffect function runs again cause due to dependency change, with variables from the previous render. After the component unmounts (i.e., when removed from the DOM). Note: When your component is added to the DOM, React runs the setup function. After each re-render with changed dependencies, React first executes the cleanup function (if provided) with old values, then runs the setup function with new values.\nExample: useEffect(() =\u0026gt; { const id = setTimeout(() =\u0026gt; { console.log(count); }, 1000); return () =\u0026gt; { clearTimeout(id); }; }, [count]); In this example, the useEffect hook runs whenever the count variable changes. It sets a timeout to log the count value after 1 second, and the cleanup function clears the previous timeout before the next execution. Cleanup Function:\nUsed for tasks like removing event listeners or clearing timeouts. Ensures stale operations are cleared before new ones are executed. Executes when dependencies change or when the component unmounts. 43. Variations of useEffect 43.1. useEffect Without Dependencies Array useEffect(() =\u0026gt; { // code here }); The useEffect function runs after every re-render. 43.2. useEffect With Empty Dependencies Array useEffect(() =\u0026gt; { // code here }, []); The useEffect function runs only once after the initial render, making it ideal for tasks like loading local storage data. 43.3. useEffect With Multiple Dependencies useEffect(() =\u0026gt; { // code here }, [count, name]); The useEffect function runs when either count or name changes. Note: In all of the variation, useEffect always runs after the first render no matter what is passed in the dependencies array.\nExample: Loading Local Storage Data Correct Usage:\nimport React, { useState, useEffect } from \u0026#39;react\u0026#39;; const App = () =\u0026gt; { const [data, setData] = useState([]); useEffect(() =\u0026gt; { const data = localStorage.getItem(\u0026#39;data\u0026#39;); if (data) { setData(JSON.parse(data)); } }, []); return ( \u0026lt;div\u0026gt; {data.map((item, index) =\u0026gt; ( \u0026lt;p key={index}\u0026gt;{item}\u0026lt;/p\u0026gt; ))} \u0026lt;/div\u0026gt; ); }; Incorrect Usage:\nimport React, { useState } from \u0026#39;react\u0026#39;; const App = () =\u0026gt; { const [data, setData] = useState([]); const loadData = () =\u0026gt; { const data = localStorage.getItem(\u0026#39;data\u0026#39;); if (data) { setData(JSON.parse(data)); } }; loadData(); return ( \u0026lt;div\u0026gt; {data.map((item, index) =\u0026gt; ( \u0026lt;p key={index}\u0026gt;{item}\u0026lt;/p\u0026gt; ))} \u0026lt;/div\u0026gt; ); }; Problem: Calling loadData directly causes an infinite loop because it triggers a re-render, which calls loadData again. Solution: Use useEffect with an empty dependency array to ensure the function runs only once after the initial render. ","permalink":"http://localhost:1313/posts/pages/react/react9/","summary":"Learn how to use the useEffect hook in React for performing side effects in functional components.","title":"React : 9"},{"content":"38. Understanding the Concept of Prop Drilling Prop drilling refers to the process of passing data from a parent component to a deeply nested child component through all the intermediate components, even if those intermediate components don’t need the data themselves. Let’s break this down with an example.\nComponent Tree Imagine the following component hierarchy: Now, suppose we want to transfer some data from the Product component to the Cart component. Since Product and Cart are in separate branches of the component tree, they don’t have a direct connection.\nHow Prop Drilling Works To make this work, we need to store the shared state in a common ancestor, which is the App component in this case. Then, we have to pass the state down through all the intermediate components, even if those components don’t actually use the data.\nHere’s a visual representation of this:\nData flows from Product → Shop → App (common ancestor). The data then flows from App → Header → CardModel → Cart. This creates a lot of unnecessary overhead because the intermediate components (Shop, Header, and CardModel) don’t need the data but still have to handle it.\nProp drilling can quickly become cumbersome in large applications with deeply nested components. To solve this, we can use state management tools like Redux, Context API, or React Query, which allow us to manage and share state more effectively without passing it through every component.\n39. Introduction to React Context API Context API is a feature in React that allows you to share data between components without having to pass props down manually at every level. It provides a way to pass data through the component tree without having to pass props down manually at every level as shown in the image below.\nHow to use context API Create a context using the createContext function. import { createContext } from \u0026#39;react\u0026#39;; const CartContext = createContext(); export default CartContext; Wrap the parent component with the Provider component. Which Component to wrap? Wrap to the common ancestor of the components that need the context data. In the example below, we wrap the App component with the Provider component. For Example:\nimport CartContext from \u0026#39;./store/CartContext\u0026#39;; function App() { return ( \u0026lt;CartContext.Provider value={data}\u0026gt; \u0026lt;Header /\u0026gt; \u0026lt;Shop /\u0026gt; \u0026lt;/CartContext.Provider\u0026gt; ); } Explaination:Since we want to share the product Component data with the Cart Component SO in order to do that we wrap the first common ancestor of the Product and Cart Component i.e App Component with the Provider Component and pass the data to the value prop of the Provider Component.\nAccess the context data in the child component using the useContext hook. for example:\nimport { useContext } from \u0026#39;react\u0026#39;; import CartContext from \u0026#39;../store/CartContext\u0026#39;; function Cart() { const cartCtx = useContext(CartContext); return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Cart\u0026lt;/h1\u0026gt; {cartCtx.products.map(product =\u0026gt; ( \u0026lt;p key={product.id}\u0026gt;{product.name}\u0026lt;/p\u0026gt; ))} \u0026lt;/div\u0026gt; ); } What Whappen when the data is updated? When the data is updated in the Provider component, all the child components that are using the context data will be re-rendered automatically. Task: Design a simple application that has a component called App. App has two child components: Header and Shop. Header has one child, CartModel, and Shop has one child, Product. Pass the data from the Product component to the CartModel component using the Context API.\nStructure of the project\nsrc\r|_components\r|_App\r|_App.js\r|_Header\r|_Header.js\r|_CartModel.js\r|_Shop\r|_Shop.js\r|_Product.js\r|_store\r|_CartContext.js CartContext.js\nimport { createContext } from \u0026#39;react\u0026#39;; const CartContext = createContext(); export default CartContext; App.js\nimport CartContext from \u0026#39;../store/CartContext\u0026#39;; import Header from \u0026#39;../Header/Header\u0026#39;; import Shop from \u0026#39;../Shop/Shop\u0026#39;; import { useState } from \u0026#39;react\u0026#39;; function App() { const [cartProducts, setCartProducts] = useState([]); const addProductToCart = (product) =\u0026gt; { setCartProducts((prevProducts) =\u0026gt; [...prevProducts, product]); }; return ( \u0026lt;CartContext.Provider value={ { products: cartProducts, addProduct: addProductToCart } }\u0026gt; \u0026lt;Header /\u0026gt; \u0026lt;Shop /\u0026gt; \u0026lt;/CartContext.Provider\u0026gt; ); } export default App; Header.js\nimport CartModel from \u0026#39;./CartModel\u0026#39;; function Header() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Header\u0026lt;/h1\u0026gt; \u0026lt;CartModel /\u0026gt; \u0026lt;/div\u0026gt; ); } export default Header; CartModel.js\nimport { useContext } from \u0026#39;react\u0026#39;; import CartContext from \u0026#39;../../store/CartContext\u0026#39;; function CartModel() { const cartCtx = useContext(CartContext); return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;CartModel\u0026lt;/h1\u0026gt; {cartCtx.products.map(product =\u0026gt; ( \u0026lt;p key={product.id}\u0026gt;{product.name}\u0026lt;/p\u0026gt; ))} \u0026lt;/div\u0026gt; ); } export default CartModel; Shop.js\nimport Product from \u0026#39;./Product\u0026#39;; function Shop() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Shop\u0026lt;/h1\u0026gt; \u0026lt;Product /\u0026gt; \u0026lt;/div\u0026gt; ); } export default Shop; Product.js\nimport { useContext } from \u0026#39;react\u0026#39;; import CartContext from \u0026#39;../../store/CartContext\u0026#39;; function Product() { const cartCtx = useContext(CartContext); const product = { id: 1, name: \u0026#39;Laptop\u0026#39; }; return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Product\u0026lt;/h1\u0026gt; \u0026lt;button onClick={() =\u0026gt; cartCtx.addProduct(product)}\u0026gt;Add to Cart\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } export default Product; Outsoursing the Context Provider Since all the logic related to the context is in the App Component so we can outsource the context provider and its logic to a separate component in order to make the App Component more clean and readable.\nCartContext.js\nimport { createContext, useState } from \u0026#39;react\u0026#39;; const CartContext = createContext(); export const CartContextProvider = (props) =\u0026gt; { const [cartProducts, setCartProducts] = useState([]); const addProductToCart = (product) =\u0026gt; { setCartProducts((prevProducts) =\u0026gt; [...prevProducts, product]); }; const context = { products: cartProducts, addProduct: addProductToCart }; return ( \u0026lt;CartContext.Provider value={context}\u0026gt; {props.children} \u0026lt;/CartContext.Provider\u0026gt; ); }; App.js\nimport Header from \u0026#39;../Header/Header\u0026#39;; import Shop from \u0026#39;../Shop/Shop\u0026#39;; import { CartContextProvider } from \u0026#39;../store/CartContext\u0026#39;; function App() { return ( \u0026lt;CartContextProvider\u0026gt; \u0026lt;Header /\u0026gt; \u0026lt;Shop /\u0026gt; \u0026lt;/CartContextProvider\u0026gt; ); } export default App; Other Components remain the same.\n39.UseReducer Hook in React USe reducer is a hook that is used for state management in React. It is an alternative to useState. It is usually preferable when you have complex state logic that involves multiple sub-values or when the next state depends on the previous one.\nHow to use useReducer Hook Create a reducer function. A reducer function is a function that takes the current state and an action as arguments and returns a new state based on the action type.action . action:It contains the object that is sent by the dispatch function. For Example:\nconst counterReducer = (state, action) =\u0026gt; { if (action.type === \u0026#39;INCREMENT\u0026#39;) { return { counter: state.counter + 1 }; } if (action.type === \u0026#39;DECREMENT\u0026#39;) { return { counter: state.counter - 1 }; } return state; }; Here, the reducer function takes two arguments: state and action. It checks the action type and returns a new state based on the action type.\nUse the useReducer hook in the component. The useReducer hook takes two arguments: the reducer function and the initial state and returns the current state and a dispatch function as an array which is shown below. For Example: import { useReducer } from \u0026#39;react\u0026#39;; const [counterState, dispatchCounter] = useReducer(counterReducer, { counter: 0 }); Here, counterState is the current state and dispatchCounter is the dispatch function that is used to dispatch an action to the reducer function and { counter: 0 } is the initial state such that the counter is initialized to 0.\nDispatch an action to the reducer function. To dispatch an action to the reducer function, you need to call the dispatch function with an object that contains the action type and any additional data that is required by the reducer function. For Example: dispatchCounter({ type: \u0026#39;INCREMENT\u0026#39; }); To change the state, you need to call the dispatch function with an object that contains the action type.Here, the action type is \u0026lsquo;INCREMENT\u0026rsquo; which increments the counter by 1.\nTask: Design a simple counter application that has a component called Counter. The Counter component has two buttons: Increment and Decrement. Use the useReducer hook to manage the state of the counter.\nStructure of the project\nsrc\r|_components\r|_Counter\r|_Counter.js Counter.js\nimport { useReducer } from \u0026#39;react\u0026#39;; const counterReducer = (state, action) =\u0026gt; { if (action.type === \u0026#39;INCREMENT\u0026#39;) { return { counter: state.counter + 1 }; } if (action.type === \u0026#39;DECREMENT\u0026#39;) { return { counter: state.counter - 1 }; } return state; }; function Counter() { const [counterState, dispatchCounter] = useReducer(counterReducer, { counter: 0 }); const handleIncrement = () =\u0026gt; { dispatchCounter({ type: \u0026#39;INCREMENT\u0026#39; }); }; const handleDecrement = () =\u0026gt; { dispatchCounter({ type: \u0026#39;DECREMENT\u0026#39; }); }; return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Counter\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;{counterState.counter}\u0026lt;/p\u0026gt; \u0026lt;button onClick={handleIncrement}\u0026gt;Increment\u0026lt;/button\u0026gt; \u0026lt;button onClick={handleDecrement}\u0026gt;Decrement\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } If we use useState hook then the code will be like this:\nimport { useState } from \u0026#39;react\u0026#39;; function Counter() { const [counter, setCounter] = useState(0); const handleIncrement = () =\u0026gt; { setCounter(counter=\u0026gt;counter + 1); }; const handleDecrement = () =\u0026gt; { setCounter(counter=\u0026gt;counter - 1); }; return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Counter\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;{counter}\u0026lt;/p\u0026gt; \u0026lt;button onClick={handleIncrement}\u0026gt;Increment\u0026lt;/button\u0026gt; \u0026lt;button onClick={handleDecrement}\u0026gt;Decrement\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } What is the difference between useState and useReducer?\nuseState is a simple and straightforward way to manage state in React. It is suitable for managing simple state logic. useReducer is more powerful and flexible than useState. It is suitable for managing complex state logic that involves multiple sub-values or when the next state depends on the previous one. Looking the example case Scenario: Here using reducer we write all the logic in a single function and then we dispatch the action to the reducer function and then the reducer function returns the new state based on the action type. This makes the code more readable and maintainable.\nbut in the case of useState, we have to write the logic for each state change separately which makes the code more complex and difficult to maintain.\nNote: Always change in state variable will cause the re-rendering of the component.\n","permalink":"http://localhost:1313/posts/pages/react/react8/","summary":"Learn about prop drilling and how to use the Context API in React to manage and share state effectively.","title":"React : 8"},{"content":"1.1 When to use asyncio? Asyncio is a library to write concurrent code using the async/await syntax. It is a single-threaded, single-process design that is ideal for I/O-bound and high-level structured network code. It is not suitable for CPU-bound code, which is better handled by the multiprocessing module.It is used for :\n2.1 Coroutine Think of a coroutine like a regular Python function but with the superpower that it can pause its execution when it encounters an operation that could take a while to complete. When that long-running operation is complete, we can “wake up” our paused coroutine and finish executing any other code in that coroutine. While a paused coroutine is waiting for the operation it paused for to finish, we can run other code. This running of other code while waiting is what gives our application concur rency. We can also run several time-consuming operations concurrently, which can give our applications big performance improvements. To both create and pause a coroutine, we’ll need to learn to use Python’s async and await keywords. The async keyword will let us define a coroutine; the await key word will let us pause our coroutine when we have a long-running operation.\n2.2 Creating a coroutine with async creating a coroutine is straightforward and not much different from creating a nor mal Python function. The only difference is that, instead of using the def keyword, we use async def. The async keyword marks a function as a coroutine instead of a nor mal Python function.\nimport asyncio async def mero_coroutine(): print(\u0026#34;Hello From Asyncio\u0026#34;) The coroutine in the preceding listing does nothing yet other than print “Hello world!” It’s also worth noting that this coroutine does not perform any long-running operations; it just prints our message and returns. This means that, when we put the coroutine on the event loop, it will execute immediately because we don’t have any blocking I/O, and nothing is pausing execution yet. This syntax is simple, but we’re creating something very different from a plain Python function. To illustrate this, let’s create a function that adds one to an integer as well as a coroutine that does the same and compare the results of calling each. We’ll also use the type convenience function to look at the type returned by calling a corou tine as compared to calling our normal function.\ndef add_function(a,b): return a+b async def add_coroutine(a,b): return a+b function=add_function(1,2) coroutine=add_coroutine(1,2) print(type(function)) print(type(coroutine)) When we run this code, we’ll see output like the following\nMethod result is 3 and the type is \u0026lt;class \u0026#39;int\u0026#39;\u0026gt;\rCoroutine result is \u0026lt;coroutine object coroutine_add_one at 0x1071d6040\u0026gt; and the type is \u0026lt;class \u0026#39;coroutine\u0026#39;\u0026gt; Notice how when we call our normal add_one function it executes immediately and returns what we would expect, another integer. However, when we call coroutine_ add_one we don’t get our code in the coroutine executed at all. We get a coroutine object instead. This is an important point, as coroutines aren’t executed when we call them directly. Instead, we create a coroutine object that can be run later. To run a corou tine, we need to explicitly run it on an event loop. So how can we create an event loop and run our coroutine?\nIn versions of Python older than 3.7, we had to create an event loop if one did not already exist. However, the asyncio library has added several functions that abstract the event loop management. There is a convenience function, asyncio.run, we can use to run our coroutine. This is illustrated in the following listing.\nimport asyncio async def add_coroutine(a,b): return a+b res=asyncio.run(add_coroutine(1,2)) print(res) When we run this code, we’ll see output like the following:\n3 We’ve properly put our coroutine on the event loop, and we have executed it! asyncio.run is doing a few important things in this scenario. First, it creates a brand-new event. Once it successfully does so, it takes whichever coroutine we pass into it and runs it until it completes, returning the result. This function will also do some cleanup of anything that might be left running after the main coroutine fin ishes. Once everything has finished, it shuts down and closes the event loop. Possibly the most important thing about asyncio.run is that it is intended to be the main entry point into the asyncio application we have created. It only executes one coroutine, and that coroutine should launch all other aspects of our application. As we progress further, we will use this function as the entry point into nearly all our applications. The coroutine that asyncio.run executes will create and run other coroutines that will allow us to utilize the concurrent nature of asyncio.\n2.3 Pausing execution with the await keyword The example we saw in block 2.2 did not need to be a coroutine, as it executed only non-blocking Python code. The real benefit of asyncio is being able to pause execu tion to let the event loop run other tasks during a long-running operation. To pause execution, we use the await keyword. The await keyword is usually followed by a call to a coroutine (more specifically, an object known as an awaitable, which is not always a coroutine; we’ll learn more about awaitables later in the chapter). Using the await keyword will cause the coroutine following it to be run, unlike calling a coroutine directly, which produces a coroutine object. The await expression will also pause the coroutine where it is contained in until the coroutine we awaited finishes and returns a result. When the coroutine we awaited finishes, we’ll have access to the result it returned, and the containing coroutine will “wake up” to handle the result. We can use the await keyword by putting it in front of a coroutine call. Expanding on our earlier program, we can write a program where we call the add_coroutine function inside of a “main” async function and get the result\nimport asyncio async def add_one(number: int) -\u0026gt; int: return number + 1 async def main() -\u0026gt; None: one_plus_one = await add_one(1) # Pause, and wait for the result of add_one(1). two_plus_one = await add_one(2) # Pause, and wait for the result of add_one(2). print(one_plus_one) print(two_plus_one) asyncio.run(main()) Note: Coroutine will only run when we use await keyword. If we call the coroutine directly it will return a coroutine object.\nIn above code we pause execution twice. We first await the call to add_one(1). Once we have the result, the main function will be “unpaused,” and we will assign the return value from add_one(1) to the variable one_plus_one, which in this case will be two. We then do the same for add_one(2) and then print the results.We can visualize the execution flow of our application, as shown in figure\nAs it stands now, this code does not operate differently from normal, sequential code. We are, in effect, mimicking a normal call stack. Next, let’s look at a simple example of how to run other code by introducing a dummy sleep operation while we’re waiting.\n2.4 Introducing long-running coroutines with sleep Our previous examples did not use any slow operations and were used to help us learn the basic syntax of coroutines. To fully see the benefits and show how we can run mul tiple events simultaneously, we’ll need to introduce some long-running operations. Instead of making web API or database queries right away, which are nondeterministic as to how much time they will take, we’ll simulate long-running operations by specify ing how long we want to wait. We’ll do this with the asyncio.sleep function. We can use asyncio.sleep to make a coroutine “sleep” for a given number of sec onds. This will pause our coroutine for the time we give it, simulating what would hap pen if we had a long-running call to a database or web API. asyncio.sleep is itself a coroutine, so we must use it with the await keyword. If we call it just by itself, we’ll get a coroutine object. Since asyncio.sleep is a coroutine, this means that when a coroutine awaits it, other code will be able to run. Let’s examine a simple example, shown in the following listing, that sleeps for 1 sec ond and then prints a \u0026lsquo;Hello World!\u0026rsquo; message.\nimport asyncio async def hello_world_message(): await asyncio.sleep(1) print(\u0026#34;Hello World\u0026#34;) asyncio.run(hello_world_message()) When we run this application, our program will wait 1 second before printing our \u0026lsquo;Hello World!\u0026rsquo; message. Since hello_world_message is a coroutine and we pause it for 1 second with asyncio.sleep, we now have 1 second where we could be running other code concurrently.\nWe’ll be using sleep a lot in the next few examples, so let’s invest the time to cre ate a reusable coroutine that sleeps for us and prints out some useful information. We’ll call this coroutine delay. This is shown in the following listing\nimport asyncio async def delay(delaysecond): print(f\u0026#39;Sleeping for delay seconds : {delaysecond}\u0026#39;) await asyncio.sleep(delaysecond) print(f\u0026#39;finished sleeping for {delay_seconds} second(s)\u0026#39;) return delay_seconds delay will take in an integer of the duration in seconds that we’d like the function to sleep and will return that integer to the caller once it has finished sleeping. We’ll also print when sleep begins and ends. This will help us see what other code, if any, is run ning concurrently while our coroutines are paused.\nTo make referencing this utility function easier in future code listings, we’ll create a module that we’ll import in the remainder of this book when needed. We’ll also add to this module as we create additional reusable functions. We’ll call this module util, and we’ll put our delay function in a file called delay_functions.py. We’ll also add an init.py file with the following line, so we can nicely import the timer\nfrom util.delay_functions import delay From now on in this book, we’ll use from util import delay whenever we need to use the delay function. Now that we have a reusable delay coroutine, let’s combine it with the earlier coroutine add_one to see if we can get our simple addition to run concur rently while hello_world_message is paused.\nimport asyncio from util.delay_functions import delay async def add_one(number): return number + 1 async def hello_world_message(): await delay(1) print(\u0026#34;Hello World\u0026#34;) async def main() -\u0026gt; None: message = await hello_world_message() #pause until hello_world_message is finished one_plus_one = await add_one(1) #pause until add_one is finished print(one_plus_one) print(message) asyncio.run(main()) When we run this, 1 second passes before the results of both function calls are printed. What we really want is the value of add_one(1) to be printed immediately while hello_world_message()runs concurrently. So why isn’t this happening with this code? The answer is that await pauses our current coroutine and won’t execute any other code inside that coroutine until the await expression gives us a value. Since it will take 1 second for our hello_world_message function to give us a value, the main coroutine will be paused for 1 second. Our code behaves as if it were sequential in this case. This behavior is illustrated in figure\nWe can see that the main coroutine is paused for 1 second while hello_world_\nBoth main and hello_world paused while we wait for delay(1) to finish. After it has finished, main resumes and can execute add_one. We’d like to move away from this sequential model and run add_one concurrently with hello_world. To achieve this, we’ll need to introduce a concept called tasks.\n2.5 Running concurrently with task In Python\u0026rsquo;s asyncio, you can create tasks to run code concurrently. This is done using the asyncio.create_task function. When you create a task, it starts running in the background immediately, allowing your program to do other things while waiting for the task to finish.\nKey Points: Creating a Task:\nUse asyncio.create_task() with a coroutine function as its input. It returns a task object instantly. Awaiting a Task:\nYou can use await with the task object to pause your program until the task is done and get its result. Why Use Tasks?\nTasks allow other parts of your program to run without waiting for one operation to finish. Code Example: Creating and Using a Task import asyncio from util import delay # A custom function that simulates a delay async def main(): # Create a task that takes 3 seconds to complete sleep_for_three = asyncio.create_task(delay(3)) # Immediately print the type of the task object print(f\u0026#34;Task type: {type(sleep_for_three)}\u0026#34;) # Wait for the task to finish and get the result result = await sleep_for_three print(f\u0026#34;Task result: {result}\u0026#34;) # Run the main coroutine asyncio.run(main()) What’s Happening in the Code: Task Creation:\nasyncio.create_task(delay(3)) creates a task to run the delay(3) coroutine in the background. The task is of type \u0026lt;class '_asyncio.Task'\u0026gt;, which is different from a regular coroutine. Running Concurrently:\nAfter creating the task, the program does not wait for the task to finish. The print() statement runs immediately after the task is created. Waiting for the Task:\nThe await sleep_for_three line pauses the main coroutine until the task finishes. Once the task is complete, it returns its result, which is printed. Why Await is Important: If you don’t use await on a task, it might not get enough time to finish. When the asyncio.run function exits, the event loop stops, and any unfinished tasks are “cleaned up” without completing. Using await ensures the task has a chance to finish.\nNote : When we create task using asyncio.create_task it run the task immediately in the background. It does not wait for the task to finish and immediately return a task object such that our program can do other things while waiting for the task to finish.We can use await later on to pause the program until the task is done and get its result.\n2.6 Running multiple tasks concurrently Given that tasks are created instantly and are scheduled to run as soon as possible, this allows us to run many long-running tasks concurrently. We can do this by sequentially starting multiple tasks with our long-running coroutine.\nimport asyncio from util.delay_functions import delay async def main(): # Create two tasks that take 3 seconds to complete sleep_for_three=asyncio.create_task(delay(3)) sleep_again=asyncio.create_task(delay(3)) sleep_once_more=asyncio.create_task(delay(3)) await sleep_for_three await sleep_again await sleep_once_more asyncio.run(main()) In this code, we create three tasks that each sleep for 3 seconds. We then await each task in sequence. This will cause each task to run concurrently, and the total time to complete will be around 3 seconds, not 9 seconds. This is because we are not waiting for each task to finish before starting the next one. Lets breakdown\nStarting Three Tasks:\nThe program begins by creating three tasks, each of which takes 3 seconds to complete. The create_task function starts the tasks immediately but doesn\u0026rsquo;t wait for them to finish—it just sets them up to run in the background. The First Await Statement:\nWhen the code reaches the await sleep_for_three line, it pauses and gives control to the event loop. This pause allows the event loop to check for any tasks waiting to run and starts them “as soon as possible.” Tasks Run Simultaneously:\nAll three tasks begin running their sleep operations at the same time because the event loop handles them concurrently. This concurrency allows the program to complete the work in 3 seconds instead of 9. Concurrency in Action:\nWhile the sleep operations run concurrently, any other code in the tasks (like print statements) runs one at a time, not simultaneously. This means only the parts of the tasks that involve waiting (like sleeping) are parallelized. Time Saved:\nIf the tasks were executed one after another, the program would take 9 seconds (3 seconds × 3 tasks). By running the tasks concurrently, the program finishes in just 3 seconds, saving a lot of time. This is illustrated in figure NOTE This benefit compounds as we add more tasks; if we had launched 10 of these tasks, we would still take roughly 3 seconds, giving us a 10-fold speedup. This is the power of concurrency in asyncio.\nasyncio.gather function Gather function is a quick way to run multiple tasks concurrently and wait for all of them to complete. It takes in an iterable of awaitables and returns a single awaitable that will yield results in the order they were created. This is useful when we want to run multiple tasks concurrently and wait for all of them to finish before proceeding.\nimport asyncio from util.delay_functions import delay async def main(): # Create three tasks that take 3 seconds to complete and handel using asyncio.gather results = await asyncio.gather( delay(3), delay(3), delay(3) ) print(results) asyncio.run(main()) Note : For understanding You can use this logic . There is a task queue and event loop. When we only await coroutine there is only one task in the task queue and event loop .\ncoroutine need to await for running the task i.e keep in the task queue and eventloop if we directly run coroutine it will just give us coroutine object.\nWhen we use asyncio.createtask() there are as much task in the task queue as the number of tasks created and event loop will run all the tasks concurrently also when we await new coroutine it will be added to the task queue and event loop will run it concurrently.\nIt return a task object instantly and run all the task concurrently i.e keep in the task queue and event loop without awaiting but does not wait for the task to finish it need to be awaited to get the proper result.\nWhen we use asyncio.gather() it will run all the tasks concurrently and wait for all of them to finish before proceeding.\nIt need to be awaited to keep all the task in the task queue and event loop and wait for all of them to finish before proceeding.After finishing all the task it will return the result in the order they were created and jump to the next line of code of the main coroutine.\n3. Synchronization Premitives Locks Semaphores 3.1 Locks Locks are a synchronization primitive that allows us to limit access to a shared resource to only one coroutine at a time. This is useful when we have a resource that can only be accessed by one coroutine at a time, like a file or a database connection. Locks are created using the asyncio.Lock class and can be acquired using the acquire method and released using the release method.\n#basic example of lock\nimport asyncio async def locking(lock): print(\u0026#39;Waiting for the lock\u0026#39;) async with lock: print(\u0026#39;Acquired the lock\u0026#39;) await asyncio.sleep(2) print(\u0026#39;Released the lock\u0026#39;) async def main(): lock = asyncio.Lock() await asyncio.gather( locking(lock), locking(lock), locking(lock) ) asyncio.run(main()) Output:\nWaiting for the lock\rAcquired the lock\rWaiting for the lock\rWaiting for the lock\rReleased the lock\rAcquired the lock\rReleased the lock\rAcquired the lock\rReleased the lock In this example, we create a lock using asyncio.Lock and pass it to the locking coroutine. We then use the async with statement to acquire the lock and release it when we are done. When we run the program, we can see that only one coroutine can acquire the lock at a time, and the other coroutines have to wait until the lock is released.\n3.2 Semaphores Semaphores are a synchronization primitive that allows us to limit access to a shared resource to a fixed number of coroutines at a time. This is useful when we have a resource that can be accessed by a limited number of coroutines, like a connection pool or a web API. Semaphores are created using the asyncio.Semaphore class and can be acquired using the acquire method and released using the release method.\n#basic example of semaphore\nimport asyncio async def semaphoring(semaphore): async with semaphore: print(\u0026#39;Acquired the semaphore\u0026#39;) await asyncio.sleep(2) print(\u0026#39;Released the semaphore\u0026#39;) async def main(): semaphore = asyncio.Semaphore(2) await asyncio.gather( semaphoring(semaphore), semaphoring(semaphore), semaphoring(semaphore), semaphoring(semaphore) ) asyncio.run(main()) Output:\nAcquired the semaphore\rAcquired the semaphore\rAcquired the semaphore\rReleased the semaphore\rReleased the semaphore\rReleased the semaphore\rAcquired the semaphore\rReleased the semaphore In this example, we create a semaphore with a limit of 2 using asyncio.Semaphore and pass it to the semaphoring coroutine. We then use the async with statement to acquire the semaphore and release it when we are done. When we run the program, we can see that only two coroutines can acquire the semaphore at a time, and the other coroutines have to wait until the semaphore is released.\nSome popular asyncio libraries aiohttp: An HTTP client and server library for asyncio. fastapi: A modern web framework for building APIs with Python 3.6+ based on standard Python type hints. aiofiles: A file operations library for asyncio. ","permalink":"http://localhost:1313/posts/pages/asyncio/asyncio2/","summary":"how to write programs using this single-threaded concurrency model with asyncio","title":"Async io : Asyncio Basics (Day 2)"},{"content":"36. useRef Hook in React useRef is a hook that is specially designed to work with DOM elements. It allows you to create a reference to a DOM element and access it directly in your components so you can modify it or read its properties as needed.\nAnother important distinction is that useRef holds the same reference across re-renders of the component Similarly, useState also retains its value between renders. However, updating a state value with useState will always trigger a re-render, whereas updating the value of a useRef does not. Its explained in the below example in ## 2. Advanvced Usage\n1. Basic Usage 1. Import useRef import { useRef } from \u0026#39;react\u0026#39;; 2. Create a Reference const myRef = useRef(); 3. Attach to DOM Elements function MyComponent() { const myRef = useRef(); return ( \u0026lt;div ref={myRef}\u0026gt; \u0026lt;h1\u0026gt;useRef Example\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ); } 4. Accessing the Reference // Access the DOM element using .current const element = myRef.current; use myRef.current.value for input elements. use myRef.current.checked for checkbox elements. use myRef.current.focus() to focus on an element. use myRef.current.style to access the style object of an element.\nNote: While you can access DOM elements directly with useRef, it\u0026rsquo;s recommended to avoid manipulating them directly unless necessary.\nPractical Example: Form Input Here\u0026rsquo;s a complete example showing how to use useRef with form inputs:\nimport { useRef, useState } from \u0026#39;react\u0026#39;; function InputExample() { const inputRef = useRef(); const [inputValue, setInputValue] = useState(\u0026#39;\u0026#39;); const handleClick = () =\u0026gt; { setInputValue(inputRef.current.value); inputRef.current.value = \u0026#39;\u0026#39;; // Clear input after reading }; return ( \u0026lt;div\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; ref={inputRef} placeholder=\u0026#34;Type something...\u0026#34; /\u0026gt; \u0026lt;button onClick={handleClick}\u0026gt;Save Input\u0026lt;/button\u0026gt; \u0026lt;p\u0026gt;Saved value: {inputValue}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } Explanation:\nWe create a reference to the input element using useRef. When the button is clicked, we read the input value using inputRef.current.value and update the state. We clear the input field by setting inputRef.current.value to an empty string. 2. Advanced Usage of useRef and useState useRef and useState are both hooks used in React. Both hooks help us store values, but they behave differently: useState: The value is persistent across re-renders, but updating it triggers a re-render. useRef: The value is also persistent across re-renders, but updating it does not trigger a re-render. 2.1. Managing Previous Values in a Stopwatch Here’s an example of how to use useRef and useState to build a simple stopwatch in React:\nimport { useRef, useState } from \u0026#39;react\u0026#39;; function Stopwatch() { const timerRef = useRef(0); // To store the timer ID const [time, setTime] = useState(0); // To store the current time const [isRunning, setIsRunning] = useState(false); // To track if the stopwatch is running // Start the timer when the Start button is clicked const startTimer = () =\u0026gt; { if (!isRunning) { timerRef.current = setInterval(() =\u0026gt; { setTime((time) =\u0026gt; time + 1); // Increment the time every second }, 1000); setIsRunning(true); // Set the timer as running } }; // Stop the timer when the Stop button is clicked const stopTimer = () =\u0026gt; { clearInterval(timerRef.current); // Clear the interval to stop the timer setIsRunning(false); // Set the timer as not running }; // Reset the timer when the Reset button is clicked const resetTimer = () =\u0026gt; { clearInterval(timerRef.current); // Clear the interval to stop the timer setIsRunning(false); // Set the timer as not running setTime(0); // Reset the time to 0 }; return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Stopwatch\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;Time: {time} seconds\u0026lt;/p\u0026gt; \u0026lt;button onClick={startTimer}\u0026gt;Start\u0026lt;/button\u0026gt; \u0026lt;button onClick={stopTimer}\u0026gt;Stop\u0026lt;/button\u0026gt; \u0026lt;button onClick={resetTimer}\u0026gt;Reset\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } Explanation Creating useRef and useState variables:\ntimerRef: This holds the timer ID (returned by setInterval). We use useRef here because we don’t need the component to re-render when the timer ID changes. time: This stores the current time value of the stopwatch, and we use useState for this because we want the component to re-render whenever the time updates. isRunning: This tracks whether the stopwatch is running or not. Starting the timer (Start Button):\nWhen the \u0026ldquo;Start\u0026rdquo; button is clicked, we check if the timer is already running. If it isn’t, we start it by calling setInterval, which increments the time value every second. setInterval returns an interval ID that we store in timerRef.current. This ID will be used to stop the timer later. Stopping the timer (Stop Button):\nWhen the \u0026ldquo;Stop\u0026rdquo; button is clicked, we clear the interval using clearInterval(timerRef.current) to stop the timer. We also set isRunning to false to indicate that the timer is no longer running. Resetting the timer (Reset Button):\nWhen the \u0026ldquo;Reset\u0026rdquo; button is clicked, we clear the interval to stop the timer, set isRunning to false, and reset the time back to 0. Why useRef? Why not just use a regular variable?\nA regular variable inside the component would reset every time the component re-renders. Since the timer is being updated every second, this would cause issues because the value would be reset each time, and the timer wouldn’t function correctly. Why useRef over useState for the timer ID?\nWe use useRef to store the timer ID because updating it with useState would trigger a re-render every time the timer ID changes. Since the timer is running independently, we don’t need a re-render, so useRef is more efficient here. Key Takeaways useRef is useful for storing values that don’t require the component to re-render when they change. useState is used for values that should trigger a re-render when updated, like the time value in our stopwatch. useRef does not cause a re-render when its value changes, making it ideal for holding values like the interval ID that don’t need to affect the UI. Common Use Cases Storing previous values Managing focus, text selection, or media playback Integrating with third-party DOM libraries Accessing underlying DOM elements Isolation in Components: Any variable that is declared inside a component is isolated to that component. It is not shared with other components unless explicitly passed as props. This isolation helps maintain the encapsulation and modularity of components in React.\n37.Forwarding Refs in React Forwarding refs is a technique in React that allows you to pass a ref from a parent component to a child component. This is useful when you want to access the DOM element of a child component from a parent component.\n1. Basic Usage 1.Import useRef import { useRef } from \u0026#39;react\u0026#39;; 2. Create a Ref in the Parent Component const myRef= useRef(); 3. Pass the Ref to the Child Component \u0026lt;MyChildComponent ref={myRef} /\u0026gt; 4.Import forward ref in child component import React, { forwardRef } from \u0026#39;react\u0026#39;; 5. Using forwardRef to Forward the Ref const MyChildComponent = forwardRef((props, ref) =\u0026gt; { return \u0026lt;input ref={ref} /\u0026gt;; }); 6. Accessing the Ref in the Parent Component const element = myRef.current.value; Practical Example: Input Focus to take input from user and focus on the input field of the child component from the parent component.\nimport React, { useRef } from \u0026#39;react\u0026#39;; const InputComponent = forwardRef(({title}, ref) =\u0026gt; { return\u0026lt;\u0026gt; \u0026lt;h1\u0026gt;{title}\u0026lt;/h1\u0026gt; \u0026lt;input ref={ref}/\u0026gt; \u0026lt;/\u0026gt; }); function ParentComponent() { const inputRef = useRef(); const handleClick = () =\u0026gt; { inputRef.current.focus(); console.log(inputRef.current.value); }; return ( \u0026lt;div\u0026gt; \u0026lt;InputComponent ref={inputRef} title=\u0026#34;ENter the Input\u0026#34;/\u0026gt; \u0026lt;button onClick={handleClick}\u0026gt;Focus Input\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 38.useImperativeHandle in React In large-scale applications, we generally avoid using refs directly to access child components. Instead, we use the useImperativeHandle hook to expose specific methods from the child component to the parent component. This approach allows the developer working on the parent component to interact with the child component\u0026rsquo;s methods without needing to understand its internal implementation. Additionally, this separation enables the developer of the child component to modify or update the child component independently, without affecting the parent component. Since only the exposed methods are used by the parent, changes to the internal structure of the child component do not disrupt the parent-child interaction.This is specially used in forwardRef to expose methods of child component to parent component.\nBasic Usage 1.Pass a Ref to the Child Component import {useRef} from \u0026#39;react\u0026#39;; function App() { const childRef = useRef(); return \u0026lt;ChildComponent ref={childRef} /\u0026gt;; } =\u0026gt; Here, we create a ref using useRef and pass it to the ChildComponent using the ref prop.\n2. Use useImperativeHandle in the Child Component with forwardRef to expose methods import { useImperativeHandle, forwardRef } from \u0026#39;react\u0026#39;; const ChildComponent = forwardRef((props, ref) =\u0026gt; { useImperativeHandle(ref, () =\u0026gt; ({ focus: () =\u0026gt; { // Focus on the input element }, reset: () =\u0026gt; { // Reset the input element }, inputValue:\u0026#39;vaule\u0026#39; }),[dependencies]); return \u0026lt;input /\u0026gt;; }); In the ChildComponent, we use the useImperativeHandle hook to expose the focus and reset methods to the parent component. The ref object is passed as the first argument, and the second argument is a function that returns an object containing the methods to be exposed. dependencies is an optional array of values that, when changed, will trigger the re-evaluation of the function that returns the methods. If the dependencies array is not provided, the function will be called on every render and empty array will call only once in entire lifecycle.\n3. Access the Exposed Methods in the Parent Component function App() { const childRef = useRef(); const handleClick = () =\u0026gt; { childRef.current.focus(); }; const resetClick = () =\u0026gt; { childRef.current.reset(); }; return ( \u0026lt;\u0026gt; \u0026lt;ChildComponent ref={childRef} /\u0026gt; \u0026lt;button onClick={handleClick}\u0026gt;Focus Input\u0026lt;/button\u0026gt; \u0026lt;button onClick={resetClick}\u0026gt;Reset Input\u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; ); } In the parent component, we can access the exposed methods using the current property of the ref object. In this example, we call the focus method when the \u0026ldquo;Focus Input\u0026rdquo; button is clicked.\nPractical Example: Use forwardRef and useImperativeHandle to Expose Methods for reset the input field and get the value of the input field. import {useRef} from \u0026#39;react\u0026#39;; function App(){ const childRef = useRef(); const handleClick = () =\u0026gt; { childRef.current.focus(); }; const resetClick = () =\u0026gt; { childRef.current.reset(); }; const getValue = () =\u0026gt; { console.log(childRef.current.value); }; return ( \u0026lt;\u0026gt; \u0026lt;ChildComponent ref={childRef} /\u0026gt; \u0026lt;button onClick={handleClick}\u0026gt;Focus Input\u0026lt;/button\u0026gt; \u0026lt;button onClick={resetClick}\u0026gt;Reset Input\u0026lt;/button\u0026gt; \u0026lt;button onClick={getValue}\u0026gt;Get Value\u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; ); } export default App; import { useImperativeHandle, forwardRef,useRef } from \u0026#39;react\u0026#39;; const ChildComponent = forwardRef((props, ref) =\u0026gt; { const inputRef = useRef(); useImperativeHandle(ref, () =\u0026gt; ({ focus: () =\u0026gt; { inputRef.current.focus(); }, reset: () =\u0026gt; { inputRef.current.value = \u0026#39;\u0026#39;; }, value: inputRef.current.value }),[]); return \u0026lt;input ref={inputRef} /\u0026gt;; }); export default ChildComponent; =\u0026gt; By using useImperativeHandle, we can expose specific methods from the child component to the parent component, allowing for more controlled interactions between the components such as focusing on the input field, resetting the input field, and getting the value of the input field in this example. =\u0026gt; By using this approach, we can maintain a clear separation of concerns between the parent and child components, making it easier to manage and update the components independently.\n37. Portals in React Portals in React provide a way to render children components outside the DOM hierarchy of the parent component. This allows you to render a child component at a different location in the DOM, such as at the root level or inside a specific container, without affecting the parent\u0026rsquo;s layout or styles.\nImporting portal from react-dom import { createPortal } from \u0026#39;react-dom\u0026#39;; using createPortal const MyPortal = ({title}) =\u0026gt; { return createPortal( \u0026lt;\u0026gt; \u0026lt;h1\u0026gt;{title}\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;This is a portal\u0026lt;/p\u0026gt; \u0026lt;\u0026gt;, document.getElementById(\u0026#39;portal-root\u0026#39;)); }; =\u0026gt;When the MyPortal component is rendered, the content will be rendered inside the element with the id \u0026lsquo;portal-root\u0026rsquo;, which can be located anywhere in the DOM.\n","permalink":"http://localhost:1313/posts/pages/react/react7/","summary":"Learn about useRef hook, ref forwarding, useImperativeHandle and Portals in React for DOM manipulation and component interactions.","title":"React : Day 7"},{"content":"1. Some Important Concepts 1.1 Parallism vs Concurrency Parallism: Running multiple tasks at the same time. There are multiple Threads or Processes running at the same time. Concurrency: Switching between multiple tasks. When one task is waiting for I/O, another task can run. There is only one Thread or Process running at a time. 1.2 Synchronous vs Asynchronous Synchronous: Code is executed in sequence. Previous task/line must be completed before the next task/line execution starts. Asynchronous: Code is executed in parallel. Tasks can run concurrently. The next task can start before the previous task is completed. 1.3 Blocking vs Non-Blocking Blocking: The execution of the code is blocked until the task is completed. The next task can\u0026rsquo;t start until the previous task is completed. import time def task1(): print(\u0026#34;Task 1 started\u0026#34;) time.sleep(2) print(\u0026#34;Task 1 completed\u0026#34;) def task2(): print(\u0026#34;Task 2 started\u0026#34;) time.sleep(2) print(\u0026#34;Task 2 completed\u0026#34;) task1() task2() Non-Blocking: The excecution of the code is not blocked. The next task can start before the previous task is completed. import asyncio async def task1(): print(\u0026#34;Task 1 started\u0026#34;) await asyncio.sleep(2) print(\u0026#34;Task 1 completed\u0026#34;) async def task2(): print(\u0026#34;Task 2 started\u0026#34;) await asyncio.sleep(2) print(\u0026#34;Task 2 completed\u0026#34;) async def main(): await asyncio.gather(task1(), task2()) asyncio.run(main()) 1.4 I/O Bound vs CPU Bound I/O Bound: The program is waiting for input/output operations to complete. The program is not using the CPU much. CPU Bound: The program is using the CPU a lot. The program is not waiting for input/output operations to complete. import request response = request.get(\u0026#34;https://www.google.com\u0026#34;) # I/O Bound items = response.headers.items() # CPU Bound headers = [f\u0026#39;{key}: {header}\u0026#39; for key, header in items] # CPU Bound formatted_headers = \u0026#39;\\n\u0026#39;.join(headers) # CPU Bound with open(\u0026#39;headers.txt\u0026#39;, \u0026#39;w\u0026#39;) as file: # I/O Bound file.write(formatted_headers) # I/O Bound 2. How Concurrency is Achieved in Os level To better understand this, we’ll need to dive into how sockets work and, in particular, how non-blocking sockets work.\n2.1 Sockets A socket is a low-level abstraction for sending and receiving data over a network. It is the basis for how data is transferred to and from servers. Sockets support two main operations: sending bytes and receiving bytes. We write bytes to a socket, which will then get sent to a remote address, typically some type of server. Once we’ve sent those bytes, we wait for the server to write its response back to our socket. Once these bytes have been sent back to our socket, we can then read the result.\nIn the case of getting the contents from example.com as we saw earlier, we open a socket that connects to example.com’s server. We then write a request to get the contents to that socket and wait for the server to reply with the result: in this case, the HTML of the web page. We can visualize the flow of bytes to and from the server in figure 1.7\nSockets are blocking by default. Simply put, this means that when we are waiting for a server to reply with data, we halt our application or block it until we get data to read. Thus, our application stops running any other tasks until we get data from the server, an error happens, or there is a timeout. At the operating system level, we don’t need to do this blocking. Sockets can operate in non-blocking mode. In non-blocking mode, when we write bytes to a socket, we can just fire and forget the write or read, and our application can go on to perform other tasks. Later, we can have the operating system tell us that we received bytes and deal with it at that time. This lets the application do any number of things while we wait for bytes to come back to us. Instead of blocking and waiting for data to come to us, we become more reactive, letting the operating system inform us when there is data for us to act on. In the background, this is performed by a few different event notification systems, depending on which operating system we’re running. asyncio is abstracted enough that it switches between the different notification systems, depending on which one our operating system supports. The following are the event notification systems used by specific operating systems:\nkqueue—FreeBSD and MacOS epoll—Linux IOCP (I/O completion port)—Windows These systems keep track of our non-blocking sockets and notify us when they are ready for us to do something with them. This notification system is the basis of how asyncio can achieve concurrency.\nBut how do we keep track of multiple tasks that are waiting for data to come back to them? This is where the event loop comes in.\n2.2 Event Loop The event loop is the core of every asyncio application. In asyncio, the event loop keeps a queue of tasks.\n2.2.1 How the Event Loop Works The event loop works by keeping a queue of tasks instead of messages. Each task is a coroutine. When a task is added to the event loop, it will execute until it encounters an I/O operation (such as a web request). When a task hits an I/O-bound operation, it pauses and allows the event loop to run other tasks that are not waiting for I/O operations to complete. 2.2.2 Understanding Event Loops in Asynchronous Programming When working with event loops in asynchronous programming, the process can be understood as a sequence of steps that efficiently handle tasks without blocking the execution. Here\u0026rsquo;s a breakdown of how it works:\n2.2.2.1 Creating the Event Loop When an event loop is created, an empty queue of tasks is initialized. This queue will hold all the tasks that need to be executed.\n2.2.2.2 Adding Tasks to the Queue We add tasks to the event loop’s queue. These tasks are executed one at a time, based on their order in the queue.\n2.2.2.3 Processing Tasks Iteratively Each iteration of the event loop checks for tasks that need to be executed. It processes tasks sequentially, running them one by one.\n2.2.2.4 Handling I/O Operations If a task encounters an I/O operation (like reading from a file or making a network request), it cannot proceed immediately. In this case, the task is paused and put on hold.\n2.2.2.5 Pausing and Waiting for I/O Completion When a task is paused, the event loop instructs the operating system to monitor any associated sockets or resources for I/O completion. During this time, the event loop continues checking for and executing other tasks.\n2.2.2.6 Waking Up Paused Tasks On each iteration of the event loop, we check if any of the I/O operations have completed. If they have:\nThe paused task is woken up. The task resumes execution and completes its process. 2.2.2.7. Conclusion This cycle of pausing, waiting for I/O, and resuming tasks allows the event loop to run multiple tasks concurrently, making it an efficient way to handle asynchronous operations without blocking the program.\nBy continuously iterating and checking for completed I/O tasks, the event loop ensures that no task is left idle while waiting for I/O operations, enabling a smooth and efficient workflow.\nVisualizing the Event Loop with Asynchronous Tasks We can visualize how the event loop works with asynchronous tasks as shown in Figure 1.9: the main thread submits tasks to the event loop, which then runs them. When a task encounters an I/O operation, it pauses and allows other tasks to run. Once the I/O operation is complete, the paused task is resumed.\nExample: Submitting Multiple Asynchronous Tasks Let\u0026rsquo;s consider three tasks that each make an asynchronous web request. These tasks consist of:\nCPU-bound setup: Some code that prepares data for the web request. I/O-bound web request: The asynchronous part where we send the web request. CPU-bound post-processing: After the web request completes, we do some more CPU-intensive work. Now, let\u0026rsquo;s submit these tasks to the event loop simultaneously. Here’s how we can write this in pseudocode:\ndef make_request(): cpu_bound_setup() io_bound_web_request() cpu_bound_postprocess() task_one = make_request() task_two = make_request() task_three = make_request() First task starts executing code, and the other two are left waiting to run. Once the CPU-bound setup work is finished in Task 1, it hits an I/O-bound operation and will pause itself to say, “I’m waiting for I/O; any other tasks waiting to run can run.” Once this happens, Task 2 can begin executing. Task 2 starts its CPU-bound code and then pauses, waiting for I/O. At this time both Task 1 and Task 2 are waiting concurrently for their network request to complete. Since Tasks 1 and 2 are both paused waiting for I/O, we start running Task 3. Now imagine once Task 3 pauses to wait for its I/O to complete, the web request for Task 1 has finished. We’re now alerted by our operating system’s event notification system that this I/O has finished. We can now resume executing Task 1 while both Task 2 and Task 3 are waiting for their I/O to finish. In figure 1.10, we show the execution flow of the pseudocode we just described. If we look at any vertical slice of this diagram, we can see that only one CPU-bound piece of work is running at any given time; however, we have up to two I/O-bound operations happening concurrently. This overlapping of waiting for I/O per each task is where the real time savings of asyncio comes in.\n","permalink":"http://localhost:1313/posts/pages/asyncio/asyncio1/","summary":"An introduction to asynchronous programming in Python using asyncio.","title":"Async io : Async io Intro (Day 1)"},{"content":"34.Styling in CSS 34.1 Setting Inline Styles =\u0026gt; In react for inline styles we use the style attribute and pass an object with camelCase properties.\nimport React from \u0026#39;react\u0026#39;; const myStyle = { color: \u0026#39;blue\u0026#39;, backgroundColor: \u0026#39;yellow\u0026#39; } const MyComponent = () =\u0026gt; { return ( \u0026lt;div style={myStyle}\u0026gt; \u0026lt;h1\u0026gt;Inline Styles\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ) } or we can use the style attribute directly in the element.\nimport React from \u0026#39;react\u0026#39;; const MyComponent = () =\u0026gt; { return ( \u0026lt;div style={{color: \u0026#39;blue\u0026#39;, backgroundColor: \u0026#39;yellow\u0026#39;}}\u0026gt; \u0026lt;h1\u0026gt;Inline Styles\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ) } 34.2 Setting External Styles =\u0026gt; We can also use external CSS files in react. We can import the CSS file in the component file and use the class name in the\nimport React from \u0026#39;react\u0026#39;; import \u0026#39;./MyComponent.css\u0026#39;; const MyComponent = () =\u0026gt; { return ( \u0026lt;div className=\u0026#34;myStyle\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;External Styles\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ) } 34.3 Setting Inline Dynamic Styles =\u0026gt;You can also set the inline styles dynamically by using the state.\nimport React,{useState} from \u0026#39;react\u0026#39;; const App=()=\u0026gt;{ const [valid,setValid]=useState(true); function changeStyle(){ setValid(!valid); } const myStyle={ color:valid?\u0026#39;blue\u0026#39;:\u0026#39;red\u0026#39;, backgroundColor:valid?\u0026#39;yellow\u0026#39;:\u0026#39;green\u0026#39; } return( \u0026lt;div\u0026gt; \u0026lt;button onClick={changeStyle}\u0026gt;Change Style\u0026lt;/button\u0026gt; \u0026lt;div style={myStyle}\u0026gt; \u0026lt;h1\u0026gt;Inline Dynamic Styles\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) } export default App; or we can use the style attribute directly in the element.\nimport React,{useState} from \u0026#39;react\u0026#39;; const App=()=\u0026gt;{ const [valid,setValid]=useState(true); function changeStyle(){ setValid(!valid); } return( \u0026lt;div\u0026gt; \u0026lt;button onClick={changeStyle}\u0026gt;Change Style\u0026lt;/button\u0026gt; \u0026lt;div style={{color:valid?\u0026#39;blue\u0026#39;:\u0026#39;red\u0026#39;,backgroundColor:valid?\u0026#39;yellow\u0026#39;:\u0026#39;green\u0026#39;}}\u0026gt; \u0026lt;h1\u0026gt;Inline Dynamic Styles\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) } export default App; 34.4 Setting Css Classes Dynamically =\u0026gt; We can also set the CSS classes dynamically by using the state.\nimport React,{useState} from \u0026#39;react\u0026#39;; import \u0026#39;./MyComponent.css\u0026#39;; const App=()=\u0026gt;{ const [valid,setValid]=useState(true); const [active,setActive]=useState(true); function changeStyle(){ setValid(!valid); setActive(!active); } return( \u0026lt;div\u0026gt; \u0026lt;button onClick={changeStyle}\u0026gt;Change Style\u0026lt;/button\u0026gt; \u0026lt;div className={`div-control ${valid?\u0026#39;right\u0026#39;:\u0026#39;wrong\u0026#39;} ${active?\u0026#39;active\u0026#39;:\u0026#39;inactive\u0026#39;}`}\u0026gt; \u0026lt;h1\u0026gt;Setting Css Classes Dynamically\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) } export default App; 34.5 Css modules =\u0026gt; Every time we import Css file in react component they are regarded as global styles i.e One component style can affect another component style =\u0026gt;So, to avoid this we can use CSS modules. CSS modules are local by default. We can use CSS modules by naming the CSS file as filename.module.css. =\u0026gt; The CSS file is imported in the component file and the class name is used as an object.\nProblem1 =\u0026gt; Imagine that you have two components with the same class name. The styles of one component can affect the styles of another component.which is not good for the application to solve this problem we can use CSS modules.\nStructure of the project\nsrc\r|_components\r|_MyComponent\r|_MyComponent.js\r|_MyComponent.module.css Step 1: Create a CSS file with the name MyComponent.module.css\n.myStyle{ color: blue; background-color: yellow; } .right{ text-align: right; } Step 2: Import the CSS file in the component file as shown below.\nimport React from \u0026#39;react\u0026#39;; import styles from \u0026#39;./MyComponent.module.css\u0026#39;; step 3: Use the class name as shown below.\nconst MyComponent = () =\u0026gt; { return ( \u0026lt;div className={styles.myStyle}\u0026gt; \u0026lt;h1\u0026gt;CSS Modules\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ) } Combined code\nimport React from \u0026#39;react\u0026#39;; import styles from \u0026#39;./MyComponent.module.css\u0026#39;; const MyComponent = () =\u0026gt; { return ( \u0026lt;div className={styles.myStyle}\u0026gt; \u0026lt;h1\u0026gt;CSS Modules\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ) } export default MyComponent; 34.5.1 Combining multiple classes import React from \u0026#39;react\u0026#39;; import styles from \u0026#39;./MyComponent.module.css\u0026#39;; const MyComponent = () =\u0026gt; { return ( \u0026lt;div className={`${styles.myStyle} ${styles.right}`}\u0026gt; \u0026lt;h1\u0026gt;CSS Modules\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ) } export default MyComponent; 34.6 Dynamic CSS Modules =\u0026gt; We can also set the CSS classes dynamically by using the state.\nimport React,{useState} from \u0026#39;react\u0026#39;; import styles from \u0026#39;./MyComponent.module.css\u0026#39;; const MyComponent = () =\u0026gt; { const [valid,setValid]=useState(true); const [active,setActive]=useState(true); function changeStyle(){ setValid(!valid); setActive(!active); } return ( \u0026lt;div className={`${styles.myStyle} ${valid?styles.right:styles.wrong} ${active?styles.active:styles.inactive}`}\u0026gt; \u0026lt;h1\u0026gt;CSS Modules\u0026lt;/h1\u0026gt; \u0026lt;button onClick={changeStyle}\u0026gt;Change Style\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } export default MyComponent; ","permalink":"http://localhost:1313/posts/pages/react/react5/","summary":"Learn various methods to style React components including inline styles, external styles, dynamic styles, and CSS modules.","title":"React : Day 5"},{"content":"35. Debugging in react 35.1 Using console.log import React from \u0026#39;react\u0026#39;; const MyComponent = () =\u0026gt; { const name = \u0026#39;John Doe\u0026#39;; console.log(name); return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Debugging in React\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ) } export default MyComponent; 35.2 Strict Mode =\u0026gt; In Strict Mode,React will render components twice. It helps to idenify the issues in the code.\nimport React,{StrictMode} from \u0026#39;react\u0026#39;; const MyComponent = () =\u0026gt; { const name = \u0026#39;John Doe\u0026#39;; console.log(name); return ( \u0026lt;StrictMode\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Debugging in React\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/StrictMode\u0026gt; ) } export default MyComponent; You can wrap any component in StrictMode.Just difference is that it will render the component twice.\n=\u0026gt; We can wrap the entire application in StrictMode in the index.js file.\nimport React,{StrictMode} from \u0026#39;react\u0026#39;; import ReactDOM from \u0026#39;react-dom\u0026#39;; import App from \u0026#39;./App\u0026#39;; ReactDOM.render( \u0026lt;StrictMode\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/StrictMode\u0026gt;, document.getElementById(\u0026#39;root\u0026#39;) ); 35.3 React Developer Tools React Developer Tools is a Chrome extension that allows you to inspect the React component hierarchy in the Chrome Developer Tools. Videos\n","permalink":"http://localhost:1313/posts/pages/react/react6/","summary":"Learn how to debug React applications using console.log, Strict Mode, and React Developer Tools.","title":"React : Day 6"},{"content":"Python Fundamentals: A Beginner\u0026rsquo;s Guide (Part 1) 1. Virtual Environment A virtual environment is a feature in Python that allows you to install the same package with different versions on the same system. This enables you to work on multiple projects using different versions of the same package.\n1.1. Installing venv The venv module is included in the Python standard library, so you don\u0026rsquo;t need to install it separately. However, if you are using an older version of Python (before 3.3), you can install virtualenv using pip:\npip install virtualenv 1.2. Creating a Virtual Environment To create a virtual environment, you can use the venv module, which is included in the Python standard library. Here\u0026rsquo;s how you can create a virtual environment named myenv:\npython -m venv myenv This command creates a new directory named myenv that contains the necessary files for the virtual environment.\n1.3. Activating a Virtual Environment To activate the virtual environment, you may run the following command:\n# For Linux/Mac: source myenv/bin/activate # For Windows: myenv\\Scripts\\activate 2. Python Packages 2.1. List All the Python Packages To list or save all the installed packages in the current environment, you can use the following command using freeze:\npip freeze # To list all the installed packages pip freeze \u0026gt; requirements.txt # To save all the installed packages in a file 2.2. Installing Python Packages To install a Python package, you can use the pip install command followed by the package name. For example, to install the requests package, you can run:\npip install requests 2.3. Uninstalling Python Packages To uninstall a Python package, you can use the pip uninstall command followed by the package name. For example, to uninstall the requests package, you can run:\npip uninstall requests 2.4. Run Python Package/Script To run a python package or script, you can use the following command:\npython -m package_name 3. Python Basics 3.1. Running a Python Script To run a Python script, you can use the following command:\npython script.py 3.2. Python Indentation In Python, the code block (body of the function, loop, etc.) starts with a colon (:) and the line following the colon should be indented.\nif 5 \u0026gt; 2: print(\u0026#34;Five is greater than two!\u0026#34;) # Indented block 3.3. Python Comments There are two types of comments in Python:\n# This is a single line comment \u0026#34;\u0026#34;\u0026#34; This is a multiline comment This is a multiline comment This is a multiline comment This is a multiline comment \u0026#34;\u0026#34;\u0026#34; 3.4. Print Statement The print() function is used to display the output on the console. For example:\nprint(\u0026#34;Hello, World!\u0026#34;) 3.5. Data Types Python has the following data types:\nint float str bool list tuple set dict None a = 10 # int b = 10.5 # float c = \u0026#34;Hello\u0026#34; # str d = True # bool e = [1,2,3] # list f = (1,2,3) # tuple g = {1,2,3} # set h = {\u0026#34;name\u0026#34;:\u0026#34;John\u0026#34;,\u0026#34;age\u0026#34;:30} # dict i = None # None print(type(a)) # \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; Note:Use type() function to check the data type of a variable.As it return the class of the variable.\n3.6. Rules of Variable Declaration A variable name must start with a letter or the underscore character. A variable name cannot start with a number. A variable name can only contain alpha-numeric characters and underscores (A-z, 0-9, and _ ). Variable names are case-sensitive (age, Age, and AGE are three different variables). 3.7. Type Conversion You can convert one data type to another using the following functions:\nint(): To convert to an integer float(): To convert to a float str(): To convert to a string bool(): To convert to a boolean list(): To convert to a list tuple(): To convert to a tuple set(): To convert to a set dict(): To convert to a dictionary a = 10 #a=10 b = float(a) #b=10.0 c = str(a) #c=\u0026#39;10\u0026#39; d = bool(a) #d=True e = list(c) #e=[\u0026#39;1\u0026#39;,\u0026#39;0\u0026#39;] f = tuple(c) #f=(\u0026#39;1\u0026#39;,\u0026#39;0\u0026#39;) g = set(c) #g={\u0026#39;1\u0026#39;,\u0026#39;0\u0026#39;} h = dict(name=\u0026#34;John\u0026#34;,age=30) or dict([(\u0026#34;name\u0026#34;,\u0026#34;John\u0026#34;),(\u0026#34;age\u0026#34;,30)]) #h={\u0026#39;name\u0026#39;:\u0026#39;John\u0026#39;,\u0026#39;age\u0026#39;:30} Note: Python is dynamically typed, which means a variable\u0026rsquo;s data type can be changed.\n4. Operators 4.1. Arithmetic Operators +: Addition -: Subtraction *: Multiplication /: Division %: Modulus **: Power //: Floor Division a = 10 b = 3 print(a + b) # 13 print(a - b) # 7 print(a * b) # 30 print(a / b) # 3.3333333333333335 print(a % b) # 1 print(a ** b) # 1000 print(a // b) # 3 4.2. Assignment Operators =: Assign value +=: Add and assign -=: Subtract and assign *=: Multiply and assign /=: Divide and assign %=: Modulus and assign **=: Power and assign //=: Floor Division and assign a = 10 a += 5 # a = a + 5 a -= 5 # a = a - 5 a *= 5 # a = a * 5 a /= 5 # a = a / 5 a %= 5 # a = a % 5 a **= 5 # a = a ** 5 a //= 5 # a = a // 5 4.3. Comparison Operators ==: Equal to !=: Not equal to \u0026gt;: Greater than \u0026lt;: Less than \u0026gt;=: Greater than or equal to \u0026lt;=: Less than or equal to a = 10 b = 20 print(a == b) # False print(a != b) # True print(a \u0026gt; b) # False print(a \u0026lt; b) # True print(a \u0026gt;= b) # False print(a \u0026lt;= b) # True 4.4. Logical Operators and: Returns True if both statements are true or: Returns True if one of the statements is true not: Reverse the result, returns False if the result is true a = 10 b = 20 c = 30 print(a \u0026lt; b and b \u0026lt; c) # True print(a \u0026lt; b or b \u0026gt; c) # True print(not(a \u0026lt; b and b \u0026lt; c)) # False 4.5. Identity Operators is: Returns True if both variables are the same object is not: Returns True if both variables are not the same object a = [1,2,3] b = [1,2,3] print(a is b) # False print(a is not b) # True 4.6. Membership Operators in: Returns True if a sequence with the specified value is present in the object not in: Returns True if a sequence with the specified value is not present in the object a = [1,2,3] #Can be used in list , tuple , set , dict, string print(1 in a) # True print(4 not in a) # True 4.7. Bitwise Operators \u0026amp;: AND |: OR ^: XOR ~: NOT \u0026lt;\u0026lt;: Left Shift \u0026gt;\u0026gt;: Right Shift a = 10 b = 4 print(a \u0026amp; b) # 0 print(a | b) # 14 print(a ^ b) # 14 print(~a) # -11 print(a \u0026lt;\u0026lt; 2) # 40 print(a \u0026gt;\u0026gt; 2) # 2 Note: is vs ==\nis is used to compare the memory location of two objects. == is used to compare the values of two objects. # For Mutable objects (list, dict, set): a = [1,2,3] b = [1,2,3] print(a == b) # True print(a is b) # False # For immutable objects (int, float, string, tuple, None): a = 10 b = 10 print(a == b) # True print(a is b) # True c = None d = None print(c == d) # True print(c is d) # True 5.Taking User Input In Python, you can take user input using the input() function. Here\u0026rsquo;s an example:\nname = input(\u0026#34;Enter your name: \u0026#34;) print(\u0026#34;Hello, \u0026#34; + name) Note: The input() function always returns a string. If you want to convert it to another data type, you can use type conversion functions like int(), float(), etc.\n","permalink":"http://localhost:1313/posts/pages/python/python_basics/","summary":"A comprehensive guide to Python programming fundamentals covering core concepts for beginners","title":"Python Fundamentals: A Beginner's Guide (Part 1)"},{"content":"30. Sharing State Between React Components: Lifting State Up In React, components are the building blocks of a user interface. Each component can have its own state, but there are situations where multiple components need to share the same state. In such cases, the concept of \u0026ldquo;lifting state up\u0026rdquo; is used to manage the shared state in a common ancestor component.\u0026ldquo;Lifting state up\u0026rdquo; is a common pattern in React used when two or more components need to share data or state. Instead of managing the state in one of the components and creating a dependency between them, the state is \u0026ldquo;lifted up\u0026rdquo; to the closest common ancestor of the components that need the state.\nKey Concept When multiple components need to interact with the same state:\nThe closest common ancestor is identified. The state is moved to this common ancestor. This ancestor manages the state and passes it down to the child components as props. If any child needs to modify the state, the ancestor provides a function (passed as a prop) to handle the state update. Step-by-Step Procedure and Syntax Identify the Closest Common Ancestor:\nDetermine which component is the nearest common parent of all components that need to share the state. Lift the State Up:\nMove the state to the identified ancestor component. Use the useState hook (or class component state) to manage the state. const [state, setState] = useState(initialValue); Pass State Down as Props:\nPass the state to child components that need it via props. \u0026lt;ChildComponent state={state} /\u0026gt; Create State-Modifier Functions:\nDefine functions in the ancestor component to modify the state. const modifyStateHandler = (newData) =\u0026gt; { setState((prev) =\u0026gt; ({ ...prev, newData })); }; Pass Modifier Functions to Children:\nPass these functions to the child components as props so they can trigger state updates. \u0026lt;ChildComponent onModifyState={modifyStateHandler} /\u0026gt; Use Props in Child Components:\nAccess and use the state and modifier functions passed as props in the child components. function ChildComponent({ state, onModifyState }) { return ( \u0026lt;button onClick={() =\u0026gt; onModifyState(\u0026#34;new data\u0026#34;)}\u0026gt;Modify State\u0026lt;/button\u0026gt; ); } Example (Sharing State/Data Between Two Child Component) Parent Component (App.js) The parent component will hold the shared state and provide functions for updating it. It will pass the state and update functions as props to the child components.\nimport React, { useState } from \u0026#34;react\u0026#34;; import ChildOne from \u0026#34;./ChildOne\u0026#34;; import ChildTwo from \u0026#34;./ChildTwo\u0026#34;; const App = () =\u0026gt; { // Shared state const [sharedState, setSharedState] = useState(\u0026#34;Initial State\u0026#34;); // Function to update the state const updateState = (newState) =\u0026gt; { setSharedState(newState); }; return ( \u0026lt;div style={{ padding: \u0026#34;20px\u0026#34;, fontFamily: \u0026#34;Arial\u0026#34; }}\u0026gt; \u0026lt;h1\u0026gt;Parent Component\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;Shared State: {sharedState}\u0026lt;/p\u0026gt; \u0026lt;hr /\u0026gt; \u0026lt;ChildOne sharedState={sharedState} updateState={updateState} /\u0026gt; \u0026lt;hr /\u0026gt; \u0026lt;ChildTwo sharedState={sharedState} updateState={updateState} /\u0026gt; \u0026lt;/div\u0026gt; ); }; export default App; Child Component 1 (ChildOne.js) This component will display the shared state and allow the user to modify it through an input field.\nimport React from \u0026#34;react\u0026#34;; const ChildOne = ({ sharedState, updateState }) =\u0026gt; { const handleChange = (e) =\u0026gt; { updateState(e.target.value); }; return ( \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;Child Component One\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;Shared State: {sharedState}\u0026lt;/p\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; value={sharedState} onChange={handleChange} placeholder=\u0026#34;Update State\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; ); }; export default ChildOne; Child Component 2 (ChildTwo.js) This component will display the shared state and provide a button to reset it.\nimport React from \u0026#34;react\u0026#34;; import React from \u0026#34;react\u0026#34;; const ChildTwo = ({ sharedState, updateState }) =\u0026gt; { const handleReset = () =\u0026gt; { updateState(\u0026#34;Initial State\u0026#34;); }; return ( \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;Child Component Two\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;Shared State: {sharedState}\u0026lt;/p\u0026gt; \u0026lt;button onClick={handleReset}\u0026gt;Reset State\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); }; export default ChildTwo; Folder Structure src/ ├── App.js ├── ChildOne.js ├── ChildTwo.js ├── index.js Explanation:\nThe App component is the parent component that holds the shared state and passes it down to ChildOne and ChildTwo. ChildOne and ChildTwo are child components that receive the shared state and update functions as props. ChildOne allows the user to update the shared state through an input field, while ChildTwo provides a button to reset the state. Note: We cant directly pass data from one child component to another child component. We need to pass the data to the parent component and then pass it to the other child component. This is called lifting state up.\nExample (Sharing State/Data Between Two Sibling Components) Parent Component (App.js) import {usState} from \u0026#39;react\u0026#39;; import Expenses from \u0026#39;./Expenses\u0026#39;; import NewExpense from \u0026#39;./NewExpense\u0026#39;; const App=()=\u0026gt;{ const [expenses,setExpenses]=useState([ {id:1,title:\u0026#39;Car Insurance\u0026#39;,amount:294.67,date:new Date(2021,2,28)}, {id:2,title:\u0026#39;Health Insurance\u0026#39;,amount:394.67,date:new Date(2021,3,28)}, {id:3,title:\u0026#39;Home Insurance\u0026#39;,amount:494.67,date:new Date(2021,4,28)}, ]); const addExpenseHandler=(expense)=\u0026gt;{ setExpenses((prevExpenses)=\u0026gt;{ return [expense,...prevExpenses]; }); }; return ( \u0026lt;div\u0026gt; \u0026lt;NewExpense onAddExpense={addExpenseHandler}/\u0026gt; \u0026lt;Expenses items={expenses}/\u0026gt; \u0026lt;/div\u0026gt; ); }; export default App; NewExpense Component import ExpenseForm from \u0026#39;./ExpenseForm\u0026#39;; const NewExpense=(props)=\u0026gt;{ const saveExpenseDataHandler=(enteredExpenseData)=\u0026gt;{ const expenseData={ ...enteredExpenseData, id:Math.random().toString() }; props.onAddExpense(expenseData); }; return ( \u0026lt;div\u0026gt; \u0026lt;ExpenseForm onSaveExpenseData={saveExpenseDataHandler}/\u0026gt; \u0026lt;/div\u0026gt; ); }; export default NewExpense; Expenses function Expenses({iteam}){ return ( \u0026lt;\u0026gt; {items.map((expense)=\u0026gt;( \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;{expense.title}\u0026lt;/h2\u0026gt; \u0026lt;div\u0026gt;{expense.amount}\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;{expense.date.toISOString()}\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ))} \u0026lt;/div\u0026gt; ) } 31. Dynamically setting object keys In JavaScript, object keys are usually set statically, but there are situations where you may need to set object keys dynamically based on some conditions or variables. This can be achieved using the square bracket notation ([]) to set object keys dynamically.\nfor example:\nconst data=\u0026#34;name\u0026#34;; const person={ [data]:\u0026#39;John\u0026#39; }; console.log(person); // {name:\u0026#39;John\u0026#39;} If we dont use square bracket notation, then the key will be set as \u0026lsquo;data\u0026rsquo; instead of \u0026rsquo;name\u0026rsquo;.\nconst data=\u0026#34;name\u0026#34;; const person={ data:\u0026#39;John\u0026#39; }; console.log(person); // {data:\u0026#39;John\u0026#39;} 32.Using SAme State Variable to store multiple values =\u0026gt; We can use the same state variable to store multiple values by using an object.\nconst [userInput,setUserInput]=useState({ enteredTitle:\u0026#39;\u0026#39;, enteredAmount:\u0026#39;\u0026#39;, enteredDate:\u0026#39;\u0026#39; }); const titleChangeHandler=(event)=\u0026gt;{ setUserInput({ ...userInput, enteredTitle:event.target.value }); }; const amountChangeHandler=(event)=\u0026gt;{ setUserInput({ ...userInput, enteredAmount:event.target.value }); }; const dateChangeHandler=(event)=\u0026gt;{ setUserInput({ ...userInput, enteredDate:event.target.value }); }; return ( \u0026lt;div\u0026gt; Title:\u0026lt;input type=\u0026#34;text\u0026#34; value={userInput.enteredTitle} onChange={titleChangeHandler}/\u0026gt; Amount:\u0026lt;input type=\u0026#34;number\u0026#34; value={userInput.enteredAmount} onChange={amountChangeHandler}/\u0026gt; Date:\u0026lt;input type=\u0026#34;date\u0026#34; value={userInput.enteredDate} onChange={dateChangeHandler}/\u0026gt; The entered title is {userInput.enteredTitle} The entered amount is {userInput.enteredAmount} The entered date is {userInput.enteredDate} \u0026lt;/div\u0026gt; ); =\u0026gt; In the above code, we are using the same state variable userInput to store multiple values. We are using an object to store the values. We are using the spread operator to copy the existing values of the object and then updating the required value.\n33.Handeling page reloads when a form is submitted When a form is submitted, the page reloads by default. This is not what we want in a single page application. We want to stay on the same page and update the content of the page. We can do this by using the preventDefault() method on the event object. The preventDefault() method prevents the default behavior of the event object. In this case, it prevents the page from reloading when the form is submitted. const submitHandler=(event)=\u0026gt;{ event.preventDefault(); // code to handle form submission }; ","permalink":"http://localhost:1313/posts/pages/react/react4/","summary":"Learn how to share state between React components by lifting state up to a common ancestor.","title":"React : Day 4"},{"content":"1. Python Manupulation of Data Types We have already discussed the basic concepts of Python programming in the previous part of this series. In this part, we will dive deeper into operations and manipulations of different data types in Python.\n1.1.Numeric Operations 1.1.1. abs() Function The abs() function returns the absolute value of a number. For example:\nnum = -10 print(abs(num)) # Output: 10 1.1.2. round() Function The round() function rounds a number to the nearest integer. For example:\nnum = 3.14159 print(round(num)) # Output: 3 1.1.3. ord() Function The ord() function returns the Unicode code point of a character. For example:\nchar = \u0026#39;A\u0026#39; print(ord(char)) # Output: 65 1.2. String Operations String is a sequence of characters enclosed within single, double, or triple quotes. In Python, strings are immutable, meaning they cannot be changed once created. Here are some common string operations:\n1.2.1. Declaring a String we can declare a string using single, double, or triple quotes. For example:\nstr1 = \u0026#39;Hello, World!\u0026#39; #for single line string str2 = \u0026#34;Hello, World!\u0026#34; #for single line string str3 = \u0026#39;\u0026#39;\u0026#39;Hello, World! This is a multiline string.\u0026#39;\u0026#39;\u0026#39;#for multiline string 1.2.2. Text Decorators There are many text decorators available in Python to format strings among them we use \\n for a new line, \\t for a tab. For example:\nstr1 = \u0026#39;Hello, \\nWorld!\u0026#39; #for new line str2 = \u0026#34;Hello, \\tWorld!\u0026#34; #for tab 1.2.3. String Indexing The indexing of a string starts from 0 to n-1, where n is the length of the string. For example: for example: a=\u0026ldquo;hello\u0026rdquo;\na = H e l l o 0 1 2 3 4 0 -4 -3 -2 -1 1.2.4. Ascessing Characters in a String We can access characters in a string using the index using []. For example:\nstr = \u0026#34;Hello, World!\u0026#34; print(str[0]) # Output: H print(str[-1]) # Output: ! 1.2.5. String Concatenation We can concatenate two strings using the + operator and * operator . For example:\nstr1 = \u0026#34;Hello\u0026#34; str2 = \u0026#34;World\u0026#34; print(str1 + str2) # Output: HelloWorld print(str1 * 3) # Output: HelloHelloHello 1.2.6. String Slicing We can slice a string using the syntax variable[start:end:step] to get a substring.\nNote: The substring contains characters from index start to end-1, meaning the character at the end index is not included but character at the start index is included . The step refers to the increment or jump of the index\nFor example:\na = \u0026#34;hello\u0026#34; # Slice from index 1 to the end of the string print(a[1:]) # ello (Characters from index 1 to the end) # Slice from the beginning of the string to index 4 (doesn\u0026#39;t contain character at index 4) print(a[:4]) # hell (Characters from index 0 to 3) # Slice from index 1 to index 4 (doesn\u0026#39;t contain character at index 4) print(a[1:4]) # ell (Characters from index 1 to 3) # Full slice of the string with default values print(a[::]) # hello (Default start is 0, end is the string length, step is 1) # Defining a step value in slicing # Slice with a step of 2 print(a[::2]) # hlo (Start from index 0 to the end, select every 2nd character) # Reverse the string using a negative step print(a[::-1]) # olleh (Reverse the string by stepping backward) # Combining start, end, and step print(a[1:4:2]) # el #(Start from index 1 to 4 (doesn\u0026#39;t contain character at index 4), with a step of 2) 1.2.7. String Methods Python provides various built-in methods to manipulate strings. Some of the commonly used string methods are:\nlen() : Returns the length of the string. str = \u0026#34;Hello, World!\u0026#34; print(len(str)) # Output: 13 replace() : Replaces a substring with another substring. str = \u0026#34;Hello, World!\u0026#34; print(str.replace(\u0026#34;World\u0026#34;, \u0026#34;Universe\u0026#34;)) # Output: Hello, Universe! upper() : Converts the string to uppercase. str = \u0026#34;Hello, World!\u0026#34; print(str.upper()) # Output: HELLO, WORLD! lower() : Converts the string to lowercase. str = \u0026#34;Hello, World!\u0026#34; print(str.lower()) # Output: hello, world! split() : Splits the string into a list based on the delimiter. str = \u0026#34;Hello, World!\u0026#34; print(str.split(\u0026#34;,\u0026#34;)) # Output: [\u0026#39;Hello\u0026#39;, \u0026#39; World!\u0026#39;] capitalize() : Converts the first character of the string to uppercase.\nstr = \u0026#34;hello, world!\u0026#34; print(str.capitalize()) # Output: Hello, world! -find() : Returns the index of the first occurrence of a substring.\nstr = \u0026#34;Hello, World!\u0026#34; print(str.find(\u0026#34;World\u0026#34;)) # Output: 7 print(str.find(\u0026#34;e\u0026#34;)) # Output: 1 print(str.find(\u0026#34;Universe\u0026#34;)) # Output: -1 count() : Returns the number of occurrences of a substring. str = \u0026#34;Hello, World!\u0026#34; print(str.count(\u0026#34;l\u0026#34;)) # Output: 3 startswith() : Returns True if the string starts with a specified substring. str = \u0026#34;Hello, World!\u0026#34; print(str.startswith(\u0026#34;Hello\u0026#34;)) # Output: True endswith() : Returns True if the string ends with a specified substring. str = \u0026#34;Hello, World!\u0026#34; print(str.endswith(\u0026#34;World!\u0026#34;)) # Output: True strip() : Removes leading and trailing whitespaces from the string. We can also specify the characters to be removed. str = \u0026#34; Hello, World! \u0026#34; print(str.strip()) # Output: Hello, World! str = \u0026#34;!!!!!!!!Hello, World!!!!!\u0026#34; print(str.strip(\u0026#34;!\u0026#34;)) # Output: Hello, World! lstrip() : Removes leading whitespaces from the string.we can also specify the characters to be removed. str = \u0026#34; Hello, World! \u0026#34; print(str.lstrip()) # Output: Hello, World! str = \u0026#34;!!!!!!!!Hello, World!!!!!\u0026#34; print(str.lstrip(\u0026#34;!\u0026#34;)) # Output: Hello, World!!!!! rstrip() : Removes trailing whitespaces from the string.We can also specify the characters to be removed. str = \u0026#34; Hello, World! \u0026#34; print(str.rstrip()) # Output: Hello, World! str = \u0026#34;!!!!!!!!Hello, World!!!!!\u0026#34; print(str.rstrip(\u0026#34;!\u0026#34;)) # Output: !!!!!!!!Hello, World 1.2.8. f-Strings f-strings are a convenient way to format strings in Python. They allow you to embed expressions inside string literals, using curly braces {}. For example:\nname = \u0026#34;Alice\u0026#34; age = 30 print(f\u0026#34;My name is {name} and I am {age} years old.\u0026#34;) # Output: My name is Alice and I am 30 years old. 1.2.9. Raw Strings Raw strings are used to ignore escape characters in a string. They are prefixed with an r or R. For example:\npath=\u0026#34;C:\\Users\\Alice\\Documents\u0026#34; print(path) # Output: C:UsersAliceDocuments path = r\u0026#34;C:\\Users\\Alice\\Documents\u0026#34; print(path) # Output: C:\\Users\\Alice\\Documents Note:String is immutable in python.\na = \u0026#34;Hello\u0026#34; a[0] = \u0026#34;h\u0026#34; # Error: \u0026#39;str\u0026#39; object does not support item assignment #Instead To change the string value we can use the following method a=\u0026#39;k\u0026#39;+a[1::] # Output: \u0026#39;kello\u0026#39; 1.3. List Operations A list is a collection of items enclosed within square brackets []. Lists are mutable, meaning they can be changed after creation. Here are some common list operations: Key Points:\nList is mutable in python. List support indexing and slicing like string 1.3.1. Declaring a List We can declare a list by enclosing items within square brackets []. For example:\nlist1 = [1, 2, 3, 4, 5] list2 = [\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;] list3 = [1, \u0026#34;apple\u0026#34;, True, 3.14] 1.3.2 List Concatenation We can concatenate two or more lists using the + operator. For example:\nlist1 = [1, 2, 3] list2 = [4, 5, 6] print(list1 + list2) # Output: [1, 2, 3, 4, 5, 6] 1.3.3. Mutable property of List List is mutable in python and its example is shown below:\n#for string a = \u0026#34;Hello\u0026#34; a[0] = \u0026#34;h\u0026#34; # Error: \u0026#39;str\u0026#39; object does not support item assignment #for list list1 = [1, 2, 3] list1[0] = 10 print(list1) # Output: [10, 2, 3] 1.3.4. Built-in List Methods Python provides various built-in methods to manipulate lists. Some of the commonly used list methods are:\nlen() : Returns the length of the list. list1 = [1, 2, 3, 4, 5] print(len(list1)) # Output: 5 append() : Adds an element to the end of the list /Change orginal list does not return anything. list1 = [1, 2, 3] list1.append(4) print(list1) # Output: [1, 2, 3, 4] insert() : Inserts an element at a specified position in the list /Change orginal list does not return anything. list1 = [1, 2, 3] list1.insert(1, 4) print(list1) # Output: [1, 4, 2, 3] pop() : Removes the element at the specified position in the list and returns it. If no index is specified, it removes and returns the last element. list1 = [1, 2, 3] print(list1.pop(1)) # Output: 2 print(list1) # Output: [1, 3] print(list1.pop()) # Output: 3 print(list1) # Output: [1] remove() : Removes the first occurrence of the specified element from the list. list1 = [1, 2, 3, 2] list1.remove(2) print(list1) # Output: [1, 3, 2] -sort() : Sorts the list in ascending order.Does not return anything but change the original list.\nlist1 = [3, 1, 2] list1.sort() print(list1) # Output: [1, 2, 3] -reverse() : Reverses the order of the list. Does not return anything but change the original list.\nlist1 = [1, 2, 3] list1.reverse() print(list1) # Output: [3, 2, 1] -count() : Returns the number of occurrences of a specified element in the list.\nlist1 = [1, 2, 3, 2] print(list1.count(2)) # Output: 2 -index() : Returns the index of the first occurrence of the specified element in the list.\nlist1 = [1, 2, 3, 2] print(list1.index(2)) # Output: 1 1.3.5. List Comprehension List comprehension is a concise way to create lists from existing lists. There are 3 type of syntax.\nNot using if list1=[variable for variable in iterable] Using if only list1 = [variable for variable in iterable if condition] Using if else list1 = [variable if condition else variable for variable in iterable] Traditional way of creating list\nlist1 = [] for i in range(5): list1.append(i) print(list1) # Output: [0, 1, 2, 3, 4] Using list comprehension\nlist1 = [i for i in range(5)] print(list1) # Output: [0, 1, 2, 3, 4] list1 = [i for i in range(5) if i%2==0] print(list1) # Output: [0, 2, 4] list1 = [i if i%2==0 else i**2 for i in range(5)] print(list1) # Output: [0, 1, 2, 9, 4] Note: When you attempt to access an index that is out of range, Python will raise an IndexError so put it in try-except block to handle the error.\nNote: The indexing and slicing of list are similar to string.\n1.4 Dictionary Operations A dictionary is a collection of key-value pairs enclosed within curly braces {}. Dictionaries are mutable and unordered. Here are some common dictionary operations:\n1.4.1. Declaring a Dictionary We can declare a dictionary by specifying key-value pairs within curly braces {}. For example:\ndict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} dict2 = {1: \u0026#34;apple\u0026#34;, 2: \u0026#34;banana\u0026#34;, 3: \u0026#34;cherry\u0026#34;} dict3 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;, \u0026#34;hobbies\u0026#34;: [\u0026#34;reading\u0026#34;, \u0026#34;painting\u0026#34;]} 1.4.2. Accessing Dictionary Elements We can access dictionary elements using keys. For example:\ndict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} print(dict1[\u0026#34;name\u0026#34;]) # Output: Alice 1.4.3 Adding Dictionary Elements We can add new key-value pairs to a dictionary by specifying the key and value. For example:\ndict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30} dict1[\u0026#34;city\u0026#34;] = \u0026#34;New York\u0026#34; print(dict1) # Output: {\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 30, \u0026#39;city\u0026#39;: \u0026#39;New York\u0026#39;} 1.4.4. Updating Dictionary Elements We can update the value of an existing key in a dictionary. For example:\ndict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} dict1[\u0026#34;age\u0026#34;] = 35 print(dict1) # Output: {\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 35, \u0026#39;city\u0026#39;: \u0026#39;New York\u0026#39;} 1.4.5 Dictionary Methods Python provides various built-in methods to manipulate dictionaries. Some of the commonly used dictionary methods are:\nlen() : Returns the number of key-value pairs in the dictionary. dict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} print(len(dict1)) # Output: 3 keys() : Returns a list of all the keys in the dictionary. dict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} print(dict1.keys()) # Output: dict_keys([\u0026#39;name\u0026#39;, \u0026#39;age\u0026#39;, \u0026#39;city\u0026#39;]) values() : Returns a list of all the values in the dictionary. dict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} print(dict1.values()) # Output: dict_values([\u0026#39;Alice\u0026#39;, 30, \u0026#39;New York\u0026#39;]) items() : Returns a list of key-value pairs in the dictionary. dict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} print(dict1.items()) # Output: dict_items([(\u0026#39;name\u0026#39;, \u0026#39;Alice\u0026#39;), (\u0026#39;age\u0026#39;, 30), (\u0026#39;city\u0026#39;, \u0026#39;New York\u0026#39;)]) -pop() : Removes the element with the specified key and returns its value.\ndict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} print(dict1.pop(\u0026#34;age\u0026#34;)) # Output: 30 print(dict1) # Output: {\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;city\u0026#39;: \u0026#39;New York\u0026#39;} -get() : Returns the value of the specified key. If the key does not exist, it returns the specified default value.\ndict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} print(dict1.get(\u0026#34;age\u0026#34;)) # Output: 30 print(dict) # Output: {\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 30, \u0026#39;city\u0026#39;: \u0026#39;New York\u0026#39;} Note: When you attempt to access a key that does not exist in the dictionary, Python will raise a KeyError so put it in try-except block to handle the error or use get() method to avoid the error.\n1.4.6. Nested Dictionaries A dictionary can contain another dictionary as a value. This is known as a nested dictionary. For example:\ndict1 = { \u0026#34;person1\u0026#34;: {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30}, \u0026#34;person2\u0026#34;: {\u0026#34;name\u0026#34;: \u0026#34;Bob\u0026#34;, \u0026#34;age\u0026#34;: 25} } print(dict1[\u0026#34;person1\u0026#34;][\u0026#34;name\u0026#34;]) # Output: Alice 1.4.7. Dictionary Comprehension Dictionary comprehension is a concise way to create dictionaries. For example:\ndict1 = {x: x**2 for x in range(5)} # Output: {0: 0, 1: 1, 2: 4, 3: 9, 4: 16} #using if only dict1 = {x: x**2 for x in range(5) if x%2==0} # Output: {0: 0, 2: 4, 4: 16} #using if else dict1 = {x: x**2 if x%2==0 else x**3 for x in range(5)} # Output: {0: 0, 1: 1, 2: 4, 3: 27, 4: 16} 1.5. Tuple Operations A tuple is a collection of items enclosed within parentheses (). Tuples are immutable, meaning they similar to python as they cant be changed using indexing as a[0]=10 will give an error.\n1.5.1. Declaring a Tuple We can declare a tuple by enclosing items within parentheses (). For example:\ntuple1 = (1, 2, 3) tuple2 = (\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;) tuple3 = (1, \u0026#34;apple\u0026#34;, True, 3.14) 1.5.2. Accessing Tuple Elements We can access tuple elements using indexing . For example:\ntuple1 = (1, 2, 3) print(tuple1[0]) # Output: 1 1.5.3. Slice Tuple We can slice a tuple using the syntax variable[start:end:step] to get a sub-tuple. For example:\ntuple1 = (1, 2, 3, 4, 5) print(tuple1[1:4]) # Output: (2, 3, 4) 1.5.4. Tuple Methods Python provides various built-in methods to manipulate tuples. Some of the commonly used tuple methods are:\ncount() : Returns the number of occurrences of a specified element in the tuple. tuple1 = (1, 2, 3, 2) print(tuple1.count(2)) # Output: 2 index() : Returns the index of the first occurrence of the specified element in the tuple. tuple1 = (1, 2, 3, 2) print(tuple1.index(2)) # Output: 1 len() : Returns the length of the tuple. tuple1 = (1, 2, 3, 2) print(len(tuple1)) # Output: 4 1.5.5 concatenation of tuple We can concatenate two or more tuples using the + operator. For example:\ntuple1 = (1, 2, 3) tuple2 = (4, 5, 6) print(tuple1 + tuple2) # Output: (1, 2, 3, 4, 5, 6) 1.5.6. Tuple Unpacking Tuple unpacking allows us to assign multiple variables at once. For example:\ntuple1 = (1, 2, 3) a, b, c = tuple1 d,*e = tuple1 print(a) # Output: 1 print(b) # Output: 2 print(c) # Output: 3 print(d) # Output: 1 print(e) # Output: [2, 3] tuple1 = (1, 2, 3, 4, 5) a, *b, c = tuple1 print(a) # Output: 1 print(b) # Output: [2, 3, 4] print(c) # Output: 5 Note:Ascessing and slicing of tuple is similar to list and string.\n1.6. Boolean Operations Boolean is a data type that represents one of two values: True or False. Boolean values are used to evaluate conditions in programming. Here are some common boolean operations:\n1.6.1. Condition when variable is True When a variable has a non-zero value, it is considered True. a = 10 if a: print(\u0026#34;The value of a is True\u0026#34;) When a string is not empty, it is considered True. a = \u0026#34;Hello\u0026#34; if a: print(\u0026#34;The value of a is True\u0026#34;) When a list is not empty, it is considered True. a = [1, 2, 3] if a: print(\u0026#34;The value of a is True\u0026#34;) When a dictionary is not empty, it is considered True. a = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30} if a: print(\u0026#34;The value of a is True\u0026#34;) When a tuple is not empty, it is considered True. a = (1, 2, 3) if a: print(\u0026#34;The value of a is True\u0026#34;) When a set is not empty, it is considered True. a = {1, 2, 3} if a: print(\u0026#34;The value of a is True\u0026#34;) When a variable is explicitly set to True, it is considered True. a = True if a: print(\u0026#34;The value of a is True\u0026#34;) 1.6.2. Condition when variable is False Those which are not in the above condition are considered as False.\n1.7. Set Operations A set is a collection of unique items enclosed within curly braces {}. Main Uses of set are:\nTo remove duplicate elements from a list. To perform mathematical set operations like union, intersection, difference, etc. 1.7.1. Declaring a Set We can declare a set by enclosing items within curly braces {} or set(). For example:\nset1 = {1, 2, 3} set2 = {\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;} set3 = {1, \u0026#34;apple\u0026#34;, True, 3.14} #using set() set4 = set([1, 2, 3]) set5=set() 1.7.2. Set Methods Python provides various built-in methods to manipulate sets. Some of the commonly used set methods are:\n-len() : Returns the number of elements in the set.\nset1 = {1, 2, 3} print(len(set1)) # Output: 3 -add() : Adds an element to the set.Doesn\u0026rsquo;t return anything.\nset1 = {1, 2, 3} set1.add(4) print(set1) # Output: {1, 2, 3, 4} -clear() : Removes all elements from the set.Doesn\u0026rsquo;t return anything.\nset1 = {1, 2, 3} set1.clear() print(set1) # Output: set() -remove() : Removes the specified element from the set. If the element is not present, it raises an error.\nset1 = {1, 2, 3} set1.remove(2) print(set1) # Output: {1, 3} discard() : Removes the specified element from the set. If the element is not present, it does not raise an error.\nset1 = {1, 2, 3} set1.discard(2) print(set1) # Output: {1, 3} -union() : Returns a set containing the union of two sets.\nset1 = {1, 2, 3} set2 = {3, 4, 5} print(set1.union(set2)) # Output: {1, 2, 3, 4, 5} -intersection() : Returns a set containing the intersection of two sets.\nset1 = {1, 2, 3} set2 = {3, 4, 5} print(set1.intersection(set2)) # Output: {3} -difference() : Returns a set containing the difference between two sets.\nset1 = {1, 2, 3} set2 = {3, 4, 5} print(set1.difference(set2)) # Output: {1, 2} -symmetric_difference() : Returns a set containing the symmetric difference between two sets.\nset1 = {1, 2, 3} set2 = {3, 4, 5} print(set1.symmetric_difference(set2)) # Output: {1, 2, 4, 5} -issubset() : Returns True if all elements of a set are present in another set.\nset1 = {1, 2, 3} set2 = {1, 2, 3, 4, 5} print(set1.issubset(set2)) # Output: True 1.8 Used in All iterable 1.8.1. in Operator The in operator is used to check if an element is present in an iterable. For example:\n# in string str = \u0026#34;Hello, World!\u0026#34; print(\u0026#34;Hello\u0026#34; in str) # Output: True # in list list1 = [1, 2, 3, 4, 5] print(3 in list1) # Output: True # in tuple tuple1 = (1, 2, 3, 4, 5) print(6 in tuple1) # Output: False # in set set1 = {1, 2, 3, 4, 5} print(5 in set1) # Output: True # in dictionary dict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30} print(\u0026#34;name\u0026#34; in dict1) # Output: True 1.8.2. not in Operator The not in operator is used to check if an element is not present in an iterable. For example:\n# not in string str = \u0026#34;Hello, World!\u0026#34; print(\u0026#34;Alice\u0026#34; not in str) # Output: True # not in list list1 = [1, 2, 3, 4, 5] print(6 not in list1) # Output: True # not in tuple tuple1 = (1, 2, 3, 4, 5) print(5 not in tuple1) # Output: False # not in set set1 = {1, 2, 3, 4, 5} print(5 not in set1) # Output: False # not in dictionary dict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30} print(\u0026#34;name\u0026#34; not in dict1) # Output: False 1.8.3. len() Function The len() function is used to get the length of an iterable. For example:\n# for string str = \u0026#34;Hello, World!\u0026#34; print(len(str)) # Output: 13 # for list list1 = [1, 2, 3, 4, 5] print(len(list1)) # Output: 5 # for tuple tuple1 = (1, 2, 3, 4, 5) print(len(tuple1)) # Output: 5 # for set set1 = {1, 2, 3, 4, 5} print(len(set1)) # Output: 5 # for dictionary dict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30} print(len(dict1)) # Output: 2 1.8.4. max() and min() Functions The max() function is used to get the maximum value from an iterable, and the min() function is used to get the minimum value for list,string,set and tuples only. for dictionary you can use .keys() or .values() and use it. For example:\n# for list list1 = [1, 2, 3, 4, 5] print(max(list1)) # Output: 5 print(min(list1)) # Output: 1 # for tuple tuple1 = (1, 2, 3, 4, 5) print(max(tuple1)) # Output: 5 print(min(tuple1)) # Output: 1 # for string string = \u0026#34;Hello, World!\u0026#34; print(max(string)) # Output: r print(min(string)) # Output: \u0026#39; \u0026#39; # for set set1 = {1, 2, 3, 4, 5} print(max(set1)) # Output: 5 print(min(set1)) # Output: 1 1.8.5. join() Function The join() function is used to concatenate elements of an iterable with a separator. For example:\n# for list list1 = [\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;] print(\u0026#34;, \u0026#34;.join(list1)) # Output: apple, banana, cherry # for tuple tuple1 = (\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;) print(\u0026#34;, \u0026#34;.join(tuple1)) # Output: apple, banana, cherry # for set set1 = {\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;} print(\u0026#34;, \u0026#34;.join(set1)) # Output: apple, banana, cherry # for string string = \u0026#34;Hello, World!\u0026#34; print(\u0026#34;, \u0026#34;.join(string)) # Output: H, e, l, l, o, ,, , W, o, r, l, d, ! ","permalink":"http://localhost:1313/posts/pages/python/python_datatype_operations/","summary":"An in-depth look at Python data types, exploring their usage and importance in programming.","title":"Python Fundamentals: Understanding Data Types (Part 2)"},{"content":"22. Fragments in React Fragments are a way to group multiple elements in React without adding extra nodes to the DOM. Fragments are useful when you want to return multiple elements from a component, but you don\u0026rsquo;t want to add an extra div or span element to the DOM.\nFragments are represented by the \u0026lt;Fragment\u0026gt; tag or the shorthand syntax \u0026lt;\u0026gt;. You can use fragments to return multiple elements from a component without adding extra nodes to the DOM.\nWithout using fragments:\nfunction App() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Hello, World!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;Welcome to React\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } Here, the App component returns two elements, but they are wrapped in a div element. If you don\u0026rsquo;t want to add an extra div element to the DOM, you can use fragments.\nUsing fragments:\nfunction App() { return ( \u0026lt;\u0026gt; or \u0026lt;Fragment\u0026gt; \u0026lt;h1\u0026gt;Hello, World!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;Welcome to React\u0026lt;/p\u0026gt; \u0026lt;/\u0026gt; or \u0026lt;/Fragment\u0026gt; ); } 23. Passing jsx as props In React, you can pass JSX as props to other components. This allows you to create reusable components that can be used in different parts of your application.\nPassing JSX as props: function App() { const heading = \u0026lt;div\u0026gt;\u0026lt;h1\u0026gt;Hello, World!\u0026lt;/h1\u0026gt;\u0026lt;p\u0026gt;My name is nirajan Khatiwada\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;; return \u0026lt;Greeting message={heading} /\u0026gt;; } or function App() { return \u0026lt;Greeting message={\u0026lt;div\u0026gt;\u0026lt;h1\u0026gt;Hello, World!\u0026lt;/h1\u0026gt;\u0026lt;p\u0026gt;My name is nirajan Khatiwada\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;} /\u0026gt;; } Using props in the Greeting component: function Greeting(props) { return \u0026lt;div\u0026gt;{props.message}\u0026lt;/div\u0026gt;; } Passing built-in components as props: function App() { return \u0026lt;Greeting element=\u0026#34;button\u0026#34; /\u0026gt;; } 24. Isolation of Component in React Isolation of components is a key concept in React that allows you to create reusable components that are independent of each other. This means that each component should be self-contained and not rely on external data or state.\nfor example:\nfunction Button(props){ const [showText, setShowText] = useState(false); return ( \u0026lt;button onClick={() =\u0026gt; setShowText(!showText)}\u0026gt; {showText ? \u0026#39;Hide Text\u0026#39; : \u0026#39;Show Text\u0026#39;} \u0026lt;/button\u0026gt; ); } function App(){ return ( \u0026lt;div\u0026gt; \u0026lt;Button /\u0026gt; \u0026lt;Button /\u0026gt; \u0026lt;/div\u0026gt; ); } Here The component Button is isolated means one state of the component does not affect the other component. Each component is self-contained and does not rely on external data or state. for example, the showText state in one Button component does not affect the showText state in the other Button component.\n25. Taking User Input in React Using onChange event: function App() { const [name, setName] = useState(\u0026#39;\u0026#39;); const handleChange = (e) =\u0026gt; { setName(e.target.value); }; return ( \u0026lt;div\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; value={name} onChange={handleChange} /\u0026gt; \u0026lt;p\u0026gt;Hello, {name}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } Whats Happen Here\nHere, we have an input element that takes user input. When the user types in the input field,the onChange event is triggered for ervy keypress. The handleChange function is called with the event object as an argument for every keypress. The setName function is called with value of user input and it rerender the component with the updated value for every keypress. The value of the input field is set to the name state, and the name is displayed below the input field. Note: use onChange event to take user input in React and update the state accordingly to reflect the changes in the UI. If you use value as a prop in the input field, you must also provide an onChange event handler to update the state. Use this method if you want to update in real-time as the user types in the input field.\nOther method will be discussed in upcoming posts. 26.Rendering 2D Arrays in React In React, you can render 2D arrays by using nested map functions to iterate over the rows and columns of the array. This allows you to display tabular data or grid-like structures in your application.\nRendering a 2D array: function App() { const data = [ [\u0026#39;John\u0026#39;, \u0026#39;Doe\u0026#39;, 30], [\u0026#39;Jane\u0026#39;, \u0026#39;Smith\u0026#39;, 25], [\u0026#39;Alice\u0026#39;, \u0026#39;Brown\u0026#39;, 35], ]; return ( \u0026lt;table\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;First Name\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Last Name\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Age\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; {data.map((row, index) =\u0026gt; ( \u0026lt;tr key={index}\u0026gt; {row.map((cell, index) =\u0026gt; ( \u0026lt;td key={index}\u0026gt;{cell}\u0026lt;/td\u0026gt; ))} \u0026lt;/tr\u0026gt; ))} \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; ); } 27. Immutable update patterns in React In react while changing the state we shouldnot change the orginal state directly Instead, we should create a new copy of the state and update the copy with the new values. This is known as immutable update pattern.speciaaly when working with arrays and objects.\nThe Wrong way to update state: function App() { const [items, setItems] = useState([\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;cherry\u0026#39;]); const removeItem = (index) =\u0026gt; { items.splice(index, 1); setItems(items); }; return ( \u0026lt;div\u0026gt; \u0026lt;ul\u0026gt; {items.map((item, index) =\u0026gt; ( \u0026lt;li key={index}\u0026gt; {item} \u0026lt;button onClick={() =\u0026gt; removeItem(index)}\u0026gt;Remove\u0026lt;/button\u0026gt; \u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ); } The Correct way to update state: function App() { const [items, setItems] = useState([\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;cherry\u0026#39;]); const removeItem = (index) =\u0026gt; { const newItems = [...items]; newItems.splice(index, 1); setItems(newItems); }; return ( \u0026lt;div\u0026gt; \u0026lt;ul\u0026gt; {items.map((item, index) =\u0026gt; ( \u0026lt;li key={index}\u0026gt; {item} \u0026lt;button onClick={() =\u0026gt; removeItem(index)}\u0026gt;Remove\u0026lt;/button\u0026gt; \u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt;x x \u0026lt;/div\u0026gt; ); } Note: Always create a new copy of the state when updating arrays or objects in React. This ensures that the state is updated correctly and prevents unexpected behavior in your application. 28. Common Pattern for update,delete and add in React In React, you can use common patterns to update, delete, and add items to an array. These patterns involve creating new copies of the array and updating the state with the new values.\nAdd an item to an array: function App() { const [items, setItems] = useState([\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;cherry\u0026#39;]); const addItem = (item) =\u0026gt; { setItems([...items, item]); // or // const newItems = [...items]; // newItems.push(item); // setItems(newItems); }; return ( \u0026lt;div\u0026gt; \u0026lt;ul\u0026gt; {items.map((item, index) =\u0026gt; ( \u0026lt;li key={index}\u0026gt;{item}\u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;button onClick={() =\u0026gt; addItem(\u0026#39;orange\u0026#39;)}\u0026gt;Add Item\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } Deleting an item from an array: function App() { const [items, setItems] = useState([\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;cherry\u0026#39;]); const removeItem = (index) =\u0026gt; { const newItems = items.filter((item, i) =\u0026gt; i !== index); setItems(newItems); }; return ( \u0026lt;div\u0026gt; \u0026lt;ul\u0026gt; {items.map((item, index) =\u0026gt; ( \u0026lt;li key={index}\u0026gt; {item} \u0026lt;button onClick={() =\u0026gt; removeItem(index)}\u0026gt;Remove\u0026lt;/button\u0026gt; \u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ); } Updating an data of an array using map: function App() { const [items, setItems] = useState([ { id: 1, name: \u0026#39;apple\u0026#39;, price: 1 }, { id: 2, name: \u0026#39;banana\u0026#39;, price: 2 }, { id: 3, name: \u0026#39;cherry\u0026#39;, price: 3 }, ]); const updateItem = (id, price) =\u0026gt; { const newItems = items.map((item) =\u0026gt; item.id === id ? { ...item, price: price } : item ); setItems(newItems); }; return ( \u0026lt;div\u0026gt; \u0026lt;ul\u0026gt; {items.map((item) =\u0026gt; ( \u0026lt;li key={item.id}\u0026gt; {item.name} - ${item.price}{\u0026#39; \u0026#39;} \u0026lt;button onClick={() =\u0026gt; updateItem(item.id, item.price + 1)}\u0026gt; Increase Price \u0026lt;/button\u0026gt; \u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ); } Updating an data of an array using find: function App() { const [items, setItems] = useState([ { id: 1, name: \u0026#39;apple\u0026#39;, price: 1 }, { id: 2, name: \u0026#39;banana\u0026#39;, price: 2 }, { id: 3, name: \u0026#39;cherry\u0026#39;, price: 3 }, ]); const updateItem = (id, price) =\u0026gt; { const newItems= [...items]; const newItem = newItems.find((item) =\u0026gt; item.id === id); if (newItem) { newItem.price = price; setItems(newItems); } }; return ( \u0026lt;div\u0026gt; \u0026lt;ul\u0026gt; {items.map((item) =\u0026gt; ( \u0026lt;li key={item.id}\u0026gt; {item.name} - ${item.price}{\u0026#39; \u0026#39;} \u0026lt;button onClick={() =\u0026gt; updateItem(item.id, item.price + 1)}\u0026gt; Increase Price \u0026lt;/button\u0026gt; \u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ); } Note: Always prefer map over find when updating an array of objects in React. This ensures that the state is updated correctly and prevents unexpected behavior in your application.\n29.Updating object in react In React, you can update an object in state by creating a new copy of the object and updating the copy with the new values. This ensures that the state is updated correctly and prevents unexpected behavior in your application.\nUpdating an object in state: function App() { const [person, setPerson] = useState({ name: \u0026#39;John\u0026#39;, age: 30 }); const updatePerson = () =\u0026gt; { setPerson({ ...person, age: person.age + 1 }); }; return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;Name: {person.name}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Age: {person.age}\u0026lt;/p\u0026gt; \u0026lt;button onClick={updatePerson}\u0026gt;Increase Age\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } use list if you want to show the list of items and use object if you want to show the details of the item to identify which one is clicked or update you can pass the index or id of the item to the function. Or you can hardcode the value to update the object or list.\n","permalink":"http://localhost:1313/posts/pages/react/react3/","summary":"A comprehensive guide covering React\u0026rsquo;s advanced concepts including Fragments, JSX Props, Component Isolation, and proper state management patterns","title":"React : Day 3"},{"content":"Python Control Structures: Mastering Loops and Conditionals In Python programming, control structures are essential for managing the flow of execution in your code. They allow you to make decisions, repeat tasks, and create complex algorithms. In this guide, we will explore two fundamental control structures in Python: loops and conditionals.\n1. Conditional Statements Conditional statements in Python allow you to execute specific blocks of code based on certain conditions. The most common conditional statements are if, elif, and else.\n1.1. The if Statement The if statement is used to check a condition and execute a block of code if the condition is true.\nExample:\nx = 10 if x \u0026gt; 5: print(\u0026#34;x is greater than 5\u0026#34;) Output:\nx is greater than 5 1.2. The elif Statement The elif statement allows you to check multiple conditions after the initial if statement. If the previous conditions are false, the elif block is evaluated.\nExample:\nx = 5 if x \u0026gt; 5: print(\u0026#34;x is greater than 5\u0026#34;) elif x == 5: print(\u0026#34;x is equal to 5\u0026#34;) Output:\nx is equal to 5 1.3. The else Statement The else statement is used to execute a block of code when all the previous conditions are false.\nExample:\nx = 3 if x \u0026gt; 5: print(\u0026#34;x is greater than 5\u0026#34;) elif x == 5: print(\u0026#34;x is equal to 5\u0026#34;) else: print(\u0026#34;x is less than 5\u0026#34;) Output:\nx is less than 5 2. Loops Loops in Python allow you to execute a block of code repeatedly. There are two main types of loops in Python: for loops and while loops.\n2.1. The while Loop The while loop executes a block of code as long as a specified condition is true.\nSyntax:\nwhile condition: # Code block else: # Optional else block Example:\ncount = 0 while count \u0026lt; 5: print(count) count += 1 else: print(\u0026#34;Loop completed\u0026#34;) 2.2. The for Loop The for loop is used to iterate over a sequence (such as a list, tuple, or string) and execute a block of code for each item in the sequence.\nSyntax:\nfor item in sequence: # Code block else: # Optional else block Example:\nfruits = [\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;] for fruit in fruits: print(fruit) else: print(\u0026#34;No more fruits\u0026#34;) 2.3 Using For Loops with different data types 2.3.1. For Loop with Strings Example:\nfor char in \u0026#34;Python\u0026#34;: print(char) Output:\np\ry\rt\rh\ro\rn 2.3.2. For Loop with Lists Example:\nnumbers = [1, 2, 3, 4, 5] for num in numbers: print(num) Output:\n1\r2\r3\r4\r5 2.3.3. For Loop with tuples Example:\nfruits = (\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;) for fruit in fruits: print(fruit) Output:\napple\rbanana\rcherry Tuple unpacking can also be used in for loops to iterate over multiple values in a tuple.\ncoordinates = [(1, 2), (3, 4), (5, 6)] for x, y in coordinates: print(f\u0026#34;X: {x}, Y: {y}\u0026#34;) Output:\nX: 1, Y: 2\rX: 3, Y: 4\rX: 5, Y: 6 2.3.4. For Loop with Sets Example:\ncolors = {\u0026#34;red\u0026#34;, \u0026#34;green\u0026#34;, \u0026#34;blue\u0026#34;} for color in colors: print(color) Output:\nred\rgreen\rblue 2.3.5. For Loop with Dictionaries Example:\nperson = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} for key, value in person.items(): print(f\u0026#34;{key}: {value}\u0026#34;) Output:\nname: Alice\rage: 30\rcity: New York 2.4. break , pass and continue statements in loops 2.4.1. The break Statement The break statement is used to exit a loop prematurely. It terminates the current loop and resumes execution at the next statement after the loop.\nExample:\nfor num in [1, 2, 3, 4, 5]: if num == 3: break print(num) Output:\n1\r2 2.4.2. The continue Statement The continue statement is used to skip the rest of the code inside a loop for the current iteration and jump to the next iteration.\nExample:\nfor num in [1, 2, 3, 4, 5]: if num == 3: continue print(num) Output:\n1\r2\r4\r5 2.4.3. The pass Statement The pass statement is a null operation that does nothing. It is used when a statement is required syntactically but you do not want any code to execute.\nExample:\nfor num in [1, 2, 3, 4, 5]: pass ","permalink":"http://localhost:1313/posts/pages/python/python_control_structure/","summary":"A detailed examination of Python\u0026rsquo;s control structures, focusing on loops and conditionals to enhance your programming skills.","title":"Python Fundamentals: Mastering Control Structures (Part 3)"},{"content":"17. Hooks in React Anythong that start with prefix use is considered as a hook in react\n17.1. Rules of Hooks Only Call Hook inside a component function correct:\nfunction App() { const [val, setVal] = useState(0); } Incorrect:\nconst [val, setVal] = useState(0); function App() { } Only Call Hooks at the Top Level Hook must not be called inside code statement (e.g., inside an if statement, loop, or nested function). correct: function App() { const [val, setVal] = useState(0); } incorrect:\nfunction App() { if (true) { const [val, setVal] = useState(0); } } 3.Hook can be used inside other custom hooks too\n18. useState Hook useState is a React hook that allows you to manage component-specific state. It provides a way to declare state variables in functional components and ensure that changes to these variables cause the component or child component to re-render while the parent component remains unaffected from where the component whose set state is triggered.\nfor example:\nfunction App() { return ( \u0026lt;div\u0026gt; \u0026lt;MemoComp /\u0026gt; \u0026lt;/div\u0026gt; ); } function MemoComp() { const [data, setData] = useState(\u0026#34;No data\u0026#34;); function handle() { setData(\u0026#34;data\u0026#34;); } return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;{data}\u0026lt;/p\u0026gt; \u0026lt;button onClick={handle}\u0026gt;Click me\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } When button is clicked the handle function is called and the setData function is called which updates the data state variable. This cause the MemoComp and its child component to re-render with a new value of data.\n18.1. Syntax const [state, setState] = useState(initialState); 18.2. Managing State State management in React involves handling data and telling React to re-execute a function using the useState hook. This ensures that state updates lead to new state values. Example:\nconst [countes, setcountes] = useState(0); countes is the state variable that holds the current state value. setcountes is the function that updates the state variable. useState(0) is the initial state value. How it works: Initially, the state variable countes is set to 0. When the setcountes function is called, it updates the state variable to a new value. This triggers a re-render of the component, updating the UI with the new state value.\n18.3 Updating State Based on Previous State Suppose the age is 42. The handler calls setAge(age + 1) three times.\nfunction handleClick() { setAge(age + 1); // setAge(42 + 1) setAge(age + 1); // setAge(42 + 1) setAge(age + 1); // setAge(42 + 1) } if the initial age is 42, after calling this function, the age will be 43, not 45.\nTo solve this problem, we use an updater function to pass setAge calls.\nfunction handleClick() { setAge(a =\u0026gt; a + 1); // setAge(42 =\u0026gt; 43) setAge(a =\u0026gt; a + 1); // setAge(43 =\u0026gt; 44) setAge(a =\u0026gt; a + 1); // setAge(44 =\u0026gt; 45) } After this age will be 45 so use updater function when you want to update value based on previous value \u0026amp; it\u0026rsquo;s always recommended to use updater function in.\nIt is mostly used in:\nCounters Toggles Incrementing or decrementing a value 18.4. Pitfalls in useState In React state updates are asynchronous meaning they don\u0026rsquo;t immediately reflect in the current execution cycle. When you call a state setter function like setSelectedValue, React schedules the state update for the next render. This can lead to unexpected behavior if you try to access the updated state immediately after setting it.\nExample: function clickHandler(data) { setSelectedValue(`${data} is being clicked`); console.log(selectedTopic); // logs the old state, not updated one } Why It Happens State updates are asynchronous: React batches state updates and applies them during the next render cycle to optimize performance. Therefore, the state change you request won’t be immediately reflected in the current execution.\nLogging state immediately: Since the update happens after the current execution cycle, logging the state/selected topic immediately after calling setSelectedValue will show the old value (before the update).\nThis can be fixed using useEffect which is read later.\nNote: Always use the state variable when you want to reflect the changes in the UI.\n19. An Example demostrating useState Hook import {useState} from \u0026#39;react\u0026#39;; function App(){ const [count,setCount] = useState(0); return(){ \u0026lt;div\u0026gt; {count} \u0026lt;/div\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;Increment\u0026lt;/button\u0026gt; } } export default App; In the above example, we have a functional component App that uses the useState hook to manage the state of the count variable. The initial value of count is set to 0 using useState(0). The setCount function is used to update the value of count when the button is clicked. The count value is displayed in the UI, and clicking the button increments the count value by 1.\n20.Conditional Rendering in React Conditional rendering is a technique used to render different components or elements based on certain conditions. In React, conditional rendering can be achieved using ternary operators, and logical operators like \u0026amp;\u0026amp; .\n20.1. Ternary Operator The ternary operator is a concise way to write conditional statements in JavaScript. It consists of a condition followed by a question mark ?, an expression to execute if the condition is true, a colon :, and an expression to execute if the condition is false.\nExample:\nfunction App() { const isLoggedIn = true; return ( \u0026lt;div\u0026gt; {isLoggedIn ? \u0026lt;p\u0026gt;Welcome, User!\u0026lt;/p\u0026gt; : \u0026lt;p\u0026gt;Please log in\u0026lt;/p\u0026gt;} \u0026lt;/div\u0026gt; ); } Also We can write jsx code in variable and use it in return statement\nfunction App() { const isLoggedIn = true; const welcomeMessage=\u0026lt;p\u0026gt;Welcome, User!\u0026lt;/p\u0026gt;; const loginMessage=\u0026lt;p\u0026gt;Please log in\u0026lt;/p\u0026gt;; return ( \u0026lt;div\u0026gt; {isLoggedIn ? welcomeMessage : loginMessage} \u0026lt;/div\u0026gt; ); } 20.2. Logical \u0026amp;\u0026amp; Operator The logical \u0026amp;\u0026amp; operator is another way to conditionally render elements in React. The \u0026amp;\u0026amp; operator works by evaluating the expression on the left side of the \u0026amp;\u0026amp; operator. If the expression is true, the expression on the right side of the \u0026amp;\u0026amp; operator is executed. If the expression is false, the right side is not executed.\nExample:\nfunction App() { const isLoggedIn = true; return ( \u0026lt;div\u0026gt; {isLoggedIn \u0026amp;\u0026amp; \u0026lt;p\u0026gt;Welcome, User!\u0026lt;/p\u0026gt;} {isLoggedIn \u0026amp;\u0026amp; \u0026lt;button\u0026gt;Logout\u0026lt;/button\u0026gt;} {!isLoggedIn \u0026amp;\u0026amp; \u0026lt;p\u0026gt;Please log in\u0026lt;/p\u0026gt;} \u0026lt;/div\u0026gt; ); } Also We can write jsx code in variable and use it in return statement\nfunction App() { const isLoggedIn = true; const welcomeMessage=\u0026lt;p\u0026gt;Welcome, User!\u0026lt;/p\u0026gt;; const logoutButton=\u0026lt;button\u0026gt;Logout\u0026lt;/button\u0026gt;; const loginMessage=\u0026lt;p\u0026gt;Please log in\u0026lt;/p\u0026gt;; return ( \u0026lt;div\u0026gt; {isLoggedIn \u0026amp;\u0026amp; welcomeMessage} {isLoggedIn \u0026amp;\u0026amp; logoutButton} {!isLoggedIn \u0026amp;\u0026amp; loginMessage} \u0026lt;/div\u0026gt; ); } 21.Outputting list data dynamically In react we use map function to output list data dynamically as using map.\n21.1. Have a list of data You typically store the list in an array, which might come from a state, props, or external data source like an API\nconst data = [ { id: 1, name: \u0026#34;John\u0026#34; }, { id: 2, name: \u0026#34;Doe\u0026#34; }, { id: 3, name: \u0026#34;Jane\u0026#34; }, ]; 21.2 Using map function to output list data const listItems = data.map((item) =\u0026gt; \u0026lt;li key={item.id}\u0026gt;{item.name}\u0026lt;/li\u0026gt;); Key is used to uniquely identify each element in the list. It helps React identify which items have changed, are added, or are removed.It can be number or string.\n21.3. Rendering the list Use {} to embed the transformed list inside your component’s JSX.\n\u0026lt;ul\u0026gt;{listItems}\u0026lt;/ul\u0026gt;; 21.4. Putting it all together function App() { const data = [ { id: 1, name: \u0026#34;John\u0026#34; }, { id: 2, name: \u0026#34;Doe\u0026#34; }, { id: 3, name: \u0026#34;Jane\u0026#34; }, ]; const listItems = data.map((item) =\u0026gt; \u0026lt;li key={item.id}\u0026gt;{item.name}\u0026lt;/li\u0026gt;); return \u0026lt;ul\u0026gt;{listItems}\u0026lt;/ul\u0026gt;; } 21.5 Another form function App() { const data = [ { id: 1, name: \u0026#34;John\u0026#34; }, { id: 2, name: \u0026#34;Doe\u0026#34; }, { id: 3, name: \u0026#34;Jane\u0026#34; }, ]; return \u0026lt;ul\u0026gt;{data.map((item) =\u0026gt; \u0026lt;li key={item.id}\u0026gt;{item.name}\u0026lt;/li\u0026gt;); }\u0026lt;/ul\u0026gt;; } When will Rerender Occur?\nWhen state varaible or props value changes ","permalink":"http://localhost:1313/posts/pages/react/react1/","summary":"A detailed guide to help you understand and use hooks in React effectively.","title":"React : Day 2"},{"content":"Python Fundamentals: Exploring Advanced Operations (Part 4) In Python programming, advanced operations allow you to perform complex tasks efficiently. These operations include working with ranges, enumerations, zip functions, and more. In this guide, we will explore various advanced operations in Python to enhance your programming skills.\n1. Ranges Ranges in Python are used to generate a sequence of numbers. They are commonly used in loops to iterate over a specific range of values. Ranges can be created using the range() function.\n1.1. Creating a Range To create a range of numbers, you can use the range() function with the desired start, stop, and step values where start number is in inclusive and stop number is exclusive.\nExample:\n# Generate a range of numbers from 0 to 9 for i in range(10): print(i) Output:\n0\r1\r2\r3\r4\r5\r6\r7\r8\r9 Example:\n# Generate a range of numbers from 1 to 10 with a step of 2 for i in range(0, 10,2): print(i) Output:\n0\r2\r4\r6\r8 1.2 Enumerate Function The enumerate() function in Python is used to iterate over a sequence while keeping track of the index and value of each item. It returns a tuple containing the index and the value of the item.\nExample:\n# Enumerate a list of fruits fruits = [\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;cherry\u0026#39;] for index, fruit in enumerate(fruits): print(index, fruit) Output:\n0 apple\r1 banana\r2 cherry Example:\na=\u0026#34;nirajan\u0026#34; for index, char in enumerate(a): print(index, char) Output:\n0 n\r1 i\r2 r\r3 a\r4 j\r5 a\r6 n 1.3. Zip Function The zip() function in Python is used to combine multiple iterables (such as lists) element-wise. It returns an iterator of tuples where the i-th tuple contains the i-th element from each of the input iterables.\nExample:\n# Zip two lists together names = [\u0026#39;Alice\u0026#39;, \u0026#39;Bob\u0026#39;, \u0026#39;Charlie\u0026#39;] ages = [25, 30, 35] for name, age in zip(names, ages): print(name, age) Output:\nAlice 25\rBob 30\rCharlie 35 Example:\na=[1,2,3] b=[4,5,6] c=[7,8,9] print(list(zip(a,b,c))) Output:\n[(1, 4, 7), (2, 5, 8), (3, 6, 9)] 1.5 Sorted Function The sorted() function in Python is used to sort a list of elements. It returns a new sorted list without modifying the original list.The main feature of the sorted() function is that it can take a key argument that specifies a function to be called on each list element prior to making comparisons.\nExample:\n# Sort a list of numbers numbers = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5] sorted_numbers = sorted(numbers) print(sorted_numbers) Output:\n[1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] Example:\n# Sort a list of strings based on the length of the string fruits = [\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;cherry\u0026#39;, \u0026#39;date\u0026#39;] sorted_fruits = sorted(fruits, key=len) print(sorted_fruits) Output:\n[\u0026#39;date\u0026#39;, \u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;cherry\u0026#39;] Example:\n#Sort an dictionary based on the value d = {\u0026#39;apple\u0026#39;: 10, \u0026#39;banana\u0026#39;: 5, \u0026#39;cherry\u0026#39;: 15} sorted_d = sorted(d.items(), key=lambda x: x[1]) print(sorted_d) Output:\n[(\u0026#39;banana\u0026#39;, 5), (\u0026#39;apple\u0026#39;, 10), (\u0026#39;cherry\u0026#39;, 15)] Example:\n#Sort a list of tuples based on the second element t = [(1, 2), (3, 1), (5, 6)] sorted_t = sorted(t, key=lambda x: x[1]) print(sorted_t) Output:\n[(3, 1), (1, 2), (5, 6)] #2. Import in Python In Python, the import statement is used to import modules or packages into your script. It allows you to use functions, classes, and variables defined in other modules in your code.\n2.1. Importing Modules To import a module in Python, you can use the import keyword followed by the module name. You can then access the functions, classes, and variables defined in the module using dot notation.\nExample:\n# Import the math module import math # Calculate the square root of a number x = 16 print(math.sqrt(x)) Output:\n4.0 Example:\n# Import the datetime module import datetime # Get the current date and time now = datetime.datetime.now() print(now) Output:\n2024-11-17 10:30:00 2.2. Importing Specific Functions You can import specific functions or variables from a module using the from keyword. This allows you to use the imported functions directly without using the module name.\nExample:\n# Import the pi constant from the math module from math import pi # Print the value of pi print(pi) Output:\n3.141592653589793 Example:\n# Import the date class from the datetime module from datetime import date # Get the current date today = date.today() print(today) Output:\n2024-11-17 2.3. Aliasing Modules You can alias a module or package by using the as keyword. This allows you to refer to the module by a different name in your code.\nExample:\n# Import the math module and alias it as m import math as m # Calculate the square root of a number x = 25 print(m.sqrt(x)) Output:\n5.0 Example:\n# Import the datetime module using import and from and alias it as dt from datetime import datetime as dt now = dt.now() print(now) Output:\n2024-11-17 10:30:00 2.4. Importing All Functions You can import all functions and variables from a module using the * operator. This imports all the functions and variables defined in the module.\nExample:\n# Import all functions from the math module from math import * # Calculate the square root of a number x = 36 print(sqrt(x)) Output:\n6.0 The General Syntax is\nfrom module_name.submodule_name.submodule_name... import funtion_name or variable_name or filename as alias_name\nrandom module The random module in Python is used to generate random numbers. It provides various functions to generate random integers, floating-point numbers, and sequences.\n1. Generating Random Numbers The random module provides functions to generate random numbers within a specified range which can contain both integers starting and ending number.\nExample:\nfrom random import randint # Generate a random integer between 1 and 10 random_number = randint(1, 10) print(random_number) Output:\n5 2.Shuffling a List The random module provides a function to shuffle the elements of a list randomly. It modifies the original list in place.\nExample:\nfrom random import shuffle # Shuffle a list of numbers numbers = [1, 2, 3, 4, 5] shuffle(numbers) print(numbers) Output:\n[3, 1, 5, 2, 4] ","permalink":"http://localhost:1313/posts/pages/python/python_advanced_operations/","summary":"An in-depth exploration of advanced Python operations to enhance your programming skills.","title":"Python Fundamentals: Exploring Advanced Operations (Part 4)"},{"content":"Python Fundamentals: Understanding Functions In Python programming, functions are essential building blocks that allow you to organize and reuse code effectively. Functions help break down complex problems into smaller, manageable tasks, making your code more readable and maintainable. In this guide, we will explore the fundamentals of Python functions, including their syntax, parameters, return values, and more.\n1. Defining Functions A function in Python is defined using the def keyword followed by the function name and parentheses. You can also specify parameters inside the parentheses if the function requires input values.\nSyntax:\ndef function_name(parameters): # Function body # Statements Example:\ndef greet(): print(\u0026#34;Hello, World!\u0026#34;) 2. Calling Functions To call a function in Python, you simply write the function name followed by parentheses. If the function requires input values, you can pass them inside the parentheses.\nSyntax:\nfunction_name(arguments) Example:\ngreet() 3. return Statement The return statement in Python is used to exit a function and return a value to the caller. You can use the return statement to send a result back to the calling code.\nSyntax:\ndef function_name(parameters): # Function body return value Demostration using all:\ndef add_numbers(a, b): return a + b result = add_numbers(5, 3) print(result) 4. Args , Default Args and Kwargs 4.1. Args Using Args you can pass any number of arguments to a function. The arguments are passed as a tuple.\nSyntax:\ndef function_name(*args): # Function body Example:\ndef display_args(*args): print(args) display_args(1, 2, 3, 4, 5) Output:\n(1, 2, 3, 4, 5) 4.2. Default Args Default arguments are used when you do not pass a value for an argument in the function call. If a value is not provided, the default value is used.\nSyntax:\ndef function_name(arg=value): # Function body Example:\ndef add(a,b,c=0): return a+b+c result = add(5,3) print(result) result = add(5,3,2) print(result) Output:\n8\r10 4.3. Kwargs Using Kwargs you can pass any number of keyword arguments to a function. The arguments are passed as a dictionary.\nSyntax:\ndef function_name(**kwargs): # Function body Example:\ndef display_kwargs(**kwargs): print(kwargs) display_kwargs(name=\u0026#34;Alice\u0026#34;, age=30, city=\u0026#34;New York\u0026#34;) Output:\n{\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 30, \u0026#39;city\u0026#39;: \u0026#39;New York\u0026#39;} 4.4. Combination of Args and Kwargs Example:\ndef display_args_kwargs(*args, **kwargs): print(args) print(kwargs) display_args_kwargs(1, 2, 3, name=\u0026#34;Alice\u0026#34;, age=30) Output:\n(1, 2, 3)\r{\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 30} 4.5. Unpacking Args and Kwargs Example:\ndef display_args_kwargs(*args, **kwargs): print(args) print(kwargs) args = (1, 2, 3) kwargs = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30} display_args_kwargs(*args, **kwargs) Output:\n(1, 2, 3)\r{\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 30} 5. Lambda Functions Lambda functions, also known as anonymous functions, are small, single-expression functions that do not require a name. They are defined using the lambda keyword.\nSyntax:\nlambda arguments: expression Example:\nadd = lambda a, b: a + b result = add(5, 3) print(result) Output:\n8 6.Map and filter functions 6.1. Map Function The map() function in Python applies a given function to each item of an iterable (such as a list, tuple, or set) and returns a new iterable with the results.\nSyntax:\nmap(function, iterable) Example:\nnumbers = [1, 2, 3, 4, 5] squared = map(lambda x: x ** 2, numbers) print(list(squared)) Output:\n[1, 4, 9, 16, 25] 6.2. Filter Function The filter() function in Python filters elements from an iterable based on a given function. It returns an iterator with the elements that satisfy the condition.\nSyntax:\nfilter(function, iterable) Example:\nnumbers = [1, 2, 3, 4, 5] even = filter(lambda x: x % 2 == 0, numbers) print(list(even)) Output:\n[2, 4] 7.Local and Global Variables 7.1. Local Variables Local variables are defined within a function and are only accessible within that function. They are created when the function is called and destroyed when the function exits.\nExample:\ndef display(): message = \u0026#34;Hello, World!\u0026#34; print(message) display() # Trying to access the local variable outside the function will result in an error print(message) # NameError: name \u0026#39;message\u0026#39; is not defined 7.2. Global Variables Global variables are defined outside any function and can be accessed from any part of the code. You can use the global keyword to modify a global variable inside a function.\nExample:\nmessage = \u0026#34;Hello, World!\u0026#34; def display(): print(message) display() # Modifying a global variable inside a function def change_message(): global message message = \u0026#34;Hello, Python!\u0026#34; change_message() print(message) Output:\nHello, World!\rHello, Python! 7.3. Local vs. Global Variables If a local variable has the same name as a global variable, the local variable takes precedence within the function scope.\nExample:\nmessage = \u0026#34;Hello, World!\u0026#34; def display(): message = \u0026#34;Hello, Python!\u0026#34; print(message) display() print(message) Output:\nHello, Python!\rHello, World! ","permalink":"http://localhost:1313/posts/pages/python/python_function/","summary":"An in-depth exploration of Python functions, their usage, and importance in programming.","title":"Python Fundamentals: Understanding Functions (Part 5)"},{"content":"1. Create A React Project To create a React app we use Vite and its command is:\nnpm create vite@latest 2. Component In a React application, one page is broken down into multiple components. Components allow:\nReusability: For example, we can create one component for cards and use it to create multiple cards with different data. Related code lives together: Related items (JS code) are stored together. Separation of logic: Different components handle different data and logic. Diagram 3. Folder Structure my-app/\r├─ node_modules/\r├─ public/\r│ ├─ index.html\r│ ├─ image.png\r│ └─ favicon.ico\r├─ src/\r│ ├─ index.js\r│ ├─ App.js\r│ ├─ App.css\r│ └─ index.css\r├─ package.json\r└─ README.md node_module: Contains all the files of installed packages.\npublic: All static files are kept in this folder. For example, if image.png is in public, we can access it in the browser as 127.0.0.1:8000/image.png.\nindex.html: It is the page that is served to us and its content is managed by React using the DOM.Modify this file if you want to change the title or favicon.\npackage.json: Contains all the configuration of the project, package list, versions, and all related information.\nsrc: This is the folder where all the code is written.\nsrc/index.js React runs this file first.Code of index.js\nThe DOM selects the element of index.html whose id is root because of this code: document.getElementById('root') Then render() renders the \u0026lt;App/\u0026gt; component so that the root element will contain the data of the \u0026lt;App/\u0026gt; component. All changes are done in the index.html root element using the DOM. Remember that we never edit this file (code). src/App.js : This is where we will write all the SPA code. We start coding from App.jsx and link components as required.\nsrc/index.css : This CSS file is used by main.jsx, so it applies to the whole page. You can remove it if needed by removing its import in main.jsx.\n*** src/App.css:*** This CSS file is used by App.jsx, so it applies to all App components.\nRemember: Component functions must follow two rules:\nThe name should start with an uppercase letter (e.g., Head, MyHead). The function must return renderable content. The function must return a value that can be rendered (displayed on screen) by React. In most cases, return JSX. Example of a simple component:\nfunction App() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Hello world\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ); } As we know, App.jsx is provided by default when we create a React app. We can modify it and tailor it to our requirements\n4. Making Custom Components function FunctionName() { return ( \u0026lt;tagname\u0026gt; content \u0026lt;/tagname\u0026gt; ); } Important Note:\nTags that don\u0026rsquo;t have ending tags, such as \u0026lt;br\u0026gt; and \u0026lt;hr\u0026gt;, should be written as \u0026lt;br/\u0026gt; and \u0026lt;hr/\u0026gt;. class is replaced by className. For example, \u0026lt;body class=\u0026quot;data\u0026quot;\u0026gt; is written as \u0026lt;body className=\u0026quot;data\u0026quot;\u0026gt;. During a return in React, we cannot return multiple elements directly. Instead, we need to wrap them inside a single parent element like \u0026lt;div\u0026gt;, \u0026lt;\u0026gt;\u0026lt;/\u0026gt;. For Example :\nWrong Way: function component1() { return ( \u0026lt;div\u0026gt; Hi \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; Hello \u0026lt;/div\u0026gt; ); } right way: function component1() { return ( \u0026lt;div\u0026gt; {/* or \u0026lt;\u0026gt; */} \u0026lt;div\u0026gt; Hi \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; Hello \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; {/* or \u0026lt;/\u0026gt; */} ); } 5.Using One Component Inside Another Component To use one component inside another in React, follow the steps\nCreate a component. function Comp1() { return \u0026lt;div\u0026gt; Component \u0026lt;/div\u0026gt; } Use the component inside another component. function Comp2() { return ( \u0026lt;div\u0026gt; \u0026lt;Comp1 /\u0026gt; or \u0026lt;Comp1\u0026gt; \u0026lt;Comp1 /\u0026gt; content \u0026lt;/div\u0026gt; ) } Here, Comp1 is used inside Comp2.We can use Comp1 multiple times inside Comp2 as needed. Note: For proper management, create a components folder, create one file for each component, and export from there. Then, import and use it in another component.\nExample structure:\nsrc/\r├─ Assets/\r├─ App.jsx\r└─ Components/\r├─ Comp1.jsx\r└─ Comp2.jsx Task: Break Down a Component into Multiple Components\nfunction App() { return ( \u0026lt;\u0026gt; \u0026lt;header\u0026gt; I am header \u0026lt;/header\u0026gt; \u0026lt;main\u0026gt; I am main content \u0026lt;/main\u0026gt; \u0026lt;footer\u0026gt; I am footer \u0026lt;/footer\u0026gt; \u0026lt;/\u0026gt; ); } Solution: components/Header.jsx\nfunction Header() { return ( \u0026lt;header\u0026gt; I am header \u0026lt;/header\u0026gt; ); } export default Header; components/Footer.jsx\nfunction Footer() { return ( \u0026lt;footer\u0026gt; I am footer \u0026lt;/footer\u0026gt; ); } export default Footer; Finally, App.jsx\nimport Header from \u0026#39;./components/Header\u0026#39;; import Footer from \u0026#39;./components/Footer\u0026#39;; function App() { return ( \u0026lt;\u0026gt; \u0026lt;Header /\u0026gt; \u0026lt;main\u0026gt; I am main content \u0026lt;/main\u0026gt; \u0026lt;Footer /\u0026gt; \u0026lt;/\u0026gt; ); } export default App; structure:\nsrc/\r├─ Assets/\r├─ App.jsx\r└─ components/\r├─ Header.jsx\r└─ Footer.jsx Note: You Can Always break down a component as many times as you want. The main goal is to make the code more readable and maintainable.\n6. Some Component Hierarchies Examples THis is the simple example of a component hierarchy. 7. Embedding JavaScript code in JSX In JSX, we can embed JavaScript code using curly braces {}. We can write any JavaScript code inside the curly braces. For example, we can write a variable, function, or any JavaScript expression but of single line.\nfunction componentName() { return ( \u0026lt;div\u0026gt; { JavaScript code } \u0026lt;/div\u0026gt; ); } Example:\nfunction App() { const name = \u0026#39;John Doe\u0026#39;; return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt; Hello, {name} \u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ); } Where To Write Javascript Logic?\nWe can write JavaScript logic inside the component function. We can write JavaScript logic outside the component function and use it inside the component function. 7.1 Using JavaScript Logic Outside Component Function syntax:\n// Multiple lines of JavaScript code function ComponentName() { return ( \u0026lt;div\u0026gt; {/* JSX code */} \u0026lt;/div\u0026gt; ); } 7.2 Using JavaScript Logic Inside Component Function syntax:\nfunction ComponentName() { // Multiple lines of JavaScript code return ( \u0026lt;div\u0026gt; {/* JSX code */} \u0026lt;/div\u0026gt; ); } When to use Inside Component Function Outside Component Function Use Case When the logic is specific to the component and not used anywhere else. When the logic is used in multiple components. Advantages Logic is specific to the component. Logic can be reused in multiple components. Disadvantages Logic cannot be reused in other components. Logic is not specific to the component. Combined Example Task1: Create a component that generate random number between 1 to 10 and display in every page reload\nfunction RandomNumber(){ return \u0026lt;\u0026gt; \u0026lt;h1\u0026gt;Random Number: {Math.floor(Math.random() * 10) + 1}\u0026lt;/h1\u0026gt; } export default RandomNumber; This can be done in another ways which is more readable and maintainable\nfunction RandomNumber(){ const randomNumber = Math.floor(Math.random() * 10) + 1; return \u0026lt;h1\u0026gt;Random Number: {randomNumber}\u0026lt;/h1\u0026gt; } export default RandomNumber; Task2 : Create a component that generate random element from an array and display on each page reload\nconst elements = [\u0026#39;Earth\u0026#39;, \u0026#39;Water\u0026#39;, \u0026#39;Fire\u0026#39;, \u0026#39;Air\u0026#39;]; function generateRandomElement(){ return elements[Math.floor(Math.random() * elements.length)]; } function RandomElement(){ const randomElement = generateRandomElement(); return \u0026lt;h1\u0026gt;Random Element: {randomElement}\u0026lt;/h1\u0026gt; } export default RandomElement; This can be done by putting the logic inside the component function\nconst elements = [\u0026#39;Earth\u0026#39;, \u0026#39;Water\u0026#39;, \u0026#39;Fire\u0026#39;, \u0026#39;Air\u0026#39;]; function generateRandomElement(){ return elements[Math.floor(Math.random() * elements.length)]; } function RandomElement(){ const randomElement = elements[Math.floor(Math.random() * elements.length)]; return \u0026lt;h1\u0026gt;Random Element: {randomElement}\u0026lt;/h1\u0026gt; } export default RandomElement; The most optimal way is using this\nconst elements = [\u0026#39;Earth\u0026#39;, \u0026#39;Water\u0026#39;, \u0026#39;Fire\u0026#39;, \u0026#39;Air\u0026#39;]; function RandomElement(){ const randomElement = elements[Math.floor(Math.random() * elements.length)]; return \u0026lt;h1\u0026gt;Random Element: {randomElement}\u0026lt;/h1\u0026gt; } export default RandomElement; 8.Loading Images in React step 1: put the images in assets folder that need to be loaded step 2: import the image in the component where it is needed as shown below import imageName from Location Note: Location is the path of the image from the current file location and imageName can be set to any name\nstep 3: use the image in the component as shown below \u0026lt;img src={imageName} alt=\u0026#34;description\u0026#34; /\u0026gt; Note: imageName is the location of the image as src/Assets/logo.png\nTask: Load an image in a Header component with the image name logo.png and description logo. structure:\nsrc/\r├─ Assets/\r└─ logo.png\r├─ App.jsx\r└─ components/\r├─ Header.jsx import logo from \u0026#39;../Assets/logo.png\u0026#39;; function Header() { return ( \u0026lt;header\u0026gt; \u0026lt;img src={logo} alt=\u0026#34;logo\u0026#34; /\u0026gt; \u0026lt;/header\u0026gt; ); } 9.Importing CSS in React step 1: create a css file in the src folder step 2: import the css file in the component where it is needed as shown below import cssfileLocation Note: style.css is the name of the css file\nfor example:\nimport \u0026#39;./style.css\u0026#39; function App() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt; Hello world \u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ); } 9.1 Managing CSS in React Create css file in same directory as of your component src/ ├─ App.jsx └─ components/ ├─ Header.jsx └─ Header.css -Import the css file in the component where it is needed as shown below\r```jsx\rimport \u0026#39;./Header.css\u0026#39; 10.Props in React Props are used to pass data from parent component to child component. It is used to reuse the same component with different data. Props are passed as attributes to the component. Prop accept any type of value like string, number, array, object, function,compenent,jsx bool etc. 10.1 Passing Props from Parent to Child Component Parent Component function ParentComponent() { return ( \u0026lt;ChildComponent prop1={value1} prop2={value2} /\u0026gt; ); } 10.2 Receiving Props in Child Component Child Component function ChildComponent(props) { console.log(props); // will print object of props {prop1: value1, prop2:value2} return ( \u0026lt;\u0026gt; {props.prop1} {props.prop2} \u0026lt;/\u0026gt; ); } This approach is not recommended because it is not clear what props are being passed to the component. Instead, we can destructure the props as shown below.\n10.3 Destructuring Props Child Component function ChildComponent({prop1, prop2}) { return ( \u0026lt;\u0026gt; {prop1} {prop2} \u0026lt;/\u0026gt; ); } Task: Create a card cmponent and use multiple cards in the App component to make card section\nfunction Card({title, description, image}) { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;{title}\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;{description}\u0026lt;/p\u0026gt; \u0026lt;img src={image} alt=\u0026#34;description\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; ); } export default Card; import Card from \u0026#39;./components/Card\u0026#39;; function App() { return ( \u0026lt;div\u0026gt; \u0026lt;Card title=\u0026#34;Card 1\u0026#34; description=\u0026#34;This is card 1\u0026#34; image={image1} /\u0026gt; \u0026lt;Card title=\u0026#34;Card 2\u0026#34; description=\u0026#34;This is card 2\u0026#34; image={image2} /\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; 11. Children Props in React Children props are used to pass data between opening and closing tags of a component. 11.1 Passing Children Props Parent Component function ParentComponent() { return ( \u0026lt;ChildComponent\u0026gt; \u0026lt;h1\u0026gt; Hello \u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt; World \u0026lt;/p\u0026gt; \u0026lt;/ChildComponent\u0026gt; ); } 11.2 Receiving Children Props Child Component function ChildComponent({ children }) { return ( \u0026lt;div\u0026gt; {children} \u0026lt;/div\u0026gt; ); } 11.3 Output \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt; Hello \u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt; World \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; 12.Using Props and Children Props Together Task: Create a card component that accepts title, description, and children props. Use the card component in the App component to make a card section.\nfunction Card({ title, description, children }) { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;{title}\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;{description}\u0026lt;/p\u0026gt; {children} \u0026lt;/div\u0026gt; ); } export default Card; import Card from \u0026#39;./components/Card\u0026#39;; function App() { return ( \u0026lt;div\u0026gt; \u0026lt;Card title=\u0026#34;Card 1\u0026#34; description=\u0026#34;This is card 1\u0026#34;\u0026gt; \u0026lt;h1\u0026gt; Hello \u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt; World \u0026lt;/p\u0026gt; \u0026lt;/Card\u0026gt; \u0026lt;Card title=\u0026#34;Card 2\u0026#34; description=\u0026#34;This is card 2\u0026#34;\u0026gt; \u0026lt;h1\u0026gt; Hello \u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt; World \u0026lt;/p\u0026gt; \u0026lt;/Card\u0026gt; \u0026lt;/div\u0026gt; ); } 13. Making a Button Component 13.1 Using Props function App() { return ( \u0026lt;div\u0026gt; \u0026lt;Button text=\u0026#34;Click me\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; ); } function Button({ text}) { return ( \u0026lt;button\u0026gt; {text} \u0026lt;/button\u0026gt; ); } export default Button; 13.2 Using Children Props function App() { return ( \u0026lt;div\u0026gt; \u0026lt;Button\u0026gt;Click me\u0026lt;/Button\u0026gt; \u0026lt;/div\u0026gt; ); } function Button({ children }) { return ( \u0026lt;button\u0026gt; {children} \u0026lt;/button\u0026gt; ); } export default Button; 14. Reacting to Events In React, we can add event listeners like onClick, onMouseOver, onMouseOut, etc to buildin components lie button, div, etc using syntax \u0026lt;InbuiltComponent eventlistener={functionName} /\u0026gt; Note: functionName is the name of the function that will be called when the event is triggered.\nThere are Many eventlisteners that can be used in React like onClick, onMouseOver, onMouseOut etc.\nYou can check the full list of event listeners in the React documentation also note that the event listener will always start with on followed by the event name.\nWe can call the handle function in two ways:\n14.1 The First Way function App() { function handleClick() { console.log(\u0026#39;Button clicked\u0026#39;); } return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={handleClick}\u0026gt;Click me\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 14.2 The Second Way function App() { return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={() =\u0026gt; {console.log(\u0026#39;Button clicked\u0026#39;)}}\u0026gt;Click me\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 15. Event Listeners in Custom Components since by default when we add event listeners to custom component it doesnot work just because it is passed as prop but on simple tweaking we can make it work\nDesign Pattern for applying event listeners in custom components\nfunction App(){ function handleClick(){ console.log(\u0026#39;Button clicked\u0026#39;); } return ( \u0026lt;div\u0026gt; \u0026lt;Button onClick={handleClick} /\u0026gt; \u0026lt;/div\u0026gt; ); } The onclick method is passed as a prop to the button component and then used in the button component as shown below\nfunction Button({onClick}){ return ( \u0026lt;button onClick={onClick}\u0026gt;Click me\u0026lt;/button\u0026gt; ); } 16. Passing Arguments to Event Functions To pass Custom arguments to event functions, we can use the arrow function syntax as shown below \u0026lt;inbuildComponent eventListener={() =\u0026gt; functionName(argument)} /\u0026gt; Example function App() { function handleClick(name) { console.log(\u0026#39;Button clicked by\u0026#39;, name); } return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={() =\u0026gt; handleClick(\u0026#39;John\u0026#39;)}\u0026gt;Click me\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } ","permalink":"http://localhost:1313/posts/pages/react/react/","summary":"A detailed reference guide to help you quickly set up and manage React projects, components, and folder structures.","title":"React : Day 1"},{"content":"Python Fundamentals: Understanding Error Handling In Python programming, error handling is an essential concept that allows you to gracefully manage exceptions and errors that may occur during program execution. By handling errors effectively, you can prevent your program from crashing and provide meaningful feedback to users. In this guide, we will explore the fundamentals of error handling in Python, including exceptions, try-except blocks, and best practices.\n1. Exceptions In Python, exceptions are events that occur during the execution of a program that disrupt the normal flow of code. When an exception occurs, the interpreter raises an exception object that can be caught and handled by the program. Exceptions can be caused by various reasons, such as invalid input, file not found, or division by zero.\n2.What May Cause Exceptions Exceptions can be caused by various reasons, such as:\nDivision by zero Invalid input File not found Syntax errors Out of Index of list, tuple , String Key Error in dictionary 3.Types of Exceptions Commonly used exceptions in Python include:\nZeroDivisionError: Raised when division or modulo by zero occurs. ValueError: Raised when a function receives an argument of the correct type but an inappropriate value. TypeError: Raised when an operation or function is applied to an object of an inappropriate type. IndexError: Raised when a sequence subscript is out of range. KeyError: Raised when a dictionary key is not found. SyntaxError: Raised when the parser encounters a syntax error. Note: All exceptions in Python are subclasses of the Exception class.\n3.Handling Exceptions To handle exceptions in Python, you can use the try-except block, which allows you to catch and handle exceptions gracefully. The try block contains the code that may raise an exception, and the except block handles the exception if it occurs.The program control will transfer the control to the except block if any exception occurs in the try block but if there is not exception then the control will not transfer to the except block.\n4.1. Using try-except Block Here\u0026rsquo;s an example of using the try-except block to handle exceptions in Python:\nsyntax:\ntry: # Code that may raise an exception except ExceptionType as e: # Handle the exception Example:\ntry: x = 10 / 0 except Exception as e: print(\u0026#34;Error: Division by zero\u0026#34;) Output:\nError: Division by zero Note: if you don\u0026rsquo;t know the type of exception you can use Exception to catch all exceptions.\nIf you dont handel exception then it will show error and stop the program.\n4.2. Finally Block The finally block is used to execute code that should always run, regardless of whether an exception occurs or not. The finally block is typically used to release resources or clean up operations that need to be performed after the try block, regardless of the outcome Any how the finally block will run. if yout return from the try block then also the finally block will run.\nsyntax:\ntry: # Code that may raise an exception except ExceptionType as e: # Handle the exception finally: # Code that always runs Example:\ntry: x = 10 / 0 except Exception as e: print(\u0026#34;Error: Division by zero\u0026#34;) finally: print(\u0026#34;Cleanup code\u0026#34;) Output:\nError: Division by zero\rCleanup code 3.5. Raising Exceptions You can raise exceptions in Python using the raise statement. This allows you to create custom exceptions and raise them when needed. You can also raise built-in exceptions to indicate errors or exceptional conditions.\nsyntax:\nraise ExceptionType(\u0026#34;Error message\u0026#34;) Example:\nx = -1 if x \u0026lt; 0: raise ValueError(\u0026#34;Value cannot be negative\u0026#34;) Output:\nValueError: Value cannot be negative 3.6. Multiple except Blocks You can use multiple except blocks to handle different types of exceptions in Python. This allows you to catch and handle specific exceptions based on their type.\nsyntax:\ntry: # Code that may raise an exception except ExceptionType1 as e: # Handle ExceptionType1 except ExceptionType2 as e: # Handle ExceptionType2 Example:\ntry: x = 10 / 0 except ZeroDivisionError as e: print(\u0026#34;Error: Division by zero\u0026#34;) except ValueError as e: print(\u0026#34;Error: Invalid value\u0026#34;) Output:\nError: Division by zero 3.7. Custom Exceptions You can create custom exceptions in Python by defining a new exception class that inherits from the Exception class. Custom exceptions allow you to define specific error conditions for your application and raise them when needed.\nsyntax:\nclass CustomException(Exception): pass Example:\n#Will read about class in oop section class CustomError(Exception): def __init__(self,message,value): self.message=message self.value=value def __str__(self): return f\u0026#34;{self.message}\\nError code:{self.value}\u0026#34; try: x = -1 if x \u0026lt; 0: raise CustomError(\u0026#34;Value cannot be negative\u0026#34;,1001) except CustomError as e: print(e) Note: Custom exceptions should inherit from the Exception class or one of its subclasses. You can simply use:\ntry: #code except: #code try: #code except Exception as e: #code try: #code except Exception: #code try: #code except: #code finally: #code ","permalink":"http://localhost:1313/posts/pages/python/python_error_handeling/","summary":"An in-depth exploration of Python error handling, exceptions, and best practices.","title":"Python Fundamentals: Understanding Error Handling (Part 6)"},{"content":"Python Fundamentals: Packages, Generators, and Decorators In this guide, we will explore advanced Python topics including packages, generators, and decorators. These concepts are essential for writing efficient and maintainable Python code. Let\u0026rsquo;s dive in!\n1. Python Packages Python packages are a way of organizing and structuring your code into reusable modules. Packages allow you to group related modules together, making it easier to manage and maintain your codebase. In this section, we will explore how to create and use Python packages.\n1.1. Creating a Package To create a Python package, you need to organize your code into a directory structure with a special file called __init__.py. This file tells Python that the directory is a package and allows you to import modules from the package.\nExample directory structure:\nmy_package/\r│\r├── __init__.py\r├── module1.py\r└── module2.py 1.2. Using a Package To use a Python package, you can import modules from the package using the import statement. You can import specific modules or the entire package.\nExample:\n# Importing a specific module from my_package import module1 # Using a function from the imported module module1.my_function() # Importing the entire package import my_package # Using a function from a module within the package my_package.module2.another_function() #Importing Function from a module from my_package.module1 import my_function my_function() Note : init.py file can be empty or contain initialization code for the package. It will automatically run when the package is imported.\n1.3 Creating a Subpackage You can create subpackages within a package to further organize your code. Subpackages are simply packages within packages, allowing you to create a hierarchical structure for your codebase.\nExample directory structure:\nmy_package/\r│\r├── __init__.py\r├── module1.py\r└── subpackage/\r├── __init__.py\r├── module3.py\r└── module4.py 1.4. Using a Subpackage To use a subpackage, you can import modules from the subpackage using the dot notation.\nExample:\n# Importing a module from a subpackage from my_package.subpackage import module3 # Using a function from the imported module module3.another_function() # Importing the entire subpackage import my_package.subpackage # Using a function from a module within the subpackage my_package.subpackage.module4.some_function() #Importing Function from a module from my_package.subpackage.module3 import another_function another_function() 1.5. name == \u0026ldquo;main\u0026rdquo; We use the __name__ variable to check if a script is being run as the main program or being imported as a module. When a script is run as the main program, __name__ is set to \u0026quot;__main__\u0026quot;. This allows you to include code that should only run when the script is executed directly.\nFor Example:\nStructure:\nMain Directory/\r├── main.py\r└── package/\r├── __init__.py\r└── module1.py module1.py:\ndef my_function(): print(\u0026#34;Hello from module1\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: my_function() When you run module1.py directly, the my_function() will be executed. However, if you import module1 into another script, the my_function() will not be executed.\nFor Example:\nfrom package import module1 print(\u0026#34;Imported module1\u0026#34;) Output:\nImported module1 When use Dont use if __name__ == \u0026quot;__main__\u0026quot;: in module1.py:\ndef my_function(): print(\u0026#34;Hello from module1\u0026#34;) my_function() also,\nfrom package import module1 print(\u0026#34;Imported module1\u0026#34;) Output:\nHello from module1\rImported module1 2. Python Generators Using generator we can instantly return all the values using the yield keyword without storing them in memory. This is useful when working with large datasets or infinite sequences.\n2.1. Creating a Generator To create a generator in Python, you can use a function with the yield keyword. When a function contains the yield keyword, it becomes a generator function. The yield keyword suspends the function\u0026rsquo;s execution and returns a value to the caller.\nExample:\ndef my_generator(): yield 1 yield 2 yield 3 # Using the generator gen = my_generator() print(next(gen)) # Output: 1 print(next(gen)) # Output: 2 print(next(gen)) # Output: 3 Example:\n#using generator in loop def generate(n): for i in range(n): yield i for i in generate(10): print(i) 3. Python Decorators Decorators are a powerful feature in Python that allows you to modify or extend the behavior of functions or methods. Decorators are functions that take another function as an argument and return a new function that extends the behavior of the original function.\n3.1. Creating a Decorator To create a decorator in Python, you can define a function that takes another function as an argument and returns a new function that extends the behavior of the original function.\nSyntax:\ndef my_decorator(func): def wrapper(): # Code to execute before calling the decorated function func() # Code to execute after return wrapper Example:\ndef my_decorator(func): def wrapper(): print(\u0026#34;Before function call\u0026#34;) func() print(\u0026#34;After function call\u0026#34;) return wrapper @my_decorator def say_hello(): print(\u0026#34;Hello!\u0026#34;) say_hello() #call to my_decorator(say_hello)() just because we use @my_decorator Output:\nBefore function call\rHello!\rAfter function call Example For decorator :\ndef Add_Wrapper(func): def wrapper(a,b,c): print(\u0026#34;Status code is\u0026#34;,c) return func(a,b) return wrapper @Add_Wrapper def add(a,b): return a+b print(add(2,3,200)) Output:\nStatus code is 200\r5 3.2. Decorator with Arguments You can also create decorators that accept arguments by defining a decorator function that takes arguments and returns a decorator function.\nSyntax:\ndef my_decorator_with_args(arg1, arg2): def decorator(func): def wrapper(): # Code to execute before calling the decorated function func() # Code to execute after return wrapper return decorator Example:\ndef my_decorator_with_args(arg1, arg2): def decorator(func): def wrapper(): print(f\u0026#34;Decorator arguments: {arg1}, {arg2}\u0026#34;) func() return wrapper return decorator @my_decorator_with_args(\u0026#34;arg1\u0026#34;, \u0026#34;arg2\u0026#34;) def say_hello(): print(\u0026#34;Hello!\u0026#34;) say_hello() Output:\nDecorator arguments: arg1, arg2\rHello! ","permalink":"http://localhost:1313/posts/pages/python/python_advanced_topics/","summary":"An in-depth exploration of Python packages, generators, and decorators.","title":"Python Fundamentals: Packages, Generators, and Decorators (Part 7)"},{"content":"Python Fundamentals: Understanding request In this guide, we will explore request package in python. This package is used to make HTTP requests in python. Let\u0026rsquo;s dive in!\n1. Python request Python request is a simple and elegant HTTP library for Python. It provides methods for sending HTTP requests and handling the responses. The requests library allows you to send HTTP requests using a simple and intuitive API, and it also provides support for handling cookies, sessions, and authentication.\n1.1. Installing requests To use the requests library in your Python project, you need to install it using pip. You can install the requests library by running the following command in your terminal:\npip install requests 1.2. Types of requests The requests library supports various types of HTTP requests, including GET, POST, PUT, DELETE, and more. You can use these methods to interact with web services and APIs.\nExample:\nimport requests # Send a GET request response = requests.get(\u0026#39;https://api.github.com\u0026#39;) # Send a POST request response = requests.post(\u0026#39;https://httpbin.org/post\u0026#39;) # Send a PUT request response = requests.put(\u0026#39;https://httpbin.org/put\u0026#39;) # Send a DELETE request response = requests.delete(\u0026#39;https://httpbin.org/delete\u0026#39;) 1.3 Parameters for requests The requests library allows you to pass various parameters when making HTTP requests. These parameters include headers, query parameters, request body, and more.\nHeaders: You can pass custom headers in your request using the headers parameter. Example: import requests # Send a GET request with custom headers headers = {\u0026#39;User-Agent\u0026#39;: \u0026#39;Mozilla/5.0\u0026#39;} response = requests.get(\u0026#39;https://api.github.com\u0026#39;, headers=headers) # Send a POST request with custom headers response = requests.post(\u0026#39;https://httpbin.org/post\u0026#39;, headers=headers) #similarly for PUT and DELETE cookie: You can pass cookies in your request using the cookies parameter. Example: import requests # Send a GET request with cookies cookies = {\u0026#39;session_id\u0026#39;: \u0026#39;12345\u0026#39;} response = requests.get(\u0026#39;https://api.github.com\u0026#39;, cookies=cookies) # Send a POST request with cookies response = requests.post(\u0026#39;https://httpbin.org/post\u0026#39;, cookies=cookies) #similarly for PUT and DELETE file: You can upload files in your request using the files parameter. Example: import requests # Upload a file in a POST request files = {\u0026#39;file\u0026#39;: open(\u0026#39;file.txt\u0026#39;, \u0026#39;rb\u0026#39;)} response = requests.post(\u0026#39;https://httpbin.org/post\u0026#39;, files=files) #similarly for PUT and DELETE params: You can pass query parameters in your request using the params parameter. Example: import requests # Send a GET request with query parameters params = {\u0026#39;key1\u0026#39;: \u0026#39;value1\u0026#39;, \u0026#39;key2\u0026#39;: \u0026#39;value2\u0026#39;} response = requests.get(\u0026#39;https://api.github.com\u0026#39;, params=params) # Send a POST request with query parameters response = requests.post(\u0026#39;https://httpbin.org/post\u0026#39;, params=params) #similarly for PUT and DELETE data: You can pass data in your request body using the data parameter. Example: import requests # Send a POST request with data data = {\u0026#39;key1\u0026#39;: \u0026#39;value1\u0026#39;, \u0026#39;key2\u0026#39;: \u0026#39;value2\u0026#39;} response = requests.post(\u0026#39;https://httpbin.org/post\u0026#39;, data=data) #similarly for PUT and DELETE json: You can pass JSON data in your request body using the json parameter. Example: import requests # Send a POST request with JSON data data = {\u0026#39;key1\u0026#39;: \u0026#39;value1\u0026#39;, \u0026#39;key2\u0026#39;: \u0026#39;value2\u0026#39;} response = requests.post(\u0026#39;https://httpbin.org/post\u0026#39;, json=data) #similarly for PUT and DELETE Note: The requests library provides a wide range of parameters and options for making HTTP requests. You can refer to the official documentation for more details.\n** Note ** : While using json it will automatically set the content type to application/json and dump the data to json format but while using data it will set the content type to application/x-www-form-urlencoded and encode the data to urlencoded format.\n1.4. Handling responses The requests library provides methods for handling the responses returned by HTTP requests. You can access the response content, status code, headers, and more.\nResponse content: You can access the response content using the text attribute. Example: import requests # Send a GET request response = requests.get(\u0026#39;https://api.github.com\u0026#39;) # Get the response content content = response.text print(content) Response Content in bytes: You can access the response content in bytes using the content attribute. Example: import requests # Send a GET request response = requests.get(\u0026#39;https://api.github.com\u0026#39;) # Get the response content in bytes content = response.content print(content) json: You can access the response content as JSON using the json method. Example:\nimport requests # Send a GET request response = requests.get(\u0026#39;https://api.github.com\u0026#39;) # Get the response content as JSON data = response.json() print(data) Status code: You can access the response status code using the status_code attribute. Example: import requests # Send a GET request response = requests.get(\u0026#39;https://api.github.com\u0026#39;) # Get the response status code status_code = response.status_code print(status_code) Headers: You can access the response headers using the headers attribute. Example: import requests # Send a GET request response = requests.get(\u0026#39;https://api.github.com\u0026#39;) # Get the response headers headers = response.headers print(headers) Cookies: You can access the response cookies using the cookies attribute. Example: import requests # Send a GET request response = requests.get(\u0026#39;https://api.github.com\u0026#39;) # Get the response cookies cookies = response.cookies print(cookies) ","permalink":"http://localhost:1313/posts/pages/python/python_request/","summary":"An in-depth exploration of Python request.","title":"Python Fundamentals: Understanding request (Part 8)"},{"content":"Python Fundamentals: Understanding File Handeling In Python programming, file handling is an essential operation that allows you to read, write, and manipulate files on your system. Files are used to store data permanently, and Python provides various functions and methods to work with files efficiently. In this guide, we will explore the basics of file handling in Python, including opening, reading, writing, and closing files.\n1.Context Manager Python provides a built-in way to manage resources and ensure that they are properly released when they are no longer needed. This is done using the with statement and is known as a context manager. When working with files, it is recommended to use the with statement to ensure that the file is properly closed after use.\n1.1. Using the with Statement The with statement in Python is used to create a context manager that automatically takes care of resource management. When working with files, the with statement ensures that the file is properly closed after use, even if an error occurs during file operations.\nExample:\nwith open(\u0026#34;example.txt\u0026#34;, \u0026#34;r\u0026#34;) as file: data = file.read() print(data) 2. Opening a File Before you can read or write to a file, you need to open it using the open() function. The open() function takes two arguments: the file path and the mode in which you want to open the file.\n2.1. Modes for Opening Files Python supports various modes for opening files, depending on the operations you want to perform. Some common modes include:\nr: Read mode. Opens the file for reading. The file must exist. w: Write mode. Opens the file for writing. If the file exists, it will be truncated. If the file does not exist, a new file will be created. a: Append mode. Opens the file for writing. If the file exists, the data will be appended to the end. If the file does not exist, a new file will be created. b: Binary mode. Opens the file in binary mode.use for image,video,etc as it will not convert the data to text .You can add b to any mode to open the file in binary mode like rb,wb,ab. t: Text mode. Opens the file in text mode (default). 2.2. Opening a File To open a file, you can use the open() function with the desired file path and mode. You can also specify additional parameters such as encoding, buffering, and newline characters.\nExample:\n# Open a file in read mode with open(\u0026#34;example.txt\u0026#34;, \u0026#34;r\u0026#34;) as file: data = file.read() print(data) 3. Reading from a File Once you have opened a file, you can read its contents using various methods provided by Python. The most common methods for reading from a file is read().\n# Open a file in read mode with open(\u0026#34;example.txt\u0026#34;, \u0026#34;r\u0026#34;) as file: data = file.read() print(data) 4. Writing to a File To write data to a file, you can use the write() method provided by Python. You can write text data to a file using the write() method.\nUsing w mode: # Open a file in write mode with open(\u0026#34;example.txt\u0026#34;, \u0026#34;w\u0026#34;) as file: file.write(\u0026#34;Hello, World!\u0026#34;) Using a mode: # Open a file in append mode with open(\u0026#34;example.txt\u0026#34;, \u0026#34;a\u0026#34;) as file: file.write(\u0026#34;Hello, World!\u0026#34;) 5.Context Manager Reference\nUse of Context Manager: In any programming language, the usage of resources like file operations or database connections is very common. But these resources are limited in supply. Therefore, the main problem lies in making sure to release these resources after usage. If they are not released then it will lead to resource leakage and may cause the system to either slow down or crash. It would be very helpful if users have a mechanism for the automatic setup and teardown of resources. In Python, it can be achieved by the usage of context managers which facilitate the proper handling of resources.\nWhat is happened When the with statement is executed, it will automatically call the __enter__ before entering the code block, and __exit__ after exiting the code block.\nHow to create a context manager To create a context manager, you need to define a class that implements the __enter__ and __exit__ methods. The __enter__ method is called when the with statement is executed, and the __exit__ method is called after the code block is executed.\nSyntax:\nclass MyContextManager: def __init__(self,params): # Code to initialize resources def __enter__(self): # Code to setup resources return self def __exit__(self, exc_type, exc_value, traceback): # Code to release resources Example:\n#implementatio of own file handeling context manager class MeroHandle: def __init__(self,filename,mode): self.filename = filename self.mode = mode def __enter__(self): self.file = open(self.filename,self.mode) return self.file def __exit__(self,exc_type,exc_value,traceback): self.file.close() #using the context manager with MeroHandle(\u0026#34;example.txt\u0026#34;,\u0026#34;r\u0026#34;) as file: data = file.read() print(data) Normal way of file handeling try: file = open(\u0026#34;example.txt\u0026#34;,\u0026#34;r\u0026#34;) data = file.read() print(data) file.close() except: print(\u0026#34;Error Occured\u0026#34;) Advantage of context manager Over normal code When we use normal code shown above then when error occured in try block before file.close() then it will not close the file(i.e file will not be closed) and it will lead to resource leakage . But when we use context manager then it will automatically close the file just because __exit__ method is called after the code block is executed whether error occured or not. but in normal code we can manage this by using finally block but it is not recommended as it is not pythonic way of doing things. try: file = open(\u0026#34;example.txt\u0026#34;,\u0026#34;r\u0026#34;) data = file.read() print(data) except: print(\u0026#34;Error Occured\u0026#34;) finally: file.close() This will work but it is not pythonic way of doing things.Just because we have to write whole try,except,finally block for just opening and closing the file. which make code more complex and lengthy.\n","permalink":"http://localhost:1313/posts/pages/python/python_filehandeling/","summary":"An in-depth look at File Handeling.","title":"Python Fundamentals: Understanding File Handeling (Part 9)"},{"content":"Python Fundamentals: Some Important Package to Know In Python programming, packages are collections of modules that provide additional functionality to your programs. Python has a rich ecosystem of packages that can help you perform a wide range of tasks, from data analysis and visualization to web development and machine learning. In this guide, we will explore some of the most important packages in Python that you should be familiar with.\n1.json The json package in Python provides functions for encoding and decoding JSON data. JSON (JavaScript Object Notation) is a lightweight data interchange format that is easy for humans to read and write and easy for machines to parse and generate. The json package allows you to work with JSON data in Python by converting Python objects to JSON strings and vice versa.\nConversion of Python dictionary to JSON string We can convert a Python dictionary to a JSON string using the json.dumps() function. This function takes a Python object as input and returns a JSON string representation of the object. Example:\nimport json # Create a Python dictionary data = { \u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34; } # Convert the dictionary to a JSON string json_string = json.dumps(data) print(json_string) Conversion of JSON string to Python dictionary We can convert a JSON string to a Python dictionary using the json.loads() function. This function takes a JSON string as input and returns a Python object (usually a dictionary) representing the JSON data. Example:\nimport json # JSON string json_string = \u0026#39;{\u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;}\u0026#39; # Convert the JSON string to a Python dictionary data = json.loads(json_string) print(data) 2.os The os package in Python provides functions for interacting with the operating system.You can get indepth knowladge of os using its own documentation.but the most common methods are:\nos.path.join(\u0026quot;C:\u0026quot;,\u0026quot;users\u0026quot;,\u0026quot;bin\u0026quot;): Join one or more path components intelligently. os.rename(\u0026quot;old\u0026quot;,\u0026quot;new\u0026quot;): Rename a file or directory. 3.time The time package in Python provides functions for working with time-related tasks. You can use the time package to get the current time, sleep for a specified duration, and measure the execution time of your code.\ntime.time(): Returns the current time in seconds since the epoch. time.sleep(seconds): Suspends the execution of the current thread for the given number of seconds. 4.uuid The uuid package in Python provides functions for generating and working with UUIDs (Universally Unique Identifiers). UUIDs are unique identifiers that are used to identify objects in a distributed computing environment. The uuid package allows you to generate UUIDs based on various algorithms and formats.\nGenerating a UUID You can generate a UUID using the uuid.uuid4() function, which generates a random UUID. Example:\nimport uuid # Generate a random UUID uuid_value = uuid.uuid4() print(uuid_value) 5.Datetime The datetime package in Python provides classes for working with dates and times. You can use the datetime package to create, manipulate, and format dates and times in your Python programs.\nCreating a datetime object You can create a datetime object using the datetime.datetime() constructor, which takes the year, month, day, hour, minute, second, and microsecond as input. Example:\nimport datetime # Create a datetime object dt = datetime.datetime(2022, 11, 27, 10, 30, 0) print(dt) Output:\n2022-11-27 10:30:00 get current date and time You can get the current date and time using the datetime.now() method. Example:\nimport datetime # Get the current date and time now = datetime.datetime.now() print(now) Output:\n2022-11-27 10:30:00 Formatting a datetime object some Properties of datetime object:\nyear: The year of the datetime object month: The month of the datetime object (1-12) day: The day of the datetime object (1-31) hour: The hour of the datetime object (0-23) minute: The minute of the datetime object (0-59) second: The second of the datetime object (0-59) import datetime # Create a datetime object dt = datetime.datetime.now() # Format the datetime object print(dt.month()) print(dt.day()) print(dt.year()) print(dt.hour()) print(dt.minute()) print(dt.second()) Output:\n11\r27\r2022\r10\r30\r0 ","permalink":"http://localhost:1313/posts/pages/python/python_extrapackage/","summary":"An in-depth look at frequently used important package.","title":"Python Fundamentals: Some Important Package to Know (Part 10)"},{"content":"Shared References in Python: How Changes Propagate Across Variables In Python, variables are references to objects in memory. When you assign a value to a variable, you are creating a reference to the object that holds that value. In some cases, multiple variables can refer to the same object in memory. This is known as a shared reference.\nMutability and Shared References in Python: How Changes Propagate Across Variables List Lists are mutable, so if two variables reference the same list, changes through one variable will affect the other.\n# Create a list list1 = [1, 2, 3] # Create a reference to the list list2 = list1 # Modify the list through one reference list2.append(4) # Check the original list print(list1) # Output: [1, 2, 3, 4] Dictionary Dictionaries are mutable as well. If two variables point to the same dictionary, any change made through one will reflect in the other.\n# Create a dictionary dict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30} # Create a reference to the dictionary dict2 = dict1 # Modify the dictionary through one reference dict2[\u0026#34;age\u0026#34;] = 31 # Check the original dictionary print(dict1) # Output: {\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 31} Set Sets are mutable, so changes made through one reference will affect the other if two variables point to the same set.\n# Create a set set1 = {1, 2, 3} # Create a reference to the set set2 = set1 # Modify the set through one reference set2.add(4) # Check the original set print(set1) # Output: {1, 2, 3, 4} Custom Objects\nclass Person: def __init__(self, name, age): self.name = name self.age = age # Create an instance of the Person class person1 = Person(\u0026#34;Alice\u0026#34;, 30) # Create a reference to the instance person2 = person1 # Modify the instance through one reference person2.age = 31 # Check the original instance print(person1.age) # Output: 31 Note: Mutable objects like lists, dictionaries, sets, and custom objects allow changes to propagate across variables that reference the same object. Immutable objects like integers, strings, and tuples do not exhibit this behavior.\n","permalink":"http://localhost:1313/posts/pages/python/python_shared_references/","summary":"An in-depth look at shared references in Python.","title":"Python Fundamentals : Shared References in Python (part 11)"},{"content":"Object oriented programming in python Object oriented programming is a programming paradigm that provides a means of structuring programs so that properties and behaviors are bundled into individual objects.\n1. Class and Object Class is a blueprint for creating objects (a particular data structure), providing initial values for state (member variables or attributes), and implementations of behavior (member functions or methods).\nObject is an instance of a class. When class is defined, only the description for the object is defined. Therefore, no memory or storage is allocated.\n1.1 Creating a class We can create a class using the class keyword followed by the class name. The class definition can contain class variables, instance variables, methods, and constructors.\nSyntax:\nclass ClassName: #code block Example:\nclass Person: name=\u0026#34;Nirajan\u0026#34; age=20 classes=\u0026#34;Bachelor\u0026#34; 1.2 Creating an object To create an object of a class, we use the class name followed by parentheses. This calls the constructor method of the class and returns an object.\nSyntax:\nobject_name = ClassName() Example:\nperson1 = Person() 1.3 Accessing class attributes We can access the attributes of a class using the dot operator (.) followed by the attribute name.\nSyntax:\nobject_name.attribute_name Example:\nprint(person1.name) # Output: Nirajan print(person1.age) # Output: 20 print(person1.classes) # Output: Bachelor 1.4 Modifying class attributes We can modify the attributes of a class using the dot operator (.) followed by the attribute name.\nSyntax:\nobject_name.attribute_name = new_value Example:\nperson1.age = 21 print(person1.age) # Output: 21 1.5 Creating a member function We can create a member function (method) inside a class using the def keyword followed by the function name. The first parameter of the method should be self, which refers to the current instance of the class.we will see about self in next part.\nSyntax:\nclass ClassName: def method_name(self, parameters): #code block Example:\nclass Person: name=\u0026#34;Nirajan\u0026#34; age=20 classes=\u0026#34;Bachelor\u0026#34; def display(self): print(f\u0026#34;Name: {self.name}\u0026#34;) print(f\u0026#34;Age: {self.age}\u0026#34;) print(f\u0026#34;Class: {self.classes}\u0026#34;) 1.6 Calling a member function We can call a member function of a class using the dot operator (.) followed by the function name and parentheses.\nSyntax:\nobject_name.method_name(arguments) Example:\nperson1.display() 1.7 Nested member function We can call a member function from another member function of the same class using the self keyword.\nSyntax:\nclass ClassName: def method1(self): #code block self.method2() def method2(self): #code block Example:\nclass Person: name=\u0026#34;Nirajan\u0026#34; age=20 classes=\u0026#34;Bachelor\u0026#34; def display(self): print(f\u0026#34;Name: {self.name}\u0026#34;) print(f\u0026#34;Age: {self.age}\u0026#34;) print(f\u0026#34;Class: {self.classes}\u0026#34;) self.greet() def greet(self): print(\u0026#34;Hello, Welcome to the class\u0026#34;) 1.8 self parameter The self parameter is a reference to the current instance of the class, and is used to access variables and methods of the class. It is the first parameter of any method in a class.\nSyntax:\nclass ClassName: def method_name(self, parameters): #code block Example:\nclass Person: name=\u0026#34;Nirajan\u0026#34; age=20 classes=\u0026#34;Bachelor\u0026#34; def display(self): print(f\u0026#34;Name: {self.name}\u0026#34;) print(f\u0026#34;Age: {self.age}\u0026#34;) print(f\u0026#34;Class: {self.classes}\u0026#34;) self.greet() def greet(self): print(\u0026#34;Hello, Welcome to the class\u0026#34;) 2. Constructor in Python A constructor is a special type of method (function) which is used to initialize the instance members of the class. It is called when an object of the class is created.\n2.1 Creating a constructor In Python, the constructor method is called __init__. It is a special method that is automatically called when an object is created.\nSyntax:\nclass ClassName: def __init__(self, parameters): #code block Example:\nclass Person: def __init__(self, name, age, classes): self.name = name self.age = age self.classes = classes def display(self): print(f\u0026#34;Name: {self.name}\u0026#34;) print(f\u0026#34;Age: {self.age}\u0026#34;) print(f\u0026#34;Class: {self.classes}\u0026#34;) 2.2 Creating an object with constructor When an object is created, the constructor method is automatically called with the arguments passed to the class.\nSyntax:\nobject_name = ClassName(arguments) Example:\nperson1 = Person(\u0026#34;Nirajan\u0026#34;, 20, \u0026#34;Bachelor\u0026#34;) 3. Getters and Setters in Python 3.1. Getters Getters are methods is implementes by using the @property decorator. They are specially used\nto act as an value ie data instead of a method. to access the value of a private attribute without directly accessing it. Syntax:\nclass ClassName: @property def method_name(self): #code block Example:\nclass Person: def __init__(self, name, age): self._name = name self._age = age @property def display(self): return f\u0026#34;Name: {self._name}, Age: {self._age}\u0026#34; person1 = Person(\u0026#34;Nirajan\u0026#34;, 20) print(person1.display) # Output: Name: Nirajan, Age: 20 3.2. Setters Setters are methods is implementes by using the @method_name.setter decorator. They are specially used\nto set the value of a private attribute without directly setting it. to perform validation before setting the value of an attribute. Syntax:\nclass ClassName: @method_name.setter def method_name(self, value): #code block Example:\nclass Person: def __init__(self, name, age): self._name = name self._age = age @property def display(self): return f\u0026#34;Name: {self._name}, Age: {self._age}\u0026#34; @display.setter def display(self, value): self._name, self._age = value.split(\u0026#34;,\u0026#34;) self._age = int(self._age) person1 = Person(\u0026#34;Nirajan\u0026#34;, 20) print(person1.display) # Output: Name: Nirajan, Age: 20 person1.display = \u0026#34;Alice, 30\u0026#34; print(person1.display) # Output: Name: Alice, Age: 30 4. Inheritance in Python Inheritance is a mechanism in which one class acquires the properties and behavior of another class. The class which inherits the properties and behavior is known as the child class, and the class whose properties and behavior are inherited is known as the parent class.\n4.1. Creating a child class To create a child class that inherits from a parent class, we specify the parent class in parentheses after the child class name.\nSyntax:\nclass ChildClassName(ParentClassName): #code block Example:\nclass Employee: def __init__(self,name,age,id): self.name=name self.age=age self.id=id def display(self): print(f\u0026#34;Name: {self.name}\u0026#34;) print(f\u0026#34;Age: {self.age}\u0026#34;) print(f\u0026#34;ID: {self.id}\u0026#34;) class Manager(Employee):# it has all the properties of Employee class so we can access the # properties of Employee class also its method using object of Manager class def task(self): self.display() print(\u0026#34;Assigning tasks to employees\u0026#34;) class Developer(Employee): # it has all the properties of Employee class so we can access # the properties of Employee class also its method using object of Developer class def task(self): self.display() print(\u0026#34;Developing software applications\u0026#34;) manager1 = Manager(\u0026#34;Alice\u0026#34;, 30, 101) manager1.task() developer1 = Developer(\u0026#34;Bob\u0026#34;, 25, 102) developer1.task() Note : Only public and protected members are inherited by the child class. Private members are not inherited by the child class.\n5.Ascess Specifiers in Python 5.1. Public members Public members are accessible from outside the class. They can be accessed using the dot operator (.) from outside the class.\nExample:\nclass Person: name = \u0026#34;Alice\u0026#34; # Public member person1 = Person() print(person1.name) # Output: Alice 5.2. Protected members Protected members are accessible within the class and its subclasses. They are denoted by a single underscore (_) before the member name.\nExample:\nclass Person: _age = 30 # Protected member class Student(Person): def display(self): print(self._age) # Accessing protected member student1 = Student() student1.display() # Output: 30 Example of protected variable and method\nclass Person: _name = \u0026#34;Alice\u0026#34; # Protected variable def _display(self): # Protected method print(f\u0026#34;Name: {self._name}\u0026#34;) class Student(Person): def display(self): self._display() # Accessing protected metho student1 = Student() student1.display() # Output: Name: Alice 5.3. Private members Private members are accessible only within the class. They are denoted by a double underscore (__) before the member name.\nExample:\nclass Person: __city = \u0026#34;New York\u0026#34; # Private member person1 = Person() print(person1.__city) # Error: \u0026#39;Person\u0026#39; object has no attribute \u0026#39;__city\u0026#39; Example of private variable and method\nclass Person: __name = \u0026#34;Alice\u0026#34; # Private variable def __display(self): # Private method print(f\u0026#34;Name: {self.__name}\u0026#34;) person1 = Person() print(person1.__name) # Error: \u0026#39;Person\u0026#39; object has no attribute \u0026#39;__name\u0026#39; person1.__display() # Error: \u0026#39;Person\u0026#39; object has no attribute \u0026#39;__display\u0026#39; Table of Access Specifiers in Python:\nAccess Specifier Accessible from class Accessible from subclass Accessible from outside class Public Yes Yes Yes Protected Yes Yes No Private Yes No No Static Method in Python Static Method is those method that can be called without creating an object of the class. They are defined using the @staticmethod decorator. They can be called using the class name . Syntax: class ClassName: @staticmethod def method_name(parameters): #code block Example:\nclass Calculator: @staticmethod def add(a, b): return a + b result = Calculator.add(5, 3) print(result) # Output: 8 #Can call using object also calculator = Calculator() result = calculator.add(5, 3) print(result) # Output: 8 #this is also valid but it is not recommended Class Method in Python They are defined using the @classmethod decorator.The useage of class method is to access the class variable and change class variable. ie when we change variable using class method it will change for all the object of the class.THey can be called using the class name. Syntax:\nclass ClassName: @classmethod def method_name(cls, parameters): #code block Example:\nclass copany : copany=\u0026#34;Google\u0026#34; @classmethod def change_company(cls,new_company): cls.copany=new_company print(copany.copany) #Output: Google copany.change_company(\u0026#34;Microsoft\u0026#34;) print(copany.copany) #Output: Microsoft c1=copany() print(c1.copany) #Output: Microsoft c1.change_company(\u0026#34;Apple\u0026#34;) c2=copany() print(c2.copany) #Output: Applex Dir and dict method in Python dir() method is used to return a list of attributes and methods of any object. It returns a list of valid attributes and methods of the object. Syntax:\ndir(object) Example:\nclass Person: name = \u0026#34;Alice\u0026#34; age = 30 person1 = Person() print(dir(person1)) # Output: [\u0026#39;__class__\u0026#39;, \u0026#39;__delattr__\u0026#39;, \u0026#39;__dict__\u0026#39;, \u0026#39;__dir__\u0026#39;, \u0026#39;__doc__\u0026#39;, \u0026#39;__eq__\u0026#39;, \u0026#39;__format__\u0026#39;, \u0026#39;__ge__\u0026#39;, \u0026#39;__getattribute__\u0026#39;, \u0026#39;__gt__\u0026#39;, \u0026#39;__hash__\u0026#39;, \u0026#39;__init__\u0026#39;, \u0026#39;__init_subclass__\u0026#39;, \u0026#39;__le__\u0026#39;, \u0026#39;__lt__\u0026#39;, \u0026#39;__module__\u0026#39;, \u0026#39;__ne__\u0026#39;, \u0026#39;__new__\u0026#39;, \u0026#39;__reduce__\u0026#39;, \u0026#39;__reduce_ex__\u0026#39;, \u0026#39;__repr__\u0026#39;, \u0026#39;__setattr__\u0026#39;, \u0026#39;__sizeof__\u0026#39;, \u0026#39;__str__\u0026#39;, \u0026#39;__subclasshook__\u0026#39;, \u0026#39;__weakref__\u0026#39;, \u0026#39;age\u0026#39;, \u0026#39;name\u0026#39;] Example:\nl=[1,2,3] print(dir(l)) # Output: [\u0026#39;__add__\u0026#39;, \u0026#39;__class__\u0026#39;, \u0026#39;__class_getitem__\u0026#39;, \u0026#39;__contains__\u0026#39;, \u0026#39;__delattr__\u0026#39;, \u0026#39;__delitem__\u0026#39;, \u0026#39;__dir__\u0026#39;, \u0026#39;__doc__\u0026#39;, \u0026#39;__eq__\u0026#39;, \u0026#39;__format__\u0026#39;, \u0026#39;__ge__\u0026#39;, \u0026#39;__getattribute__\u0026#39;, \u0026#39;__getitem__\u0026#39;, \u0026#39;__getstate__\u0026#39;, \u0026#39;__gt__\u0026#39;, \u0026#39;__hash__\u0026#39;, \u0026#39;__iadd__\u0026#39;, \u0026#39;__imul__\u0026#39;, \u0026#39;__init__\u0026#39;, \u0026#39;__init_subclass__\u0026#39;, \u0026#39;__iter__\u0026#39;, \u0026#39;__le__\u0026#39;, \u0026#39;__len__\u0026#39;, \u0026#39;__lt__\u0026#39;, \u0026#39;__mul__\u0026#39;, \u0026#39;__ne__\u0026#39;, \u0026#39;__new__\u0026#39;, \u0026#39;__reduce__\u0026#39;, \u0026#39;__reduce_ex__\u0026#39;, \u0026#39;__repr__\u0026#39;, \u0026#39;__reversed__\u0026#39;, \u0026#39;__rmul__\u0026#39;, \u0026#39;__setattr__\u0026#39;, \u0026#39;__setitem__\u0026#39;, \u0026#39;__sizeof__\u0026#39;, \u0026#39;__str__\u0026#39;, \u0026#39;__subclasshook__\u0026#39;, \u0026#39;append\u0026#39;, \u0026#39;clear\u0026#39;, \u0026#39;copy\u0026#39;, \u0026#39;count\u0026#39;, \u0026#39;extend\u0026#39;, \u0026#39;index\u0026#39;, \u0026#39;insert\u0026#39;, \u0026#39;pop\u0026#39;, \u0026#39;remove\u0026#39;, \u0026#39;reverse\u0026#39;, \u0026#39;sort\u0026#39;] __dict__ method is used to return a dictionary containing the attributes of an object. It returns a dictionary containing the attributes of the object.\nSyntax:\nobject.__dict__ Example:\nclass Person: name = \u0026#34;Alice\u0026#34; age = 30 person1 = Person() print(person1.__dict__) # Output: {\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 30} 9.super() method in Python When a parent class and a child class define a method with the same name, and we create an object of the child class, invoking the method on the child class object will execute the method defined in the child class, not the one in the parent class. To explicitly call the parent class\u0026rsquo;s method, we can use the super() function.\nTo explicitly invoke the parent class\u0026rsquo;s version of the method, the super() function is used. This is especially useful when the child class\u0026rsquo;s method needs to build upon or extend the functionality of the parent class\u0026rsquo;s method.\nSyntax:\nsuper().method_name() Example:\nclass Person: def display(self): print(\u0026#34;Person class\u0026#34;) class Student(Person): def display(self): super().display() print(\u0026#34;Student class\u0026#34;) student1 = Student() student1.display() # Output: # Person class # Student class Example:\nclass Person: def __init__(self,name,age): self.name=name self.age=age class Student(Person): def __init__(self,name,age,roll): super().__init__(name,age) self.roll=roll def display(self): print(f\u0026#34;Name: {self.name}\u0026#34;) print(f\u0026#34;Age: {self.age}\u0026#34;) print(f\u0026#34;Roll: {self.roll}\u0026#34;) student1 = Student(\u0026#34;Alice\u0026#34;, 30, 101) student1.display() # Output: # Name: Alice # Age: 30 # Roll: 101 Note: Use super for single inheritance only. For multiple inheritance, use the class name directly.\nMagic/dunder methods in Python Magic methods are special methods that have double underscores at the beginning and end of their names. They are also known as dunder methods (short for \u0026ldquo;double underscore\u0026rdquo;). Magic methods are used to define the behavior of objects. They are automatically called when certain operations are performed on objects. Some of the commonly used magic methods are:\n__init__: Constructor method, called when an object is created. __str__: Called by the str() built-in function to return a string representation of an object. __repr__: Called by the repr() built-in function to return an unambiguous string representation of an object. __add__: Called by the + operator to perform addition. __len__: Called by the len() built-in function to return the length of an object. __call__: Called when an object is called as a function. Note : All magic method can be seen using dir(objectname) method and we can override the magic method in our class.\nexample of all method:\nclass Person: def __init__(self, name, age): self.name = name self.age = age def __str__(self): return f\u0026#34;Name: {self.name}, Age: {self.age}\u0026#34; def __repr__(self): return f\u0026#34;Person(\u0026#39;{self.name}\u0026#39;, {self.age})\u0026#34; def __add__(self, other): return self.age + other.age def __len__(self): return len(self.name) def __call__(self): return f\u0026#34;Name: {self.name}, Age: {self.age}\u0026#34; person1 = Person(\u0026#34;Alice\u0026#34;, 30) person2 = Person(\u0026#34;Bob\u0026#34;, 25) print(person1) # Output: Name: Alice, Age: 30 print(repr(person1)) # Output: Person(\u0026#39;Alice\u0026#39;, 30) print(person1 + person2) # Output: 55 print(len(person1)) # Output: 5 print(person1()) # Output: Name: Alice, Age: 30 Method Overriding Method overriding is a feature of object-oriented programming that allows a subclass to provide a specific implementation of a method that is already provided by its parent class. When a method in a subclass has the same name, same parameters or signature, and same return type as a method in its parent class, then the method in the subclass is said to override the method in the parent class. Example:\nclass Person: def display(self): print(\u0026#34;Person class\u0026#34;) class Student(Person): def display(self): print(\u0026#34;Student class\u0026#34;) student1 = Student() student1.display() # Output: Student class We can also call the parent class\u0026rsquo;s method from the overridden method using the super() function.\nExample:\nclass Person: def display(self): print(\u0026#34;Person class\u0026#34;) class Student(Person): def display(self): super().display() #Or Person.display(self) print(\u0026#34;Student class\u0026#34;) student1 = Student() student1.display() # Output: # Person class # Student class Operator overloading in Python Operator overloading is a feature of object-oriented programming that allows us to define the behavior of operators for user-defined objects. It allows us to define the behavior of operators such as +, -, *, /, ==, !=, etc., for objects of a class. To overload an operator, we need to define a special method in the class that corresponds to the operator. These special methods are called magic methods or dunder methods.\nExample:\nclass Point: def __init__(self, x, y): self.x = x self.y = y def __add__(self, other): x = self.x + other.x y = self.y + other.y return Point(x, y) def __str__(self): return f\u0026#34;({self.x}, {self.y})\u0026#34; point1 = Point(1, 2) point2 = Point(3, 4) point3 = point1 + point2 print(point3) # Output: (4, 6) Types of Inheritance in Python Inheritance is a mechanism in which one class acquires the properties and behavior of another class. There are different types of inheritance in Python: Single Inheritance: In single inheritance, a class inherits from only one parent class. The pictorial representation of single inheritance is:\nA\r|\rB Syntax:\nclass ParentClass: #code block class ChildClass(ParentClass): #code block Example:\nclass Person: def __init__(self, name, age): self.name = name self.age = age def display(self): return f\u0026#34;Name: {self.name}, Age: {self.age}\u0026#34; def __str__(self): return f\u0026#34;Name: {self.name}, Age: {self.age}\u0026#34; def __repr__(self): return f\u0026#34;Person(\u0026#39;{self.name}\u0026#39;, {self.age})\u0026#34; def __call__(self): return f\u0026#34;Name: {self.name}, Age: {self.age}\u0026#34; class Student(Person): def __init__(self,naem,age,id): super().__init__(name,age) #or Person.__init__(self,name,age) self.id=id def display(self): print(f\u0026#34;ID: {self.id}\u0026#34;,super().display()) #or Person.display(self) student1 = Student(\u0026#34;Alice\u0026#34;, 30, 101) student1.display() # Output: # ID: 101 # Name: Alice, Age: 30 Multiple Inheritance: In multiple inheritance, a class inherits from more than one parent class. The pictorial representation of multiple inheritance is:\nA B\r\\ /\rC Syntax:\nclass ParentClass1: #code block class ParentClass2: #code block class ChildClass(ParentClass1, ParentClass2): #code block Example:\nclass Person: def __init__(self, name, age): self.name = name self.age = age def display(self): return f\u0026#34;Name: {self.name}, Age: {self.age}\u0026#34; class Address: def __init__(self,city,state): self.city=city self.state=state def display(self): return f\u0026#34;City: {self.city}, State: {self.state}\u0026#34; class Student(Person,Address): def __init__(self,name,age,id,city,state): Person.__init__(self,name,age) Address.__init__(self,city,state) self.id=id def display(self): print(f\u0026#34;ID: {self.id}\u0026#34;,Person.display(self),Address.display(self)) student1 = Student(\u0026#34;Alice\u0026#34;, 30, 101,\u0026#34;New York\u0026#34;,\u0026#34;New York\u0026#34;) student1.display() # Output: # ID: 101 # Name: Alice, Age: 30 # City: New York, State: New York Multilevel Inheritance: In multilevel inheritance, a class inherits from a parent class, and another class inherits from the child class. The pictorial representation of multilevel inheritance is:\nA\r|\rB\r|\rC Syntax:\nclass ParentClass: #code block class ChildClass(ParentClass): #code block class GrandChildClass(ChildClass): #code block Example:\nclass Person: def __init__(self, name, age): self.name = name self.age = age def display(self): return f\u0026#34;Name: {self.name}, Age: {self.age}\u0026#34; class Student(Person): def __init__(self,name,age,id): super().__init__(name,age) # or Person.__init__(self,name,age) self.id=id def display(self): print(f\u0026#34;ID: {self.id}\u0026#34;,super().display()) # print(f\u0026#34;ID: {self.id}\u0026#34;,Person.display(self)) class CollegeStudent(Student): def __init__(self,name,age,id,classes): super().__init__(name,age,id) #or Student.__init__(self,name,age,id) self.classes=classes def display(self): print(f\u0026#34;Class: {self.classes}\u0026#34;,super().display()) #or print(f\u0026#34;Class: {self.classes}\u0026#34;,Student.display(self)) student1 = CollegeStudent(\u0026#34;Alice\u0026#34;, 30, 101,\u0026#34;Bachelor\u0026#34;) student1.display() # Output: # Class: Bachelor # ID: 101 # Name: Alice, Age: 30 Hierarchical Inheritance: In hierarchical inheritance, more than one class inherits from a single parent class. The pictorial representation of hierarchical inheritance is:\nA\r/ \\\rB C Syntax:\nclass ParentClass: #code block class ChildClass1(ParentClass): #code block class ChildClass2(ParentClass): #code block Example:\nclass Person: def __init__(self, name, age): self.name = name self.age = age def display(self): return f\u0026#34;Name: {self.name}, Age: {self.age}\u0026#34; class Student(Person): def __init__(self,name,age,id): super().__init__(name,age) #or Person.__init__(self,name,age) self.id=id def display(self): print(f\u0026#34;ID: {self.id}\u0026#34;,super().display()) #or print(f\u0026#34;ID: {self.id}\u0026#34;,Person.display(self)) class Employee(Person): def __init__(self,name,age,emp_id): super().__init__(name,age) #or Person.__init__(self,name,age) self.emp_id=emp_id def display(self): print(f\u0026#34;Emp ID: {self.emp_id}\u0026#34;,super().display()) #or print(f\u0026#34;Emp ID: {self.emp_id}\u0026#34;,Person.display(self)) student1 = Student(\u0026#34;Alice\u0026#34;, 30, 101) student1.display() employee1 = Employee(\u0026#34;Bob\u0026#34;, 25, 201) employee1.display() # Output: # ID: 101 # Name: Alice, Age: 30 # Emp ID: 201 # Name: Bob, Age: 25 Note: Hybrid inheritance is a combination of two or more types of inheritance.\n14. MRO (Method Resolution Order) in Python Method Resolution Order (MRO) is the order in which methods are resolved in the inheritance hierarchy. It defines the order in which the base classes are searched when executing a method.\nfor example:\nclass C: f=\u0026#34;dirajan\u0026#34; class A(C): f=\u0026#34;nirajan\u0026#34; class B(C): f=\u0026#34;kirajan\u0026#34; class D(A,B): pass def display(self): print(self.f) d=D() print(D.__mro__) d.display() Output:\n(\u0026lt;class \u0026#39;__main__.D\u0026#39;\u0026gt;, \u0026lt;class \u0026#39;__main__.A\u0026#39;\u0026gt;, \u0026lt;class \u0026#39;__main__.B\u0026#39;\u0026gt;, \u0026lt;class \u0026#39;__main__.C\u0026#39;\u0026gt;, \u0026lt;class \u0026#39;object\u0026#39;\u0026gt;)\rnirajan It means it will search for the method in the order of D-\u0026gt;A-\u0026gt;B-\u0026gt;C-\u0026gt;object if the method is not found in the D it will search in A and so on. but if the method is found in the D it will not search in the A,B,C and object.\n15.Class Inside a Class in Python A class can be defined inside another class. The class inside the class is known as nested class. The nested class can access the attributes and methods of the outer class.\nSyntax:\nclass OuterClass: class InnerClass: #code block Example:\nclass OuterClass: def __init__(self): self.name = \u0026#34;Alice\u0026#34; self.age = 30 class InnerClass: def display(self, outer): print(f\u0026#34;Name: {outer.name}\u0026#34;) print(f\u0026#34;Age: {outer.age}\u0026#34;) outer1 = OuterClass() inner1 = outer1.InnerClass() inner1.display(outer1) # Output: # Name: Alice # Age: 30 16. Nested class in Python A class can be defined inside another class. The class inside the class is known as nested class. The nested class can access the attributes and methods of the outer class.\nSyntax:\nclass OuterClass: class InnerClass: #code block Creating an object of the nested class: Syntax:\nouter_object = OuterClass() inner_object = outer_object.InnerClass() Example:\nclass OuterClass: def __init__(self): self.name = \u0026#34;Alice\u0026#34; self.age = 30 class InnerClass: def display(self, outer): print(f\u0026#34;Name: {outer.name}\u0026#34;) print(f\u0026#34;Age: {outer.age}\u0026#34;) outer1 = OuterClass() inner1 = outer1.InnerClass() inner1.display(outer1) # Output: # Name: Alice # Age: 30 creating an object of the nested class inside the outer class:\nclass OuterClass: def __init__(self): self.name = \u0026#34;Alice\u0026#34; self.age = 30 self.inner = self.InnerClass() class InnerClass: def display(self, outer): print(f\u0026#34;Name: {outer.name}\u0026#34;) print(f\u0026#34;Age: {outer.age}\u0026#34;) outer1 = OuterClass() outer1.inner.display(outer1) # Output: # Name: Alice # Age: 30 ","permalink":"http://localhost:1313/posts/pages/python/python_object_oriented1/","summary":"This is the first part of series of Object Oriented Programming in Python","title":"Python Fundamentals: Exploring OOP (Part 12)"},{"content":"DOM (Document Object Model) Theory The DOM is a programming interface for HTML and XML documents. It represents the document as a tree structure where each node is an object representing a part of the document. This allows programming languages to interact with the document structure, style, and content.\n1. DOM Selection Methods a) document.getElementById() Selects an element by its ID attribute.\n\u0026lt;!-- HTML --\u0026gt; \u0026lt;div id=\u0026#34;myDiv\u0026#34;\u0026gt;Hello\u0026lt;/div\u0026gt; // JavaScript const element = document.getElementById(\u0026#39;myDiv\u0026#39;); console.log(element.innerText); // Output: // \u0026#34;Hello\u0026#34; b) document.getElementsByClassName() Returns a collection of elements with the specified class name.\n\u0026lt;!-- HTML --\u0026gt; \u0026lt;div class=\u0026#34;myClass\u0026#34;\u0026gt;Item 1\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;myClass\u0026#34;\u0026gt;Item 2\u0026lt;/div\u0026gt; // JavaScript const elements = document.getElementsByClassName(\u0026#39;myClass\u0026#39;); for (let i = 0; i \u0026lt; elements.length; i++) { console.log(elements[i].innerText); } // Output: // \u0026#34;Item 1\u0026#34; // \u0026#34;Item 2\u0026#34; c) document.getElementsByTagName() Returns a collection of elements with the specified tag name.\n\u0026lt;!-- HTML --\u0026gt; \u0026lt;p\u0026gt;Paragraph 1\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Paragraph 2\u0026lt;/p\u0026gt; // JavaScript const paragraphs = document.getElementsByTagName(\u0026#39;p\u0026#39;); for (let i = 0; i \u0026lt; paragraphs.length; i++) { console.log(paragraphs[i].innerText); // Output: // \u0026#34;Paragraph 1\u0026#34; // \u0026#34;Paragraph 2\u0026#34; d) document.querySelector() Returns the first element that matches the CSS selector.\n\u0026lt;!-- HTML --\u0026gt; \u0026lt;div class=\u0026#34;myClass\u0026#34;\u0026gt;First Element\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;myClass\u0026#34;\u0026gt;Second Element\u0026lt;/div\u0026gt; // JavaScript const firstElement = document.querySelector(\u0026#39;.myClass\u0026#39;); console.log(firstElement.innerText); // Output: // \u0026#34;First Element\u0026#34; e) document.querySelectorAll() Returns all elements that match the CSS selector.\n\u0026lt;!-- HTML --\u0026gt; \u0026lt;div class=\u0026#34;myClass\u0026#34;\u0026gt;First Element\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;myClass\u0026#34;\u0026gt;Second Element\u0026lt;/div\u0026gt; // JavaScript const allElements = document.querySelectorAll(\u0026#39;.myClass\u0026#39;); allElements.forEach(el =\u0026gt; console.log(el.innerText)); // Output: // \u0026#34;First Element\u0026#34; // \u0026#34;Second Element\u0026#34; 2. DOM Properties a) innerText Gets or sets the text content of an element.\n\u0026lt;!-- HTML --\u0026gt; \u0026lt;div id=\u0026#34;textElement\u0026#34;\u0026gt;Original Text\u0026lt;/div\u0026gt; // JavaScript const element = document.getElementById(\u0026#39;textElement\u0026#39;); element.innerText = \u0026#39;Hello World\u0026#39;; console.log(element.innerText); // Output: // \u0026#34;Hello World\u0026#34; b) innerHTML Gets or sets the HTML content of an element.\n\u0026lt;!-- HTML --\u0026gt; \u0026lt;div id=\u0026#34;htmlElement\u0026#34;\u0026gt;Original Content\u0026lt;/div\u0026gt; // JavaScript const element = document.getElementById(\u0026#39;htmlElement\u0026#39;); element.innerHTML = \u0026#39;\u0026lt;span\u0026gt;Hello World\u0026lt;/span\u0026gt;\u0026#39;; console.log(element.innerHTML); // Output: // \u0026#34;\u0026lt;span\u0026gt;Hello World\u0026lt;/span\u0026gt;\u0026#34; c) textContent Gets or sets the text content of a node and its descendants.\n\u0026lt;!-- HTML --\u0026gt; \u0026lt;div id=\u0026#34;contentElement\u0026#34;\u0026gt;Original Content\u0026lt;/div\u0026gt; // JavaScript const element = document.getElementById(\u0026#39;contentElement\u0026#39;); element.textContent = \u0026#39;Hello World\u0026#39;; console.log(element.textContent); // Output: // \u0026#34;Hello World\u0026#34; d) style Gets or sets inline styles of an element.\n\u0026lt;!-- HTML --\u0026gt; \u0026lt;div id=\u0026#34;styledElement\u0026#34;\u0026gt;Style Me\u0026lt;/div\u0026gt; // JavaScript const element = document.getElementById(\u0026#39;styledElement\u0026#39;); element.style.backgroundColor = \u0026#39;red\u0026#39;; element.style.fontSize = \u0026#39;16px\u0026#39;; // Result: Element with red background and font size of 16px 3. Events in JavaScript Events are actions that occur in a web page that can be detected by JavaScript.\nClick Event Example \u0026lt;!-- HTML --\u0026gt; \u0026lt;button id=\u0026#34;clickButton\u0026#34;\u0026gt;Click Me\u0026lt;/button\u0026gt; // JavaScript const button = document.getElementById(\u0026#39;clickButton\u0026#39;); button.addEventListener(\u0026#39;click\u0026#39;, function(e) { console.log(\u0026#39;Clicked!\u0026#39;); }); // Output when clicked: // \u0026#34;Clicked!\u0026#34; Mouse Over Event Example \u0026lt;!-- HTML --\u0026gt; \u0026lt;div id=\u0026#34;hoverElement\u0026#34;\u0026gt;Hover Over Me\u0026lt;/div\u0026gt; // JavaScript const element = document.getElementById(\u0026#39;hoverElement\u0026#39;); element.addEventListener(\u0026#39;mouseover\u0026#39;, function(e) { console.log(\u0026#39;Mouse over!\u0026#39;); }); // Output when hovered: // \u0026#34;Mouse over!\u0026#34; ","permalink":"http://localhost:1313/posts/pages/js/domevents/","summary":"A complete reference guide for DOM manipulation and Events","title":"Javascript : Dom and Events"},{"content":"Asynchronous Programming in JavaScript Asynchronous programming allows a program to perform multiple tasks simultaneously. It enables non-blocking operations, making it possible to execute long-running tasks without freezing the main program.\nFor example:\nconsole.log(\u0026#39;Start\u0026#39;); setTimeout(() =\u0026gt; { console.log(\u0026#39;This message is delayed by 2 seconds\u0026#39;); }, 2000); console.log(\u0026#39;End\u0026#39;); When you run this code, the output will be:\nStart\rEnd\rThis message is delayed by 2 seconds Explanation:\nconsole.log('Start'); is executed, and \u0026ldquo;Start\u0026rdquo; is printed. setTimeout() sets up a callback function to run after 2000 milliseconds (2 seconds) but does not block the next line. console.log('End'); is executed immediately after, and \u0026ldquo;End\u0026rdquo; is printed. After 2 seconds, the callback function in setTimeout() is executed, and \u0026ldquo;This message is delayed by 2 seconds\u0026rdquo; is printed. This demonstrates how asynchronous functions like setTimeout() work without blocking the execution of subsequent code.\nPromises Promises are a way to handle asynchronous operations in JavaScript. They represent a value that may be available now, in the future, or never. Promises can be in one of three states: pending, fulfilled, or rejected. They allow us to run code when the promise is fulfilled or rejected using the .then() and .catch() methods.\nSyntax to create a new Promise:\nconst promise = new Promise((resolve, reject) =\u0026gt; { // Perform an asynchronous operation // If successful, call resolve(value) // If an error occurs, call reject(error) }); Why We Use Promises Consider the following code:\nfunction main() { setTimeout(() =\u0026gt; { console.log(\u0026#34;Hello\u0026#34;); }, 1000); } main(); main(); main(); This code waits for 1 second and then logs \u0026ldquo;Hello\u0026rdquo; three times instantly. But what if we want to wait for the first to be completed before the second?\nThis can be solved using promises:\nfunction promise() { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { console.log(\u0026#34;Hello\u0026#34;); resolve(\u0026#34;Done\u0026#34;); }, 2000); }); } let data = promise(); When a promise is called, it returns a promise object instantly in a pending state. When the asynchronous operation completes, the promise is either fulfilled or rejected.\nHandling Promises To do a task when the promise is fulfilled (resolved):\ndata.then((data) =\u0026gt; { console.log(data); }); To do a task when the promise is rejected:\ndata.catch((err) =\u0026gt; { console.log(\u0026#34;Promise rejected\u0026#34;, err); }); Handling Multiple Promises function promise1() { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { console.log(\u0026#34;Promise 1 resolved\u0026#34;); resolve(\u0026#34;Done 1\u0026#34;); }, 2000); }); } function promise2() { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { console.log(\u0026#34;Promise 2 resolved\u0026#34;); resolve(\u0026#34;Done 2\u0026#34;); }, 2000); }); } function promise3() { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { console.log(\u0026#34;Promise 3 resolved\u0026#34;); resolve(\u0026#34;Done 3\u0026#34;); }, 2000); }); } let data1 = promise1(); let data2 = promise2(); let data3 = promise3(); How Promises Work:\npromise1 is called. promise2 is called immediately. promise3 is called immediately, regardless of whether the previous promises are resolved. To execute promises one by one:\nlet data1 = promise1(); data1.then((data) =\u0026gt; { console.log(data); return promise2(); }).then((data) =\u0026gt; { console.log(data); return promise3(); }).then((data) =\u0026gt; { console.log(data); }).catch((err) =\u0026gt; { console.log(\u0026#34;Error\u0026#34;, err); }); Here, the first promise will run, then the second, then the third, and so on, one by one.\nAsync and Await Async functions always return a promise. await is used to wait for a promise to be resolved, such that the code below it will not run until the promise is resolved.\nTo use await, we need to use an async function:\nasync function main() { console.log(\u0026#34;Hello\u0026#34;); } main(); Example with await:\nlet promise = new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { resolve(\u0026#34;Done\u0026#34;); }, 2000); }); async function main() { console.log(\u0026#34;Hello\u0026#34;); await promise; console.log(\u0026#34;Hello again\u0026#34;); } main(); console.log(\u0026#34;Hi\u0026#34;); What happens here is the main function is called, it prints \u0026ldquo;Hello\u0026rdquo;, then waits for 2 seconds to resolve. During that time, it prints \u0026ldquo;Hi\u0026rdquo;. When the promise is resolved, it prints \u0026ldquo;Hello again\u0026rdquo;.\nWhen await is called, the function pauses its execution until the promise is resolved. Then it continues the execution of the function, such that code below await will not run until the promise is resolved, but the code outside the function will run.\nasync function main() { console.log(\u0026#34;Hello\u0026#34;); await promise; await promise; await promise; console.log(\u0026#34;Hello again\u0026#34;); } Here, the first promise is resolved, then the second is resolved, and so on.\n","permalink":"http://localhost:1313/posts/pages/js/asyncronous/","summary":"A complete guide to asynchronous programming in JavaScript, covering promises and async/await.","title":"Asynchronous Programming in JavaScript"},{"content":"Basics of Vim Vim is a powerful text editor, often used in the command line, that is known for its efficiency and speed once mastered. Here are the basic commands and modes that you need to get started.\nOpening a File To open a file in Vim, use the following command:\nvim filename Replace filename with the name of the file you wish to open.\nBasic Modes in Vim Vim operates in different modes, and understanding these modes is crucial for using Vim effectively:\nNormal Mode: This is the default mode when you open a file. In this mode, you can navigate, delete, copy, and paste text. To return to Normal Mode from other modes, press Esc.\nInsert Mode: This mode allows you to insert text into the file. To enter Insert Mode, press i. After you\u0026rsquo;re done typing, press Esc to go back to Normal Mode.\nCommon Commands Here are some essential commands for working with files in Vim:\nSave the current file:\n:w This writes (saves) changes to the file.\nQuit Vim:\n:q To quit Vim. If there are unsaved changes, Vim will warn you. You can force quit without saving using:\n:q! Save changes and quit:\n:wq or\n:x These commands save changes and then exit Vim.\nTips for Beginners Press Esc frequently to return to Normal Mode, as it helps you avoid unintended actions while in other modes. Practice using both Normal and Insert modes to become comfortable with the flow of editing and saving files in Vim. Vim can be intimidating at first, but with practice, it becomes an extremely efficient tool for editing text files, especially in programming and development environments. ","permalink":"http://localhost:1313/posts/pages/linux/vim_basics_guide/","summary":"Learn the basics of using Vim, including navigation, saving, and quitting.","title":"Basics of Vim"},{"content":"Docker Cheat Sheet: Commands and Concepts This guide covers essential Docker commands, from creating containers, managing images, building Dockerfiles, to working with volumes.\n🚀 Creating and Running Containers 1. Run a Container from an Image To create and run a container from an image:\ndocker run image 2. Run a Container in Interactive Mode To run a container and open its terminal:\ndocker run -it image After the container starts, you can interact with it directly in the terminal. 3. Name a Container To give a container a specific name:\ndocker run --name container_name image 4. Port Mapping To map a port from your computer to the container:\ndocker run -p computer_port:container_port image Incoming traffic to computer_port will be forwarded to container_port in the container. 5. Run a Container in the Background (Detached Mode) To run the container in the background:\ndocker run -d image 6. Passing Environment Variables to a Container To pass environment variables to a container:\ndocker run -e key=value image 🛠️ Managing Containers 7. Start a Container To start an existing container:\ndocker start container_id 8. Stop a Container To stop a running container:\ndocker stop container_id 9. Remove a Container To remove a container:\ndocker rm container_id Note: The container must be stopped before removal. 10. Execute a Command in a Running Container To start a terminal session inside a running container:\ndocker exec -it container_id bash 11. View Running Containers To list all currently running containers:\ndocker ps 12. View All Containers (Running and Stopped) To see all containers, including those that are stopped:\ndocker ps -a 🧱 Building Docker Images 13. Creating a Dockerfile A Dockerfile is a script used to build Docker images. Here’s an example of common Dockerfile commands:\n# Set the base image for your container FROM base_image # Run commands during the image build process RUN command # Copy files from your local machine to the container COPY source /path/in/container # Set environment variables ENV key=value # Expose a port for the container EXPOSE 8080 # Define the command to run when the container starts CMD [\u0026#34;executable\u0026#34;] # Optionally, run commands automatically when the container starts ENTRYPOINT [\u0026#34;/path/to/script\u0026#34;] # Set the working directory in the container WORKDIR /app # Copy all files from the local directory to the container, excluding files listed in .dockerignore COPY . . 14. Building a Docker Image To build a Docker image from a Dockerfile:\ndocker build -t image_name /path/to/Dockerfile 📂 Managing Docker Files 15. Using the .dockerignore File The .dockerignore file helps exclude unnecessary files from being copied into the Docker image, improving build speed and reducing image size:\nnode_modules/ .git/ 16. COPY Command in Dockerfile The COPY command copies files from your local system to the container:\nCopy all files from the current directory to the container: COPY . /path/in/container Copy a specific file: COPY ./filename.extension /path/in/container Copy an entire folder: COPY ./foldername /path/in/container Copy contents of a folder (not the folder itself): COPY ./foldername/ /path/in/container 📦 Working with Volumes 17. Mounting Volumes Volumes allow data to persist even if the container is deleted. To mount a folder from your host to the container:\ndocker run -it -v /path/on/host:/path/in/container image Example: docker run -it -v /home/user/backup:/app/data ubuntu This will map /home/user/backup on your host to /app/data inside the container. Use Cases for Volumes: Data Persistence: Preserve data even after the container is removed. Backups: Easily back up container data to the host. Shared Data: Share data between multiple containers or between host and container. 💾 Publishing Docker Images 18. Pushing an Image to Docker Hub To publish an image to Docker Hub:\nTag the image with your Docker Hub username: docker tag image_name username/image_name Log in to Docker Hub: docker login Push the image to your repository: docker push username/image_name This guide gives you the essentials for working with Docker. With these commands, you\u0026rsquo;ll be able to manage containers, build images, use volumes, and more effectively.\n","permalink":"http://localhost:1313/posts/pages/docker/docker_basics/","summary":"A guide to understanding Docker commands and concepts.","title":"Docker Basic: Commands and Concepts"},{"content":"Docker Compose Documentation Introduction Docker Compose is a tool for defining and running multi-container Docker applications. With Docker Compose, you can use a YAML file to configure your application\u0026rsquo;s services and create and start all the services from your configuration with a single command.\nBasic docker-compose.yml Structure The docker-compose.yml file is where you define the services that make up your app. A typical file might look like this:\nversion: \u0026#39;3.8\u0026#39; services: service_name: image: image_name:tag ports: - \u0026#34;host_port:container_port\u0026#34; environment: - ENV_VAR=value volumes: - \u0026#34;host_path:container_path\u0026#34; depends_on: - dependency_service Example Configurations Example 1: Basic Setup with PostgreSQL and Redis version: \u0026#39;3.8\u0026#39; services: postgres: image: postgres ports: - \u0026#34;5432:5432\u0026#34; environment: POSTGRES_USER: postgres POSTGRES_DB: review POSTGRES_PASSWORD: password redis: image: redis ports: - \u0026#34;80:80\u0026#34; Example 2: Real-World Application version: \u0026#39;3\u0026#39; services: pythonapp: image: your-python-image:tag ports: - \u0026#34;8000:8000\u0026#34; volumes: - /Users/data:/src/bin/data depends_on: - db - redis db: image: postgres environment: POSTGRES_DB: mydatabase POSTGRES_USER: myuser POSTGRES_PASSWORD: mypassword redis: image: redis volumes: - /path/to/local/directory:/data Example 3: Building from Dockerfile version: \u0026#39;3\u0026#39; services: pythonapp: build: context: . dockerfile: Dockerfile ports: - \u0026#34;8000:8000\u0026#34; volumes: - /Users/desktop:/src/bin/desktop depends_on: - db - redis db: image: postgres environment: POSTGRES_DB: mydatabase POSTGRES_USER: myuser POSTGRES_PASSWORD: mypassword redis: image: redis volumes: - /path/to/local/directory:/data Example 4: Django Application with PostgreSQL and Redis version: \u0026#39;3.8\u0026#39; services: django-app: container_name: django-app image: django-app:latest # Replace with your actual Django image name/tag ports: - \u0026#34;8000:8000\u0026#34; # Expose Django app on port 8000 environment: - DEBUG=1 # Set Django debug mode to 1 for development - POSTGRES_HOST=postgres # PostgreSQL host - POSTGRES_DB_NAME=nirajan # PostgreSQL database name - POSTGRES_DB_PASSWORD=nirajan@9845 # PostgreSQL database password - REDIS_URL=redis://redis:6379/0 # Redis URL depends_on: - postgres - redis volumes: - static_volume:/code/static # Volume for Django static files - media_volume:/code/media # Volume for Django media files postgres: container_name: postgres image: postgres:latest environment: POSTGRES_DB: nirajan # Database name POSTGRES_USER: nirajan # Database username POSTGRES_PASSWORD: nirajan@9845 # Database password volumes: - postgres_data:/var/lib/postgresql/data redis: container_name: redis image: redis:latest ports: - \u0026#34;6379:6379\u0026#34; Service Names as Hostnames In Docker Compose, the names of the services defined in the docker-compose.yml file are used as hostnames for inter-service communication.\nService Names as Hostnames Each service name in the docker-compose.yml file acts as a hostname for that service. For example, in the configuration above:\nThe django-app service can connect to the postgres service using POSTGRES_HOST=postgres. The django-app service can connect to the redis service using REDIS_URL=redis://redis:6379/0. Example In the django-app service:\nPostgreSQL Host: POSTGRES_HOST=postgres — The Django app connects to the PostgreSQL service using the hostname postgres, which matches the name of the PostgreSQL service defined in Docker Compose. Redis Host: REDIS_URL=redis://redis:6379/0 — The Django app connects to the Redis service using the hostname redis, which matches the name of the Redis service defined in Docker Compose. Note: In Docker, services within a Docker Compose setup are typically connected to the same network by default. This allows containers to communicate with each other using service names as hostnames.\nDocker Compose Commands To start the containers defined in docker-compose.yml:\nsudo docker compose up To stop and remove all containers, networks, and volumes created by docker-compose up:\nsudo docker compose down To run the containers in the background (detached mode):\nsudo docker compose up -d Tips Use depends_on to specify dependencies between services. This ensures that the dependent services start in the correct order. Use volumes to persist data outside of your containers, which is especially useful for databases. Use environment variables to configure your services and avoid hardcoding sensitive information. Conclusion Docker Compose simplifies the process of managing multi-container Docker applications. By defining your services in a docker-compose.yml file, you can easily spin up your entire application stack with a single command. This guide provides a solid starting point for using Docker Compose to manage multi-container applications effectively.\n","permalink":"http://localhost:1313/posts/pages/docker/docker_compose/","summary":"Learn how to define and manage services in Docker Compose.","title":"Docker Compose Documentation"},{"content":"Docker CPU and Memory Limits When you want to control the CPU and memory usage of Docker containers, you can use specific options in both Docker CLI commands and Docker Compose files. Here\u0026rsquo;s a detailed guide on how to use these options:\nDocker CLI Commands Setting CPU Limits:\nOption: --cpus Usage: Specifies the number of CPUs that the container can use. Example: docker run --cpus=\u0026#34;1.5\u0026#34; my-image The --cpus option limits the container to 1.5 CPU cores. Setting Memory Limits:\nOption: --memory or -m\nUsage: Sets the maximum amount of memory the container can use.\nExample:\ndocker run --memory=\u0026#34;500m\u0026#34; my-image This command limits the container to 500MB of RAM. If the limit is exceeded, the container will be throttled or terminated.\nNote: The options take a positive integer followed by suffixes such as b, k, m, or g to indicate bytes, kilobytes, megabytes, or gigabytes.\nSoft Memory Limits:\nOption: --memory-reservation Example: docker run --memory=\u0026#34;1g\u0026#34; --memory-reservation=\u0026#34;512m\u0026#34; nginx This reserves 512MB of memory while setting a hard limit of 1GB. Docker Compose Configuration In Docker Compose, you can define resource limits under the deploy section for version 3.x or directly under the services section for version 2.x.\nSetting CPU and Memory Limits in Docker Compose (Version 2.x):\nversion: \u0026#39;2\u0026#39; services: my-service: image: my-image deploy: resources: limits: cpus: \u0026#39;1.5\u0026#39; memory: 500M This limits the service to 1.5 CPUs and 500MB of memory.\nSetting CPU and Memory Limits in Docker Compose (Version 3.x and above):\nversion: \u0026#39;3.8\u0026#39; services: my-service: image: my-image deploy: resources: limits: cpus: \u0026#39;1.5\u0026#39; memory: \u0026#39;500M\u0026#39; This limits the service to 1.5 CPUs and 500MB of memory.\nNotes: Swap Memory: You can enable swap memory using the --memory-swap option in CLI. For example:\ndocker run --memory=\u0026#34;512m\u0026#34; --memory-swap=\u0026#34;1g\u0026#34; nginx CPU Shares: Set CPU priorities between containers using --cpu-shares, with 1024 being the default.\nBy using these options, you can ensure that your Docker containers use resources efficiently, preventing them from overwhelming the host machine.\n","permalink":"http://localhost:1313/posts/pages/docker/docker_cpu_memory_limits_guide/","summary":"Control the CPU and memory usage of Docker containers with CLI and Docker Compose configurations.","title":"Docker CPU and Memory Limits"},{"content":"Docker Networking and Port Access In Docker, containers are isolated by default, meaning:\nContainers cannot access the host machine\u0026rsquo;s ports directly. Containers cannot access the ports of other containers directly. Container ports are not accessible from outside the host machine unless configured. 🛠️ Accessing Container Ports from Outside To access a container\u0026rsquo;s port from outside (e.g., from the host or another machine), you can use port mapping:\n1. Port Mapping docker run -p host_port:container_port imagename This command maps a container\u0026rsquo;s port to a port on the host machine. 2. Host Network To share the host\u0026rsquo;s network namespace with the container:\ndocker run --network host imagename 🌐 Accessing Container Ports from Another Container To allow inter-container communication, you need to create and use a custom Docker network.\nSteps: 1. Create a Docker Network docker network create my_network 2. Run Containers in the Same Network docker run --network my_network --name container1 imagename docker run --network my_network --name container2 imagename 3. Access One Container from Another Use the container name and port to access one container from another:\ncontainer1:port Example Scenario Create a Network docker network create my_network Run First Container docker run --network my_network --name webserver -d nginx Run Second Container docker run --network my_network --name client -it alpine /bin/sh Access Web Server from Client Inside the client container, use the following commands to access the web server: wget -qO- http://webserver or\ncurl http://webserver 📝 Important Notes Container-to-Container Access: Containers in the same custom network can communicate using their names as hostnames. Host Machine Access: Containers cannot directly access the host machine\u0026rsquo;s ports. External Access: Use port mapping or host networking to access container ports from outside the host machine. List Docker Networks To list all available Docker networks and verify the existence of custom networks:\ndocker network ls ","permalink":"http://localhost:1313/posts/pages/docker/docker_networking_guide/","summary":"Understanding Docker networking and inter-container communication.","title":"Docker Networking and Port Access"},{"content":" 1. Configure Git To set up your Git username and email globally on your machine:\ngit config --global user.name \u0026#34;username\u0026#34; # Set your Git username git config --global user.email \u0026#34;email\u0026#34; # Set your Git email git config --list # Display the current Git configuration (username and email) 2. Git Status and Git Clone Clone a remote repository to your local machine:\ngit clone \u0026lt;url\u0026gt; # Copy repository to the local machine Check the status of your local repository:\ngit status # Show the current status of the repository Git Status Breakdown: untracked: A new file that has not been added or committed. unstaged: A file that has been added but not committed. unchanged: No changes have been made. changed: Changes have been made but not yet added or committed. 3. Git Add and Commit Add specific files or all changes and commit them:\ngit add \u0026lt;filename\u0026gt; # Add a specific file to the staging area git add . # Add all changes (modified and untracked files) git commit -m \u0026#34;Your commit message\u0026#34; # Commit the changes with a message 4. Push Local Repo to Remote To upload your local repository changes to the remote repository:\ngit push [alias] [branch] # Push changes to a specific alias and branch git remote add \u0026lt;alias\u0026gt; \u0026lt;url\u0026gt; # Add a remote alias (e.g., \u0026#39;origin\u0026#39;) git push -u [alias] [branch] # Save the alias and branch for future pushes 5. Git Initialization Initialize a new Git repository:\ngit init # Initialize a new Git repository 6. Git Branches Manage Git branches with the following commands:\ngit branch # List all local branches git branch -m \u0026lt;oldbranch\u0026gt; \u0026lt;newbranch\u0026gt; # Rename a branch git checkout \u0026lt;branchname\u0026gt; # Switch to another branch git checkout -b \u0026lt;branchname\u0026gt; # Create and switch to a new branch git branch -d \u0026lt;branchname\u0026gt; # Delete a branch (ensure you\u0026#39;re not on it) git diff \u0026lt;branchname\u0026gt; # Compare the current branch with another 7. Git Merge Merge changes from one branch into another:\ngit merge \u0026lt;branchname\u0026gt; # Merge changes from \u0026lt;branchname\u0026gt; into the current branch 8. Pull Request and Syncing Changes To pull updates from the remote repository to your local one:\ngit pull # Pull the latest changes from the remote repository git pull [alias] [branch] # Pull changes from a specific alias and branch 9. Undoing Changes If You Have Only Added Changes: git reset \u0026lt;filename\u0026gt; # Unstage a file from the staging area git reset # Unstage all files that have been added If You Have Committed Changes: git reset HEAD~1 # Undo the last commit (one step back) git reset \u0026lt;commit_hash\u0026gt; # Reset to a specific commit hash git reset --hard \u0026lt;commit_hash\u0026gt; # Hard reset to a commit and reflect changes in your editor git log # View all commit hashes and logs 10. Forking Repositories When contributing to open-source projects, you can fork a repository, which creates a copy of the repo under your GitHub account. Afterward, you can make changes and submit a pull request:\n# Fork a repository on GitHub and clone it locally git clone \u0026lt;forked_repo_url\u0026gt; # Clone your forked repository Make changes, commit them, and push to your fork. Finally, create a pull request on GitHub to merge your changes into the original repository.\nIF ANY CONCEPT IS LAGGING THEN: Watch this helpful video\n","permalink":"http://localhost:1313/posts/pages/git/git-cheetsheet/","summary":"A brief tutorial on github recipe and git command","title":"Git Commands and Configuration Guide"},{"content":"How to Create Content for Hugo Using Markdown Hugo, a static site generator, uses Markdown (.md) files to generate content. In this guide, we will explain how you can create content for Hugo using Markdown.\n1. Front Matter Every Markdown file in Hugo requires front matter, which is metadata placed at the top of the file. It helps Hugo understand how to process the file.\nExample:\n--- title: \u0026#34;My First Hugo Post\u0026#34; date: 2024-10-18 tags: [\u0026#34;Hugo\u0026#34;, \u0026#34;Markdown\u0026#34;] summary: \u0026#34;A brief summary of the post.\u0026#34; --- 2. Headers Headers are used to organize content. Use one # for an H1 header, two ## for H2, and so on.\nExample:\n# H1 Header ## H2 Header ### H3 Header Output:\nH3 Header 3. Text Formatting Markdown supports several text formatting options:\nExample:\n**Bold Text** *Italic Text* ~~Strikethrough~~ Output: Bold Text\nItalic Text\nStrikethrough\n4. Spacing and Line Breaks In Markdown, you can create paragraphs by leaving a blank line between lines of text.\nExample:\nThis is the first paragraph. This is the second paragraph. Output: This is the first paragraph.\nThis is the second paragraph.\n5. Horizontal Rules You can create horizontal lines (dividers) using three or more dashes (---), asterisks (***), or underscores (___).\nExample:\n--- Output:\n6. Lists Create unordered lists with - or *, and ordered lists with numbers followed by periods.\nExample:\n- Item 1 - Item 2 1. First item 2. Second item Output:\nItem 1 Item 2 First item Second item 7. Links and Images Add links and images with square brackets [] and parentheses ().\nExample:\n[Hugo Documentation](https://gohugo.io) ![Hugo Logo](/images/hugo.webp) Output: Hugo Documentation\n8. Code Blocks For inline code, use backticks. For block code, use triple backticks.\nExample:\nInline code: `print(\u0026#34;Hello World\u0026#34;)` Output: Inline code: print(\u0026quot;Hello World\u0026quot;)\nExample:\nBlock Code: def hello(): print(\u0026#34;Hello, Hugo!\u0026#34;) def hello(): print(\u0026#34;Hello, Hugo!\u0026#34;) 9. Blockquotes Use the greater than symbol (\u0026gt;) to create blockquotes.\nExample:\n\u0026gt; This is a blockquote in Hugo. Output:\nThis is a blockquote in Hugo.\n10. Tables You can create tables using pipes | and dashes -.\nExample:\n| Column 1 | Column 2 | |----------|----------| | Row 1 | Data 1 | | Row 2 | Data 2 | Output:\nColumn 1 Column 2 Row 1 Data 1 Row 2 Data 2 11. Task Lists Create task lists by using square brackets []. An x in the brackets [x] marks a task as completed.\nExample:\n- [ ] Task 1 - [x] Task 2 (Completed) Output:\nTask 1 Task 2 (Completed) 12. Syntax Highlighting Hugo supports syntax highlighting for various programming languages. You can specify the language after the triple backticks(```).\nExample: Output:\ndef greet(): print(\u0026#34;Hello, Hugo!\u0026#34;) 12. Task Lists Create task lists by using square brackets []. An x in the brackets [x] marks a task as completed.\nExample:\n- [ ] Task 1 - [ ] Sub-task 1 - [x] Sub-task 2 (Completed) - [x] Task 2 (Completed) Output:\nTask 1 Sub-task 1 Sub-task 2 (Completed) Task 2 (Completed) 13. Escaping Special Characters To use special characters like #, escape them using a backslash \\.\nExample:\n\\# This is not a header Output: # This is not a header\n14. Backtick To display backtick use four space before it as\n``` 15. Consistency It\u0026rsquo;s important to maintain consistent formatting throughout your Markdown files to ensure a clean and readable structure.\nBy following these steps, you can effectively create well-formatted content for your Hugo site using Markdown.\n","permalink":"http://localhost:1313/posts/pages/hugo/markdown_hugo_content_guide/","summary":"A tutorial on creating content with Markdown in Hugo.","title":"How to Create Content for Hugo"},{"content":"JavaScript Reference Behavior: Objects and Arrays Introduction In JavaScript, both objects and arrays are considered reference types. This means that when you assign an object or an array to another variable, you’re not creating a new copy of that object or array. Instead, the new variable holds a reference to the original object or array in memory. Understanding this concept is crucial because it directly affects how data is manipulated and shared within your code.\nObject Reference Behavior 1. Overview When you work with objects in JavaScript, it\u0026rsquo;s essential to recognize that assigning an object to a new variable does not create a new object. Instead, it creates a reference to the original object. This means that any changes made through the new reference will affect the original object.\n2. Example const person = { name: \u0026#34;Alice\u0026#34;, address: { city: \u0026#34;Wonderland\u0026#34; } }; const newPerson = person.address; // newPerson now references the same object as person.address newPerson.city = \u0026#34;New Wonderland\u0026#34;; // modifying newPerson affects the original object console.log(person); // Output: { name: \u0026#39;Alice\u0026#39;, address: { city: \u0026#39;New Wonderland\u0026#39; } } ## JavaScript Reference Behavior: Objects and Arrays ### Introduction In JavaScript, both objects and arrays are considered reference types. This means that when you assign an object or an array to another variable, you’re not creating a new copy of that object or array. Instead, the new variable holds a reference to the original object or array in memory. Understanding this concept is crucial because it directly affects how data is manipulated and shared within your code. ### Object Reference Behavior #### 1. Overview When you work with objects in JavaScript, it\u0026#39;s essential to recognize that assigning an object to a new variable does not create a new object. Instead, it creates a reference to the original object. This means that any changes made through the new reference will affect the original object. #### 2. Example ```javascript const person = { name: \u0026#34;Alice\u0026#34;, address: { city: \u0026#34;Wonderland\u0026#34; } }; const newPerson = person.address; // newPerson now references the same object as person.address newPerson.city = \u0026#34;New Wonderland\u0026#34;; // modifying newPerson affects the original object console.log(person); // Output: { name: \u0026#39;Alice\u0026#39;, address: { city: \u0026#39;New Wonderland\u0026#39; } } 3. Explanation Object Reference: When you create const newPerson = person.address;, you\u0026rsquo;re not making a copy of the address object. Instead, newPerson references the same address object that person.address references. Thus, when you update newPerson.city = \u0026quot;New Wonderland\u0026quot;;, it directly modifies the person.address object because both newPerson and person.address are pointing to the same location in memory. Output: The console logs the person object, which now reflects the change: { name: 'Alice', address: { city: 'New Wonderland' } }. Array Reference Behavior 1. Overview Arrays in JavaScript behave similarly to objects in terms of reference handling. When you assign an array to another variable, you create a reference to the original array. As a result, any modifications through this reference will affect the original array.\n2. Example const numbers = [1, 2, 3]; const moreNumbers = numbers; // moreNumbers now references the same array as numbers moreNumbers[0] = 99; // modifying moreNumbers affects the original array console.log(numbers); // Output: [99, 2, 3] 3. Explanation Array Reference: When you create const moreNumbers = numbers;, you\u0026rsquo;re not creating a new array. Instead, moreNumbers becomes a reference to the same array that numbers references. Any changes to moreNumbers, such as moreNumbers[0] = 99, directly modify the numbers array because both variables point to the same array in memory. Output: The console logs the numbers array, which now reflects the change: [99, 2, 3]. Key Takeaways Reference Types: Both objects and arrays are reference types in JavaScript, meaning that variables assigned to them hold references to the same data in memory. Shared Modifications: Changes made to an object or array through one reference will affect all other references to that same object or array. Memory Efficiency: This reference behavior allows for memory-efficient data management but requires careful handling to avoid unintended side effects. JavaScript References with filter() and find() In JavaScript, the way references work with methods like filter() and find() is different, leading to distinct behaviors. Understanding these differences is crucial for working effectively with arrays and avoiding unintended side effects.\nfilter(): Creating a New Array 1. Overview The filter() method in JavaScript creates a new array that contains only the elements that satisfy the provided condition. This means that a new array is returned, and it does not affect the original array. However, if the elements in the array are objects, the references to these objects are retained, meaning any modifications to the objects in the new array will also affect the original array.\n2. Example const originalArray = [ { id: 1, name: \u0026#34;Alice\u0026#34; }, { id: 2, name: \u0026#34;Bob\u0026#34; }, { id: 3, name: \u0026#34;Charlie\u0026#34; } ]; const filteredArray = originalArray.filter(item =\u0026gt; item.id !== 2); // Modify an object in the filtered array filteredArray[0].name = \u0026#34;Alicia\u0026#34;; console.log(originalArray); // Output: [{ id: 1, name: \u0026#39;Alicia\u0026#39; }, { id: 2, name: \u0026#39;Bob\u0026#39; }, { id: 3, name: \u0026#39;Charlie\u0026#39; }] console.log(filteredArray); // Output: [{ id: 1, name: \u0026#39;Alicia\u0026#39; }, { id: 3, name: \u0026#39;Charlie\u0026#39; }] 3. Explanation New Array Creation: The filter() method creates a new array (filteredArray) that includes all elements from originalArray except the one with id 2. However, the objects within the new array are still references to the original objects in originalArray. Shared References: When you modify the name property of the first object in filteredArray (filteredArray[0].name = \u0026quot;Alicia\u0026quot;;), it also changes in originalArray because both arrays reference the same object in memory. Output: The original array shows that the name of the first object has been changed to \u0026ldquo;Alicia\u0026rdquo;, indicating that the object references are shared. find(): Returning a Single Element Reference 1. Overview The find() method returns the first element in the array that satisfies the provided condition. This element is not a copy but a reference to the original element in the array. As a result, any modification to this element directly affects the original array.\n2. Example const originalArray = [ { id: 1, name: \u0026#34;Alice\u0026#34; }, { id: 2, name: \u0026#34;Bob\u0026#34; }, { id: 3, name: \u0026#34;Charlie\u0026#34; } ]; const foundItem = originalArray.find(item =\u0026gt; item.id === 2); // Modify the found item foundItem.name = \u0026#34;Robert\u0026#34;; console.log(originalArray); // Output: [{ id: 1, name: \u0026#39;Alice\u0026#39; }, { id: 2, name: \u0026#39;Robert\u0026#39; }, { id: 3, name: \u0026#39;Charlie\u0026#39; }] console.log(foundItem); // Output: { id: 2, name: \u0026#39;Robert\u0026#39; } 3. Explanation Element Reference: The find() method returns a reference to the first element that meets the condition (item.id === 2). In this case, foundItem references the same object in memory as the element in originalArray with id: 2. Direct Modification: When you modify the name property of foundItem (foundItem.name = \u0026quot;Robert\u0026quot;;), it directly alters the corresponding object in originalArray because they are the same object in memory. Output: The original array now shows that the name of the object with id: 2 has been changed to \u0026ldquo;Robert\u0026rdquo;, demonstrating that the reference was modified. Key Differences Between filter() and find() New Array vs. Single Element: filter(): Returns a new array containing references to elements that meet the condition. find(): Returns a reference to the first element that meets the condition. Impact on Original Array: filter(): The original array remains unchanged, but the objects within the new array are still references to the original objects. find(): The original array can be directly modified through the returned element. Use Cases: Use filter() when you need a subset of the original array without altering it directly. Use find() when you need to retrieve and possibly modify a specific element from the array. Conclusion Understanding how references work with methods like filter() and find() is crucial in JavaScript. While filter() returns a new array that retains references to the original objects, find() returns a direct reference to a single element. Being aware of these behaviors helps prevent unintended modifications to your data.\n","permalink":"http://localhost:1313/posts/pages/js/referencebehavious/","summary":"Learn about reference types in JavaScript, including objects and arrays, and how methods like filter() and find() handle references.","title":"JavaScript Reference Behavior: Objects and Arrays"},{"content":"JavaScript Reference Guide 1. Console.log() Method Purpose: Prints output to the console, useful for debugging. Syntax: console.log(value); Example: const name = \u0026#39;John\u0026#39;; console.log(name); // Output: John 2. Variables: let, const let: Block-scoped variable that can be updated but not accessed before declaration.\nlet x = 10; if (true) { let x = 20; // Block-scoped console.log(x); // 20 } console.log(x); // 10 const: Block-scoped variable that cannot be reassigned and must be initialized when declared.\nconst pi = 3.14; // pi = 3.1415; // Error: Cannot reassign 3. JavaScript Data Types String\nExplanation: Represents a sequence of characters. Can be enclosed in single quotes, double quotes, or backticks (for template literals). Syntax: const str = 'Hello, World!'; Example: const greeting = \u0026#34;Hello, \u0026#34; + \u0026#34;World!\u0026#34;; // Output: Hello, World! Number\nExplanation: Represents both integer and floating-point numbers. JavaScript numbers range from -(2^53 - 1) to 2^53 - 1. Syntax: const num = 123; Example: const amount = 25; // Output: 25 BigInt\nExplanation: Represents integers with arbitrary precision. Denoted by appending an n to the end of the number. Syntax: const bigNum = 1234567890123456789012345678901234567890n; Example: const bigNumber = 1234567890123456789012345678901234567890n; Boolean\nExplanation: Represents a value that is either true or false. Syntax: const isTrue = true; Example: const isActive = Boolean(1); // Output: true Null\nExplanation: Represents the intentional absence of any value. Syntax: const emptyValue = null; Example: const noValue = null; Undefined\nExplanation: Represents a variable that has been declared but not assigned a value. Syntax: let uninitialized; Example: let value; console.log(value); // Output: undefined For Checking Data Type We Use: typeof variableName; 4. Explicit Type Conversion To String: String(value) or value.toString()\nlet str = String(123); // \u0026#39;123\u0026#39; To Number: Number(value), parseInt(value), or parseFloat(value)\nlet num = Number(\u0026#39;456\u0026#39;); // 456 To Boolean: Boolean(value)\nlet bool = Boolean(\u0026#39;hello\u0026#39;); // true 5. JavaScript Operators i) Comparison Operators Greater than: a \u0026gt; b Less than: a \u0026lt; b Greater than or equal to: a \u0026gt;= b Less than or equal to: a \u0026lt;= b Not equal to: a != b Equal to: a == b Strictly equal to: a === b Examples:\nconsole.log(\u0026#34;2\u0026#34; == 2); // true console.log(\u0026#34;2\u0026#34; === 2); // false ii) Logical Operators AND: operand1 \u0026amp;\u0026amp; operand2 OR: operand1 || operand2 NOT: !operand Examples:\nconsole.log(true \u0026amp;\u0026amp; false); // false console.log(true || false); // true console.log(!true); // false iii) Arithmetic Operators Addition: operand1 + operand2 Subtraction: operand1 - operand2 Multiplication: operand1 * operand2 Division: operand1 / operand2 Modulo: operand1 % operand2 Increment: operand++ Decrement: operand-- Examples:\nconsole.log(5 + 3); // 8 console.log(5 - 3); // 2 console.log(5 * 3); // 15 console.log(6 / 3); // 2 console.log(5 % 3); // 2 6. String Methods and Operations 1. Concatenation Explanation: Combines two or more strings into one. Syntax: string1 + string2 Returns: A new string combining the original strings. Example: let a = \u0026#39; My name is nirajan \u0026#39;; let b = \u0026#34;nirajan\u0026#34;; console.log(a + b + \u0026#34;Khatiwada\u0026#34;); // Output: \u0026#39; My name is nirajan nirajanKhatiwada\u0026#39; 2. Simple Form (String Boilerplate) Explanation: Uses template literals to embed expressions within a string. Syntax: ${expression} Returns: A new string with evaluated expressions. Example: let a = \u0026#39; My name is nirajan \u0026#39;; let b = \u0026#34;nirajan\u0026#34;; console.log(`${a}${b}khatiwada`); // Output: \u0026#39; My name is nirajan nirajankhatiwada\u0026#39; 3. Accessing Element of String Explanation: Retrieves the character at a specified index. Syntax: string[index] Returns: The character at the given index (or undefined if out of range). Example: let a = \u0026#39; My name is nirajan \u0026#39;; console.log(a[0]); // Output: \u0026#39; \u0026#39; 4. Finding Length of String Explanation: Gets the number of characters in the string. Syntax: string.length Returns: The length of the string as a number. Example: let a = \u0026#39; My name is nirajan \u0026#39;; console.log(a.length); // Output: 21 5. To Uppercase Explanation: Converts all characters in the string to uppercase. Syntax: string.toUpperCase() Returns: A new string with all characters in uppercase. Example: let a = \u0026#39; My name is nirajan \u0026#39;; console.log(a.toUpperCase()); // Output: \u0026#39; MY NAME IS NIRAJAN \u0026#39; 6. To Lowercase Explanation: Converts all characters in the string to lowercase. Syntax: string.toLowerCase() Returns: A new string with all characters in lowercase. Example: let a = \u0026#39; My name is nirajan \u0026#39;; console.log(a.toLowerCase()); // Output: \u0026#39; my name is nirajan \u0026#39; 8. String Slicing Explanation: Extracts a section of the string based on start and end indices. Syntax: string.slice(start, end) Returns: A new string containing the extracted section. Example: let a = \u0026#39; My name is nirajan \u0026#39;; console.log(a.slice(0, 4)); // Output: \u0026#39; My\u0026#39; 9. Trim Explanation: Removes whitespace from both ends of the string. Syntax: string.trim() Returns: A new string with whitespace removed from both ends. Example: let a = \u0026#39; My name is nirajan \u0026#39;; console.log(a.trim()); // Output: \u0026#39;My name is nirajan\u0026#39; 10. Replace Explanation: Replaces the first occurrence of a specified substring or pattern with a new substring. Syntax: string.replace(search, replacement) Returns: A new string with the specified substring replaced. Example: let a = \u0026#39; My name is nirajan \u0026#39;; console.log(a.replace(\u0026#34;nirajan\u0026#34;, \u0026#34;kirajan\u0026#34;)); // Output: \u0026#39; My name is kirajan \u0026#39; 11. Split Explanation: Splits the string into an array of substrings based on a separator. Syntax: string.split(separator, limit) Returns: An array of substrings. Example: let a = \u0026#39; My name is nirajan \u0026#39;; console.log(a.split(\u0026#34; \u0026#34;)); // Output: [\u0026#39; My\u0026#39;, \u0026#39;name\u0026#39;, \u0026#39;is\u0026#39;, \u0026#39;nirajan\u0026#39;] 7. Number Methods 1. toFixed() Explanation: Formats a number using fixed-point notation with a specified number of decimal places. Syntax: number.toFixed(digits); Returns: A string representing the number with the specified number of decimal places. Example: let c = 10.001; console.log(c.toFixed(10)); // Output: \u0026#39;10.0010000000\u0026#39; 2. Math.ceil() Explanation: Rounds a number up to the nearest integer. Syntax: Math.ceil(number); Returns: The smallest integer greater than or equal to the given number. Example: let a = 1.1000; console.log(Math.ceil(a)); // Output: 2 3. Math.floor() Explanation: Rounds a number down to the nearest integer. Syntax: Math.floor(number); Returns: The largest integer less than or equal to the given number. Example: console.log(Math.floor(a)); // Output: 1 4. Math.round() Explanation: Rounds a number to the nearest integer. Syntax: Math.round(number); Returns: The value of the number rounded to the nearest integer. Example: console.log(Math.round(a)); // Output: 1 5. Math.random() Explanation: Returns a pseudo-random floating-point number between 0 (inclusive) and 1 (exclusive). Syntax: Math.random(); Returns: A floating-point number between 0 (inclusive) and 1 (exclusive). Example: console.log(Math.random()); // Output: A random number between 0 and 1 8. Non-Primitive Data Types in JavaScript 1. Object Explanation: Objects are collections of key-value pairs. Keys are usually strings (or symbols) and values can be any data type. Syntax: let objectName = { key1: value1, key2: value2, // more key-value pairs }; Example: let data = { \u0026#34;name\u0026#34;: \u0026#34;nirajan\u0026#34;, \u0026#34;age\u0026#34;: 20 }; 2. Array Explanation: Arrays are ordered collections of values. Values can be of any data type and are accessed by their index. Syntax: let arrayName = [value1, value2, value3, ...]; Example: let a = [\u0026#34;nirajan\u0026#34;, \u0026#34;kirajan\u0026#34;, \u0026#34;birajan\u0026#34;]; 3. Function Explanation: Functions are blocks of code designed to perform a particular task. They can be invoked (called) to execute their code. Syntax: function functionName(parameters) { // code to be executed } Example: function outer() { console.log(\u0026#34;hi\u0026#34;); } outer(); // Output: hi 9. Array Methods 1. Indexing in Array Accessing Elements: Description: Arrays are zero-indexed, so the first element is at index 0. Returns: Value of the element at the specified index. Example: console.log(a[0]); // Output: 1 console.log(a[3]); // Output: 4 2. Slicing in Array Slicing: Description: Extracts a section of the array and returns it as a new array. Syntax: array.slice(startIndex, endIndex) Returns: A new array containing the elements from startIndex up to, but not including, endIndex. Example: console.log(a.slice(0, 2)); // Output: [1, 2] 3. Length of Array Description: Returns the number of elements in the array. Returns: Integer (length of the array). Example: console.log(a.length); // Output: 4 4. Push Description: Adds one or more elements to the end of the array. Returns: The new length of the array. Example: a.push(5); console.log(a); // Output: [1, 2, 3, 4, 5] 5. Pop Description: Removes the last element from the array. Returns: The removed element. Example: a.pop(); console.log(a); // Output: [1, 2, 3, 4] 6. Shift Description: Removes the first element from the array. Returns: The removed element. Example: a.shift(); console.log(a); // Output: [2, 3, 4] 7. Unshift Description: Adds one or more elements to the beginning of the array. Returns: The new length of the array. Example: a.unshift(0); console.log(a); // Output: [0, 1, 2, 3, 4] 8. Join Description: Joins all elements of an array into a string, separated by a specified separator. Returns: A string representing the array elements joined by the specified separator. Example: let data = a.join(\u0026#34; \u0026#34;); console.log(data); // Output: \u0026#34;1 2 3 4\u0026#34; 9. Concatenation of Two Arrays Description: Merges two or more arrays into one. Returns: A new array containing the elements of the original arrays. Example: let a2 = [5, 4, 1, 3, 4]; console.log(a.concat(a2)); // Output: [1, 2, 3, 4, 5, 4, 1, 3, 4] 10. Sort Description: Sorts the elements of an array in place. Returns: The sorted array. Example: a2.sort(); console.log(a2); // Output: [1, 3, 4, 4, 5] 11. Reverse Description: Reverses the order of the elements in the array. Returns: The reversed array. Example: a2.reverse(); console.log(a2); // Output: [5, 4, 4, 3, 1] 12. Removing Elements from a Specific Position Description: Changes the contents of an array by removing or replacing existing elements. Syntax: array.splice(index, numberOfElementsToRemove) Returns: An array containing the removed elements. Example: let newData = [1, 2, 3, 4]; newData.splice(1, 2); // Removes 2 elements starting at index 1 console.log(newData); // Output: [1, 4] 13. Inserting Elements at a Specific Position Description: Inserts elements into the array. Syntax: array.splice(index, 0, element1, element2, ...) Returns: An array containing the removed elements (empty if no elements were removed). Example: let lasrData = [1, 4]; lasrData.splice(1, 0, 2, 3); // Inserts elements 2 and 3 at index 1 console.log(lasrData); // Output: [1, 2, 3, 4] 14. Spread Operator (\u0026hellip;) Description: Spreads out elements of an array into another array or function arguments. Returns: A new array containing the elements spread from the original arrays. Example: let finalData = [...newData, ...lasrData]; console.log(finalData); // Output: [1, 4, 1, 2, 3, 4] 15. Array Destructuring Description: Allows unpacking values from arrays into distinct variables in a concise and readable way. Basic Syntax: const [var1, var2, var3] = array; Example: const numbers = [1, 2, 3]; const [first, second, third] = numbers; console.log(first); // Output: 1 console.log(second); // Output: 2 console.log(third); // Output: 3 10. Object in Js i. Defining an Object An object in JavaScript is a collection of key-value pairs. Each key (also known as a property) is a unique identifier, and the value can be anything: a string, number, array, function, or even another object. Example:\nconst myObject = { name: \u0026#34;Nirajan\u0026#34;, // String property class: \u0026#34;Bachelor\u0026#34;, // String property is_topper: \u0026#34;No\u0026#34;, // Boolean property (as a string) greet: function (from) { // Method (function inside an object) console.log(`Welcome ${this.name}. From ${from}`); } }; ii. Accessing There are two common ways to access properties in an object:\nDot Notation: console.log(myObject.name); // Output: nirajan This is the most common and preferred method when you know the property name in advance. Bracket Notation: console.log(myObject[\u0026#39;name\u0026#39;]); // Output: nirajan Bracket notation is useful when the property name is stored in a variable or when it contains special characters or spaces. iii. Modifying Object Properties You can modify an object\u0026rsquo;s properties using dot or bracket notation:\nDot Notation: Use when you know the property name.\nmyObject.name = \u0026#34;Kirajan\u0026#34;; // Modifies the \u0026#39;name\u0026#39; property Bracket Notation: Use when the property name is dynamic or contains special characters.\nmyObject[\u0026#39;class\u0026#39;] = \u0026#34;Master\u0026#39;s\u0026#34;; // Modifies the \u0026#39;class\u0026#39; property iv. Adding New Properties You can dynamically add new key-value pairs to an object.\nmyObject.lol = \u0026#34;lol\u0026#34;; console.log(myObject.lol); // Output: lol v. Using the this Keyword The this keyword inside an object’s method refers to the object itself, allowing you to access its properties. Example:\nconst person = { name: \u0026#34;Kirajan\u0026#34;, greet: function() { console.log(`Hello, my name is ${this.name}`); } }; person.greet(); // Output: Hello, my name is Kirajan vi. Objects Inside Objects Objects can contain other objects, allowing you to create complex data structures. Example:\nconst a = { details: { name: \u0026#34;Nirajan\u0026#34;, age: 20 } }; console.log(a.details.name); // Output: Nirajan vii. Spread Operator (\u0026hellip;) The spread operator lets you copy, merge, or combine objects efficiently.\nCopying Properties: const original = { name: \u0026#34;Kirajan\u0026#34;, class: \u0026#34;Bachelor\u0026#34; }; const copy = { ...original }; console.log(copy); // Output: { name: \u0026#34;Kirajan\u0026#34;, class: \u0026#34;Bachelor\u0026#34; } Merging Objects: const info1 = { name: \u0026#34;Kirajan\u0026#34;, class: \u0026#34;Bachelor\u0026#34; }; const info2 = { age: 21, is_topper: true }; const combined = { ...info1, ...info2 }; console.log(combined); // Output: { name: \u0026#34;Kirajan\u0026#34;, class: \u0026#34;Bachelor\u0026#34;, age: 21, is_topper: true } viii. Object Destructuring Destructuring allows you to extract properties from an object and assign them to variables. Example:\nconst lol = { name: \u0026#34;Nirajan\u0026#34;, class: 12, rollno: \u0026#34;11\u0026#34; }; const { name, rollno } = lol; console.log(name); // Output: Nirajan console.log(rollno); // Output: 11 Also, Renaming in Destructuring: const lol = { name: \u0026#34;Nirajan\u0026#34;, class: 12, rollno: \u0026#34;11\u0026#34; }; const { name: studentName, rollno: studentRollNo } = lol; console.log(studentName); // Output: Nirajan console.log(studentRollNo); // Output: 11 ix. Object Methods Objects can have methods—functions that are properties of the object. These methods can perform actions using the object’s data. Example:\nconst calculator = { add: function(a, b) { return a + b; }, subtract: function(a, b) { return a - b; } }; console.log(calculator.add(5, 3)); // Output: 8 console.log(calculator.subtract(5, 3)); // Output: 2 11. JavaScript Functions Function Definitions: Function Expression: const add1 = function(a, b) { return a + b; }; Creates a function and assigns it to a variable. You call the function using the variable name. Arrow Function: const add2 = (a, b) =\u0026gt; { return a + b; }; Provides a shorter syntax and does not have its own this context. Function Declaration: function add3(a, b) { return a + b; } Defines a function with a name. It is hoisted, so it can be called before its declaration. Comparison: add3 has its own this context, while add1 and add2 do not. Using the Spread Operator: function add(...data) { let sum = 0; for (let i = 0; i \u0026lt; data.length; i++) { sum += data[i]; } return sum; } console.log(add(1, 2, 3)); // Output: 6 The ...data syntax lets the function accept any number of arguments as an array.\nImmediately Invoked Function Expression (IIFE): ( function add(a, b) { console.log(a + b); } )(2, 3); // Output: 5 An IIFE is a function that runs immediately after its definition, creating a local scope to avoid affecting the global scope.\n12. Control Flow in JavaScript Conditional Statements: if-else Statement: Executes code blocks based on a condition. let a = 2; if (a === 1) { console.log(1); } else if (a === 2) { console.log(2); } else { console.log(\u0026#34;None\u0026#34;); } Truthy and Falsy Values: Falsy Values: Values that evaluate to false in a boolean context. console.log(Boolean(false)); // false console.log(Boolean(0)); // false console.log(Boolean(-0)); // false console.log(Boolean(0n)); // false console.log(Boolean(\u0026#34;\u0026#34;)); // false console.log(Boolean(null)); // false console.log(Boolean(undefined)); // false console.log(Boolean(NaN)); // false Truthy Values: Any value that is not falsy. console.log(Boolean(true)); // true console.log(Boolean(1)); // true console.log(Boolean(-1)); // true console.log(Boolean(\u0026#34;hello\u0026#34;)); // true console.log(Boolean(\u0026#34; \u0026#34;)); // true console.log(Boolean({})); // true console.log(Boolean([])); // true console.log(Boolean(function() {})); // true console.log(Boolean(Symbol())); // true console.log(Boolean(1n)); // true Nullish Coalescing Operator (??): Provides a default value when dealing with null or undefined. let val1 = null; let val2 = val1 ?? 10; console.log(val2); // Output: 10 Ternary Operator (?:): A shorthand for the if-else statement. let c = 10; let b = 10; let largest = (c \u0026gt; b) ? c : b; console.log(largest); // Output: 10 13. Loops in JavaScript For Loop // Syntax: for(initialization; condition; increment/decrement) { ... } for (let i = 0; i \u0026lt; 10; i++) { console.log(i); } While Loop // Syntax: while(condition) { ... } let i = 0; while (i \u0026lt; 10) { console.log(i); i++; } Do-While Loop // Syntax: do { ... } while(condition); let i = 0; do { console.log(i); i++; } while (i \u0026lt; 10); For-Of Loop Usage: Iterates over arrays and strings const array = [1, 2, 3]; for (const x of array) { console.log(x); } For-In Loop Usage: Iterates over the properties of an object, indices of an array, or characters of a string const obj = { \u0026#34;name\u0026#34;: \u0026#34;nirajan\u0026#34;, \u0026#34;lol\u0026#34;: \u0026#34;lol\u0026#34; }; const arr = [\u0026#34;nirajan\u0026#34;, \u0026#34;lol\u0026#34;]; const str = \u0026#34;mynameisnirajan\u0026#34;; for (const key in obj) { console.log(key); // Prints the keys of the object } for (const index in arr) { console.log(arr[index]); // Prints the values of the array } for (const index in str) { console.log(str[index]); // Prints the characters of the string } For-Each Loop Usage: Iterates over array elements const array = [1, 2, 3]; array.forEach((data) =\u0026gt; { console.log(data); }); Break and Continue Statements break: Exits the loop continue: Skips the current iteration and continues with the next iteration 14. Map, Filter, and Reduce in JavaScript i. filter() Purpose: Creates a new array with elements that pass a test. Example: To get all odd numbers from an array: const a = [1, 2, 3, 4, 5, 6]; const filtered = a.filter(num =\u0026gt; num % 2); // [1, 3, 5] ii. map() Method Purpose: map() creates a new array populated with the results of calling a provided function on every element in the calling array. It’s used to transform each element in the array. Example: Create an array of squares from an existing array. const a = [1, 2, 3, 4, 5, 6]; const squares = a.map((num) =\u0026gt; num * num); console.log(squares); // Output: [1, 4, 9, 16, 25, 36] Here, the function num * num is applied to each element, resulting in a new array of squared numbers. iii. reduce() Method Purpose: reduce() executes a reducer function on each element of the array, resulting in a single output value. It’s used to accumulate or combine values from the array into a single result. Example: Sum up all the numbers in the array. const a = [1, 2, 3, 4, 5, 6]; const sum = a.reduce((accumulator, currentValue) =\u0026gt; accumulator + currentValue, 0); console.log(sum); // Output: 21 Here, accumulator starts at 0 and currentValue iterates over each element, summing them up. iv. Method Chaining Purpose: You can chain filter(), map(), and other array methods together to perform multiple operations in a single, readable statement. Example: Filter out odd numbers and then square them. const a = [1, 2, 3, 4, 5, 6]; const result = a.filter((num) =\u0026gt; num % 2) .map((num) =\u0026gt; num * num); console.log(result); // Output: [1, 9, 25] Here, filter() first selects the odd numbers, and then map() squares those numbers, producing a new array with the squared values of the odd numbers. Summary filter(): Selects elements that meet a specific condition. map(): Transforms elements based on a function. reduce(): Reduces the array to a single value based on a function. Method Chaining: Combines multiple array operations in a concise and readable manner. These methods are powerful tools for processing and transforming arrays in JavaScript. 15. Importing and Exporting in JavaScript Default Export Only one default export is allowed per module. Use for the primary function, class, or object in a module. // utils.js export default function primaryFunction() { console.log(\u0026#34;This is the primary function\u0026#34;); } // main.js import primaryFunction from \u0026#39;./utils.js\u0026#39;; primaryFunction(); // Output: This is the primary function Named Export Allows multiple exports per module. Use to export multiple functions, variables, or objects. // utils.js function function1() { console.log(\u0026#34;This is function1\u0026#34;); } function function2() { console.log(\u0026#34;This is function2\u0026#34;); } export { function1, function2 }; // main.js import { function1, function2 } from \u0026#39;./utils.js\u0026#39;; function1(); // Output: This is function1 function2(); // Output: This is function2 Summary Default Export: One per module, no curly braces during import. Named Export: Multiple per module, use curly braces during import. 16. Error Handling Try-catch blocks are used to handle errors gracefully.\ntry { // Code that might throw an error let result = nonExistentFunction(); } catch (error) { // Code to handle the error console.log(\u0026#39;An error occurred:\u0026#39;, error.message); } finally { // Code that always executes console.log(\u0026#39;This always executes\u0026#39;); } // Output: // \u0026#34;An error occurred: nonExistentFunction is not defined\u0026#34; // \u0026#34;This always executes\u0026#34; 16.1. Custom Error Throwing You can throw custom errors using the throw statement.\nfunction divide(a, b) { if (b === 0) { throw new Error(\u0026#39;Division by zero is not allowed\u0026#39;); } return a / b; } try { console.log(divide(4, 2)); console.log(divide(4, 0)); } catch (error) { console.log(\u0026#39;Error:\u0026#39;, error.message); } // Output: // 2 // \u0026#34;Error: Division by zero is not allowed\u0026#34; 17. Timers setTimeout Schedules a function to be executed after a specified delay (in milliseconds).\nconst timeoutId = setTimeout(() =\u0026gt; { console.log(\u0026#39;Executed after 1 second\u0026#39;); }, 1000); setInterval Repeatedly executes a function at specified intervals (in milliseconds).\nconst intervalId = setInterval((a, b) =\u0026gt; { console.log(a); // Output: hi console.log(b); // Output: oi }, 20, \u0026#34;hi\u0026#34;, \u0026#34;oi\u0026#34;); clearInterval Stops a function from being executed repeatedly by clearing the interval.\nclearInterval(intervalId); clearTimeout Cancels a timeout previously established by setTimeout.\nclearTimeout(timeoutId); 18. Local Storage Local storage is a way to store data in the browser that persists even after the browser is closed.\nStoring Data localStorage.setItem(\u0026#39;name\u0026#39;, \u0026#39;Nirajan\u0026#39;); Retrieving Data const name = localStorage.getItem(\u0026#39;name\u0026#39;); console.log(name); // Output: Nirajan 19. JSON JSON (JavaScript Object Notation) is a lightweight data interchange format that is easy for humans to read and write and easy for machines to parse and generate.\nConverting Objects to JSON const person = { name: \u0026#39;Nirajan\u0026#39;, age: 20 }; const json = JSON.stringify(person); console.log(json); // Output: {\u0026#34;name\u0026#34;:\u0026#34;Nirajan\u0026#34;,\u0026#34;age\u0026#34;:20} Converting JSON to Objects const json = \u0026#39;{\u0026#34;name\u0026#34;:\u0026#34;Nirajan\u0026#34;,\u0026#34;age\u0026#34;:20}\u0026#39;; const person = JSON.parse(json); console.log(person.name); // Output: Nirajan 20. Fetch API Fetch is used to make HTTP requests and returns a promise that resolves to the response of the request.\nBasic Usage fetch(\u0026#39;https://api.example.com/data\u0026#39;) .then(response =\u0026gt; response.json()) .then(data =\u0026gt; console.log(data)) .catch(error =\u0026gt; console.error(\u0026#39;Error:\u0026#39;, error)); ","permalink":"http://localhost:1313/posts/pages/js/javascript/","summary":"A complete reference guide for JavaScript including data types, functions, DOM manipulation, and modern ES6+ features","title":"JavaScript Reference Guide"},{"content":" Linux Commands and Directories Guide Important Directories Default Web Server Root Directory\nLocation: /var/www/html\nThis is the standard location for serving web content on Apache.\nDownloads Folder\nLocation: /home/username/Downloads\nThis is where files downloaded from the internet are usually saved by default.\nDocuments Folder\nLocation: /home/username/Documents\nA common directory for storing personal documents and files.\nDesktop Folder\nLocation: /home/username/Desktop\nThis is the location for files and shortcuts displayed on your desktop screen.\nCommon Commands cd Change the current directory to another one.\nUsage: cd [directory]\nExample: cd /var/www/html changes to the web server root directory.\nls List files and directories in the current location or specified path.\nUsage: ls [options] [path]\nExample: ls -l lists files in a detailed format.\npwd Print the path of the current working directory.\nUsage: pwd\nThis command shows where you are in the filesystem.\nsudo su Switch to the superuser (root) account, allowing you to perform administrative tasks.\nUsage: sudo su\nAfter entering your password, you\u0026rsquo;ll have root access.\nsudo Execute a command with elevated privileges.\nUsage: sudo [command]\nExample: sudo apt update runs the update command as an administrator.\nmkdir Create a new directory.\nUsage: mkdir [directory name]\nExample: mkdir new_folder creates a directory named \u0026ldquo;new_folder\u0026rdquo;.\ndir List files and directories, similar to ls.\nUsage: dir [options] [path]\nThis command can be used interchangeably with ls.\nmv Move or rename files and directories.\nUsage: mv [source] [destination]\nExample: mv /home/username/Downloads/file.txt /home/username/Documents/ moves the file to a different directory.\ncp Copy files or directories.\nUsage: cp [source] [destination]\nExample: cp /home/username/Downloads/file.txt /home/username/Documents/ copies the file.\nrm Remove files or directories.\nUsage: rm [options] [file/directory]\nExample: To remove a directory and its contents, use rm -r [directory].\ntouch Create an empty file or update the timestamp of an existing file.\nUsage: touch [filename]\nExample: touch newfile.txt creates an empty file named \u0026ldquo;newfile.txt\u0026rdquo;.\ncat Display the contents of a file in the terminal.\nUsage: cat [filename]\nExample: cat file.txt shows the content of \u0026ldquo;file.txt\u0026rdquo;.\ngedit Open the Gedit text editor to edit files.\nUsage: gedit [filename]\nExample: gedit notes.txt opens \u0026ldquo;notes.txt\u0026rdquo; for editing.\nkill Terminate a process using its process ID (PID).\nUsage: kill [PID]\nExample: kill 1234 stops the process with the ID 1234.\ntop Display real-time information about system processes and resource usage.\nUsage: top\nThis command helps monitor system performance.\napt-get update Update the package lists for upgrades and new package installations.\nUsage: apt-get update\nThis command fetches the latest package information.\napt install path_of_.deb_file Install a .deb file package.\nUsage: apt install ./filename.deb\nExample: apt install ./main.deb installs the specified Debian package.\napt-get upgrade Upgrade all installed packages to their latest versions.\nUsage: apt-get upgrade\nThis command updates your installed software.\napt-get install package Install a specific software package.\nUsage: apt-get install [package]\nExample: apt-get install vim installs the Vim text editor.\nman Display the manual page for a command, providing detailed information.\nUsage: man [command]\nExample: man ls shows the manual for the ls command.\nwhoami Show the currently logged-in user\u0026rsquo;s username.\nUsage: whoami\nThis command is useful for confirming your user identity.\nzip Compress a directory and its contents into a zip file.\nUsage: zip -r [filename.zip] [foldername]\nExample: zip -r archive.zip myfolder creates a zip file of \u0026ldquo;myfolder\u0026rdquo;.\nunzip Extract files from a zip archive.\nUsage: unzip [filename]\nExample: unzip archive.zip extracts files from \u0026ldquo;archive.zip\u0026rdquo;.\napt install apache2 Install the Apache web server.\nUsage: apt install apache2\nThis command sets up Apache on your system.\nservice apache2 start Start the Apache web server.\nUsage: service apache2 start\nUse this to begin serving web content.\nservice apache2 restart Restart the Apache web server.\nUsage: service apache2 restart\nThis is useful for applying configuration changes.\nservice apache2 stop Stop the Apache web server.\nUsage: service apache2 stop\nUse this command to halt the server.\napt install redis Install the Redis database server.\nUsage: apt install redis\nThis sets up Redis for use.\nservice redis start Start the Redis server.\nUsage: service redis start\nThis command activates the Redis service.\nservice redis restart Restart the Redis server.\nUsage: service redis restart\nUse this to refresh the Redis service.\nservice redis stop Stop the Redis server.\nUsage: service redis stop\nThis halts the Redis service.\napt install mysql-server Install the MySQL server.\nUsage: apt install mysql-server\nThis command installs the MySQL database management system.\nchmod Change file or directory permissions.\nUsage: chmod [permissions] [file/folder]\nExample: chmod +rwx file.txt grants read, write, and execute permissions.\nTo remove permissions, use chmod -r file.txt.\nImportant Notes Folder Names with Spaces:\nIf a folder name contains spaces, enclose it in double quotes.\nmkdir \u0026quot;New Folder\u0026quot; creates a single folder named \u0026ldquo;New Folder\u0026rdquo;. mkdir New Folder creates two separate folders named \u0026ldquo;New\u0026rdquo; and \u0026ldquo;Folder\u0026rdquo;. Using Wildcards for Operations:\nTo perform operations on:\nAll files/folders: use *. Files with a specific extension (e.g., .exe): use *.exe. Files/folders starting with \u0026ldquo;hello\u0026rdquo;: use hello*. Use Relative Paths:\nPrefer using relative paths whenever possible to simplify navigation.\nExample: mv /home/username/Downloads/index.html /var/www/html/index.html moves a file to the web server directory. ","permalink":"http://localhost:1313/posts/pages/linux/linux_cheatsheet/","summary":"A practical guide to navigating and managing files in Linux.","title":"Linux Commands and Directories Guide"},{"content":"Learning Journey Topics I Have Learned So Far Docker Linux Celery Django Channels Git Celery Python Django JavaScript React Basics HTML CSS Tailwind Css What I Plan to Learn In third Semester Django Rest Framework (DRF) Django ORM Deep Dive React Advanced Git Advanced Docker Advanced WebSOcket Deep Dive in Django Celery Deep Dive Plan to learn in future WebSocket Deep Dive in Django Celery Deep Dive Redis for Cache Kafka Basics + Advanced Docker Advanced + Kubernetes Message Brokers Django Rest Framework (DRF) Django ORM Deep Dive React Advanced Git Advanced Django Docs+Advance Like class based views Additional Topics for Future Learning Real-time WebSocket usage in Django. Kafka streaming for handling large data volumes. Implementing Kubernetes for containerized applications. ","permalink":"http://localhost:1313/posts/pages/readinglist/my_reading/","summary":"A detailed overview of my learning journey and future plans.","title":"Learning Journey"},{"content":"Fetching data from server 21.1. Fetching data from server ","permalink":"http://localhost:1313/posts/pages/react/react11/","summary":"\u003ch2 id=\"fetching-data-from-server\"\u003eFetching data from server\u003c/h2\u003e\n\u003ch3 id=\"211-fetching-data-from-server\"\u003e21.1. Fetching data from server\u003c/h3\u003e","title":""},{"content":"44. Optimizing Performance 44.1. memo memo is a higher-order function in React that optimizes functional components by preventing unnecessary re-renders. It returns a new component that behaves the same as the original one but only re-renders if its props change or internal state changes not every time the parent component re-renders.\nWhy Use memo? When a parent component re-renders, all its child components also re-render by default—even if their props remain unchanged. This behavior can lead to performance bottlenecks. Using memo, we can avoid these unnecessary re-renders for child components.\nExample:\nimport { memo } from \u0026#39;react\u0026#39;; const MyComponent = memo((props) =\u0026gt; { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;{props.title}\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ); }); export default MyComponent; In the above example, the MyComponent functional component is wrapped with the memo function. This ensures that the component will only re-render if its props have changed or if its satate has been change not every time the parent component re-renders.\nUse Case:\nBefore using memo: In this example, the Custom component re-renders unnecessarily whenever the parent component re-renders, even if its props haven\u0026rsquo;t changed or internal state hasn\u0026rsquo;t changed. Custom.js import { useState } from \u0026#39;react\u0026#39;; const Custom = ({ title }) =\u0026gt; { const [count, setCount] = useState(0); return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;{title}\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;{count}\u0026lt;/p\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;Increment\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); }; export default Custom; App.js\nimport { useState } from \u0026#39;react\u0026#39;; import Custom from \u0026#39;./Custom\u0026#39;; function App() { const [count, setCount] = useState(0); return ( \u0026lt;div\u0026gt; \u0026lt;Custom title=\u0026#34;Counter\u0026#34; /\u0026gt; \u0026lt;p\u0026gt;{count}\u0026lt;/p\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;Increment Parent Count\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; Problem: The Custom component re-renders whenever the count state in the App component changes, even though the title prop remains the same. This can cause unnecessary rendering and reduce performance.i.e child component re-renders even if the props are not changed when the parent component re-renders.\nAfter using memo: Using memo, we can optimize the Custom component to only re-render when its props change. Custom.jsx import { useState, memo } from \u0026#39;react\u0026#39;; const Custom = memo(({ title }) =\u0026gt; { const [count, setCount] = useState(0); return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;{title}\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;{count}\u0026lt;/p\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;Increment\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); }); export default Custom; App.js\nimport { useState } from \u0026#39;react\u0026#39;; import Custom from \u0026#39;./Custom\u0026#39;; function App() { const [count, setCount] = useState(0); return ( \u0026lt;div\u0026gt; \u0026lt;Custom title=\u0026#34;Counter\u0026#34; /\u0026gt; \u0026lt;p\u0026gt;{count}\u0026lt;/p\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;Increment Parent Count\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; After using memo the Custom component will only re-render when its props change or state change i.e when the title prop changes or the count state of the Custom component changes . It will not re-render when the count state of the App component changes, which optimizes performance in this scenario as that change does not affect the Custom component.\n44.2. useCallback In every rerender of a component, the functions defined inside the component are recreated. This can lead to performance issues, especially when passing functions as props to child components. useCallback is a hook in React that memoizes functions to prevent unnecessary re-creations.\nSyntax:\nuseCallback(fn, dependencies) fn: The function value that you want to cache. It can take any arguments and return any values. React will return (not call!) your function back to you during the initial render. On next renders, React will give you the same function again if the dependencies have not changed since the last render. Otherwise, it will give you the function that you have passed during the current render, and store it in case it can be reused later. React will not call your function. The function is returned to you so you can decide when and whether to call it. dependencies: An array of values that, when changed, will cause the function to be re-created. If the dependencies array is empty, the function will only be created once, and will not be re-created on subsequent renders. Whats the use of dependencies array in useCallback? just because dependency array the function is recreated with the new values of the dependencies.\nBefore using useCallback:\nimport { useState,memo } from \u0026#39;react\u0026#39;; const Child = memo(({ handleClick }) =\u0026gt; { return ( \u0026lt;button onClick={handleClick}\u0026gt;Click Me\u0026lt;/button\u0026gt; ); }); const Parent = () =\u0026gt; { const [count, setCount] = useState(0); const handleClick = () =\u0026gt; { setCount(count + 1); }; return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;{count}\u0026lt;/p\u0026gt; \u0026lt;Child handleClick={handleClick} /\u0026gt; \u0026lt;/div\u0026gt; ); }; In the above example, the handleClick function is re-created on every re-render of the Parent component. As a result, the reference to the handleClick function passed as a prop to the Child component changes on every re-render of the Parent component. This causes the Child component to re-render unnecessarily, even though the handleClick function remains logically the same After using useCallback:\nimport { useState, useCallback, memo } from \u0026#39;react\u0026#39;; const Child = memo(({ handleClick }) =\u0026gt; { return ( \u0026lt;button onClick={handleClick}\u0026gt;Click Me\u0026lt;/button\u0026gt; ); }); const Parent = () =\u0026gt; { const [count, setCount] = useState(0); const handleClick = useCallback(() =\u0026gt; { setCount(count + 1); }, [count]); return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;{count}\u0026lt;/p\u0026gt; \u0026lt;Child handleClick={handleClick} /\u0026gt; \u0026lt;/div\u0026gt; ); }; By using useCallback, the handleClick function is memoized and will only be re-created when the count state changes. The reference to the handleClick function remains the same across re-renders of the Parent component unless the dependencies specified in the dependency array (in this case, [count]) change. This ensures that the Child component only re-renders when the count state changes, and not when the handleClick function reference changes, thus improving performance.\n44.3. useMemo useMemo is a hook in React that memoizes the result of a function. It is similar to useCallback, but instead of memoizing a function, it memoizes the result of a function.\nSyntax:\nconst cachedValue = useMemo(calculateValue, dependencies) calculateValue: The function calculating the value that you want to cache. It should be pure, should take no arguments, and should return a value of any type. React will call your function during the initial render. On next renders, React will return the same value again if the dependencies have not changed since the last render. Otherwise, it will call calculateValue, return its result, and store it so it can be reused later. dependencies: An array of values that, when changed, will cause the function to be re-executed.\nreturn On the initial render, useMemo returns the result of calling calculateValue with no arguments.During next renders, it will either return an already stored value from the last render (if the dependencies haven’t changed), or call calculateValue again, and return the result that calculateValue has returned.\nBefore using useMemo:\nimport { useState, memo } from \u0026#39;react\u0026#39;; const fibonacci = (n) =\u0026gt; { if (n \u0026lt;= 1) { return n; } return fibonacci(n - 1) + fibonacci(n - 2); }; const Fib = ()=\u0026gt;{ const [count, setCount] = useState(1); const result = fibonacci(100000000000); return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;{result} and count is {count}\u0026lt;/p\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;Increase Count\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } In the above example, the fibonacci function is called on every re-render of the Fib component. This can lead to performance issues, especially when the function is computationally expensive. In this case, the fibonacci function is called with a large number, which can cause the component to freeze or crash.\nAfter using useMemo:\nimport { useState, useMemo } from \u0026#39;react\u0026#39;; const fibonacci = (n) =\u0026gt; { if (n \u0026lt;= 1) { return n; } return fibonacci(n - 1) + fibonacci(n - 2); }; const Fib = ()=\u0026gt;{ const [count, setCount] = useState(1); const result = useMemo(() =\u0026gt; fibonacci(100000000000), []); return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;{result} and count is {count}\u0026lt;/p\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;Increase Count\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } By using useMemo, the result of the fibonacci function is memoized and will only be re-calculated when the dependencies specified in the dependency array change. In this case, the fibonacci function is only called once during the initial render of the Fib component, and the result is stored and reused on subsequent renders. This optimizes performance by preventing unnecessary re-calculation of the fibonacci function on every re-render of the component.\n45.Key conside a scenarion where your base component state variable need to be initialized with the value of the props passed to the component. since the state variable is initialized with the props value, the state variable will not be updated when the props value changes as it is initialized only. to handle we can either use useEffect or we can use key prop.\nUsing useEffect:\nimport { useEffect, useState } from \u0026#39;react\u0026#39;; const Parent = () =\u0026gt; { const [value, setValue] = useState(0); return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={() =\u0026gt; setValue(value + 1)}\u0026gt;Increment\u0026lt;/button\u0026gt; \u0026lt;Child value={value} /\u0026gt; \u0026lt;/div\u0026gt; ); }; const Child = ({ value }) =\u0026gt; { const [stateValue, setStateValue] = useState(value); useEffect(() =\u0026gt; { setStateValue(value); }, [value]); return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;State Value: {stateValue}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Props Value: {value}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); }; stateValue is initialized with the value prop and const [stateValue, setStateValue] = useState(value); runs only once during initial render so useEffect is used to update the stateValue when the value prop changes.\nUsing key prop:\nimport { useState } from \u0026#39;react\u0026#39;; const Parent = () =\u0026gt; { const [value, setValue] = useState(0); return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={() =\u0026gt; setValue(value + 1)}\u0026gt;Increment\u0026lt;/button\u0026gt; \u0026lt;Child key={value} value={value} /\u0026gt; \u0026lt;/div\u0026gt; ); }; const Child = ({ value }) =\u0026gt; { const [stateValue, setStateValue] = useState(value); return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;State Value: {stateValue}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Props Value: {value}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); }; IN the above example,When a key changes between renders, React will create a new instance of the component. By using the key prop with the value prop, we ensure that a new instance of the Child component is created whenever the value prop changes. This allows the stateValue to be initialized with the new value prop on every render, without the need for useEffect.\nNote:The useState() hook us run only one time during the initial render of the component. If the state variable is initialized with a prop value, it will not be updated when the prop value changes. To handle this scenario, we can use the useEffect() hook to update the state variable when the prop value changes. Alternatively, we can use the key prop to create a new instance of the component whenever the prop value changes, allowing the state variable to be initialized with the new prop value on every render. Similar goes for useReducer() and useRef() hooks as well.\n","permalink":"http://localhost:1313/posts/pages/react/react10/","summary":"Learn how to optimize React applications using memo for component memoization, useCallback for function memoization, and useMemo for value memoization.","title":"React : 10"},{"content":"40. useEffect useEffect is a React hook that lets you perform side effects in functional components. Common use cases include:\nEstablishing a database connection when the DOM content loads. Updating the page title when the content changes. Note: The useEffect hook runs after the component has rendered.\n41. What to Put in useEffect Use useEffect for:\nNetwork requests Operations that take time to complete (e.g., fetching data, setting timers, etc.) 42. useEffect Syntax 42.1. Importing useEffect import React, { useEffect } from \u0026#39;react\u0026#39;; 42.2. useEffect Syntax useEffect(() =\u0026gt; { // code here return () =\u0026gt; { // cleanup code here }; }, [dependencies]); The first argument is a function containing the code to execute. The second argument is an array of dependencies. If any dependency changes, the function runs again. The return statement is optional and is used for cleanup tasks, such as removing event listeners or canceling subscriptions. This cleanup function is executed: Just before the the useEffect function runs again cause due to dependency change, with variables from the previous render. After the component unmounts (i.e., when removed from the DOM). Note: When your component is added to the DOM, React runs the setup function. After each re-render with changed dependencies, React first executes the cleanup function (if provided) with old values, then runs the setup function with new values.\nExample: useEffect(() =\u0026gt; { const id = setTimeout(() =\u0026gt; { console.log(count); }, 1000); return () =\u0026gt; { clearTimeout(id); }; }, [count]); In this example, the useEffect hook runs whenever the count variable changes. It sets a timeout to log the count value after 1 second, and the cleanup function clears the previous timeout before the next execution. Cleanup Function:\nUsed for tasks like removing event listeners or clearing timeouts. Ensures stale operations are cleared before new ones are executed. Executes when dependencies change or when the component unmounts. 43. Variations of useEffect 43.1. useEffect Without Dependencies Array useEffect(() =\u0026gt; { // code here }); The useEffect function runs after every re-render. 43.2. useEffect With Empty Dependencies Array useEffect(() =\u0026gt; { // code here }, []); The useEffect function runs only once after the initial render, making it ideal for tasks like loading local storage data. 43.3. useEffect With Multiple Dependencies useEffect(() =\u0026gt; { // code here }, [count, name]); The useEffect function runs when either count or name changes. Note: In all of the variation, useEffect always runs after the first render no matter what is passed in the dependencies array.\nExample: Loading Local Storage Data Correct Usage:\nimport React, { useState, useEffect } from \u0026#39;react\u0026#39;; const App = () =\u0026gt; { const [data, setData] = useState([]); useEffect(() =\u0026gt; { const data = localStorage.getItem(\u0026#39;data\u0026#39;); if (data) { setData(JSON.parse(data)); } }, []); return ( \u0026lt;div\u0026gt; {data.map((item, index) =\u0026gt; ( \u0026lt;p key={index}\u0026gt;{item}\u0026lt;/p\u0026gt; ))} \u0026lt;/div\u0026gt; ); }; Incorrect Usage:\nimport React, { useState } from \u0026#39;react\u0026#39;; const App = () =\u0026gt; { const [data, setData] = useState([]); const loadData = () =\u0026gt; { const data = localStorage.getItem(\u0026#39;data\u0026#39;); if (data) { setData(JSON.parse(data)); } }; loadData(); return ( \u0026lt;div\u0026gt; {data.map((item, index) =\u0026gt; ( \u0026lt;p key={index}\u0026gt;{item}\u0026lt;/p\u0026gt; ))} \u0026lt;/div\u0026gt; ); }; Problem: Calling loadData directly causes an infinite loop because it triggers a re-render, which calls loadData again. Solution: Use useEffect with an empty dependency array to ensure the function runs only once after the initial render. ","permalink":"http://localhost:1313/posts/pages/react/react9/","summary":"Learn how to use the useEffect hook in React for performing side effects in functional components.","title":"React : 9"},{"content":"38. Understanding the Concept of Prop Drilling Prop drilling refers to the process of passing data from a parent component to a deeply nested child component through all the intermediate components, even if those intermediate components don’t need the data themselves. Let’s break this down with an example.\nComponent Tree Imagine the following component hierarchy: Now, suppose we want to transfer some data from the Product component to the Cart component. Since Product and Cart are in separate branches of the component tree, they don’t have a direct connection.\nHow Prop Drilling Works To make this work, we need to store the shared state in a common ancestor, which is the App component in this case. Then, we have to pass the state down through all the intermediate components, even if those components don’t actually use the data.\nHere’s a visual representation of this:\nData flows from Product → Shop → App (common ancestor). The data then flows from App → Header → CardModel → Cart. This creates a lot of unnecessary overhead because the intermediate components (Shop, Header, and CardModel) don’t need the data but still have to handle it.\nProp drilling can quickly become cumbersome in large applications with deeply nested components. To solve this, we can use state management tools like Redux, Context API, or React Query, which allow us to manage and share state more effectively without passing it through every component.\n39. Introduction to React Context API Context API is a feature in React that allows you to share data between components without having to pass props down manually at every level. It provides a way to pass data through the component tree without having to pass props down manually at every level as shown in the image below.\nHow to use context API Create a context using the createContext function. import { createContext } from \u0026#39;react\u0026#39;; const CartContext = createContext(); export default CartContext; Wrap the parent component with the Provider component. Which Component to wrap? Wrap to the common ancestor of the components that need the context data. In the example below, we wrap the App component with the Provider component. For Example:\nimport CartContext from \u0026#39;./store/CartContext\u0026#39;; function App() { return ( \u0026lt;CartContext.Provider value={data}\u0026gt; \u0026lt;Header /\u0026gt; \u0026lt;Shop /\u0026gt; \u0026lt;/CartContext.Provider\u0026gt; ); } Explaination:Since we want to share the product Component data with the Cart Component SO in order to do that we wrap the first common ancestor of the Product and Cart Component i.e App Component with the Provider Component and pass the data to the value prop of the Provider Component.\nAccess the context data in the child component using the useContext hook. for example:\nimport { useContext } from \u0026#39;react\u0026#39;; import CartContext from \u0026#39;../store/CartContext\u0026#39;; function Cart() { const cartCtx = useContext(CartContext); return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Cart\u0026lt;/h1\u0026gt; {cartCtx.products.map(product =\u0026gt; ( \u0026lt;p key={product.id}\u0026gt;{product.name}\u0026lt;/p\u0026gt; ))} \u0026lt;/div\u0026gt; ); } What Whappen when the data is updated? When the data is updated in the Provider component, all the child components that are using the context data will be re-rendered automatically. Task: Design a simple application that has a component called App. App has two child components: Header and Shop. Header has one child, CartModel, and Shop has one child, Product. Pass the data from the Product component to the CartModel component using the Context API.\nStructure of the project\nsrc\r|_components\r|_App\r|_App.js\r|_Header\r|_Header.js\r|_CartModel.js\r|_Shop\r|_Shop.js\r|_Product.js\r|_store\r|_CartContext.js CartContext.js\nimport { createContext } from \u0026#39;react\u0026#39;; const CartContext = createContext(); export default CartContext; App.js\nimport CartContext from \u0026#39;../store/CartContext\u0026#39;; import Header from \u0026#39;../Header/Header\u0026#39;; import Shop from \u0026#39;../Shop/Shop\u0026#39;; import { useState } from \u0026#39;react\u0026#39;; function App() { const [cartProducts, setCartProducts] = useState([]); const addProductToCart = (product) =\u0026gt; { setCartProducts((prevProducts) =\u0026gt; [...prevProducts, product]); }; return ( \u0026lt;CartContext.Provider value={ { products: cartProducts, addProduct: addProductToCart } }\u0026gt; \u0026lt;Header /\u0026gt; \u0026lt;Shop /\u0026gt; \u0026lt;/CartContext.Provider\u0026gt; ); } export default App; Header.js\nimport CartModel from \u0026#39;./CartModel\u0026#39;; function Header() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Header\u0026lt;/h1\u0026gt; \u0026lt;CartModel /\u0026gt; \u0026lt;/div\u0026gt; ); } export default Header; CartModel.js\nimport { useContext } from \u0026#39;react\u0026#39;; import CartContext from \u0026#39;../../store/CartContext\u0026#39;; function CartModel() { const cartCtx = useContext(CartContext); return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;CartModel\u0026lt;/h1\u0026gt; {cartCtx.products.map(product =\u0026gt; ( \u0026lt;p key={product.id}\u0026gt;{product.name}\u0026lt;/p\u0026gt; ))} \u0026lt;/div\u0026gt; ); } export default CartModel; Shop.js\nimport Product from \u0026#39;./Product\u0026#39;; function Shop() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Shop\u0026lt;/h1\u0026gt; \u0026lt;Product /\u0026gt; \u0026lt;/div\u0026gt; ); } export default Shop; Product.js\nimport { useContext } from \u0026#39;react\u0026#39;; import CartContext from \u0026#39;../../store/CartContext\u0026#39;; function Product() { const cartCtx = useContext(CartContext); const product = { id: 1, name: \u0026#39;Laptop\u0026#39; }; return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Product\u0026lt;/h1\u0026gt; \u0026lt;button onClick={() =\u0026gt; cartCtx.addProduct(product)}\u0026gt;Add to Cart\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } export default Product; Outsoursing the Context Provider Since all the logic related to the context is in the App Component so we can outsource the context provider and its logic to a separate component in order to make the App Component more clean and readable.\nCartContext.js\nimport { createContext, useState } from \u0026#39;react\u0026#39;; const CartContext = createContext(); export const CartContextProvider = (props) =\u0026gt; { const [cartProducts, setCartProducts] = useState([]); const addProductToCart = (product) =\u0026gt; { setCartProducts((prevProducts) =\u0026gt; [...prevProducts, product]); }; const context = { products: cartProducts, addProduct: addProductToCart }; return ( \u0026lt;CartContext.Provider value={context}\u0026gt; {props.children} \u0026lt;/CartContext.Provider\u0026gt; ); }; App.js\nimport Header from \u0026#39;../Header/Header\u0026#39;; import Shop from \u0026#39;../Shop/Shop\u0026#39;; import { CartContextProvider } from \u0026#39;../store/CartContext\u0026#39;; function App() { return ( \u0026lt;CartContextProvider\u0026gt; \u0026lt;Header /\u0026gt; \u0026lt;Shop /\u0026gt; \u0026lt;/CartContextProvider\u0026gt; ); } export default App; Other Components remain the same.\n39.UseReducer Hook in React USe reducer is a hook that is used for state management in React. It is an alternative to useState. It is usually preferable when you have complex state logic that involves multiple sub-values or when the next state depends on the previous one.\nHow to use useReducer Hook Create a reducer function. A reducer function is a function that takes the current state and an action as arguments and returns a new state based on the action type.action . action:It contains the object that is sent by the dispatch function. For Example:\nconst counterReducer = (state, action) =\u0026gt; { if (action.type === \u0026#39;INCREMENT\u0026#39;) { return { counter: state.counter + 1 }; } if (action.type === \u0026#39;DECREMENT\u0026#39;) { return { counter: state.counter - 1 }; } return state; }; Here, the reducer function takes two arguments: state and action. It checks the action type and returns a new state based on the action type.\nUse the useReducer hook in the component. The useReducer hook takes two arguments: the reducer function and the initial state and returns the current state and a dispatch function as an array which is shown below. For Example: import { useReducer } from \u0026#39;react\u0026#39;; const [counterState, dispatchCounter] = useReducer(counterReducer, { counter: 0 }); Here, counterState is the current state and dispatchCounter is the dispatch function that is used to dispatch an action to the reducer function and { counter: 0 } is the initial state such that the counter is initialized to 0.\nDispatch an action to the reducer function. To dispatch an action to the reducer function, you need to call the dispatch function with an object that contains the action type and any additional data that is required by the reducer function. For Example: dispatchCounter({ type: \u0026#39;INCREMENT\u0026#39; }); To change the state, you need to call the dispatch function with an object that contains the action type.Here, the action type is \u0026lsquo;INCREMENT\u0026rsquo; which increments the counter by 1.\nTask: Design a simple counter application that has a component called Counter. The Counter component has two buttons: Increment and Decrement. Use the useReducer hook to manage the state of the counter.\nStructure of the project\nsrc\r|_components\r|_Counter\r|_Counter.js Counter.js\nimport { useReducer } from \u0026#39;react\u0026#39;; const counterReducer = (state, action) =\u0026gt; { if (action.type === \u0026#39;INCREMENT\u0026#39;) { return { counter: state.counter + 1 }; } if (action.type === \u0026#39;DECREMENT\u0026#39;) { return { counter: state.counter - 1 }; } return state; }; function Counter() { const [counterState, dispatchCounter] = useReducer(counterReducer, { counter: 0 }); const handleIncrement = () =\u0026gt; { dispatchCounter({ type: \u0026#39;INCREMENT\u0026#39; }); }; const handleDecrement = () =\u0026gt; { dispatchCounter({ type: \u0026#39;DECREMENT\u0026#39; }); }; return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Counter\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;{counterState.counter}\u0026lt;/p\u0026gt; \u0026lt;button onClick={handleIncrement}\u0026gt;Increment\u0026lt;/button\u0026gt; \u0026lt;button onClick={handleDecrement}\u0026gt;Decrement\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } If we use useState hook then the code will be like this:\nimport { useState } from \u0026#39;react\u0026#39;; function Counter() { const [counter, setCounter] = useState(0); const handleIncrement = () =\u0026gt; { setCounter(counter=\u0026gt;counter + 1); }; const handleDecrement = () =\u0026gt; { setCounter(counter=\u0026gt;counter - 1); }; return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Counter\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;{counter}\u0026lt;/p\u0026gt; \u0026lt;button onClick={handleIncrement}\u0026gt;Increment\u0026lt;/button\u0026gt; \u0026lt;button onClick={handleDecrement}\u0026gt;Decrement\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } What is the difference between useState and useReducer?\nuseState is a simple and straightforward way to manage state in React. It is suitable for managing simple state logic. useReducer is more powerful and flexible than useState. It is suitable for managing complex state logic that involves multiple sub-values or when the next state depends on the previous one. Looking the example case Scenario: Here using reducer we write all the logic in a single function and then we dispatch the action to the reducer function and then the reducer function returns the new state based on the action type. This makes the code more readable and maintainable.\nbut in the case of useState, we have to write the logic for each state change separately which makes the code more complex and difficult to maintain.\nNote: Always change in state variable will cause the re-rendering of the component.\n","permalink":"http://localhost:1313/posts/pages/react/react8/","summary":"Learn about prop drilling and how to use the Context API in React to manage and share state effectively.","title":"React : 8"},{"content":"1.1 When to use asyncio? Asyncio is a library to write concurrent code using the async/await syntax. It is a single-threaded, single-process design that is ideal for I/O-bound and high-level structured network code. It is not suitable for CPU-bound code, which is better handled by the multiprocessing module.It is used for :\n2.1 Coroutine Think of a coroutine like a regular Python function but with the superpower that it can pause its execution when it encounters an operation that could take a while to complete. When that long-running operation is complete, we can “wake up” our paused coroutine and finish executing any other code in that coroutine. While a paused coroutine is waiting for the operation it paused for to finish, we can run other code. This running of other code while waiting is what gives our application concur rency. We can also run several time-consuming operations concurrently, which can give our applications big performance improvements. To both create and pause a coroutine, we’ll need to learn to use Python’s async and await keywords. The async keyword will let us define a coroutine; the await key word will let us pause our coroutine when we have a long-running operation.\n2.2 Creating a coroutine with async creating a coroutine is straightforward and not much different from creating a nor mal Python function. The only difference is that, instead of using the def keyword, we use async def. The async keyword marks a function as a coroutine instead of a nor mal Python function.\nimport asyncio async def mero_coroutine(): print(\u0026#34;Hello From Asyncio\u0026#34;) The coroutine in the preceding listing does nothing yet other than print “Hello world!” It’s also worth noting that this coroutine does not perform any long-running operations; it just prints our message and returns. This means that, when we put the coroutine on the event loop, it will execute immediately because we don’t have any blocking I/O, and nothing is pausing execution yet. This syntax is simple, but we’re creating something very different from a plain Python function. To illustrate this, let’s create a function that adds one to an integer as well as a coroutine that does the same and compare the results of calling each. We’ll also use the type convenience function to look at the type returned by calling a corou tine as compared to calling our normal function.\ndef add_function(a,b): return a+b async def add_coroutine(a,b): return a+b function=add_function(1,2) coroutine=add_coroutine(1,2) print(type(function)) print(type(coroutine)) When we run this code, we’ll see output like the following\nMethod result is 3 and the type is \u0026lt;class \u0026#39;int\u0026#39;\u0026gt;\rCoroutine result is \u0026lt;coroutine object coroutine_add_one at 0x1071d6040\u0026gt; and the type is \u0026lt;class \u0026#39;coroutine\u0026#39;\u0026gt; Notice how when we call our normal add_one function it executes immediately and returns what we would expect, another integer. However, when we call coroutine_ add_one we don’t get our code in the coroutine executed at all. We get a coroutine object instead. This is an important point, as coroutines aren’t executed when we call them directly. Instead, we create a coroutine object that can be run later. To run a corou tine, we need to explicitly run it on an event loop. So how can we create an event loop and run our coroutine?\nIn versions of Python older than 3.7, we had to create an event loop if one did not already exist. However, the asyncio library has added several functions that abstract the event loop management. There is a convenience function, asyncio.run, we can use to run our coroutine. This is illustrated in the following listing.\nimport asyncio async def add_coroutine(a,b): return a+b res=asyncio.run(add_coroutine(1,2)) print(res) When we run this code, we’ll see output like the following:\n3 We’ve properly put our coroutine on the event loop, and we have executed it! asyncio.run is doing a few important things in this scenario. First, it creates a brand-new event. Once it successfully does so, it takes whichever coroutine we pass into it and runs it until it completes, returning the result. This function will also do some cleanup of anything that might be left running after the main coroutine fin ishes. Once everything has finished, it shuts down and closes the event loop. Possibly the most important thing about asyncio.run is that it is intended to be the main entry point into the asyncio application we have created. It only executes one coroutine, and that coroutine should launch all other aspects of our application. As we progress further, we will use this function as the entry point into nearly all our applications. The coroutine that asyncio.run executes will create and run other coroutines that will allow us to utilize the concurrent nature of asyncio.\n2.3 Pausing execution with the await keyword The example we saw in block 2.2 did not need to be a coroutine, as it executed only non-blocking Python code. The real benefit of asyncio is being able to pause execu tion to let the event loop run other tasks during a long-running operation. To pause execution, we use the await keyword. The await keyword is usually followed by a call to a coroutine (more specifically, an object known as an awaitable, which is not always a coroutine; we’ll learn more about awaitables later in the chapter). Using the await keyword will cause the coroutine following it to be run, unlike calling a coroutine directly, which produces a coroutine object. The await expression will also pause the coroutine where it is contained in until the coroutine we awaited finishes and returns a result. When the coroutine we awaited finishes, we’ll have access to the result it returned, and the containing coroutine will “wake up” to handle the result. We can use the await keyword by putting it in front of a coroutine call. Expanding on our earlier program, we can write a program where we call the add_coroutine function inside of a “main” async function and get the result\nimport asyncio async def add_one(number: int) -\u0026gt; int: return number + 1 async def main() -\u0026gt; None: one_plus_one = await add_one(1) # Pause, and wait for the result of add_one(1). two_plus_one = await add_one(2) # Pause, and wait for the result of add_one(2). print(one_plus_one) print(two_plus_one) asyncio.run(main()) Note: Coroutine will only run when we use await keyword. If we call the coroutine directly it will return a coroutine object.\nIn above code we pause execution twice. We first await the call to add_one(1). Once we have the result, the main function will be “unpaused,” and we will assign the return value from add_one(1) to the variable one_plus_one, which in this case will be two. We then do the same for add_one(2) and then print the results.We can visualize the execution flow of our application, as shown in figure\nAs it stands now, this code does not operate differently from normal, sequential code. We are, in effect, mimicking a normal call stack. Next, let’s look at a simple example of how to run other code by introducing a dummy sleep operation while we’re waiting.\n2.4 Introducing long-running coroutines with sleep Our previous examples did not use any slow operations and were used to help us learn the basic syntax of coroutines. To fully see the benefits and show how we can run mul tiple events simultaneously, we’ll need to introduce some long-running operations. Instead of making web API or database queries right away, which are nondeterministic as to how much time they will take, we’ll simulate long-running operations by specify ing how long we want to wait. We’ll do this with the asyncio.sleep function. We can use asyncio.sleep to make a coroutine “sleep” for a given number of sec onds. This will pause our coroutine for the time we give it, simulating what would hap pen if we had a long-running call to a database or web API. asyncio.sleep is itself a coroutine, so we must use it with the await keyword. If we call it just by itself, we’ll get a coroutine object. Since asyncio.sleep is a coroutine, this means that when a coroutine awaits it, other code will be able to run. Let’s examine a simple example, shown in the following listing, that sleeps for 1 sec ond and then prints a \u0026lsquo;Hello World!\u0026rsquo; message.\nimport asyncio async def hello_world_message(): await asyncio.sleep(1) print(\u0026#34;Hello World\u0026#34;) asyncio.run(hello_world_message()) When we run this application, our program will wait 1 second before printing our \u0026lsquo;Hello World!\u0026rsquo; message. Since hello_world_message is a coroutine and we pause it for 1 second with asyncio.sleep, we now have 1 second where we could be running other code concurrently.\nWe’ll be using sleep a lot in the next few examples, so let’s invest the time to cre ate a reusable coroutine that sleeps for us and prints out some useful information. We’ll call this coroutine delay. This is shown in the following listing\nimport asyncio async def delay(delaysecond): print(f\u0026#39;Sleeping for delay seconds : {delaysecond}\u0026#39;) await asyncio.sleep(delaysecond) print(f\u0026#39;finished sleeping for {delay_seconds} second(s)\u0026#39;) return delay_seconds delay will take in an integer of the duration in seconds that we’d like the function to sleep and will return that integer to the caller once it has finished sleeping. We’ll also print when sleep begins and ends. This will help us see what other code, if any, is run ning concurrently while our coroutines are paused.\nTo make referencing this utility function easier in future code listings, we’ll create a module that we’ll import in the remainder of this book when needed. We’ll also add to this module as we create additional reusable functions. We’ll call this module util, and we’ll put our delay function in a file called delay_functions.py. We’ll also add an init.py file with the following line, so we can nicely import the timer\nfrom util.delay_functions import delay From now on in this book, we’ll use from util import delay whenever we need to use the delay function. Now that we have a reusable delay coroutine, let’s combine it with the earlier coroutine add_one to see if we can get our simple addition to run concur rently while hello_world_message is paused.\nimport asyncio from util.delay_functions import delay async def add_one(number): return number + 1 async def hello_world_message(): await delay(1) print(\u0026#34;Hello World\u0026#34;) async def main() -\u0026gt; None: message = await hello_world_message() #pause until hello_world_message is finished one_plus_one = await add_one(1) #pause until add_one is finished print(one_plus_one) print(message) asyncio.run(main()) When we run this, 1 second passes before the results of both function calls are printed. What we really want is the value of add_one(1) to be printed immediately while hello_world_message()runs concurrently. So why isn’t this happening with this code? The answer is that await pauses our current coroutine and won’t execute any other code inside that coroutine until the await expression gives us a value. Since it will take 1 second for our hello_world_message function to give us a value, the main coroutine will be paused for 1 second. Our code behaves as if it were sequential in this case. This behavior is illustrated in figure\nWe can see that the main coroutine is paused for 1 second while hello_world_\nBoth main and hello_world paused while we wait for delay(1) to finish. After it has finished, main resumes and can execute add_one. We’d like to move away from this sequential model and run add_one concurrently with hello_world. To achieve this, we’ll need to introduce a concept called tasks.\n2.5 Running concurrently with task In Python\u0026rsquo;s asyncio, you can create tasks to run code concurrently. This is done using the asyncio.create_task function. When you create a task, it starts running in the background immediately, allowing your program to do other things while waiting for the task to finish.\nKey Points: Creating a Task:\nUse asyncio.create_task() with a coroutine function as its input. It returns a task object instantly. Awaiting a Task:\nYou can use await with the task object to pause your program until the task is done and get its result. Why Use Tasks?\nTasks allow other parts of your program to run without waiting for one operation to finish. Code Example: Creating and Using a Task import asyncio from util import delay # A custom function that simulates a delay async def main(): # Create a task that takes 3 seconds to complete sleep_for_three = asyncio.create_task(delay(3)) # Immediately print the type of the task object print(f\u0026#34;Task type: {type(sleep_for_three)}\u0026#34;) # Wait for the task to finish and get the result result = await sleep_for_three print(f\u0026#34;Task result: {result}\u0026#34;) # Run the main coroutine asyncio.run(main()) What’s Happening in the Code: Task Creation:\nasyncio.create_task(delay(3)) creates a task to run the delay(3) coroutine in the background. The task is of type \u0026lt;class '_asyncio.Task'\u0026gt;, which is different from a regular coroutine. Running Concurrently:\nAfter creating the task, the program does not wait for the task to finish. The print() statement runs immediately after the task is created. Waiting for the Task:\nThe await sleep_for_three line pauses the main coroutine until the task finishes. Once the task is complete, it returns its result, which is printed. Why Await is Important: If you don’t use await on a task, it might not get enough time to finish. When the asyncio.run function exits, the event loop stops, and any unfinished tasks are “cleaned up” without completing. Using await ensures the task has a chance to finish.\nNote : When we create task using asyncio.create_task it run the task immediately in the background. It does not wait for the task to finish and immediately return a task object such that our program can do other things while waiting for the task to finish.We can use await later on to pause the program until the task is done and get its result.\n2.6 Running multiple tasks concurrently Given that tasks are created instantly and are scheduled to run as soon as possible, this allows us to run many long-running tasks concurrently. We can do this by sequentially starting multiple tasks with our long-running coroutine.\nimport asyncio from util.delay_functions import delay async def main(): # Create two tasks that take 3 seconds to complete sleep_for_three=asyncio.create_task(delay(3)) sleep_again=asyncio.create_task(delay(3)) sleep_once_more=asyncio.create_task(delay(3)) await sleep_for_three await sleep_again await sleep_once_more asyncio.run(main()) In this code, we create three tasks that each sleep for 3 seconds. We then await each task in sequence. This will cause each task to run concurrently, and the total time to complete will be around 3 seconds, not 9 seconds. This is because we are not waiting for each task to finish before starting the next one. Lets breakdown\nStarting Three Tasks:\nThe program begins by creating three tasks, each of which takes 3 seconds to complete. The create_task function starts the tasks immediately but doesn\u0026rsquo;t wait for them to finish—it just sets them up to run in the background. The First Await Statement:\nWhen the code reaches the await sleep_for_three line, it pauses and gives control to the event loop. This pause allows the event loop to check for any tasks waiting to run and starts them “as soon as possible.” Tasks Run Simultaneously:\nAll three tasks begin running their sleep operations at the same time because the event loop handles them concurrently. This concurrency allows the program to complete the work in 3 seconds instead of 9. Concurrency in Action:\nWhile the sleep operations run concurrently, any other code in the tasks (like print statements) runs one at a time, not simultaneously. This means only the parts of the tasks that involve waiting (like sleeping) are parallelized. Time Saved:\nIf the tasks were executed one after another, the program would take 9 seconds (3 seconds × 3 tasks). By running the tasks concurrently, the program finishes in just 3 seconds, saving a lot of time. This is illustrated in figure NOTE This benefit compounds as we add more tasks; if we had launched 10 of these tasks, we would still take roughly 3 seconds, giving us a 10-fold speedup. This is the power of concurrency in asyncio.\nasyncio.gather function Gather function is a quick way to run multiple tasks concurrently and wait for all of them to complete. It takes in an iterable of awaitables and returns a single awaitable that will yield results in the order they were created. This is useful when we want to run multiple tasks concurrently and wait for all of them to finish before proceeding.\nimport asyncio from util.delay_functions import delay async def main(): # Create three tasks that take 3 seconds to complete and handel using asyncio.gather results = await asyncio.gather( delay(3), delay(3), delay(3) ) print(results) asyncio.run(main()) Note : For understanding You can use this logic . There is a task queue and event loop. When we only await coroutine there is only one task in the task queue and event loop .\ncoroutine need to await for running the task i.e keep in the task queue and eventloop if we directly run coroutine it will just give us coroutine object.\nWhen we use asyncio.createtask() there are as much task in the task queue as the number of tasks created and event loop will run all the tasks concurrently also when we await new coroutine it will be added to the task queue and event loop will run it concurrently.\nIt return a task object instantly and run all the task concurrently i.e keep in the task queue and event loop without awaiting but does not wait for the task to finish it need to be awaited to get the proper result.\nWhen we use asyncio.gather() it will run all the tasks concurrently and wait for all of them to finish before proceeding.\nIt need to be awaited to keep all the task in the task queue and event loop and wait for all of them to finish before proceeding.After finishing all the task it will return the result in the order they were created and jump to the next line of code of the main coroutine.\n3. Synchronization Premitives Locks Semaphores 3.1 Locks Locks are a synchronization primitive that allows us to limit access to a shared resource to only one coroutine at a time. This is useful when we have a resource that can only be accessed by one coroutine at a time, like a file or a database connection. Locks are created using the asyncio.Lock class and can be acquired using the acquire method and released using the release method.\n#basic example of lock\nimport asyncio async def locking(lock): print(\u0026#39;Waiting for the lock\u0026#39;) async with lock: print(\u0026#39;Acquired the lock\u0026#39;) await asyncio.sleep(2) print(\u0026#39;Released the lock\u0026#39;) async def main(): lock = asyncio.Lock() await asyncio.gather( locking(lock), locking(lock), locking(lock) ) asyncio.run(main()) Output:\nWaiting for the lock\rAcquired the lock\rWaiting for the lock\rWaiting for the lock\rReleased the lock\rAcquired the lock\rReleased the lock\rAcquired the lock\rReleased the lock In this example, we create a lock using asyncio.Lock and pass it to the locking coroutine. We then use the async with statement to acquire the lock and release it when we are done. When we run the program, we can see that only one coroutine can acquire the lock at a time, and the other coroutines have to wait until the lock is released.\n3.2 Semaphores Semaphores are a synchronization primitive that allows us to limit access to a shared resource to a fixed number of coroutines at a time. This is useful when we have a resource that can be accessed by a limited number of coroutines, like a connection pool or a web API. Semaphores are created using the asyncio.Semaphore class and can be acquired using the acquire method and released using the release method.\n#basic example of semaphore\nimport asyncio async def semaphoring(semaphore): async with semaphore: print(\u0026#39;Acquired the semaphore\u0026#39;) await asyncio.sleep(2) print(\u0026#39;Released the semaphore\u0026#39;) async def main(): semaphore = asyncio.Semaphore(2) await asyncio.gather( semaphoring(semaphore), semaphoring(semaphore), semaphoring(semaphore), semaphoring(semaphore) ) asyncio.run(main()) Output:\nAcquired the semaphore\rAcquired the semaphore\rAcquired the semaphore\rReleased the semaphore\rReleased the semaphore\rReleased the semaphore\rAcquired the semaphore\rReleased the semaphore In this example, we create a semaphore with a limit of 2 using asyncio.Semaphore and pass it to the semaphoring coroutine. We then use the async with statement to acquire the semaphore and release it when we are done. When we run the program, we can see that only two coroutines can acquire the semaphore at a time, and the other coroutines have to wait until the semaphore is released.\nSome popular asyncio libraries aiohttp: An HTTP client and server library for asyncio. fastapi: A modern web framework for building APIs with Python 3.6+ based on standard Python type hints. aiofiles: A file operations library for asyncio. ","permalink":"http://localhost:1313/posts/pages/asyncio/asyncio2/","summary":"how to write programs using this single-threaded concurrency model with asyncio","title":"Async io : Asyncio Basics (Day 2)"},{"content":"36. useRef Hook in React useRef is a hook that is specially designed to work with DOM elements. It allows you to create a reference to a DOM element and access it directly in your components so you can modify it or read its properties as needed.\nAnother important distinction is that useRef holds the same reference across re-renders of the component Similarly, useState also retains its value between renders. However, updating a state value with useState will always trigger a re-render, whereas updating the value of a useRef does not. Its explained in the below example in ## 2. Advanvced Usage\n1. Basic Usage 1. Import useRef import { useRef } from \u0026#39;react\u0026#39;; 2. Create a Reference const myRef = useRef(); 3. Attach to DOM Elements function MyComponent() { const myRef = useRef(); return ( \u0026lt;div ref={myRef}\u0026gt; \u0026lt;h1\u0026gt;useRef Example\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ); } 4. Accessing the Reference // Access the DOM element using .current const element = myRef.current; use myRef.current.value for input elements. use myRef.current.checked for checkbox elements. use myRef.current.focus() to focus on an element. use myRef.current.style to access the style object of an element.\nNote: While you can access DOM elements directly with useRef, it\u0026rsquo;s recommended to avoid manipulating them directly unless necessary.\nPractical Example: Form Input Here\u0026rsquo;s a complete example showing how to use useRef with form inputs:\nimport { useRef, useState } from \u0026#39;react\u0026#39;; function InputExample() { const inputRef = useRef(); const [inputValue, setInputValue] = useState(\u0026#39;\u0026#39;); const handleClick = () =\u0026gt; { setInputValue(inputRef.current.value); inputRef.current.value = \u0026#39;\u0026#39;; // Clear input after reading }; return ( \u0026lt;div\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; ref={inputRef} placeholder=\u0026#34;Type something...\u0026#34; /\u0026gt; \u0026lt;button onClick={handleClick}\u0026gt;Save Input\u0026lt;/button\u0026gt; \u0026lt;p\u0026gt;Saved value: {inputValue}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } Explanation:\nWe create a reference to the input element using useRef. When the button is clicked, we read the input value using inputRef.current.value and update the state. We clear the input field by setting inputRef.current.value to an empty string. 2. Advanced Usage of useRef and useState useRef and useState are both hooks used in React. Both hooks help us store values, but they behave differently: useState: The value is persistent across re-renders, but updating it triggers a re-render. useRef: The value is also persistent across re-renders, but updating it does not trigger a re-render. 2.1. Managing Previous Values in a Stopwatch Here’s an example of how to use useRef and useState to build a simple stopwatch in React:\nimport { useRef, useState } from \u0026#39;react\u0026#39;; function Stopwatch() { const timerRef = useRef(0); // To store the timer ID const [time, setTime] = useState(0); // To store the current time const [isRunning, setIsRunning] = useState(false); // To track if the stopwatch is running // Start the timer when the Start button is clicked const startTimer = () =\u0026gt; { if (!isRunning) { timerRef.current = setInterval(() =\u0026gt; { setTime((time) =\u0026gt; time + 1); // Increment the time every second }, 1000); setIsRunning(true); // Set the timer as running } }; // Stop the timer when the Stop button is clicked const stopTimer = () =\u0026gt; { clearInterval(timerRef.current); // Clear the interval to stop the timer setIsRunning(false); // Set the timer as not running }; // Reset the timer when the Reset button is clicked const resetTimer = () =\u0026gt; { clearInterval(timerRef.current); // Clear the interval to stop the timer setIsRunning(false); // Set the timer as not running setTime(0); // Reset the time to 0 }; return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Stopwatch\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;Time: {time} seconds\u0026lt;/p\u0026gt; \u0026lt;button onClick={startTimer}\u0026gt;Start\u0026lt;/button\u0026gt; \u0026lt;button onClick={stopTimer}\u0026gt;Stop\u0026lt;/button\u0026gt; \u0026lt;button onClick={resetTimer}\u0026gt;Reset\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } Explanation Creating useRef and useState variables:\ntimerRef: This holds the timer ID (returned by setInterval). We use useRef here because we don’t need the component to re-render when the timer ID changes. time: This stores the current time value of the stopwatch, and we use useState for this because we want the component to re-render whenever the time updates. isRunning: This tracks whether the stopwatch is running or not. Starting the timer (Start Button):\nWhen the \u0026ldquo;Start\u0026rdquo; button is clicked, we check if the timer is already running. If it isn’t, we start it by calling setInterval, which increments the time value every second. setInterval returns an interval ID that we store in timerRef.current. This ID will be used to stop the timer later. Stopping the timer (Stop Button):\nWhen the \u0026ldquo;Stop\u0026rdquo; button is clicked, we clear the interval using clearInterval(timerRef.current) to stop the timer. We also set isRunning to false to indicate that the timer is no longer running. Resetting the timer (Reset Button):\nWhen the \u0026ldquo;Reset\u0026rdquo; button is clicked, we clear the interval to stop the timer, set isRunning to false, and reset the time back to 0. Why useRef? Why not just use a regular variable?\nA regular variable inside the component would reset every time the component re-renders. Since the timer is being updated every second, this would cause issues because the value would be reset each time, and the timer wouldn’t function correctly. Why useRef over useState for the timer ID?\nWe use useRef to store the timer ID because updating it with useState would trigger a re-render every time the timer ID changes. Since the timer is running independently, we don’t need a re-render, so useRef is more efficient here. Key Takeaways useRef is useful for storing values that don’t require the component to re-render when they change. useState is used for values that should trigger a re-render when updated, like the time value in our stopwatch. useRef does not cause a re-render when its value changes, making it ideal for holding values like the interval ID that don’t need to affect the UI. Common Use Cases Storing previous values Managing focus, text selection, or media playback Integrating with third-party DOM libraries Accessing underlying DOM elements Isolation in Components: Any variable that is declared inside a component is isolated to that component. It is not shared with other components unless explicitly passed as props. This isolation helps maintain the encapsulation and modularity of components in React.\n37.Forwarding Refs in React Forwarding refs is a technique in React that allows you to pass a ref from a parent component to a child component. This is useful when you want to access the DOM element of a child component from a parent component.\n1. Basic Usage 1.Import useRef import { useRef } from \u0026#39;react\u0026#39;; 2. Create a Ref in the Parent Component const myRef= useRef(); 3. Pass the Ref to the Child Component \u0026lt;MyChildComponent ref={myRef} /\u0026gt; 4.Import forward ref in child component import React, { forwardRef } from \u0026#39;react\u0026#39;; 5. Using forwardRef to Forward the Ref const MyChildComponent = forwardRef((props, ref) =\u0026gt; { return \u0026lt;input ref={ref} /\u0026gt;; }); 6. Accessing the Ref in the Parent Component const element = myRef.current.value; Practical Example: Input Focus to take input from user and focus on the input field of the child component from the parent component.\nimport React, { useRef } from \u0026#39;react\u0026#39;; const InputComponent = forwardRef(({title}, ref) =\u0026gt; { return\u0026lt;\u0026gt; \u0026lt;h1\u0026gt;{title}\u0026lt;/h1\u0026gt; \u0026lt;input ref={ref}/\u0026gt; \u0026lt;/\u0026gt; }); function ParentComponent() { const inputRef = useRef(); const handleClick = () =\u0026gt; { inputRef.current.focus(); console.log(inputRef.current.value); }; return ( \u0026lt;div\u0026gt; \u0026lt;InputComponent ref={inputRef} title=\u0026#34;ENter the Input\u0026#34;/\u0026gt; \u0026lt;button onClick={handleClick}\u0026gt;Focus Input\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 38.useImperativeHandle in React In large-scale applications, we generally avoid using refs directly to access child components. Instead, we use the useImperativeHandle hook to expose specific methods from the child component to the parent component. This approach allows the developer working on the parent component to interact with the child component\u0026rsquo;s methods without needing to understand its internal implementation. Additionally, this separation enables the developer of the child component to modify or update the child component independently, without affecting the parent component. Since only the exposed methods are used by the parent, changes to the internal structure of the child component do not disrupt the parent-child interaction.This is specially used in forwardRef to expose methods of child component to parent component.\nBasic Usage 1.Pass a Ref to the Child Component import {useRef} from \u0026#39;react\u0026#39;; function App() { const childRef = useRef(); return \u0026lt;ChildComponent ref={childRef} /\u0026gt;; } =\u0026gt; Here, we create a ref using useRef and pass it to the ChildComponent using the ref prop.\n2. Use useImperativeHandle in the Child Component with forwardRef to expose methods import { useImperativeHandle, forwardRef } from \u0026#39;react\u0026#39;; const ChildComponent = forwardRef((props, ref) =\u0026gt; { useImperativeHandle(ref, () =\u0026gt; ({ focus: () =\u0026gt; { // Focus on the input element }, reset: () =\u0026gt; { // Reset the input element }, inputValue:\u0026#39;vaule\u0026#39; }),[dependencies]); return \u0026lt;input /\u0026gt;; }); In the ChildComponent, we use the useImperativeHandle hook to expose the focus and reset methods to the parent component. The ref object is passed as the first argument, and the second argument is a function that returns an object containing the methods to be exposed. dependencies is an optional array of values that, when changed, will trigger the re-evaluation of the function that returns the methods. If the dependencies array is not provided, the function will be called on every render and empty array will call only once in entire lifecycle.\n3. Access the Exposed Methods in the Parent Component function App() { const childRef = useRef(); const handleClick = () =\u0026gt; { childRef.current.focus(); }; const resetClick = () =\u0026gt; { childRef.current.reset(); }; return ( \u0026lt;\u0026gt; \u0026lt;ChildComponent ref={childRef} /\u0026gt; \u0026lt;button onClick={handleClick}\u0026gt;Focus Input\u0026lt;/button\u0026gt; \u0026lt;button onClick={resetClick}\u0026gt;Reset Input\u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; ); } In the parent component, we can access the exposed methods using the current property of the ref object. In this example, we call the focus method when the \u0026ldquo;Focus Input\u0026rdquo; button is clicked.\nPractical Example: Use forwardRef and useImperativeHandle to Expose Methods for reset the input field and get the value of the input field. import {useRef} from \u0026#39;react\u0026#39;; function App(){ const childRef = useRef(); const handleClick = () =\u0026gt; { childRef.current.focus(); }; const resetClick = () =\u0026gt; { childRef.current.reset(); }; const getValue = () =\u0026gt; { console.log(childRef.current.value); }; return ( \u0026lt;\u0026gt; \u0026lt;ChildComponent ref={childRef} /\u0026gt; \u0026lt;button onClick={handleClick}\u0026gt;Focus Input\u0026lt;/button\u0026gt; \u0026lt;button onClick={resetClick}\u0026gt;Reset Input\u0026lt;/button\u0026gt; \u0026lt;button onClick={getValue}\u0026gt;Get Value\u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; ); } export default App; import { useImperativeHandle, forwardRef,useRef } from \u0026#39;react\u0026#39;; const ChildComponent = forwardRef((props, ref) =\u0026gt; { const inputRef = useRef(); useImperativeHandle(ref, () =\u0026gt; ({ focus: () =\u0026gt; { inputRef.current.focus(); }, reset: () =\u0026gt; { inputRef.current.value = \u0026#39;\u0026#39;; }, value: inputRef.current.value }),[]); return \u0026lt;input ref={inputRef} /\u0026gt;; }); export default ChildComponent; =\u0026gt; By using useImperativeHandle, we can expose specific methods from the child component to the parent component, allowing for more controlled interactions between the components such as focusing on the input field, resetting the input field, and getting the value of the input field in this example. =\u0026gt; By using this approach, we can maintain a clear separation of concerns between the parent and child components, making it easier to manage and update the components independently.\n37. Portals in React Portals in React provide a way to render children components outside the DOM hierarchy of the parent component. This allows you to render a child component at a different location in the DOM, such as at the root level or inside a specific container, without affecting the parent\u0026rsquo;s layout or styles.\nImporting portal from react-dom import { createPortal } from \u0026#39;react-dom\u0026#39;; using createPortal const MyPortal = ({title}) =\u0026gt; { return createPortal( \u0026lt;\u0026gt; \u0026lt;h1\u0026gt;{title}\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;This is a portal\u0026lt;/p\u0026gt; \u0026lt;\u0026gt;, document.getElementById(\u0026#39;portal-root\u0026#39;)); }; =\u0026gt;When the MyPortal component is rendered, the content will be rendered inside the element with the id \u0026lsquo;portal-root\u0026rsquo;, which can be located anywhere in the DOM.\n","permalink":"http://localhost:1313/posts/pages/react/react7/","summary":"Learn about useRef hook, ref forwarding, useImperativeHandle and Portals in React for DOM manipulation and component interactions.","title":"React : Day 7"},{"content":"1. Some Important Concepts 1.1 Parallism vs Concurrency Parallism: Running multiple tasks at the same time. There are multiple Threads or Processes running at the same time. Concurrency: Switching between multiple tasks. When one task is waiting for I/O, another task can run. There is only one Thread or Process running at a time. 1.2 Synchronous vs Asynchronous Synchronous: Code is executed in sequence. Previous task/line must be completed before the next task/line execution starts. Asynchronous: Code is executed in parallel. Tasks can run concurrently. The next task can start before the previous task is completed. 1.3 Blocking vs Non-Blocking Blocking: The execution of the code is blocked until the task is completed. The next task can\u0026rsquo;t start until the previous task is completed. import time def task1(): print(\u0026#34;Task 1 started\u0026#34;) time.sleep(2) print(\u0026#34;Task 1 completed\u0026#34;) def task2(): print(\u0026#34;Task 2 started\u0026#34;) time.sleep(2) print(\u0026#34;Task 2 completed\u0026#34;) task1() task2() Non-Blocking: The excecution of the code is not blocked. The next task can start before the previous task is completed. import asyncio async def task1(): print(\u0026#34;Task 1 started\u0026#34;) await asyncio.sleep(2) print(\u0026#34;Task 1 completed\u0026#34;) async def task2(): print(\u0026#34;Task 2 started\u0026#34;) await asyncio.sleep(2) print(\u0026#34;Task 2 completed\u0026#34;) async def main(): await asyncio.gather(task1(), task2()) asyncio.run(main()) 1.4 I/O Bound vs CPU Bound I/O Bound: The program is waiting for input/output operations to complete. The program is not using the CPU much. CPU Bound: The program is using the CPU a lot. The program is not waiting for input/output operations to complete. import request response = request.get(\u0026#34;https://www.google.com\u0026#34;) # I/O Bound items = response.headers.items() # CPU Bound headers = [f\u0026#39;{key}: {header}\u0026#39; for key, header in items] # CPU Bound formatted_headers = \u0026#39;\\n\u0026#39;.join(headers) # CPU Bound with open(\u0026#39;headers.txt\u0026#39;, \u0026#39;w\u0026#39;) as file: # I/O Bound file.write(formatted_headers) # I/O Bound 2. How Concurrency is Achieved in Os level To better understand this, we’ll need to dive into how sockets work and, in particular, how non-blocking sockets work.\n2.1 Sockets A socket is a low-level abstraction for sending and receiving data over a network. It is the basis for how data is transferred to and from servers. Sockets support two main operations: sending bytes and receiving bytes. We write bytes to a socket, which will then get sent to a remote address, typically some type of server. Once we’ve sent those bytes, we wait for the server to write its response back to our socket. Once these bytes have been sent back to our socket, we can then read the result.\nIn the case of getting the contents from example.com as we saw earlier, we open a socket that connects to example.com’s server. We then write a request to get the contents to that socket and wait for the server to reply with the result: in this case, the HTML of the web page. We can visualize the flow of bytes to and from the server in figure 1.7\nSockets are blocking by default. Simply put, this means that when we are waiting for a server to reply with data, we halt our application or block it until we get data to read. Thus, our application stops running any other tasks until we get data from the server, an error happens, or there is a timeout. At the operating system level, we don’t need to do this blocking. Sockets can operate in non-blocking mode. In non-blocking mode, when we write bytes to a socket, we can just fire and forget the write or read, and our application can go on to perform other tasks. Later, we can have the operating system tell us that we received bytes and deal with it at that time. This lets the application do any number of things while we wait for bytes to come back to us. Instead of blocking and waiting for data to come to us, we become more reactive, letting the operating system inform us when there is data for us to act on. In the background, this is performed by a few different event notification systems, depending on which operating system we’re running. asyncio is abstracted enough that it switches between the different notification systems, depending on which one our operating system supports. The following are the event notification systems used by specific operating systems:\nkqueue—FreeBSD and MacOS epoll—Linux IOCP (I/O completion port)—Windows These systems keep track of our non-blocking sockets and notify us when they are ready for us to do something with them. This notification system is the basis of how asyncio can achieve concurrency.\nBut how do we keep track of multiple tasks that are waiting for data to come back to them? This is where the event loop comes in.\n2.2 Event Loop The event loop is the core of every asyncio application. In asyncio, the event loop keeps a queue of tasks.\n2.2.1 How the Event Loop Works The event loop works by keeping a queue of tasks instead of messages. Each task is a coroutine. When a task is added to the event loop, it will execute until it encounters an I/O operation (such as a web request). When a task hits an I/O-bound operation, it pauses and allows the event loop to run other tasks that are not waiting for I/O operations to complete. 2.2.2 Understanding Event Loops in Asynchronous Programming When working with event loops in asynchronous programming, the process can be understood as a sequence of steps that efficiently handle tasks without blocking the execution. Here\u0026rsquo;s a breakdown of how it works:\n2.2.2.1 Creating the Event Loop When an event loop is created, an empty queue of tasks is initialized. This queue will hold all the tasks that need to be executed.\n2.2.2.2 Adding Tasks to the Queue We add tasks to the event loop’s queue. These tasks are executed one at a time, based on their order in the queue.\n2.2.2.3 Processing Tasks Iteratively Each iteration of the event loop checks for tasks that need to be executed. It processes tasks sequentially, running them one by one.\n2.2.2.4 Handling I/O Operations If a task encounters an I/O operation (like reading from a file or making a network request), it cannot proceed immediately. In this case, the task is paused and put on hold.\n2.2.2.5 Pausing and Waiting for I/O Completion When a task is paused, the event loop instructs the operating system to monitor any associated sockets or resources for I/O completion. During this time, the event loop continues checking for and executing other tasks.\n2.2.2.6 Waking Up Paused Tasks On each iteration of the event loop, we check if any of the I/O operations have completed. If they have:\nThe paused task is woken up. The task resumes execution and completes its process. 2.2.2.7. Conclusion This cycle of pausing, waiting for I/O, and resuming tasks allows the event loop to run multiple tasks concurrently, making it an efficient way to handle asynchronous operations without blocking the program.\nBy continuously iterating and checking for completed I/O tasks, the event loop ensures that no task is left idle while waiting for I/O operations, enabling a smooth and efficient workflow.\nVisualizing the Event Loop with Asynchronous Tasks We can visualize how the event loop works with asynchronous tasks as shown in Figure 1.9: the main thread submits tasks to the event loop, which then runs them. When a task encounters an I/O operation, it pauses and allows other tasks to run. Once the I/O operation is complete, the paused task is resumed.\nExample: Submitting Multiple Asynchronous Tasks Let\u0026rsquo;s consider three tasks that each make an asynchronous web request. These tasks consist of:\nCPU-bound setup: Some code that prepares data for the web request. I/O-bound web request: The asynchronous part where we send the web request. CPU-bound post-processing: After the web request completes, we do some more CPU-intensive work. Now, let\u0026rsquo;s submit these tasks to the event loop simultaneously. Here’s how we can write this in pseudocode:\ndef make_request(): cpu_bound_setup() io_bound_web_request() cpu_bound_postprocess() task_one = make_request() task_two = make_request() task_three = make_request() First task starts executing code, and the other two are left waiting to run. Once the CPU-bound setup work is finished in Task 1, it hits an I/O-bound operation and will pause itself to say, “I’m waiting for I/O; any other tasks waiting to run can run.” Once this happens, Task 2 can begin executing. Task 2 starts its CPU-bound code and then pauses, waiting for I/O. At this time both Task 1 and Task 2 are waiting concurrently for their network request to complete. Since Tasks 1 and 2 are both paused waiting for I/O, we start running Task 3. Now imagine once Task 3 pauses to wait for its I/O to complete, the web request for Task 1 has finished. We’re now alerted by our operating system’s event notification system that this I/O has finished. We can now resume executing Task 1 while both Task 2 and Task 3 are waiting for their I/O to finish. In figure 1.10, we show the execution flow of the pseudocode we just described. If we look at any vertical slice of this diagram, we can see that only one CPU-bound piece of work is running at any given time; however, we have up to two I/O-bound operations happening concurrently. This overlapping of waiting for I/O per each task is where the real time savings of asyncio comes in.\n","permalink":"http://localhost:1313/posts/pages/asyncio/asyncio1/","summary":"An introduction to asynchronous programming in Python using asyncio.","title":"Async io : Async io Intro (Day 1)"},{"content":"34.Styling in CSS 34.1 Setting Inline Styles =\u0026gt; In react for inline styles we use the style attribute and pass an object with camelCase properties.\nimport React from \u0026#39;react\u0026#39;; const myStyle = { color: \u0026#39;blue\u0026#39;, backgroundColor: \u0026#39;yellow\u0026#39; } const MyComponent = () =\u0026gt; { return ( \u0026lt;div style={myStyle}\u0026gt; \u0026lt;h1\u0026gt;Inline Styles\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ) } or we can use the style attribute directly in the element.\nimport React from \u0026#39;react\u0026#39;; const MyComponent = () =\u0026gt; { return ( \u0026lt;div style={{color: \u0026#39;blue\u0026#39;, backgroundColor: \u0026#39;yellow\u0026#39;}}\u0026gt; \u0026lt;h1\u0026gt;Inline Styles\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ) } 34.2 Setting External Styles =\u0026gt; We can also use external CSS files in react. We can import the CSS file in the component file and use the class name in the\nimport React from \u0026#39;react\u0026#39;; import \u0026#39;./MyComponent.css\u0026#39;; const MyComponent = () =\u0026gt; { return ( \u0026lt;div className=\u0026#34;myStyle\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;External Styles\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ) } 34.3 Setting Inline Dynamic Styles =\u0026gt;You can also set the inline styles dynamically by using the state.\nimport React,{useState} from \u0026#39;react\u0026#39;; const App=()=\u0026gt;{ const [valid,setValid]=useState(true); function changeStyle(){ setValid(!valid); } const myStyle={ color:valid?\u0026#39;blue\u0026#39;:\u0026#39;red\u0026#39;, backgroundColor:valid?\u0026#39;yellow\u0026#39;:\u0026#39;green\u0026#39; } return( \u0026lt;div\u0026gt; \u0026lt;button onClick={changeStyle}\u0026gt;Change Style\u0026lt;/button\u0026gt; \u0026lt;div style={myStyle}\u0026gt; \u0026lt;h1\u0026gt;Inline Dynamic Styles\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) } export default App; or we can use the style attribute directly in the element.\nimport React,{useState} from \u0026#39;react\u0026#39;; const App=()=\u0026gt;{ const [valid,setValid]=useState(true); function changeStyle(){ setValid(!valid); } return( \u0026lt;div\u0026gt; \u0026lt;button onClick={changeStyle}\u0026gt;Change Style\u0026lt;/button\u0026gt; \u0026lt;div style={{color:valid?\u0026#39;blue\u0026#39;:\u0026#39;red\u0026#39;,backgroundColor:valid?\u0026#39;yellow\u0026#39;:\u0026#39;green\u0026#39;}}\u0026gt; \u0026lt;h1\u0026gt;Inline Dynamic Styles\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) } export default App; 34.4 Setting Css Classes Dynamically =\u0026gt; We can also set the CSS classes dynamically by using the state.\nimport React,{useState} from \u0026#39;react\u0026#39;; import \u0026#39;./MyComponent.css\u0026#39;; const App=()=\u0026gt;{ const [valid,setValid]=useState(true); const [active,setActive]=useState(true); function changeStyle(){ setValid(!valid); setActive(!active); } return( \u0026lt;div\u0026gt; \u0026lt;button onClick={changeStyle}\u0026gt;Change Style\u0026lt;/button\u0026gt; \u0026lt;div className={`div-control ${valid?\u0026#39;right\u0026#39;:\u0026#39;wrong\u0026#39;} ${active?\u0026#39;active\u0026#39;:\u0026#39;inactive\u0026#39;}`}\u0026gt; \u0026lt;h1\u0026gt;Setting Css Classes Dynamically\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) } export default App; 34.5 Css modules =\u0026gt; Every time we import Css file in react component they are regarded as global styles i.e One component style can affect another component style =\u0026gt;So, to avoid this we can use CSS modules. CSS modules are local by default. We can use CSS modules by naming the CSS file as filename.module.css. =\u0026gt; The CSS file is imported in the component file and the class name is used as an object.\nProblem1 =\u0026gt; Imagine that you have two components with the same class name. The styles of one component can affect the styles of another component.which is not good for the application to solve this problem we can use CSS modules.\nStructure of the project\nsrc\r|_components\r|_MyComponent\r|_MyComponent.js\r|_MyComponent.module.css Step 1: Create a CSS file with the name MyComponent.module.css\n.myStyle{ color: blue; background-color: yellow; } .right{ text-align: right; } Step 2: Import the CSS file in the component file as shown below.\nimport React from \u0026#39;react\u0026#39;; import styles from \u0026#39;./MyComponent.module.css\u0026#39;; step 3: Use the class name as shown below.\nconst MyComponent = () =\u0026gt; { return ( \u0026lt;div className={styles.myStyle}\u0026gt; \u0026lt;h1\u0026gt;CSS Modules\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ) } Combined code\nimport React from \u0026#39;react\u0026#39;; import styles from \u0026#39;./MyComponent.module.css\u0026#39;; const MyComponent = () =\u0026gt; { return ( \u0026lt;div className={styles.myStyle}\u0026gt; \u0026lt;h1\u0026gt;CSS Modules\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ) } export default MyComponent; 34.5.1 Combining multiple classes import React from \u0026#39;react\u0026#39;; import styles from \u0026#39;./MyComponent.module.css\u0026#39;; const MyComponent = () =\u0026gt; { return ( \u0026lt;div className={`${styles.myStyle} ${styles.right}`}\u0026gt; \u0026lt;h1\u0026gt;CSS Modules\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ) } export default MyComponent; 34.6 Dynamic CSS Modules =\u0026gt; We can also set the CSS classes dynamically by using the state.\nimport React,{useState} from \u0026#39;react\u0026#39;; import styles from \u0026#39;./MyComponent.module.css\u0026#39;; const MyComponent = () =\u0026gt; { const [valid,setValid]=useState(true); const [active,setActive]=useState(true); function changeStyle(){ setValid(!valid); setActive(!active); } return ( \u0026lt;div className={`${styles.myStyle} ${valid?styles.right:styles.wrong} ${active?styles.active:styles.inactive}`}\u0026gt; \u0026lt;h1\u0026gt;CSS Modules\u0026lt;/h1\u0026gt; \u0026lt;button onClick={changeStyle}\u0026gt;Change Style\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } export default MyComponent; ","permalink":"http://localhost:1313/posts/pages/react/react5/","summary":"Learn various methods to style React components including inline styles, external styles, dynamic styles, and CSS modules.","title":"React : Day 5"},{"content":"35. Debugging in react 35.1 Using console.log import React from \u0026#39;react\u0026#39;; const MyComponent = () =\u0026gt; { const name = \u0026#39;John Doe\u0026#39;; console.log(name); return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Debugging in React\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ) } export default MyComponent; 35.2 Strict Mode =\u0026gt; In Strict Mode,React will render components twice. It helps to idenify the issues in the code.\nimport React,{StrictMode} from \u0026#39;react\u0026#39;; const MyComponent = () =\u0026gt; { const name = \u0026#39;John Doe\u0026#39;; console.log(name); return ( \u0026lt;StrictMode\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Debugging in React\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/StrictMode\u0026gt; ) } export default MyComponent; You can wrap any component in StrictMode.Just difference is that it will render the component twice.\n=\u0026gt; We can wrap the entire application in StrictMode in the index.js file.\nimport React,{StrictMode} from \u0026#39;react\u0026#39;; import ReactDOM from \u0026#39;react-dom\u0026#39;; import App from \u0026#39;./App\u0026#39;; ReactDOM.render( \u0026lt;StrictMode\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/StrictMode\u0026gt;, document.getElementById(\u0026#39;root\u0026#39;) ); 35.3 React Developer Tools React Developer Tools is a Chrome extension that allows you to inspect the React component hierarchy in the Chrome Developer Tools. Videos\n","permalink":"http://localhost:1313/posts/pages/react/react6/","summary":"Learn how to debug React applications using console.log, Strict Mode, and React Developer Tools.","title":"React : Day 6"},{"content":"Python Fundamentals: A Beginner\u0026rsquo;s Guide (Part 1) 1. Virtual Environment A virtual environment is a feature in Python that allows you to install the same package with different versions on the same system. This enables you to work on multiple projects using different versions of the same package.\n1.1. Installing venv The venv module is included in the Python standard library, so you don\u0026rsquo;t need to install it separately. However, if you are using an older version of Python (before 3.3), you can install virtualenv using pip:\npip install virtualenv 1.2. Creating a Virtual Environment To create a virtual environment, you can use the venv module, which is included in the Python standard library. Here\u0026rsquo;s how you can create a virtual environment named myenv:\npython -m venv myenv This command creates a new directory named myenv that contains the necessary files for the virtual environment.\n1.3. Activating a Virtual Environment To activate the virtual environment, you may run the following command:\n# For Linux/Mac: source myenv/bin/activate # For Windows: myenv\\Scripts\\activate 2. Python Packages 2.1. List All the Python Packages To list or save all the installed packages in the current environment, you can use the following command using freeze:\npip freeze # To list all the installed packages pip freeze \u0026gt; requirements.txt # To save all the installed packages in a file 2.2. Installing Python Packages To install a Python package, you can use the pip install command followed by the package name. For example, to install the requests package, you can run:\npip install requests 2.3. Uninstalling Python Packages To uninstall a Python package, you can use the pip uninstall command followed by the package name. For example, to uninstall the requests package, you can run:\npip uninstall requests 2.4. Run Python Package/Script To run a python package or script, you can use the following command:\npython -m package_name 3. Python Basics 3.1. Running a Python Script To run a Python script, you can use the following command:\npython script.py 3.2. Python Indentation In Python, the code block (body of the function, loop, etc.) starts with a colon (:) and the line following the colon should be indented.\nif 5 \u0026gt; 2: print(\u0026#34;Five is greater than two!\u0026#34;) # Indented block 3.3. Python Comments There are two types of comments in Python:\n# This is a single line comment \u0026#34;\u0026#34;\u0026#34; This is a multiline comment This is a multiline comment This is a multiline comment This is a multiline comment \u0026#34;\u0026#34;\u0026#34; 3.4. Print Statement The print() function is used to display the output on the console. For example:\nprint(\u0026#34;Hello, World!\u0026#34;) 3.5. Data Types Python has the following data types:\nint float str bool list tuple set dict None a = 10 # int b = 10.5 # float c = \u0026#34;Hello\u0026#34; # str d = True # bool e = [1,2,3] # list f = (1,2,3) # tuple g = {1,2,3} # set h = {\u0026#34;name\u0026#34;:\u0026#34;John\u0026#34;,\u0026#34;age\u0026#34;:30} # dict i = None # None print(type(a)) # \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; Note:Use type() function to check the data type of a variable.As it return the class of the variable.\n3.6. Rules of Variable Declaration A variable name must start with a letter or the underscore character. A variable name cannot start with a number. A variable name can only contain alpha-numeric characters and underscores (A-z, 0-9, and _ ). Variable names are case-sensitive (age, Age, and AGE are three different variables). 3.7. Type Conversion You can convert one data type to another using the following functions:\nint(): To convert to an integer float(): To convert to a float str(): To convert to a string bool(): To convert to a boolean list(): To convert to a list tuple(): To convert to a tuple set(): To convert to a set dict(): To convert to a dictionary a = 10 #a=10 b = float(a) #b=10.0 c = str(a) #c=\u0026#39;10\u0026#39; d = bool(a) #d=True e = list(c) #e=[\u0026#39;1\u0026#39;,\u0026#39;0\u0026#39;] f = tuple(c) #f=(\u0026#39;1\u0026#39;,\u0026#39;0\u0026#39;) g = set(c) #g={\u0026#39;1\u0026#39;,\u0026#39;0\u0026#39;} h = dict(name=\u0026#34;John\u0026#34;,age=30) or dict([(\u0026#34;name\u0026#34;,\u0026#34;John\u0026#34;),(\u0026#34;age\u0026#34;,30)]) #h={\u0026#39;name\u0026#39;:\u0026#39;John\u0026#39;,\u0026#39;age\u0026#39;:30} Note: Python is dynamically typed, which means a variable\u0026rsquo;s data type can be changed.\n4. Operators 4.1. Arithmetic Operators +: Addition -: Subtraction *: Multiplication /: Division %: Modulus **: Power //: Floor Division a = 10 b = 3 print(a + b) # 13 print(a - b) # 7 print(a * b) # 30 print(a / b) # 3.3333333333333335 print(a % b) # 1 print(a ** b) # 1000 print(a // b) # 3 4.2. Assignment Operators =: Assign value +=: Add and assign -=: Subtract and assign *=: Multiply and assign /=: Divide and assign %=: Modulus and assign **=: Power and assign //=: Floor Division and assign a = 10 a += 5 # a = a + 5 a -= 5 # a = a - 5 a *= 5 # a = a * 5 a /= 5 # a = a / 5 a %= 5 # a = a % 5 a **= 5 # a = a ** 5 a //= 5 # a = a // 5 4.3. Comparison Operators ==: Equal to !=: Not equal to \u0026gt;: Greater than \u0026lt;: Less than \u0026gt;=: Greater than or equal to \u0026lt;=: Less than or equal to a = 10 b = 20 print(a == b) # False print(a != b) # True print(a \u0026gt; b) # False print(a \u0026lt; b) # True print(a \u0026gt;= b) # False print(a \u0026lt;= b) # True 4.4. Logical Operators and: Returns True if both statements are true or: Returns True if one of the statements is true not: Reverse the result, returns False if the result is true a = 10 b = 20 c = 30 print(a \u0026lt; b and b \u0026lt; c) # True print(a \u0026lt; b or b \u0026gt; c) # True print(not(a \u0026lt; b and b \u0026lt; c)) # False 4.5. Identity Operators is: Returns True if both variables are the same object is not: Returns True if both variables are not the same object a = [1,2,3] b = [1,2,3] print(a is b) # False print(a is not b) # True 4.6. Membership Operators in: Returns True if a sequence with the specified value is present in the object not in: Returns True if a sequence with the specified value is not present in the object a = [1,2,3] #Can be used in list , tuple , set , dict, string print(1 in a) # True print(4 not in a) # True 4.7. Bitwise Operators \u0026amp;: AND |: OR ^: XOR ~: NOT \u0026lt;\u0026lt;: Left Shift \u0026gt;\u0026gt;: Right Shift a = 10 b = 4 print(a \u0026amp; b) # 0 print(a | b) # 14 print(a ^ b) # 14 print(~a) # -11 print(a \u0026lt;\u0026lt; 2) # 40 print(a \u0026gt;\u0026gt; 2) # 2 Note: is vs ==\nis is used to compare the memory location of two objects. == is used to compare the values of two objects. # For Mutable objects (list, dict, set): a = [1,2,3] b = [1,2,3] print(a == b) # True print(a is b) # False # For immutable objects (int, float, string, tuple, None): a = 10 b = 10 print(a == b) # True print(a is b) # True c = None d = None print(c == d) # True print(c is d) # True 5.Taking User Input In Python, you can take user input using the input() function. Here\u0026rsquo;s an example:\nname = input(\u0026#34;Enter your name: \u0026#34;) print(\u0026#34;Hello, \u0026#34; + name) Note: The input() function always returns a string. If you want to convert it to another data type, you can use type conversion functions like int(), float(), etc.\n","permalink":"http://localhost:1313/posts/pages/python/python_basics/","summary":"A comprehensive guide to Python programming fundamentals covering core concepts for beginners","title":"Python Fundamentals: A Beginner's Guide (Part 1)"},{"content":"30. Sharing State Between React Components: Lifting State Up In React, components are the building blocks of a user interface. Each component can have its own state, but there are situations where multiple components need to share the same state. In such cases, the concept of \u0026ldquo;lifting state up\u0026rdquo; is used to manage the shared state in a common ancestor component.\u0026ldquo;Lifting state up\u0026rdquo; is a common pattern in React used when two or more components need to share data or state. Instead of managing the state in one of the components and creating a dependency between them, the state is \u0026ldquo;lifted up\u0026rdquo; to the closest common ancestor of the components that need the state.\nKey Concept When multiple components need to interact with the same state:\nThe closest common ancestor is identified. The state is moved to this common ancestor. This ancestor manages the state and passes it down to the child components as props. If any child needs to modify the state, the ancestor provides a function (passed as a prop) to handle the state update. Step-by-Step Procedure and Syntax Identify the Closest Common Ancestor:\nDetermine which component is the nearest common parent of all components that need to share the state. Lift the State Up:\nMove the state to the identified ancestor component. Use the useState hook (or class component state) to manage the state. const [state, setState] = useState(initialValue); Pass State Down as Props:\nPass the state to child components that need it via props. \u0026lt;ChildComponent state={state} /\u0026gt; Create State-Modifier Functions:\nDefine functions in the ancestor component to modify the state. const modifyStateHandler = (newData) =\u0026gt; { setState((prev) =\u0026gt; ({ ...prev, newData })); }; Pass Modifier Functions to Children:\nPass these functions to the child components as props so they can trigger state updates. \u0026lt;ChildComponent onModifyState={modifyStateHandler} /\u0026gt; Use Props in Child Components:\nAccess and use the state and modifier functions passed as props in the child components. function ChildComponent({ state, onModifyState }) { return ( \u0026lt;button onClick={() =\u0026gt; onModifyState(\u0026#34;new data\u0026#34;)}\u0026gt;Modify State\u0026lt;/button\u0026gt; ); } Example (Sharing State/Data Between Two Child Component) Parent Component (App.js) The parent component will hold the shared state and provide functions for updating it. It will pass the state and update functions as props to the child components.\nimport React, { useState } from \u0026#34;react\u0026#34;; import ChildOne from \u0026#34;./ChildOne\u0026#34;; import ChildTwo from \u0026#34;./ChildTwo\u0026#34;; const App = () =\u0026gt; { // Shared state const [sharedState, setSharedState] = useState(\u0026#34;Initial State\u0026#34;); // Function to update the state const updateState = (newState) =\u0026gt; { setSharedState(newState); }; return ( \u0026lt;div style={{ padding: \u0026#34;20px\u0026#34;, fontFamily: \u0026#34;Arial\u0026#34; }}\u0026gt; \u0026lt;h1\u0026gt;Parent Component\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;Shared State: {sharedState}\u0026lt;/p\u0026gt; \u0026lt;hr /\u0026gt; \u0026lt;ChildOne sharedState={sharedState} updateState={updateState} /\u0026gt; \u0026lt;hr /\u0026gt; \u0026lt;ChildTwo sharedState={sharedState} updateState={updateState} /\u0026gt; \u0026lt;/div\u0026gt; ); }; export default App; Child Component 1 (ChildOne.js) This component will display the shared state and allow the user to modify it through an input field.\nimport React from \u0026#34;react\u0026#34;; const ChildOne = ({ sharedState, updateState }) =\u0026gt; { const handleChange = (e) =\u0026gt; { updateState(e.target.value); }; return ( \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;Child Component One\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;Shared State: {sharedState}\u0026lt;/p\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; value={sharedState} onChange={handleChange} placeholder=\u0026#34;Update State\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; ); }; export default ChildOne; Child Component 2 (ChildTwo.js) This component will display the shared state and provide a button to reset it.\nimport React from \u0026#34;react\u0026#34;; import React from \u0026#34;react\u0026#34;; const ChildTwo = ({ sharedState, updateState }) =\u0026gt; { const handleReset = () =\u0026gt; { updateState(\u0026#34;Initial State\u0026#34;); }; return ( \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;Child Component Two\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;Shared State: {sharedState}\u0026lt;/p\u0026gt; \u0026lt;button onClick={handleReset}\u0026gt;Reset State\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); }; export default ChildTwo; Folder Structure src/ ├── App.js ├── ChildOne.js ├── ChildTwo.js ├── index.js Explanation:\nThe App component is the parent component that holds the shared state and passes it down to ChildOne and ChildTwo. ChildOne and ChildTwo are child components that receive the shared state and update functions as props. ChildOne allows the user to update the shared state through an input field, while ChildTwo provides a button to reset the state. Note: We cant directly pass data from one child component to another child component. We need to pass the data to the parent component and then pass it to the other child component. This is called lifting state up.\nExample (Sharing State/Data Between Two Sibling Components) Parent Component (App.js) import {usState} from \u0026#39;react\u0026#39;; import Expenses from \u0026#39;./Expenses\u0026#39;; import NewExpense from \u0026#39;./NewExpense\u0026#39;; const App=()=\u0026gt;{ const [expenses,setExpenses]=useState([ {id:1,title:\u0026#39;Car Insurance\u0026#39;,amount:294.67,date:new Date(2021,2,28)}, {id:2,title:\u0026#39;Health Insurance\u0026#39;,amount:394.67,date:new Date(2021,3,28)}, {id:3,title:\u0026#39;Home Insurance\u0026#39;,amount:494.67,date:new Date(2021,4,28)}, ]); const addExpenseHandler=(expense)=\u0026gt;{ setExpenses((prevExpenses)=\u0026gt;{ return [expense,...prevExpenses]; }); }; return ( \u0026lt;div\u0026gt; \u0026lt;NewExpense onAddExpense={addExpenseHandler}/\u0026gt; \u0026lt;Expenses items={expenses}/\u0026gt; \u0026lt;/div\u0026gt; ); }; export default App; NewExpense Component import ExpenseForm from \u0026#39;./ExpenseForm\u0026#39;; const NewExpense=(props)=\u0026gt;{ const saveExpenseDataHandler=(enteredExpenseData)=\u0026gt;{ const expenseData={ ...enteredExpenseData, id:Math.random().toString() }; props.onAddExpense(expenseData); }; return ( \u0026lt;div\u0026gt; \u0026lt;ExpenseForm onSaveExpenseData={saveExpenseDataHandler}/\u0026gt; \u0026lt;/div\u0026gt; ); }; export default NewExpense; Expenses function Expenses({iteam}){ return ( \u0026lt;\u0026gt; {items.map((expense)=\u0026gt;( \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;{expense.title}\u0026lt;/h2\u0026gt; \u0026lt;div\u0026gt;{expense.amount}\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;{expense.date.toISOString()}\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ))} \u0026lt;/div\u0026gt; ) } 31. Dynamically setting object keys In JavaScript, object keys are usually set statically, but there are situations where you may need to set object keys dynamically based on some conditions or variables. This can be achieved using the square bracket notation ([]) to set object keys dynamically.\nfor example:\nconst data=\u0026#34;name\u0026#34;; const person={ [data]:\u0026#39;John\u0026#39; }; console.log(person); // {name:\u0026#39;John\u0026#39;} If we dont use square bracket notation, then the key will be set as \u0026lsquo;data\u0026rsquo; instead of \u0026rsquo;name\u0026rsquo;.\nconst data=\u0026#34;name\u0026#34;; const person={ data:\u0026#39;John\u0026#39; }; console.log(person); // {data:\u0026#39;John\u0026#39;} 32.Using SAme State Variable to store multiple values =\u0026gt; We can use the same state variable to store multiple values by using an object.\nconst [userInput,setUserInput]=useState({ enteredTitle:\u0026#39;\u0026#39;, enteredAmount:\u0026#39;\u0026#39;, enteredDate:\u0026#39;\u0026#39; }); const titleChangeHandler=(event)=\u0026gt;{ setUserInput({ ...userInput, enteredTitle:event.target.value }); }; const amountChangeHandler=(event)=\u0026gt;{ setUserInput({ ...userInput, enteredAmount:event.target.value }); }; const dateChangeHandler=(event)=\u0026gt;{ setUserInput({ ...userInput, enteredDate:event.target.value }); }; return ( \u0026lt;div\u0026gt; Title:\u0026lt;input type=\u0026#34;text\u0026#34; value={userInput.enteredTitle} onChange={titleChangeHandler}/\u0026gt; Amount:\u0026lt;input type=\u0026#34;number\u0026#34; value={userInput.enteredAmount} onChange={amountChangeHandler}/\u0026gt; Date:\u0026lt;input type=\u0026#34;date\u0026#34; value={userInput.enteredDate} onChange={dateChangeHandler}/\u0026gt; The entered title is {userInput.enteredTitle} The entered amount is {userInput.enteredAmount} The entered date is {userInput.enteredDate} \u0026lt;/div\u0026gt; ); =\u0026gt; In the above code, we are using the same state variable userInput to store multiple values. We are using an object to store the values. We are using the spread operator to copy the existing values of the object and then updating the required value.\n33.Handeling page reloads when a form is submitted When a form is submitted, the page reloads by default. This is not what we want in a single page application. We want to stay on the same page and update the content of the page. We can do this by using the preventDefault() method on the event object. The preventDefault() method prevents the default behavior of the event object. In this case, it prevents the page from reloading when the form is submitted. const submitHandler=(event)=\u0026gt;{ event.preventDefault(); // code to handle form submission }; ","permalink":"http://localhost:1313/posts/pages/react/react4/","summary":"Learn how to share state between React components by lifting state up to a common ancestor.","title":"React : Day 4"},{"content":"1. Python Manupulation of Data Types We have already discussed the basic concepts of Python programming in the previous part of this series. In this part, we will dive deeper into operations and manipulations of different data types in Python.\n1.1.Numeric Operations 1.1.1. abs() Function The abs() function returns the absolute value of a number. For example:\nnum = -10 print(abs(num)) # Output: 10 1.1.2. round() Function The round() function rounds a number to the nearest integer. For example:\nnum = 3.14159 print(round(num)) # Output: 3 1.1.3. ord() Function The ord() function returns the Unicode code point of a character. For example:\nchar = \u0026#39;A\u0026#39; print(ord(char)) # Output: 65 1.2. String Operations String is a sequence of characters enclosed within single, double, or triple quotes. In Python, strings are immutable, meaning they cannot be changed once created. Here are some common string operations:\n1.2.1. Declaring a String we can declare a string using single, double, or triple quotes. For example:\nstr1 = \u0026#39;Hello, World!\u0026#39; #for single line string str2 = \u0026#34;Hello, World!\u0026#34; #for single line string str3 = \u0026#39;\u0026#39;\u0026#39;Hello, World! This is a multiline string.\u0026#39;\u0026#39;\u0026#39;#for multiline string 1.2.2. Text Decorators There are many text decorators available in Python to format strings among them we use \\n for a new line, \\t for a tab. For example:\nstr1 = \u0026#39;Hello, \\nWorld!\u0026#39; #for new line str2 = \u0026#34;Hello, \\tWorld!\u0026#34; #for tab 1.2.3. String Indexing The indexing of a string starts from 0 to n-1, where n is the length of the string. For example: for example: a=\u0026ldquo;hello\u0026rdquo;\na = H e l l o 0 1 2 3 4 0 -4 -3 -2 -1 1.2.4. Ascessing Characters in a String We can access characters in a string using the index using []. For example:\nstr = \u0026#34;Hello, World!\u0026#34; print(str[0]) # Output: H print(str[-1]) # Output: ! 1.2.5. String Concatenation We can concatenate two strings using the + operator and * operator . For example:\nstr1 = \u0026#34;Hello\u0026#34; str2 = \u0026#34;World\u0026#34; print(str1 + str2) # Output: HelloWorld print(str1 * 3) # Output: HelloHelloHello 1.2.6. String Slicing We can slice a string using the syntax variable[start:end:step] to get a substring.\nNote: The substring contains characters from index start to end-1, meaning the character at the end index is not included but character at the start index is included . The step refers to the increment or jump of the index\nFor example:\na = \u0026#34;hello\u0026#34; # Slice from index 1 to the end of the string print(a[1:]) # ello (Characters from index 1 to the end) # Slice from the beginning of the string to index 4 (doesn\u0026#39;t contain character at index 4) print(a[:4]) # hell (Characters from index 0 to 3) # Slice from index 1 to index 4 (doesn\u0026#39;t contain character at index 4) print(a[1:4]) # ell (Characters from index 1 to 3) # Full slice of the string with default values print(a[::]) # hello (Default start is 0, end is the string length, step is 1) # Defining a step value in slicing # Slice with a step of 2 print(a[::2]) # hlo (Start from index 0 to the end, select every 2nd character) # Reverse the string using a negative step print(a[::-1]) # olleh (Reverse the string by stepping backward) # Combining start, end, and step print(a[1:4:2]) # el #(Start from index 1 to 4 (doesn\u0026#39;t contain character at index 4), with a step of 2) 1.2.7. String Methods Python provides various built-in methods to manipulate strings. Some of the commonly used string methods are:\nlen() : Returns the length of the string. str = \u0026#34;Hello, World!\u0026#34; print(len(str)) # Output: 13 replace() : Replaces a substring with another substring. str = \u0026#34;Hello, World!\u0026#34; print(str.replace(\u0026#34;World\u0026#34;, \u0026#34;Universe\u0026#34;)) # Output: Hello, Universe! upper() : Converts the string to uppercase. str = \u0026#34;Hello, World!\u0026#34; print(str.upper()) # Output: HELLO, WORLD! lower() : Converts the string to lowercase. str = \u0026#34;Hello, World!\u0026#34; print(str.lower()) # Output: hello, world! split() : Splits the string into a list based on the delimiter. str = \u0026#34;Hello, World!\u0026#34; print(str.split(\u0026#34;,\u0026#34;)) # Output: [\u0026#39;Hello\u0026#39;, \u0026#39; World!\u0026#39;] capitalize() : Converts the first character of the string to uppercase.\nstr = \u0026#34;hello, world!\u0026#34; print(str.capitalize()) # Output: Hello, world! -find() : Returns the index of the first occurrence of a substring.\nstr = \u0026#34;Hello, World!\u0026#34; print(str.find(\u0026#34;World\u0026#34;)) # Output: 7 print(str.find(\u0026#34;e\u0026#34;)) # Output: 1 print(str.find(\u0026#34;Universe\u0026#34;)) # Output: -1 count() : Returns the number of occurrences of a substring. str = \u0026#34;Hello, World!\u0026#34; print(str.count(\u0026#34;l\u0026#34;)) # Output: 3 startswith() : Returns True if the string starts with a specified substring. str = \u0026#34;Hello, World!\u0026#34; print(str.startswith(\u0026#34;Hello\u0026#34;)) # Output: True endswith() : Returns True if the string ends with a specified substring. str = \u0026#34;Hello, World!\u0026#34; print(str.endswith(\u0026#34;World!\u0026#34;)) # Output: True strip() : Removes leading and trailing whitespaces from the string. We can also specify the characters to be removed. str = \u0026#34; Hello, World! \u0026#34; print(str.strip()) # Output: Hello, World! str = \u0026#34;!!!!!!!!Hello, World!!!!!\u0026#34; print(str.strip(\u0026#34;!\u0026#34;)) # Output: Hello, World! lstrip() : Removes leading whitespaces from the string.we can also specify the characters to be removed. str = \u0026#34; Hello, World! \u0026#34; print(str.lstrip()) # Output: Hello, World! str = \u0026#34;!!!!!!!!Hello, World!!!!!\u0026#34; print(str.lstrip(\u0026#34;!\u0026#34;)) # Output: Hello, World!!!!! rstrip() : Removes trailing whitespaces from the string.We can also specify the characters to be removed. str = \u0026#34; Hello, World! \u0026#34; print(str.rstrip()) # Output: Hello, World! str = \u0026#34;!!!!!!!!Hello, World!!!!!\u0026#34; print(str.rstrip(\u0026#34;!\u0026#34;)) # Output: !!!!!!!!Hello, World 1.2.8. f-Strings f-strings are a convenient way to format strings in Python. They allow you to embed expressions inside string literals, using curly braces {}. For example:\nname = \u0026#34;Alice\u0026#34; age = 30 print(f\u0026#34;My name is {name} and I am {age} years old.\u0026#34;) # Output: My name is Alice and I am 30 years old. 1.2.9. Raw Strings Raw strings are used to ignore escape characters in a string. They are prefixed with an r or R. For example:\npath=\u0026#34;C:\\Users\\Alice\\Documents\u0026#34; print(path) # Output: C:UsersAliceDocuments path = r\u0026#34;C:\\Users\\Alice\\Documents\u0026#34; print(path) # Output: C:\\Users\\Alice\\Documents Note:String is immutable in python.\na = \u0026#34;Hello\u0026#34; a[0] = \u0026#34;h\u0026#34; # Error: \u0026#39;str\u0026#39; object does not support item assignment #Instead To change the string value we can use the following method a=\u0026#39;k\u0026#39;+a[1::] # Output: \u0026#39;kello\u0026#39; 1.3. List Operations A list is a collection of items enclosed within square brackets []. Lists are mutable, meaning they can be changed after creation. Here are some common list operations: Key Points:\nList is mutable in python. List support indexing and slicing like string 1.3.1. Declaring a List We can declare a list by enclosing items within square brackets []. For example:\nlist1 = [1, 2, 3, 4, 5] list2 = [\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;] list3 = [1, \u0026#34;apple\u0026#34;, True, 3.14] 1.3.2 List Concatenation We can concatenate two or more lists using the + operator. For example:\nlist1 = [1, 2, 3] list2 = [4, 5, 6] print(list1 + list2) # Output: [1, 2, 3, 4, 5, 6] 1.3.3. Mutable property of List List is mutable in python and its example is shown below:\n#for string a = \u0026#34;Hello\u0026#34; a[0] = \u0026#34;h\u0026#34; # Error: \u0026#39;str\u0026#39; object does not support item assignment #for list list1 = [1, 2, 3] list1[0] = 10 print(list1) # Output: [10, 2, 3] 1.3.4. Built-in List Methods Python provides various built-in methods to manipulate lists. Some of the commonly used list methods are:\nlen() : Returns the length of the list. list1 = [1, 2, 3, 4, 5] print(len(list1)) # Output: 5 append() : Adds an element to the end of the list /Change orginal list does not return anything. list1 = [1, 2, 3] list1.append(4) print(list1) # Output: [1, 2, 3, 4] insert() : Inserts an element at a specified position in the list /Change orginal list does not return anything. list1 = [1, 2, 3] list1.insert(1, 4) print(list1) # Output: [1, 4, 2, 3] pop() : Removes the element at the specified position in the list and returns it. If no index is specified, it removes and returns the last element. list1 = [1, 2, 3] print(list1.pop(1)) # Output: 2 print(list1) # Output: [1, 3] print(list1.pop()) # Output: 3 print(list1) # Output: [1] remove() : Removes the first occurrence of the specified element from the list. list1 = [1, 2, 3, 2] list1.remove(2) print(list1) # Output: [1, 3, 2] -sort() : Sorts the list in ascending order.Does not return anything but change the original list.\nlist1 = [3, 1, 2] list1.sort() print(list1) # Output: [1, 2, 3] -reverse() : Reverses the order of the list. Does not return anything but change the original list.\nlist1 = [1, 2, 3] list1.reverse() print(list1) # Output: [3, 2, 1] -count() : Returns the number of occurrences of a specified element in the list.\nlist1 = [1, 2, 3, 2] print(list1.count(2)) # Output: 2 -index() : Returns the index of the first occurrence of the specified element in the list.\nlist1 = [1, 2, 3, 2] print(list1.index(2)) # Output: 1 1.3.5. List Comprehension List comprehension is a concise way to create lists from existing lists. There are 3 type of syntax.\nNot using if list1=[variable for variable in iterable] Using if only list1 = [variable for variable in iterable if condition] Using if else list1 = [variable if condition else variable for variable in iterable] Traditional way of creating list\nlist1 = [] for i in range(5): list1.append(i) print(list1) # Output: [0, 1, 2, 3, 4] Using list comprehension\nlist1 = [i for i in range(5)] print(list1) # Output: [0, 1, 2, 3, 4] list1 = [i for i in range(5) if i%2==0] print(list1) # Output: [0, 2, 4] list1 = [i if i%2==0 else i**2 for i in range(5)] print(list1) # Output: [0, 1, 2, 9, 4] Note: When you attempt to access an index that is out of range, Python will raise an IndexError so put it in try-except block to handle the error.\nNote: The indexing and slicing of list are similar to string.\n1.4 Dictionary Operations A dictionary is a collection of key-value pairs enclosed within curly braces {}. Dictionaries are mutable and unordered. Here are some common dictionary operations:\n1.4.1. Declaring a Dictionary We can declare a dictionary by specifying key-value pairs within curly braces {}. For example:\ndict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} dict2 = {1: \u0026#34;apple\u0026#34;, 2: \u0026#34;banana\u0026#34;, 3: \u0026#34;cherry\u0026#34;} dict3 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;, \u0026#34;hobbies\u0026#34;: [\u0026#34;reading\u0026#34;, \u0026#34;painting\u0026#34;]} 1.4.2. Accessing Dictionary Elements We can access dictionary elements using keys. For example:\ndict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} print(dict1[\u0026#34;name\u0026#34;]) # Output: Alice 1.4.3 Adding Dictionary Elements We can add new key-value pairs to a dictionary by specifying the key and value. For example:\ndict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30} dict1[\u0026#34;city\u0026#34;] = \u0026#34;New York\u0026#34; print(dict1) # Output: {\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 30, \u0026#39;city\u0026#39;: \u0026#39;New York\u0026#39;} 1.4.4. Updating Dictionary Elements We can update the value of an existing key in a dictionary. For example:\ndict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} dict1[\u0026#34;age\u0026#34;] = 35 print(dict1) # Output: {\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 35, \u0026#39;city\u0026#39;: \u0026#39;New York\u0026#39;} 1.4.5 Dictionary Methods Python provides various built-in methods to manipulate dictionaries. Some of the commonly used dictionary methods are:\nlen() : Returns the number of key-value pairs in the dictionary. dict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} print(len(dict1)) # Output: 3 keys() : Returns a list of all the keys in the dictionary. dict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} print(dict1.keys()) # Output: dict_keys([\u0026#39;name\u0026#39;, \u0026#39;age\u0026#39;, \u0026#39;city\u0026#39;]) values() : Returns a list of all the values in the dictionary. dict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} print(dict1.values()) # Output: dict_values([\u0026#39;Alice\u0026#39;, 30, \u0026#39;New York\u0026#39;]) items() : Returns a list of key-value pairs in the dictionary. dict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} print(dict1.items()) # Output: dict_items([(\u0026#39;name\u0026#39;, \u0026#39;Alice\u0026#39;), (\u0026#39;age\u0026#39;, 30), (\u0026#39;city\u0026#39;, \u0026#39;New York\u0026#39;)]) -pop() : Removes the element with the specified key and returns its value.\ndict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} print(dict1.pop(\u0026#34;age\u0026#34;)) # Output: 30 print(dict1) # Output: {\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;city\u0026#39;: \u0026#39;New York\u0026#39;} -get() : Returns the value of the specified key. If the key does not exist, it returns the specified default value.\ndict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} print(dict1.get(\u0026#34;age\u0026#34;)) # Output: 30 print(dict) # Output: {\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 30, \u0026#39;city\u0026#39;: \u0026#39;New York\u0026#39;} Note: When you attempt to access a key that does not exist in the dictionary, Python will raise a KeyError so put it in try-except block to handle the error or use get() method to avoid the error.\n1.4.6. Nested Dictionaries A dictionary can contain another dictionary as a value. This is known as a nested dictionary. For example:\ndict1 = { \u0026#34;person1\u0026#34;: {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30}, \u0026#34;person2\u0026#34;: {\u0026#34;name\u0026#34;: \u0026#34;Bob\u0026#34;, \u0026#34;age\u0026#34;: 25} } print(dict1[\u0026#34;person1\u0026#34;][\u0026#34;name\u0026#34;]) # Output: Alice 1.4.7. Dictionary Comprehension Dictionary comprehension is a concise way to create dictionaries. For example:\ndict1 = {x: x**2 for x in range(5)} # Output: {0: 0, 1: 1, 2: 4, 3: 9, 4: 16} #using if only dict1 = {x: x**2 for x in range(5) if x%2==0} # Output: {0: 0, 2: 4, 4: 16} #using if else dict1 = {x: x**2 if x%2==0 else x**3 for x in range(5)} # Output: {0: 0, 1: 1, 2: 4, 3: 27, 4: 16} 1.5. Tuple Operations A tuple is a collection of items enclosed within parentheses (). Tuples are immutable, meaning they similar to python as they cant be changed using indexing as a[0]=10 will give an error.\n1.5.1. Declaring a Tuple We can declare a tuple by enclosing items within parentheses (). For example:\ntuple1 = (1, 2, 3) tuple2 = (\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;) tuple3 = (1, \u0026#34;apple\u0026#34;, True, 3.14) 1.5.2. Accessing Tuple Elements We can access tuple elements using indexing . For example:\ntuple1 = (1, 2, 3) print(tuple1[0]) # Output: 1 1.5.3. Slice Tuple We can slice a tuple using the syntax variable[start:end:step] to get a sub-tuple. For example:\ntuple1 = (1, 2, 3, 4, 5) print(tuple1[1:4]) # Output: (2, 3, 4) 1.5.4. Tuple Methods Python provides various built-in methods to manipulate tuples. Some of the commonly used tuple methods are:\ncount() : Returns the number of occurrences of a specified element in the tuple. tuple1 = (1, 2, 3, 2) print(tuple1.count(2)) # Output: 2 index() : Returns the index of the first occurrence of the specified element in the tuple. tuple1 = (1, 2, 3, 2) print(tuple1.index(2)) # Output: 1 len() : Returns the length of the tuple. tuple1 = (1, 2, 3, 2) print(len(tuple1)) # Output: 4 1.5.5 concatenation of tuple We can concatenate two or more tuples using the + operator. For example:\ntuple1 = (1, 2, 3) tuple2 = (4, 5, 6) print(tuple1 + tuple2) # Output: (1, 2, 3, 4, 5, 6) 1.5.6. Tuple Unpacking Tuple unpacking allows us to assign multiple variables at once. For example:\ntuple1 = (1, 2, 3) a, b, c = tuple1 d,*e = tuple1 print(a) # Output: 1 print(b) # Output: 2 print(c) # Output: 3 print(d) # Output: 1 print(e) # Output: [2, 3] tuple1 = (1, 2, 3, 4, 5) a, *b, c = tuple1 print(a) # Output: 1 print(b) # Output: [2, 3, 4] print(c) # Output: 5 Note:Ascessing and slicing of tuple is similar to list and string.\n1.6. Boolean Operations Boolean is a data type that represents one of two values: True or False. Boolean values are used to evaluate conditions in programming. Here are some common boolean operations:\n1.6.1. Condition when variable is True When a variable has a non-zero value, it is considered True. a = 10 if a: print(\u0026#34;The value of a is True\u0026#34;) When a string is not empty, it is considered True. a = \u0026#34;Hello\u0026#34; if a: print(\u0026#34;The value of a is True\u0026#34;) When a list is not empty, it is considered True. a = [1, 2, 3] if a: print(\u0026#34;The value of a is True\u0026#34;) When a dictionary is not empty, it is considered True. a = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30} if a: print(\u0026#34;The value of a is True\u0026#34;) When a tuple is not empty, it is considered True. a = (1, 2, 3) if a: print(\u0026#34;The value of a is True\u0026#34;) When a set is not empty, it is considered True. a = {1, 2, 3} if a: print(\u0026#34;The value of a is True\u0026#34;) When a variable is explicitly set to True, it is considered True. a = True if a: print(\u0026#34;The value of a is True\u0026#34;) 1.6.2. Condition when variable is False Those which are not in the above condition are considered as False.\n1.7. Set Operations A set is a collection of unique items enclosed within curly braces {}. Main Uses of set are:\nTo remove duplicate elements from a list. To perform mathematical set operations like union, intersection, difference, etc. 1.7.1. Declaring a Set We can declare a set by enclosing items within curly braces {} or set(). For example:\nset1 = {1, 2, 3} set2 = {\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;} set3 = {1, \u0026#34;apple\u0026#34;, True, 3.14} #using set() set4 = set([1, 2, 3]) set5=set() 1.7.2. Set Methods Python provides various built-in methods to manipulate sets. Some of the commonly used set methods are:\n-len() : Returns the number of elements in the set.\nset1 = {1, 2, 3} print(len(set1)) # Output: 3 -add() : Adds an element to the set.Doesn\u0026rsquo;t return anything.\nset1 = {1, 2, 3} set1.add(4) print(set1) # Output: {1, 2, 3, 4} -clear() : Removes all elements from the set.Doesn\u0026rsquo;t return anything.\nset1 = {1, 2, 3} set1.clear() print(set1) # Output: set() -remove() : Removes the specified element from the set. If the element is not present, it raises an error.\nset1 = {1, 2, 3} set1.remove(2) print(set1) # Output: {1, 3} discard() : Removes the specified element from the set. If the element is not present, it does not raise an error.\nset1 = {1, 2, 3} set1.discard(2) print(set1) # Output: {1, 3} -union() : Returns a set containing the union of two sets.\nset1 = {1, 2, 3} set2 = {3, 4, 5} print(set1.union(set2)) # Output: {1, 2, 3, 4, 5} -intersection() : Returns a set containing the intersection of two sets.\nset1 = {1, 2, 3} set2 = {3, 4, 5} print(set1.intersection(set2)) # Output: {3} -difference() : Returns a set containing the difference between two sets.\nset1 = {1, 2, 3} set2 = {3, 4, 5} print(set1.difference(set2)) # Output: {1, 2} -symmetric_difference() : Returns a set containing the symmetric difference between two sets.\nset1 = {1, 2, 3} set2 = {3, 4, 5} print(set1.symmetric_difference(set2)) # Output: {1, 2, 4, 5} -issubset() : Returns True if all elements of a set are present in another set.\nset1 = {1, 2, 3} set2 = {1, 2, 3, 4, 5} print(set1.issubset(set2)) # Output: True 1.8 Used in All iterable 1.8.1. in Operator The in operator is used to check if an element is present in an iterable. For example:\n# in string str = \u0026#34;Hello, World!\u0026#34; print(\u0026#34;Hello\u0026#34; in str) # Output: True # in list list1 = [1, 2, 3, 4, 5] print(3 in list1) # Output: True # in tuple tuple1 = (1, 2, 3, 4, 5) print(6 in tuple1) # Output: False # in set set1 = {1, 2, 3, 4, 5} print(5 in set1) # Output: True # in dictionary dict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30} print(\u0026#34;name\u0026#34; in dict1) # Output: True 1.8.2. not in Operator The not in operator is used to check if an element is not present in an iterable. For example:\n# not in string str = \u0026#34;Hello, World!\u0026#34; print(\u0026#34;Alice\u0026#34; not in str) # Output: True # not in list list1 = [1, 2, 3, 4, 5] print(6 not in list1) # Output: True # not in tuple tuple1 = (1, 2, 3, 4, 5) print(5 not in tuple1) # Output: False # not in set set1 = {1, 2, 3, 4, 5} print(5 not in set1) # Output: False # not in dictionary dict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30} print(\u0026#34;name\u0026#34; not in dict1) # Output: False 1.8.3. len() Function The len() function is used to get the length of an iterable. For example:\n# for string str = \u0026#34;Hello, World!\u0026#34; print(len(str)) # Output: 13 # for list list1 = [1, 2, 3, 4, 5] print(len(list1)) # Output: 5 # for tuple tuple1 = (1, 2, 3, 4, 5) print(len(tuple1)) # Output: 5 # for set set1 = {1, 2, 3, 4, 5} print(len(set1)) # Output: 5 # for dictionary dict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30} print(len(dict1)) # Output: 2 1.8.4. max() and min() Functions The max() function is used to get the maximum value from an iterable, and the min() function is used to get the minimum value for list,string,set and tuples only. for dictionary you can use .keys() or .values() and use it. For example:\n# for list list1 = [1, 2, 3, 4, 5] print(max(list1)) # Output: 5 print(min(list1)) # Output: 1 # for tuple tuple1 = (1, 2, 3, 4, 5) print(max(tuple1)) # Output: 5 print(min(tuple1)) # Output: 1 # for string string = \u0026#34;Hello, World!\u0026#34; print(max(string)) # Output: r print(min(string)) # Output: \u0026#39; \u0026#39; # for set set1 = {1, 2, 3, 4, 5} print(max(set1)) # Output: 5 print(min(set1)) # Output: 1 1.8.5. join() Function The join() function is used to concatenate elements of an iterable with a separator. For example:\n# for list list1 = [\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;] print(\u0026#34;, \u0026#34;.join(list1)) # Output: apple, banana, cherry # for tuple tuple1 = (\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;) print(\u0026#34;, \u0026#34;.join(tuple1)) # Output: apple, banana, cherry # for set set1 = {\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;} print(\u0026#34;, \u0026#34;.join(set1)) # Output: apple, banana, cherry # for string string = \u0026#34;Hello, World!\u0026#34; print(\u0026#34;, \u0026#34;.join(string)) # Output: H, e, l, l, o, ,, , W, o, r, l, d, ! ","permalink":"http://localhost:1313/posts/pages/python/python_datatype_operations/","summary":"An in-depth look at Python data types, exploring their usage and importance in programming.","title":"Python Fundamentals: Understanding Data Types (Part 2)"},{"content":"22. Fragments in React Fragments are a way to group multiple elements in React without adding extra nodes to the DOM. Fragments are useful when you want to return multiple elements from a component, but you don\u0026rsquo;t want to add an extra div or span element to the DOM.\nFragments are represented by the \u0026lt;Fragment\u0026gt; tag or the shorthand syntax \u0026lt;\u0026gt;. You can use fragments to return multiple elements from a component without adding extra nodes to the DOM.\nWithout using fragments:\nfunction App() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Hello, World!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;Welcome to React\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } Here, the App component returns two elements, but they are wrapped in a div element. If you don\u0026rsquo;t want to add an extra div element to the DOM, you can use fragments.\nUsing fragments:\nfunction App() { return ( \u0026lt;\u0026gt; or \u0026lt;Fragment\u0026gt; \u0026lt;h1\u0026gt;Hello, World!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;Welcome to React\u0026lt;/p\u0026gt; \u0026lt;/\u0026gt; or \u0026lt;/Fragment\u0026gt; ); } 23. Passing jsx as props In React, you can pass JSX as props to other components. This allows you to create reusable components that can be used in different parts of your application.\nPassing JSX as props: function App() { const heading = \u0026lt;div\u0026gt;\u0026lt;h1\u0026gt;Hello, World!\u0026lt;/h1\u0026gt;\u0026lt;p\u0026gt;My name is nirajan Khatiwada\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;; return \u0026lt;Greeting message={heading} /\u0026gt;; } or function App() { return \u0026lt;Greeting message={\u0026lt;div\u0026gt;\u0026lt;h1\u0026gt;Hello, World!\u0026lt;/h1\u0026gt;\u0026lt;p\u0026gt;My name is nirajan Khatiwada\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;} /\u0026gt;; } Using props in the Greeting component: function Greeting(props) { return \u0026lt;div\u0026gt;{props.message}\u0026lt;/div\u0026gt;; } Passing built-in components as props: function App() { return \u0026lt;Greeting element=\u0026#34;button\u0026#34; /\u0026gt;; } 24. Isolation of Component in React Isolation of components is a key concept in React that allows you to create reusable components that are independent of each other. This means that each component should be self-contained and not rely on external data or state.\nfor example:\nfunction Button(props){ const [showText, setShowText] = useState(false); return ( \u0026lt;button onClick={() =\u0026gt; setShowText(!showText)}\u0026gt; {showText ? \u0026#39;Hide Text\u0026#39; : \u0026#39;Show Text\u0026#39;} \u0026lt;/button\u0026gt; ); } function App(){ return ( \u0026lt;div\u0026gt; \u0026lt;Button /\u0026gt; \u0026lt;Button /\u0026gt; \u0026lt;/div\u0026gt; ); } Here The component Button is isolated means one state of the component does not affect the other component. Each component is self-contained and does not rely on external data or state. for example, the showText state in one Button component does not affect the showText state in the other Button component.\n25. Taking User Input in React Using onChange event: function App() { const [name, setName] = useState(\u0026#39;\u0026#39;); const handleChange = (e) =\u0026gt; { setName(e.target.value); }; return ( \u0026lt;div\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; value={name} onChange={handleChange} /\u0026gt; \u0026lt;p\u0026gt;Hello, {name}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } Whats Happen Here\nHere, we have an input element that takes user input. When the user types in the input field,the onChange event is triggered for ervy keypress. The handleChange function is called with the event object as an argument for every keypress. The setName function is called with value of user input and it rerender the component with the updated value for every keypress. The value of the input field is set to the name state, and the name is displayed below the input field. Note: use onChange event to take user input in React and update the state accordingly to reflect the changes in the UI. If you use value as a prop in the input field, you must also provide an onChange event handler to update the state. Use this method if you want to update in real-time as the user types in the input field.\nOther method will be discussed in upcoming posts. 26.Rendering 2D Arrays in React In React, you can render 2D arrays by using nested map functions to iterate over the rows and columns of the array. This allows you to display tabular data or grid-like structures in your application.\nRendering a 2D array: function App() { const data = [ [\u0026#39;John\u0026#39;, \u0026#39;Doe\u0026#39;, 30], [\u0026#39;Jane\u0026#39;, \u0026#39;Smith\u0026#39;, 25], [\u0026#39;Alice\u0026#39;, \u0026#39;Brown\u0026#39;, 35], ]; return ( \u0026lt;table\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;First Name\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Last Name\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Age\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; {data.map((row, index) =\u0026gt; ( \u0026lt;tr key={index}\u0026gt; {row.map((cell, index) =\u0026gt; ( \u0026lt;td key={index}\u0026gt;{cell}\u0026lt;/td\u0026gt; ))} \u0026lt;/tr\u0026gt; ))} \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; ); } 27. Immutable update patterns in React In react while changing the state we shouldnot change the orginal state directly Instead, we should create a new copy of the state and update the copy with the new values. This is known as immutable update pattern.speciaaly when working with arrays and objects.\nThe Wrong way to update state: function App() { const [items, setItems] = useState([\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;cherry\u0026#39;]); const removeItem = (index) =\u0026gt; { items.splice(index, 1); setItems(items); }; return ( \u0026lt;div\u0026gt; \u0026lt;ul\u0026gt; {items.map((item, index) =\u0026gt; ( \u0026lt;li key={index}\u0026gt; {item} \u0026lt;button onClick={() =\u0026gt; removeItem(index)}\u0026gt;Remove\u0026lt;/button\u0026gt; \u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ); } The Correct way to update state: function App() { const [items, setItems] = useState([\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;cherry\u0026#39;]); const removeItem = (index) =\u0026gt; { const newItems = [...items]; newItems.splice(index, 1); setItems(newItems); }; return ( \u0026lt;div\u0026gt; \u0026lt;ul\u0026gt; {items.map((item, index) =\u0026gt; ( \u0026lt;li key={index}\u0026gt; {item} \u0026lt;button onClick={() =\u0026gt; removeItem(index)}\u0026gt;Remove\u0026lt;/button\u0026gt; \u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt;x x \u0026lt;/div\u0026gt; ); } Note: Always create a new copy of the state when updating arrays or objects in React. This ensures that the state is updated correctly and prevents unexpected behavior in your application. 28. Common Pattern for update,delete and add in React In React, you can use common patterns to update, delete, and add items to an array. These patterns involve creating new copies of the array and updating the state with the new values.\nAdd an item to an array: function App() { const [items, setItems] = useState([\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;cherry\u0026#39;]); const addItem = (item) =\u0026gt; { setItems([...items, item]); // or // const newItems = [...items]; // newItems.push(item); // setItems(newItems); }; return ( \u0026lt;div\u0026gt; \u0026lt;ul\u0026gt; {items.map((item, index) =\u0026gt; ( \u0026lt;li key={index}\u0026gt;{item}\u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;button onClick={() =\u0026gt; addItem(\u0026#39;orange\u0026#39;)}\u0026gt;Add Item\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } Deleting an item from an array: function App() { const [items, setItems] = useState([\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;cherry\u0026#39;]); const removeItem = (index) =\u0026gt; { const newItems = items.filter((item, i) =\u0026gt; i !== index); setItems(newItems); }; return ( \u0026lt;div\u0026gt; \u0026lt;ul\u0026gt; {items.map((item, index) =\u0026gt; ( \u0026lt;li key={index}\u0026gt; {item} \u0026lt;button onClick={() =\u0026gt; removeItem(index)}\u0026gt;Remove\u0026lt;/button\u0026gt; \u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ); } Updating an data of an array using map: function App() { const [items, setItems] = useState([ { id: 1, name: \u0026#39;apple\u0026#39;, price: 1 }, { id: 2, name: \u0026#39;banana\u0026#39;, price: 2 }, { id: 3, name: \u0026#39;cherry\u0026#39;, price: 3 }, ]); const updateItem = (id, price) =\u0026gt; { const newItems = items.map((item) =\u0026gt; item.id === id ? { ...item, price: price } : item ); setItems(newItems); }; return ( \u0026lt;div\u0026gt; \u0026lt;ul\u0026gt; {items.map((item) =\u0026gt; ( \u0026lt;li key={item.id}\u0026gt; {item.name} - ${item.price}{\u0026#39; \u0026#39;} \u0026lt;button onClick={() =\u0026gt; updateItem(item.id, item.price + 1)}\u0026gt; Increase Price \u0026lt;/button\u0026gt; \u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ); } Updating an data of an array using find: function App() { const [items, setItems] = useState([ { id: 1, name: \u0026#39;apple\u0026#39;, price: 1 }, { id: 2, name: \u0026#39;banana\u0026#39;, price: 2 }, { id: 3, name: \u0026#39;cherry\u0026#39;, price: 3 }, ]); const updateItem = (id, price) =\u0026gt; { const newItems= [...items]; const newItem = newItems.find((item) =\u0026gt; item.id === id); if (newItem) { newItem.price = price; setItems(newItems); } }; return ( \u0026lt;div\u0026gt; \u0026lt;ul\u0026gt; {items.map((item) =\u0026gt; ( \u0026lt;li key={item.id}\u0026gt; {item.name} - ${item.price}{\u0026#39; \u0026#39;} \u0026lt;button onClick={() =\u0026gt; updateItem(item.id, item.price + 1)}\u0026gt; Increase Price \u0026lt;/button\u0026gt; \u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ); } Note: Always prefer map over find when updating an array of objects in React. This ensures that the state is updated correctly and prevents unexpected behavior in your application.\n29.Updating object in react In React, you can update an object in state by creating a new copy of the object and updating the copy with the new values. This ensures that the state is updated correctly and prevents unexpected behavior in your application.\nUpdating an object in state: function App() { const [person, setPerson] = useState({ name: \u0026#39;John\u0026#39;, age: 30 }); const updatePerson = () =\u0026gt; { setPerson({ ...person, age: person.age + 1 }); }; return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;Name: {person.name}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Age: {person.age}\u0026lt;/p\u0026gt; \u0026lt;button onClick={updatePerson}\u0026gt;Increase Age\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } use list if you want to show the list of items and use object if you want to show the details of the item to identify which one is clicked or update you can pass the index or id of the item to the function. Or you can hardcode the value to update the object or list.\n","permalink":"http://localhost:1313/posts/pages/react/react3/","summary":"A comprehensive guide covering React\u0026rsquo;s advanced concepts including Fragments, JSX Props, Component Isolation, and proper state management patterns","title":"React : Day 3"},{"content":"Python Control Structures: Mastering Loops and Conditionals In Python programming, control structures are essential for managing the flow of execution in your code. They allow you to make decisions, repeat tasks, and create complex algorithms. In this guide, we will explore two fundamental control structures in Python: loops and conditionals.\n1. Conditional Statements Conditional statements in Python allow you to execute specific blocks of code based on certain conditions. The most common conditional statements are if, elif, and else.\n1.1. The if Statement The if statement is used to check a condition and execute a block of code if the condition is true.\nExample:\nx = 10 if x \u0026gt; 5: print(\u0026#34;x is greater than 5\u0026#34;) Output:\nx is greater than 5 1.2. The elif Statement The elif statement allows you to check multiple conditions after the initial if statement. If the previous conditions are false, the elif block is evaluated.\nExample:\nx = 5 if x \u0026gt; 5: print(\u0026#34;x is greater than 5\u0026#34;) elif x == 5: print(\u0026#34;x is equal to 5\u0026#34;) Output:\nx is equal to 5 1.3. The else Statement The else statement is used to execute a block of code when all the previous conditions are false.\nExample:\nx = 3 if x \u0026gt; 5: print(\u0026#34;x is greater than 5\u0026#34;) elif x == 5: print(\u0026#34;x is equal to 5\u0026#34;) else: print(\u0026#34;x is less than 5\u0026#34;) Output:\nx is less than 5 2. Loops Loops in Python allow you to execute a block of code repeatedly. There are two main types of loops in Python: for loops and while loops.\n2.1. The while Loop The while loop executes a block of code as long as a specified condition is true.\nSyntax:\nwhile condition: # Code block else: # Optional else block Example:\ncount = 0 while count \u0026lt; 5: print(count) count += 1 else: print(\u0026#34;Loop completed\u0026#34;) 2.2. The for Loop The for loop is used to iterate over a sequence (such as a list, tuple, or string) and execute a block of code for each item in the sequence.\nSyntax:\nfor item in sequence: # Code block else: # Optional else block Example:\nfruits = [\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;] for fruit in fruits: print(fruit) else: print(\u0026#34;No more fruits\u0026#34;) 2.3 Using For Loops with different data types 2.3.1. For Loop with Strings Example:\nfor char in \u0026#34;Python\u0026#34;: print(char) Output:\np\ry\rt\rh\ro\rn 2.3.2. For Loop with Lists Example:\nnumbers = [1, 2, 3, 4, 5] for num in numbers: print(num) Output:\n1\r2\r3\r4\r5 2.3.3. For Loop with tuples Example:\nfruits = (\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;) for fruit in fruits: print(fruit) Output:\napple\rbanana\rcherry Tuple unpacking can also be used in for loops to iterate over multiple values in a tuple.\ncoordinates = [(1, 2), (3, 4), (5, 6)] for x, y in coordinates: print(f\u0026#34;X: {x}, Y: {y}\u0026#34;) Output:\nX: 1, Y: 2\rX: 3, Y: 4\rX: 5, Y: 6 2.3.4. For Loop with Sets Example:\ncolors = {\u0026#34;red\u0026#34;, \u0026#34;green\u0026#34;, \u0026#34;blue\u0026#34;} for color in colors: print(color) Output:\nred\rgreen\rblue 2.3.5. For Loop with Dictionaries Example:\nperson = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} for key, value in person.items(): print(f\u0026#34;{key}: {value}\u0026#34;) Output:\nname: Alice\rage: 30\rcity: New York 2.4. break , pass and continue statements in loops 2.4.1. The break Statement The break statement is used to exit a loop prematurely. It terminates the current loop and resumes execution at the next statement after the loop.\nExample:\nfor num in [1, 2, 3, 4, 5]: if num == 3: break print(num) Output:\n1\r2 2.4.2. The continue Statement The continue statement is used to skip the rest of the code inside a loop for the current iteration and jump to the next iteration.\nExample:\nfor num in [1, 2, 3, 4, 5]: if num == 3: continue print(num) Output:\n1\r2\r4\r5 2.4.3. The pass Statement The pass statement is a null operation that does nothing. It is used when a statement is required syntactically but you do not want any code to execute.\nExample:\nfor num in [1, 2, 3, 4, 5]: pass ","permalink":"http://localhost:1313/posts/pages/python/python_control_structure/","summary":"A detailed examination of Python\u0026rsquo;s control structures, focusing on loops and conditionals to enhance your programming skills.","title":"Python Fundamentals: Mastering Control Structures (Part 3)"},{"content":"17. Hooks in React Anythong that start with prefix use is considered as a hook in react\n17.1. Rules of Hooks Only Call Hook inside a component function correct:\nfunction App() { const [val, setVal] = useState(0); } Incorrect:\nconst [val, setVal] = useState(0); function App() { } Only Call Hooks at the Top Level Hook must not be called inside code statement (e.g., inside an if statement, loop, or nested function). correct: function App() { const [val, setVal] = useState(0); } incorrect:\nfunction App() { if (true) { const [val, setVal] = useState(0); } } 3.Hook can be used inside other custom hooks too\n18. useState Hook useState is a React hook that allows you to manage component-specific state. It provides a way to declare state variables in functional components and ensure that changes to these variables cause the component or child component to re-render while the parent component remains unaffected from where the component whose set state is triggered.\nfor example:\nfunction App() { return ( \u0026lt;div\u0026gt; \u0026lt;MemoComp /\u0026gt; \u0026lt;/div\u0026gt; ); } function MemoComp() { const [data, setData] = useState(\u0026#34;No data\u0026#34;); function handle() { setData(\u0026#34;data\u0026#34;); } return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;{data}\u0026lt;/p\u0026gt; \u0026lt;button onClick={handle}\u0026gt;Click me\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } When button is clicked the handle function is called and the setData function is called which updates the data state variable. This cause the MemoComp and its child component to re-render with a new value of data.\n18.1. Syntax const [state, setState] = useState(initialState); 18.2. Managing State State management in React involves handling data and telling React to re-execute a function using the useState hook. This ensures that state updates lead to new state values. Example:\nconst [countes, setcountes] = useState(0); countes is the state variable that holds the current state value. setcountes is the function that updates the state variable. useState(0) is the initial state value. How it works: Initially, the state variable countes is set to 0. When the setcountes function is called, it updates the state variable to a new value. This triggers a re-render of the component, updating the UI with the new state value.\n18.3 Updating State Based on Previous State Suppose the age is 42. The handler calls setAge(age + 1) three times.\nfunction handleClick() { setAge(age + 1); // setAge(42 + 1) setAge(age + 1); // setAge(42 + 1) setAge(age + 1); // setAge(42 + 1) } if the initial age is 42, after calling this function, the age will be 43, not 45.\nTo solve this problem, we use an updater function to pass setAge calls.\nfunction handleClick() { setAge(a =\u0026gt; a + 1); // setAge(42 =\u0026gt; 43) setAge(a =\u0026gt; a + 1); // setAge(43 =\u0026gt; 44) setAge(a =\u0026gt; a + 1); // setAge(44 =\u0026gt; 45) } After this age will be 45 so use updater function when you want to update value based on previous value \u0026amp; it\u0026rsquo;s always recommended to use updater function in.\nIt is mostly used in:\nCounters Toggles Incrementing or decrementing a value 18.4. Pitfalls in useState In React state updates are asynchronous meaning they don\u0026rsquo;t immediately reflect in the current execution cycle. When you call a state setter function like setSelectedValue, React schedules the state update for the next render. This can lead to unexpected behavior if you try to access the updated state immediately after setting it.\nExample: function clickHandler(data) { setSelectedValue(`${data} is being clicked`); console.log(selectedTopic); // logs the old state, not updated one } Why It Happens State updates are asynchronous: React batches state updates and applies them during the next render cycle to optimize performance. Therefore, the state change you request won’t be immediately reflected in the current execution.\nLogging state immediately: Since the update happens after the current execution cycle, logging the state/selected topic immediately after calling setSelectedValue will show the old value (before the update).\nThis can be fixed using useEffect which is read later.\nNote: Always use the state variable when you want to reflect the changes in the UI.\n19. An Example demostrating useState Hook import {useState} from \u0026#39;react\u0026#39;; function App(){ const [count,setCount] = useState(0); return(){ \u0026lt;div\u0026gt; {count} \u0026lt;/div\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;Increment\u0026lt;/button\u0026gt; } } export default App; In the above example, we have a functional component App that uses the useState hook to manage the state of the count variable. The initial value of count is set to 0 using useState(0). The setCount function is used to update the value of count when the button is clicked. The count value is displayed in the UI, and clicking the button increments the count value by 1.\n20.Conditional Rendering in React Conditional rendering is a technique used to render different components or elements based on certain conditions. In React, conditional rendering can be achieved using ternary operators, and logical operators like \u0026amp;\u0026amp; .\n20.1. Ternary Operator The ternary operator is a concise way to write conditional statements in JavaScript. It consists of a condition followed by a question mark ?, an expression to execute if the condition is true, a colon :, and an expression to execute if the condition is false.\nExample:\nfunction App() { const isLoggedIn = true; return ( \u0026lt;div\u0026gt; {isLoggedIn ? \u0026lt;p\u0026gt;Welcome, User!\u0026lt;/p\u0026gt; : \u0026lt;p\u0026gt;Please log in\u0026lt;/p\u0026gt;} \u0026lt;/div\u0026gt; ); } Also We can write jsx code in variable and use it in return statement\nfunction App() { const isLoggedIn = true; const welcomeMessage=\u0026lt;p\u0026gt;Welcome, User!\u0026lt;/p\u0026gt;; const loginMessage=\u0026lt;p\u0026gt;Please log in\u0026lt;/p\u0026gt;; return ( \u0026lt;div\u0026gt; {isLoggedIn ? welcomeMessage : loginMessage} \u0026lt;/div\u0026gt; ); } 20.2. Logical \u0026amp;\u0026amp; Operator The logical \u0026amp;\u0026amp; operator is another way to conditionally render elements in React. The \u0026amp;\u0026amp; operator works by evaluating the expression on the left side of the \u0026amp;\u0026amp; operator. If the expression is true, the expression on the right side of the \u0026amp;\u0026amp; operator is executed. If the expression is false, the right side is not executed.\nExample:\nfunction App() { const isLoggedIn = true; return ( \u0026lt;div\u0026gt; {isLoggedIn \u0026amp;\u0026amp; \u0026lt;p\u0026gt;Welcome, User!\u0026lt;/p\u0026gt;} {isLoggedIn \u0026amp;\u0026amp; \u0026lt;button\u0026gt;Logout\u0026lt;/button\u0026gt;} {!isLoggedIn \u0026amp;\u0026amp; \u0026lt;p\u0026gt;Please log in\u0026lt;/p\u0026gt;} \u0026lt;/div\u0026gt; ); } Also We can write jsx code in variable and use it in return statement\nfunction App() { const isLoggedIn = true; const welcomeMessage=\u0026lt;p\u0026gt;Welcome, User!\u0026lt;/p\u0026gt;; const logoutButton=\u0026lt;button\u0026gt;Logout\u0026lt;/button\u0026gt;; const loginMessage=\u0026lt;p\u0026gt;Please log in\u0026lt;/p\u0026gt;; return ( \u0026lt;div\u0026gt; {isLoggedIn \u0026amp;\u0026amp; welcomeMessage} {isLoggedIn \u0026amp;\u0026amp; logoutButton} {!isLoggedIn \u0026amp;\u0026amp; loginMessage} \u0026lt;/div\u0026gt; ); } 21.Outputting list data dynamically In react we use map function to output list data dynamically as using map.\n21.1. Have a list of data You typically store the list in an array, which might come from a state, props, or external data source like an API\nconst data = [ { id: 1, name: \u0026#34;John\u0026#34; }, { id: 2, name: \u0026#34;Doe\u0026#34; }, { id: 3, name: \u0026#34;Jane\u0026#34; }, ]; 21.2 Using map function to output list data const listItems = data.map((item) =\u0026gt; \u0026lt;li key={item.id}\u0026gt;{item.name}\u0026lt;/li\u0026gt;); Key is used to uniquely identify each element in the list. It helps React identify which items have changed, are added, or are removed.It can be number or string.\n21.3. Rendering the list Use {} to embed the transformed list inside your component’s JSX.\n\u0026lt;ul\u0026gt;{listItems}\u0026lt;/ul\u0026gt;; 21.4. Putting it all together function App() { const data = [ { id: 1, name: \u0026#34;John\u0026#34; }, { id: 2, name: \u0026#34;Doe\u0026#34; }, { id: 3, name: \u0026#34;Jane\u0026#34; }, ]; const listItems = data.map((item) =\u0026gt; \u0026lt;li key={item.id}\u0026gt;{item.name}\u0026lt;/li\u0026gt;); return \u0026lt;ul\u0026gt;{listItems}\u0026lt;/ul\u0026gt;; } 21.5 Another form function App() { const data = [ { id: 1, name: \u0026#34;John\u0026#34; }, { id: 2, name: \u0026#34;Doe\u0026#34; }, { id: 3, name: \u0026#34;Jane\u0026#34; }, ]; return \u0026lt;ul\u0026gt;{data.map((item) =\u0026gt; \u0026lt;li key={item.id}\u0026gt;{item.name}\u0026lt;/li\u0026gt;); }\u0026lt;/ul\u0026gt;; } When will Rerender Occur?\nWhen state varaible or props value changes ","permalink":"http://localhost:1313/posts/pages/react/react1/","summary":"A detailed guide to help you understand and use hooks in React effectively.","title":"React : Day 2"},{"content":"Python Fundamentals: Exploring Advanced Operations (Part 4) In Python programming, advanced operations allow you to perform complex tasks efficiently. These operations include working with ranges, enumerations, zip functions, and more. In this guide, we will explore various advanced operations in Python to enhance your programming skills.\n1. Ranges Ranges in Python are used to generate a sequence of numbers. They are commonly used in loops to iterate over a specific range of values. Ranges can be created using the range() function.\n1.1. Creating a Range To create a range of numbers, you can use the range() function with the desired start, stop, and step values where start number is in inclusive and stop number is exclusive.\nExample:\n# Generate a range of numbers from 0 to 9 for i in range(10): print(i) Output:\n0\r1\r2\r3\r4\r5\r6\r7\r8\r9 Example:\n# Generate a range of numbers from 1 to 10 with a step of 2 for i in range(0, 10,2): print(i) Output:\n0\r2\r4\r6\r8 1.2 Enumerate Function The enumerate() function in Python is used to iterate over a sequence while keeping track of the index and value of each item. It returns a tuple containing the index and the value of the item.\nExample:\n# Enumerate a list of fruits fruits = [\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;cherry\u0026#39;] for index, fruit in enumerate(fruits): print(index, fruit) Output:\n0 apple\r1 banana\r2 cherry Example:\na=\u0026#34;nirajan\u0026#34; for index, char in enumerate(a): print(index, char) Output:\n0 n\r1 i\r2 r\r3 a\r4 j\r5 a\r6 n 1.3. Zip Function The zip() function in Python is used to combine multiple iterables (such as lists) element-wise. It returns an iterator of tuples where the i-th tuple contains the i-th element from each of the input iterables.\nExample:\n# Zip two lists together names = [\u0026#39;Alice\u0026#39;, \u0026#39;Bob\u0026#39;, \u0026#39;Charlie\u0026#39;] ages = [25, 30, 35] for name, age in zip(names, ages): print(name, age) Output:\nAlice 25\rBob 30\rCharlie 35 Example:\na=[1,2,3] b=[4,5,6] c=[7,8,9] print(list(zip(a,b,c))) Output:\n[(1, 4, 7), (2, 5, 8), (3, 6, 9)] 1.5 Sorted Function The sorted() function in Python is used to sort a list of elements. It returns a new sorted list without modifying the original list.The main feature of the sorted() function is that it can take a key argument that specifies a function to be called on each list element prior to making comparisons.\nExample:\n# Sort a list of numbers numbers = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5] sorted_numbers = sorted(numbers) print(sorted_numbers) Output:\n[1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] Example:\n# Sort a list of strings based on the length of the string fruits = [\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;cherry\u0026#39;, \u0026#39;date\u0026#39;] sorted_fruits = sorted(fruits, key=len) print(sorted_fruits) Output:\n[\u0026#39;date\u0026#39;, \u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;cherry\u0026#39;] Example:\n#Sort an dictionary based on the value d = {\u0026#39;apple\u0026#39;: 10, \u0026#39;banana\u0026#39;: 5, \u0026#39;cherry\u0026#39;: 15} sorted_d = sorted(d.items(), key=lambda x: x[1]) print(sorted_d) Output:\n[(\u0026#39;banana\u0026#39;, 5), (\u0026#39;apple\u0026#39;, 10), (\u0026#39;cherry\u0026#39;, 15)] Example:\n#Sort a list of tuples based on the second element t = [(1, 2), (3, 1), (5, 6)] sorted_t = sorted(t, key=lambda x: x[1]) print(sorted_t) Output:\n[(3, 1), (1, 2), (5, 6)] #2. Import in Python In Python, the import statement is used to import modules or packages into your script. It allows you to use functions, classes, and variables defined in other modules in your code.\n2.1. Importing Modules To import a module in Python, you can use the import keyword followed by the module name. You can then access the functions, classes, and variables defined in the module using dot notation.\nExample:\n# Import the math module import math # Calculate the square root of a number x = 16 print(math.sqrt(x)) Output:\n4.0 Example:\n# Import the datetime module import datetime # Get the current date and time now = datetime.datetime.now() print(now) Output:\n2024-11-17 10:30:00 2.2. Importing Specific Functions You can import specific functions or variables from a module using the from keyword. This allows you to use the imported functions directly without using the module name.\nExample:\n# Import the pi constant from the math module from math import pi # Print the value of pi print(pi) Output:\n3.141592653589793 Example:\n# Import the date class from the datetime module from datetime import date # Get the current date today = date.today() print(today) Output:\n2024-11-17 2.3. Aliasing Modules You can alias a module or package by using the as keyword. This allows you to refer to the module by a different name in your code.\nExample:\n# Import the math module and alias it as m import math as m # Calculate the square root of a number x = 25 print(m.sqrt(x)) Output:\n5.0 Example:\n# Import the datetime module using import and from and alias it as dt from datetime import datetime as dt now = dt.now() print(now) Output:\n2024-11-17 10:30:00 2.4. Importing All Functions You can import all functions and variables from a module using the * operator. This imports all the functions and variables defined in the module.\nExample:\n# Import all functions from the math module from math import * # Calculate the square root of a number x = 36 print(sqrt(x)) Output:\n6.0 The General Syntax is\nfrom module_name.submodule_name.submodule_name... import funtion_name or variable_name or filename as alias_name\nrandom module The random module in Python is used to generate random numbers. It provides various functions to generate random integers, floating-point numbers, and sequences.\n1. Generating Random Numbers The random module provides functions to generate random numbers within a specified range which can contain both integers starting and ending number.\nExample:\nfrom random import randint # Generate a random integer between 1 and 10 random_number = randint(1, 10) print(random_number) Output:\n5 2.Shuffling a List The random module provides a function to shuffle the elements of a list randomly. It modifies the original list in place.\nExample:\nfrom random import shuffle # Shuffle a list of numbers numbers = [1, 2, 3, 4, 5] shuffle(numbers) print(numbers) Output:\n[3, 1, 5, 2, 4] ","permalink":"http://localhost:1313/posts/pages/python/python_advanced_operations/","summary":"An in-depth exploration of advanced Python operations to enhance your programming skills.","title":"Python Fundamentals: Exploring Advanced Operations (Part 4)"},{"content":"Python Fundamentals: Understanding Functions In Python programming, functions are essential building blocks that allow you to organize and reuse code effectively. Functions help break down complex problems into smaller, manageable tasks, making your code more readable and maintainable. In this guide, we will explore the fundamentals of Python functions, including their syntax, parameters, return values, and more.\n1. Defining Functions A function in Python is defined using the def keyword followed by the function name and parentheses. You can also specify parameters inside the parentheses if the function requires input values.\nSyntax:\ndef function_name(parameters): # Function body # Statements Example:\ndef greet(): print(\u0026#34;Hello, World!\u0026#34;) 2. Calling Functions To call a function in Python, you simply write the function name followed by parentheses. If the function requires input values, you can pass them inside the parentheses.\nSyntax:\nfunction_name(arguments) Example:\ngreet() 3. return Statement The return statement in Python is used to exit a function and return a value to the caller. You can use the return statement to send a result back to the calling code.\nSyntax:\ndef function_name(parameters): # Function body return value Demostration using all:\ndef add_numbers(a, b): return a + b result = add_numbers(5, 3) print(result) 4. Args , Default Args and Kwargs 4.1. Args Using Args you can pass any number of arguments to a function. The arguments are passed as a tuple.\nSyntax:\ndef function_name(*args): # Function body Example:\ndef display_args(*args): print(args) display_args(1, 2, 3, 4, 5) Output:\n(1, 2, 3, 4, 5) 4.2. Default Args Default arguments are used when you do not pass a value for an argument in the function call. If a value is not provided, the default value is used.\nSyntax:\ndef function_name(arg=value): # Function body Example:\ndef add(a,b,c=0): return a+b+c result = add(5,3) print(result) result = add(5,3,2) print(result) Output:\n8\r10 4.3. Kwargs Using Kwargs you can pass any number of keyword arguments to a function. The arguments are passed as a dictionary.\nSyntax:\ndef function_name(**kwargs): # Function body Example:\ndef display_kwargs(**kwargs): print(kwargs) display_kwargs(name=\u0026#34;Alice\u0026#34;, age=30, city=\u0026#34;New York\u0026#34;) Output:\n{\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 30, \u0026#39;city\u0026#39;: \u0026#39;New York\u0026#39;} 4.4. Combination of Args and Kwargs Example:\ndef display_args_kwargs(*args, **kwargs): print(args) print(kwargs) display_args_kwargs(1, 2, 3, name=\u0026#34;Alice\u0026#34;, age=30) Output:\n(1, 2, 3)\r{\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 30} 4.5. Unpacking Args and Kwargs Example:\ndef display_args_kwargs(*args, **kwargs): print(args) print(kwargs) args = (1, 2, 3) kwargs = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30} display_args_kwargs(*args, **kwargs) Output:\n(1, 2, 3)\r{\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 30} 5. Lambda Functions Lambda functions, also known as anonymous functions, are small, single-expression functions that do not require a name. They are defined using the lambda keyword.\nSyntax:\nlambda arguments: expression Example:\nadd = lambda a, b: a + b result = add(5, 3) print(result) Output:\n8 6.Map and filter functions 6.1. Map Function The map() function in Python applies a given function to each item of an iterable (such as a list, tuple, or set) and returns a new iterable with the results.\nSyntax:\nmap(function, iterable) Example:\nnumbers = [1, 2, 3, 4, 5] squared = map(lambda x: x ** 2, numbers) print(list(squared)) Output:\n[1, 4, 9, 16, 25] 6.2. Filter Function The filter() function in Python filters elements from an iterable based on a given function. It returns an iterator with the elements that satisfy the condition.\nSyntax:\nfilter(function, iterable) Example:\nnumbers = [1, 2, 3, 4, 5] even = filter(lambda x: x % 2 == 0, numbers) print(list(even)) Output:\n[2, 4] 7.Local and Global Variables 7.1. Local Variables Local variables are defined within a function and are only accessible within that function. They are created when the function is called and destroyed when the function exits.\nExample:\ndef display(): message = \u0026#34;Hello, World!\u0026#34; print(message) display() # Trying to access the local variable outside the function will result in an error print(message) # NameError: name \u0026#39;message\u0026#39; is not defined 7.2. Global Variables Global variables are defined outside any function and can be accessed from any part of the code. You can use the global keyword to modify a global variable inside a function.\nExample:\nmessage = \u0026#34;Hello, World!\u0026#34; def display(): print(message) display() # Modifying a global variable inside a function def change_message(): global message message = \u0026#34;Hello, Python!\u0026#34; change_message() print(message) Output:\nHello, World!\rHello, Python! 7.3. Local vs. Global Variables If a local variable has the same name as a global variable, the local variable takes precedence within the function scope.\nExample:\nmessage = \u0026#34;Hello, World!\u0026#34; def display(): message = \u0026#34;Hello, Python!\u0026#34; print(message) display() print(message) Output:\nHello, Python!\rHello, World! ","permalink":"http://localhost:1313/posts/pages/python/python_function/","summary":"An in-depth exploration of Python functions, their usage, and importance in programming.","title":"Python Fundamentals: Understanding Functions (Part 5)"},{"content":"1. Create A React Project To create a React app we use Vite and its command is:\nnpm create vite@latest 2. Component In a React application, one page is broken down into multiple components. Components allow:\nReusability: For example, we can create one component for cards and use it to create multiple cards with different data. Related code lives together: Related items (JS code) are stored together. Separation of logic: Different components handle different data and logic. Diagram 3. Folder Structure my-app/\r├─ node_modules/\r├─ public/\r│ ├─ index.html\r│ ├─ image.png\r│ └─ favicon.ico\r├─ src/\r│ ├─ index.js\r│ ├─ App.js\r│ ├─ App.css\r│ └─ index.css\r├─ package.json\r└─ README.md node_module: Contains all the files of installed packages.\npublic: All static files are kept in this folder. For example, if image.png is in public, we can access it in the browser as 127.0.0.1:8000/image.png.\nindex.html: It is the page that is served to us and its content is managed by React using the DOM.Modify this file if you want to change the title or favicon.\npackage.json: Contains all the configuration of the project, package list, versions, and all related information.\nsrc: This is the folder where all the code is written.\nsrc/index.js React runs this file first.Code of index.js\nThe DOM selects the element of index.html whose id is root because of this code: document.getElementById('root') Then render() renders the \u0026lt;App/\u0026gt; component so that the root element will contain the data of the \u0026lt;App/\u0026gt; component. All changes are done in the index.html root element using the DOM. Remember that we never edit this file (code). src/App.js : This is where we will write all the SPA code. We start coding from App.jsx and link components as required.\nsrc/index.css : This CSS file is used by main.jsx, so it applies to the whole page. You can remove it if needed by removing its import in main.jsx.\n*** src/App.css:*** This CSS file is used by App.jsx, so it applies to all App components.\nRemember: Component functions must follow two rules:\nThe name should start with an uppercase letter (e.g., Head, MyHead). The function must return renderable content. The function must return a value that can be rendered (displayed on screen) by React. In most cases, return JSX. Example of a simple component:\nfunction App() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Hello world\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ); } As we know, App.jsx is provided by default when we create a React app. We can modify it and tailor it to our requirements\n4. Making Custom Components function FunctionName() { return ( \u0026lt;tagname\u0026gt; content \u0026lt;/tagname\u0026gt; ); } Important Note:\nTags that don\u0026rsquo;t have ending tags, such as \u0026lt;br\u0026gt; and \u0026lt;hr\u0026gt;, should be written as \u0026lt;br/\u0026gt; and \u0026lt;hr/\u0026gt;. class is replaced by className. For example, \u0026lt;body class=\u0026quot;data\u0026quot;\u0026gt; is written as \u0026lt;body className=\u0026quot;data\u0026quot;\u0026gt;. During a return in React, we cannot return multiple elements directly. Instead, we need to wrap them inside a single parent element like \u0026lt;div\u0026gt;, \u0026lt;\u0026gt;\u0026lt;/\u0026gt;. For Example :\nWrong Way: function component1() { return ( \u0026lt;div\u0026gt; Hi \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; Hello \u0026lt;/div\u0026gt; ); } right way: function component1() { return ( \u0026lt;div\u0026gt; {/* or \u0026lt;\u0026gt; */} \u0026lt;div\u0026gt; Hi \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; Hello \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; {/* or \u0026lt;/\u0026gt; */} ); } 5.Using One Component Inside Another Component To use one component inside another in React, follow the steps\nCreate a component. function Comp1() { return \u0026lt;div\u0026gt; Component \u0026lt;/div\u0026gt; } Use the component inside another component. function Comp2() { return ( \u0026lt;div\u0026gt; \u0026lt;Comp1 /\u0026gt; or \u0026lt;Comp1\u0026gt; \u0026lt;Comp1 /\u0026gt; content \u0026lt;/div\u0026gt; ) } Here, Comp1 is used inside Comp2.We can use Comp1 multiple times inside Comp2 as needed. Note: For proper management, create a components folder, create one file for each component, and export from there. Then, import and use it in another component.\nExample structure:\nsrc/\r├─ Assets/\r├─ App.jsx\r└─ Components/\r├─ Comp1.jsx\r└─ Comp2.jsx Task: Break Down a Component into Multiple Components\nfunction App() { return ( \u0026lt;\u0026gt; \u0026lt;header\u0026gt; I am header \u0026lt;/header\u0026gt; \u0026lt;main\u0026gt; I am main content \u0026lt;/main\u0026gt; \u0026lt;footer\u0026gt; I am footer \u0026lt;/footer\u0026gt; \u0026lt;/\u0026gt; ); } Solution: components/Header.jsx\nfunction Header() { return ( \u0026lt;header\u0026gt; I am header \u0026lt;/header\u0026gt; ); } export default Header; components/Footer.jsx\nfunction Footer() { return ( \u0026lt;footer\u0026gt; I am footer \u0026lt;/footer\u0026gt; ); } export default Footer; Finally, App.jsx\nimport Header from \u0026#39;./components/Header\u0026#39;; import Footer from \u0026#39;./components/Footer\u0026#39;; function App() { return ( \u0026lt;\u0026gt; \u0026lt;Header /\u0026gt; \u0026lt;main\u0026gt; I am main content \u0026lt;/main\u0026gt; \u0026lt;Footer /\u0026gt; \u0026lt;/\u0026gt; ); } export default App; structure:\nsrc/\r├─ Assets/\r├─ App.jsx\r└─ components/\r├─ Header.jsx\r└─ Footer.jsx Note: You Can Always break down a component as many times as you want. The main goal is to make the code more readable and maintainable.\n6. Some Component Hierarchies Examples THis is the simple example of a component hierarchy. 7. Embedding JavaScript code in JSX In JSX, we can embed JavaScript code using curly braces {}. We can write any JavaScript code inside the curly braces. For example, we can write a variable, function, or any JavaScript expression but of single line.\nfunction componentName() { return ( \u0026lt;div\u0026gt; { JavaScript code } \u0026lt;/div\u0026gt; ); } Example:\nfunction App() { const name = \u0026#39;John Doe\u0026#39;; return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt; Hello, {name} \u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ); } Where To Write Javascript Logic?\nWe can write JavaScript logic inside the component function. We can write JavaScript logic outside the component function and use it inside the component function. 7.1 Using JavaScript Logic Outside Component Function syntax:\n// Multiple lines of JavaScript code function ComponentName() { return ( \u0026lt;div\u0026gt; {/* JSX code */} \u0026lt;/div\u0026gt; ); } 7.2 Using JavaScript Logic Inside Component Function syntax:\nfunction ComponentName() { // Multiple lines of JavaScript code return ( \u0026lt;div\u0026gt; {/* JSX code */} \u0026lt;/div\u0026gt; ); } When to use Inside Component Function Outside Component Function Use Case When the logic is specific to the component and not used anywhere else. When the logic is used in multiple components. Advantages Logic is specific to the component. Logic can be reused in multiple components. Disadvantages Logic cannot be reused in other components. Logic is not specific to the component. Combined Example Task1: Create a component that generate random number between 1 to 10 and display in every page reload\nfunction RandomNumber(){ return \u0026lt;\u0026gt; \u0026lt;h1\u0026gt;Random Number: {Math.floor(Math.random() * 10) + 1}\u0026lt;/h1\u0026gt; } export default RandomNumber; This can be done in another ways which is more readable and maintainable\nfunction RandomNumber(){ const randomNumber = Math.floor(Math.random() * 10) + 1; return \u0026lt;h1\u0026gt;Random Number: {randomNumber}\u0026lt;/h1\u0026gt; } export default RandomNumber; Task2 : Create a component that generate random element from an array and display on each page reload\nconst elements = [\u0026#39;Earth\u0026#39;, \u0026#39;Water\u0026#39;, \u0026#39;Fire\u0026#39;, \u0026#39;Air\u0026#39;]; function generateRandomElement(){ return elements[Math.floor(Math.random() * elements.length)]; } function RandomElement(){ const randomElement = generateRandomElement(); return \u0026lt;h1\u0026gt;Random Element: {randomElement}\u0026lt;/h1\u0026gt; } export default RandomElement; This can be done by putting the logic inside the component function\nconst elements = [\u0026#39;Earth\u0026#39;, \u0026#39;Water\u0026#39;, \u0026#39;Fire\u0026#39;, \u0026#39;Air\u0026#39;]; function generateRandomElement(){ return elements[Math.floor(Math.random() * elements.length)]; } function RandomElement(){ const randomElement = elements[Math.floor(Math.random() * elements.length)]; return \u0026lt;h1\u0026gt;Random Element: {randomElement}\u0026lt;/h1\u0026gt; } export default RandomElement; The most optimal way is using this\nconst elements = [\u0026#39;Earth\u0026#39;, \u0026#39;Water\u0026#39;, \u0026#39;Fire\u0026#39;, \u0026#39;Air\u0026#39;]; function RandomElement(){ const randomElement = elements[Math.floor(Math.random() * elements.length)]; return \u0026lt;h1\u0026gt;Random Element: {randomElement}\u0026lt;/h1\u0026gt; } export default RandomElement; 8.Loading Images in React step 1: put the images in assets folder that need to be loaded step 2: import the image in the component where it is needed as shown below import imageName from Location Note: Location is the path of the image from the current file location and imageName can be set to any name\nstep 3: use the image in the component as shown below \u0026lt;img src={imageName} alt=\u0026#34;description\u0026#34; /\u0026gt; Note: imageName is the location of the image as src/Assets/logo.png\nTask: Load an image in a Header component with the image name logo.png and description logo. structure:\nsrc/\r├─ Assets/\r└─ logo.png\r├─ App.jsx\r└─ components/\r├─ Header.jsx import logo from \u0026#39;../Assets/logo.png\u0026#39;; function Header() { return ( \u0026lt;header\u0026gt; \u0026lt;img src={logo} alt=\u0026#34;logo\u0026#34; /\u0026gt; \u0026lt;/header\u0026gt; ); } 9.Importing CSS in React step 1: create a css file in the src folder step 2: import the css file in the component where it is needed as shown below import cssfileLocation Note: style.css is the name of the css file\nfor example:\nimport \u0026#39;./style.css\u0026#39; function App() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt; Hello world \u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ); } 9.1 Managing CSS in React Create css file in same directory as of your component src/ ├─ App.jsx └─ components/ ├─ Header.jsx └─ Header.css -Import the css file in the component where it is needed as shown below\r```jsx\rimport \u0026#39;./Header.css\u0026#39; 10.Props in React Props are used to pass data from parent component to child component. It is used to reuse the same component with different data. Props are passed as attributes to the component. Prop accept any type of value like string, number, array, object, function,compenent,jsx bool etc. 10.1 Passing Props from Parent to Child Component Parent Component function ParentComponent() { return ( \u0026lt;ChildComponent prop1={value1} prop2={value2} /\u0026gt; ); } 10.2 Receiving Props in Child Component Child Component function ChildComponent(props) { console.log(props); // will print object of props {prop1: value1, prop2:value2} return ( \u0026lt;\u0026gt; {props.prop1} {props.prop2} \u0026lt;/\u0026gt; ); } This approach is not recommended because it is not clear what props are being passed to the component. Instead, we can destructure the props as shown below.\n10.3 Destructuring Props Child Component function ChildComponent({prop1, prop2}) { return ( \u0026lt;\u0026gt; {prop1} {prop2} \u0026lt;/\u0026gt; ); } Task: Create a card cmponent and use multiple cards in the App component to make card section\nfunction Card({title, description, image}) { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;{title}\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;{description}\u0026lt;/p\u0026gt; \u0026lt;img src={image} alt=\u0026#34;description\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; ); } export default Card; import Card from \u0026#39;./components/Card\u0026#39;; function App() { return ( \u0026lt;div\u0026gt; \u0026lt;Card title=\u0026#34;Card 1\u0026#34; description=\u0026#34;This is card 1\u0026#34; image={image1} /\u0026gt; \u0026lt;Card title=\u0026#34;Card 2\u0026#34; description=\u0026#34;This is card 2\u0026#34; image={image2} /\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; 11. Children Props in React Children props are used to pass data between opening and closing tags of a component. 11.1 Passing Children Props Parent Component function ParentComponent() { return ( \u0026lt;ChildComponent\u0026gt; \u0026lt;h1\u0026gt; Hello \u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt; World \u0026lt;/p\u0026gt; \u0026lt;/ChildComponent\u0026gt; ); } 11.2 Receiving Children Props Child Component function ChildComponent({ children }) { return ( \u0026lt;div\u0026gt; {children} \u0026lt;/div\u0026gt; ); } 11.3 Output \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt; Hello \u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt; World \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; 12.Using Props and Children Props Together Task: Create a card component that accepts title, description, and children props. Use the card component in the App component to make a card section.\nfunction Card({ title, description, children }) { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;{title}\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;{description}\u0026lt;/p\u0026gt; {children} \u0026lt;/div\u0026gt; ); } export default Card; import Card from \u0026#39;./components/Card\u0026#39;; function App() { return ( \u0026lt;div\u0026gt; \u0026lt;Card title=\u0026#34;Card 1\u0026#34; description=\u0026#34;This is card 1\u0026#34;\u0026gt; \u0026lt;h1\u0026gt; Hello \u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt; World \u0026lt;/p\u0026gt; \u0026lt;/Card\u0026gt; \u0026lt;Card title=\u0026#34;Card 2\u0026#34; description=\u0026#34;This is card 2\u0026#34;\u0026gt; \u0026lt;h1\u0026gt; Hello \u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt; World \u0026lt;/p\u0026gt; \u0026lt;/Card\u0026gt; \u0026lt;/div\u0026gt; ); } 13. Making a Button Component 13.1 Using Props function App() { return ( \u0026lt;div\u0026gt; \u0026lt;Button text=\u0026#34;Click me\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; ); } function Button({ text}) { return ( \u0026lt;button\u0026gt; {text} \u0026lt;/button\u0026gt; ); } export default Button; 13.2 Using Children Props function App() { return ( \u0026lt;div\u0026gt; \u0026lt;Button\u0026gt;Click me\u0026lt;/Button\u0026gt; \u0026lt;/div\u0026gt; ); } function Button({ children }) { return ( \u0026lt;button\u0026gt; {children} \u0026lt;/button\u0026gt; ); } export default Button; 14. Reacting to Events In React, we can add event listeners like onClick, onMouseOver, onMouseOut, etc to buildin components lie button, div, etc using syntax \u0026lt;InbuiltComponent eventlistener={functionName} /\u0026gt; Note: functionName is the name of the function that will be called when the event is triggered.\nThere are Many eventlisteners that can be used in React like onClick, onMouseOver, onMouseOut etc.\nYou can check the full list of event listeners in the React documentation also note that the event listener will always start with on followed by the event name.\nWe can call the handle function in two ways:\n14.1 The First Way function App() { function handleClick() { console.log(\u0026#39;Button clicked\u0026#39;); } return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={handleClick}\u0026gt;Click me\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 14.2 The Second Way function App() { return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={() =\u0026gt; {console.log(\u0026#39;Button clicked\u0026#39;)}}\u0026gt;Click me\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 15. Event Listeners in Custom Components since by default when we add event listeners to custom component it doesnot work just because it is passed as prop but on simple tweaking we can make it work\nDesign Pattern for applying event listeners in custom components\nfunction App(){ function handleClick(){ console.log(\u0026#39;Button clicked\u0026#39;); } return ( \u0026lt;div\u0026gt; \u0026lt;Button onClick={handleClick} /\u0026gt; \u0026lt;/div\u0026gt; ); } The onclick method is passed as a prop to the button component and then used in the button component as shown below\nfunction Button({onClick}){ return ( \u0026lt;button onClick={onClick}\u0026gt;Click me\u0026lt;/button\u0026gt; ); } 16. Passing Arguments to Event Functions To pass Custom arguments to event functions, we can use the arrow function syntax as shown below \u0026lt;inbuildComponent eventListener={() =\u0026gt; functionName(argument)} /\u0026gt; Example function App() { function handleClick(name) { console.log(\u0026#39;Button clicked by\u0026#39;, name); } return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={() =\u0026gt; handleClick(\u0026#39;John\u0026#39;)}\u0026gt;Click me\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } ","permalink":"http://localhost:1313/posts/pages/react/react/","summary":"A detailed reference guide to help you quickly set up and manage React projects, components, and folder structures.","title":"React : Day 1"},{"content":"Python Fundamentals: Understanding Error Handling In Python programming, error handling is an essential concept that allows you to gracefully manage exceptions and errors that may occur during program execution. By handling errors effectively, you can prevent your program from crashing and provide meaningful feedback to users. In this guide, we will explore the fundamentals of error handling in Python, including exceptions, try-except blocks, and best practices.\n1. Exceptions In Python, exceptions are events that occur during the execution of a program that disrupt the normal flow of code. When an exception occurs, the interpreter raises an exception object that can be caught and handled by the program. Exceptions can be caused by various reasons, such as invalid input, file not found, or division by zero.\n2.What May Cause Exceptions Exceptions can be caused by various reasons, such as:\nDivision by zero Invalid input File not found Syntax errors Out of Index of list, tuple , String Key Error in dictionary 3.Types of Exceptions Commonly used exceptions in Python include:\nZeroDivisionError: Raised when division or modulo by zero occurs. ValueError: Raised when a function receives an argument of the correct type but an inappropriate value. TypeError: Raised when an operation or function is applied to an object of an inappropriate type. IndexError: Raised when a sequence subscript is out of range. KeyError: Raised when a dictionary key is not found. SyntaxError: Raised when the parser encounters a syntax error. Note: All exceptions in Python are subclasses of the Exception class.\n3.Handling Exceptions To handle exceptions in Python, you can use the try-except block, which allows you to catch and handle exceptions gracefully. The try block contains the code that may raise an exception, and the except block handles the exception if it occurs.The program control will transfer the control to the except block if any exception occurs in the try block but if there is not exception then the control will not transfer to the except block.\n4.1. Using try-except Block Here\u0026rsquo;s an example of using the try-except block to handle exceptions in Python:\nsyntax:\ntry: # Code that may raise an exception except ExceptionType as e: # Handle the exception Example:\ntry: x = 10 / 0 except Exception as e: print(\u0026#34;Error: Division by zero\u0026#34;) Output:\nError: Division by zero Note: if you don\u0026rsquo;t know the type of exception you can use Exception to catch all exceptions.\nIf you dont handel exception then it will show error and stop the program.\n4.2. Finally Block The finally block is used to execute code that should always run, regardless of whether an exception occurs or not. The finally block is typically used to release resources or clean up operations that need to be performed after the try block, regardless of the outcome Any how the finally block will run. if yout return from the try block then also the finally block will run.\nsyntax:\ntry: # Code that may raise an exception except ExceptionType as e: # Handle the exception finally: # Code that always runs Example:\ntry: x = 10 / 0 except Exception as e: print(\u0026#34;Error: Division by zero\u0026#34;) finally: print(\u0026#34;Cleanup code\u0026#34;) Output:\nError: Division by zero\rCleanup code 3.5. Raising Exceptions You can raise exceptions in Python using the raise statement. This allows you to create custom exceptions and raise them when needed. You can also raise built-in exceptions to indicate errors or exceptional conditions.\nsyntax:\nraise ExceptionType(\u0026#34;Error message\u0026#34;) Example:\nx = -1 if x \u0026lt; 0: raise ValueError(\u0026#34;Value cannot be negative\u0026#34;) Output:\nValueError: Value cannot be negative 3.6. Multiple except Blocks You can use multiple except blocks to handle different types of exceptions in Python. This allows you to catch and handle specific exceptions based on their type.\nsyntax:\ntry: # Code that may raise an exception except ExceptionType1 as e: # Handle ExceptionType1 except ExceptionType2 as e: # Handle ExceptionType2 Example:\ntry: x = 10 / 0 except ZeroDivisionError as e: print(\u0026#34;Error: Division by zero\u0026#34;) except ValueError as e: print(\u0026#34;Error: Invalid value\u0026#34;) Output:\nError: Division by zero 3.7. Custom Exceptions You can create custom exceptions in Python by defining a new exception class that inherits from the Exception class. Custom exceptions allow you to define specific error conditions for your application and raise them when needed.\nsyntax:\nclass CustomException(Exception): pass Example:\n#Will read about class in oop section class CustomError(Exception): def __init__(self,message,value): self.message=message self.value=value def __str__(self): return f\u0026#34;{self.message}\\nError code:{self.value}\u0026#34; try: x = -1 if x \u0026lt; 0: raise CustomError(\u0026#34;Value cannot be negative\u0026#34;,1001) except CustomError as e: print(e) Note: Custom exceptions should inherit from the Exception class or one of its subclasses. You can simply use:\ntry: #code except: #code try: #code except Exception as e: #code try: #code except Exception: #code try: #code except: #code finally: #code ","permalink":"http://localhost:1313/posts/pages/python/python_error_handeling/","summary":"An in-depth exploration of Python error handling, exceptions, and best practices.","title":"Python Fundamentals: Understanding Error Handling (Part 6)"},{"content":"Python Fundamentals: Packages, Generators, and Decorators In this guide, we will explore advanced Python topics including packages, generators, and decorators. These concepts are essential for writing efficient and maintainable Python code. Let\u0026rsquo;s dive in!\n1. Python Packages Python packages are a way of organizing and structuring your code into reusable modules. Packages allow you to group related modules together, making it easier to manage and maintain your codebase. In this section, we will explore how to create and use Python packages.\n1.1. Creating a Package To create a Python package, you need to organize your code into a directory structure with a special file called __init__.py. This file tells Python that the directory is a package and allows you to import modules from the package.\nExample directory structure:\nmy_package/\r│\r├── __init__.py\r├── module1.py\r└── module2.py 1.2. Using a Package To use a Python package, you can import modules from the package using the import statement. You can import specific modules or the entire package.\nExample:\n# Importing a specific module from my_package import module1 # Using a function from the imported module module1.my_function() # Importing the entire package import my_package # Using a function from a module within the package my_package.module2.another_function() #Importing Function from a module from my_package.module1 import my_function my_function() Note : init.py file can be empty or contain initialization code for the package. It will automatically run when the package is imported.\n1.3 Creating a Subpackage You can create subpackages within a package to further organize your code. Subpackages are simply packages within packages, allowing you to create a hierarchical structure for your codebase.\nExample directory structure:\nmy_package/\r│\r├── __init__.py\r├── module1.py\r└── subpackage/\r├── __init__.py\r├── module3.py\r└── module4.py 1.4. Using a Subpackage To use a subpackage, you can import modules from the subpackage using the dot notation.\nExample:\n# Importing a module from a subpackage from my_package.subpackage import module3 # Using a function from the imported module module3.another_function() # Importing the entire subpackage import my_package.subpackage # Using a function from a module within the subpackage my_package.subpackage.module4.some_function() #Importing Function from a module from my_package.subpackage.module3 import another_function another_function() 1.5. name == \u0026ldquo;main\u0026rdquo; We use the __name__ variable to check if a script is being run as the main program or being imported as a module. When a script is run as the main program, __name__ is set to \u0026quot;__main__\u0026quot;. This allows you to include code that should only run when the script is executed directly.\nFor Example:\nStructure:\nMain Directory/\r├── main.py\r└── package/\r├── __init__.py\r└── module1.py module1.py:\ndef my_function(): print(\u0026#34;Hello from module1\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: my_function() When you run module1.py directly, the my_function() will be executed. However, if you import module1 into another script, the my_function() will not be executed.\nFor Example:\nfrom package import module1 print(\u0026#34;Imported module1\u0026#34;) Output:\nImported module1 When use Dont use if __name__ == \u0026quot;__main__\u0026quot;: in module1.py:\ndef my_function(): print(\u0026#34;Hello from module1\u0026#34;) my_function() also,\nfrom package import module1 print(\u0026#34;Imported module1\u0026#34;) Output:\nHello from module1\rImported module1 2. Python Generators Using generator we can instantly return all the values using the yield keyword without storing them in memory. This is useful when working with large datasets or infinite sequences.\n2.1. Creating a Generator To create a generator in Python, you can use a function with the yield keyword. When a function contains the yield keyword, it becomes a generator function. The yield keyword suspends the function\u0026rsquo;s execution and returns a value to the caller.\nExample:\ndef my_generator(): yield 1 yield 2 yield 3 # Using the generator gen = my_generator() print(next(gen)) # Output: 1 print(next(gen)) # Output: 2 print(next(gen)) # Output: 3 Example:\n#using generator in loop def generate(n): for i in range(n): yield i for i in generate(10): print(i) 3. Python Decorators Decorators are a powerful feature in Python that allows you to modify or extend the behavior of functions or methods. Decorators are functions that take another function as an argument and return a new function that extends the behavior of the original function.\n3.1. Creating a Decorator To create a decorator in Python, you can define a function that takes another function as an argument and returns a new function that extends the behavior of the original function.\nSyntax:\ndef my_decorator(func): def wrapper(): # Code to execute before calling the decorated function func() # Code to execute after return wrapper Example:\ndef my_decorator(func): def wrapper(): print(\u0026#34;Before function call\u0026#34;) func() print(\u0026#34;After function call\u0026#34;) return wrapper @my_decorator def say_hello(): print(\u0026#34;Hello!\u0026#34;) say_hello() #call to my_decorator(say_hello)() just because we use @my_decorator Output:\nBefore function call\rHello!\rAfter function call Example For decorator :\ndef Add_Wrapper(func): def wrapper(a,b,c): print(\u0026#34;Status code is\u0026#34;,c) return func(a,b) return wrapper @Add_Wrapper def add(a,b): return a+b print(add(2,3,200)) Output:\nStatus code is 200\r5 3.2. Decorator with Arguments You can also create decorators that accept arguments by defining a decorator function that takes arguments and returns a decorator function.\nSyntax:\ndef my_decorator_with_args(arg1, arg2): def decorator(func): def wrapper(): # Code to execute before calling the decorated function func() # Code to execute after return wrapper return decorator Example:\ndef my_decorator_with_args(arg1, arg2): def decorator(func): def wrapper(): print(f\u0026#34;Decorator arguments: {arg1}, {arg2}\u0026#34;) func() return wrapper return decorator @my_decorator_with_args(\u0026#34;arg1\u0026#34;, \u0026#34;arg2\u0026#34;) def say_hello(): print(\u0026#34;Hello!\u0026#34;) say_hello() Output:\nDecorator arguments: arg1, arg2\rHello! ","permalink":"http://localhost:1313/posts/pages/python/python_advanced_topics/","summary":"An in-depth exploration of Python packages, generators, and decorators.","title":"Python Fundamentals: Packages, Generators, and Decorators (Part 7)"},{"content":"Python Fundamentals: Understanding request In this guide, we will explore request package in python. This package is used to make HTTP requests in python. Let\u0026rsquo;s dive in!\n1. Python request Python request is a simple and elegant HTTP library for Python. It provides methods for sending HTTP requests and handling the responses. The requests library allows you to send HTTP requests using a simple and intuitive API, and it also provides support for handling cookies, sessions, and authentication.\n1.1. Installing requests To use the requests library in your Python project, you need to install it using pip. You can install the requests library by running the following command in your terminal:\npip install requests 1.2. Types of requests The requests library supports various types of HTTP requests, including GET, POST, PUT, DELETE, and more. You can use these methods to interact with web services and APIs.\nExample:\nimport requests # Send a GET request response = requests.get(\u0026#39;https://api.github.com\u0026#39;) # Send a POST request response = requests.post(\u0026#39;https://httpbin.org/post\u0026#39;) # Send a PUT request response = requests.put(\u0026#39;https://httpbin.org/put\u0026#39;) # Send a DELETE request response = requests.delete(\u0026#39;https://httpbin.org/delete\u0026#39;) 1.3 Parameters for requests The requests library allows you to pass various parameters when making HTTP requests. These parameters include headers, query parameters, request body, and more.\nHeaders: You can pass custom headers in your request using the headers parameter. Example: import requests # Send a GET request with custom headers headers = {\u0026#39;User-Agent\u0026#39;: \u0026#39;Mozilla/5.0\u0026#39;} response = requests.get(\u0026#39;https://api.github.com\u0026#39;, headers=headers) # Send a POST request with custom headers response = requests.post(\u0026#39;https://httpbin.org/post\u0026#39;, headers=headers) #similarly for PUT and DELETE cookie: You can pass cookies in your request using the cookies parameter. Example: import requests # Send a GET request with cookies cookies = {\u0026#39;session_id\u0026#39;: \u0026#39;12345\u0026#39;} response = requests.get(\u0026#39;https://api.github.com\u0026#39;, cookies=cookies) # Send a POST request with cookies response = requests.post(\u0026#39;https://httpbin.org/post\u0026#39;, cookies=cookies) #similarly for PUT and DELETE file: You can upload files in your request using the files parameter. Example: import requests # Upload a file in a POST request files = {\u0026#39;file\u0026#39;: open(\u0026#39;file.txt\u0026#39;, \u0026#39;rb\u0026#39;)} response = requests.post(\u0026#39;https://httpbin.org/post\u0026#39;, files=files) #similarly for PUT and DELETE params: You can pass query parameters in your request using the params parameter. Example: import requests # Send a GET request with query parameters params = {\u0026#39;key1\u0026#39;: \u0026#39;value1\u0026#39;, \u0026#39;key2\u0026#39;: \u0026#39;value2\u0026#39;} response = requests.get(\u0026#39;https://api.github.com\u0026#39;, params=params) # Send a POST request with query parameters response = requests.post(\u0026#39;https://httpbin.org/post\u0026#39;, params=params) #similarly for PUT and DELETE data: You can pass data in your request body using the data parameter. Example: import requests # Send a POST request with data data = {\u0026#39;key1\u0026#39;: \u0026#39;value1\u0026#39;, \u0026#39;key2\u0026#39;: \u0026#39;value2\u0026#39;} response = requests.post(\u0026#39;https://httpbin.org/post\u0026#39;, data=data) #similarly for PUT and DELETE json: You can pass JSON data in your request body using the json parameter. Example: import requests # Send a POST request with JSON data data = {\u0026#39;key1\u0026#39;: \u0026#39;value1\u0026#39;, \u0026#39;key2\u0026#39;: \u0026#39;value2\u0026#39;} response = requests.post(\u0026#39;https://httpbin.org/post\u0026#39;, json=data) #similarly for PUT and DELETE Note: The requests library provides a wide range of parameters and options for making HTTP requests. You can refer to the official documentation for more details.\n** Note ** : While using json it will automatically set the content type to application/json and dump the data to json format but while using data it will set the content type to application/x-www-form-urlencoded and encode the data to urlencoded format.\n1.4. Handling responses The requests library provides methods for handling the responses returned by HTTP requests. You can access the response content, status code, headers, and more.\nResponse content: You can access the response content using the text attribute. Example: import requests # Send a GET request response = requests.get(\u0026#39;https://api.github.com\u0026#39;) # Get the response content content = response.text print(content) Response Content in bytes: You can access the response content in bytes using the content attribute. Example: import requests # Send a GET request response = requests.get(\u0026#39;https://api.github.com\u0026#39;) # Get the response content in bytes content = response.content print(content) json: You can access the response content as JSON using the json method. Example:\nimport requests # Send a GET request response = requests.get(\u0026#39;https://api.github.com\u0026#39;) # Get the response content as JSON data = response.json() print(data) Status code: You can access the response status code using the status_code attribute. Example: import requests # Send a GET request response = requests.get(\u0026#39;https://api.github.com\u0026#39;) # Get the response status code status_code = response.status_code print(status_code) Headers: You can access the response headers using the headers attribute. Example: import requests # Send a GET request response = requests.get(\u0026#39;https://api.github.com\u0026#39;) # Get the response headers headers = response.headers print(headers) Cookies: You can access the response cookies using the cookies attribute. Example: import requests # Send a GET request response = requests.get(\u0026#39;https://api.github.com\u0026#39;) # Get the response cookies cookies = response.cookies print(cookies) ","permalink":"http://localhost:1313/posts/pages/python/python_request/","summary":"An in-depth exploration of Python request.","title":"Python Fundamentals: Understanding request (Part 8)"},{"content":"Python Fundamentals: Understanding File Handeling In Python programming, file handling is an essential operation that allows you to read, write, and manipulate files on your system. Files are used to store data permanently, and Python provides various functions and methods to work with files efficiently. In this guide, we will explore the basics of file handling in Python, including opening, reading, writing, and closing files.\n1.Context Manager Python provides a built-in way to manage resources and ensure that they are properly released when they are no longer needed. This is done using the with statement and is known as a context manager. When working with files, it is recommended to use the with statement to ensure that the file is properly closed after use.\n1.1. Using the with Statement The with statement in Python is used to create a context manager that automatically takes care of resource management. When working with files, the with statement ensures that the file is properly closed after use, even if an error occurs during file operations.\nExample:\nwith open(\u0026#34;example.txt\u0026#34;, \u0026#34;r\u0026#34;) as file: data = file.read() print(data) 2. Opening a File Before you can read or write to a file, you need to open it using the open() function. The open() function takes two arguments: the file path and the mode in which you want to open the file.\n2.1. Modes for Opening Files Python supports various modes for opening files, depending on the operations you want to perform. Some common modes include:\nr: Read mode. Opens the file for reading. The file must exist. w: Write mode. Opens the file for writing. If the file exists, it will be truncated. If the file does not exist, a new file will be created. a: Append mode. Opens the file for writing. If the file exists, the data will be appended to the end. If the file does not exist, a new file will be created. b: Binary mode. Opens the file in binary mode.use for image,video,etc as it will not convert the data to text .You can add b to any mode to open the file in binary mode like rb,wb,ab. t: Text mode. Opens the file in text mode (default). 2.2. Opening a File To open a file, you can use the open() function with the desired file path and mode. You can also specify additional parameters such as encoding, buffering, and newline characters.\nExample:\n# Open a file in read mode with open(\u0026#34;example.txt\u0026#34;, \u0026#34;r\u0026#34;) as file: data = file.read() print(data) 3. Reading from a File Once you have opened a file, you can read its contents using various methods provided by Python. The most common methods for reading from a file is read().\n# Open a file in read mode with open(\u0026#34;example.txt\u0026#34;, \u0026#34;r\u0026#34;) as file: data = file.read() print(data) 4. Writing to a File To write data to a file, you can use the write() method provided by Python. You can write text data to a file using the write() method.\nUsing w mode: # Open a file in write mode with open(\u0026#34;example.txt\u0026#34;, \u0026#34;w\u0026#34;) as file: file.write(\u0026#34;Hello, World!\u0026#34;) Using a mode: # Open a file in append mode with open(\u0026#34;example.txt\u0026#34;, \u0026#34;a\u0026#34;) as file: file.write(\u0026#34;Hello, World!\u0026#34;) 5.Context Manager Reference\nUse of Context Manager: In any programming language, the usage of resources like file operations or database connections is very common. But these resources are limited in supply. Therefore, the main problem lies in making sure to release these resources after usage. If they are not released then it will lead to resource leakage and may cause the system to either slow down or crash. It would be very helpful if users have a mechanism for the automatic setup and teardown of resources. In Python, it can be achieved by the usage of context managers which facilitate the proper handling of resources.\nWhat is happened When the with statement is executed, it will automatically call the __enter__ before entering the code block, and __exit__ after exiting the code block.\nHow to create a context manager To create a context manager, you need to define a class that implements the __enter__ and __exit__ methods. The __enter__ method is called when the with statement is executed, and the __exit__ method is called after the code block is executed.\nSyntax:\nclass MyContextManager: def __init__(self,params): # Code to initialize resources def __enter__(self): # Code to setup resources return self def __exit__(self, exc_type, exc_value, traceback): # Code to release resources Example:\n#implementatio of own file handeling context manager class MeroHandle: def __init__(self,filename,mode): self.filename = filename self.mode = mode def __enter__(self): self.file = open(self.filename,self.mode) return self.file def __exit__(self,exc_type,exc_value,traceback): self.file.close() #using the context manager with MeroHandle(\u0026#34;example.txt\u0026#34;,\u0026#34;r\u0026#34;) as file: data = file.read() print(data) Normal way of file handeling try: file = open(\u0026#34;example.txt\u0026#34;,\u0026#34;r\u0026#34;) data = file.read() print(data) file.close() except: print(\u0026#34;Error Occured\u0026#34;) Advantage of context manager Over normal code When we use normal code shown above then when error occured in try block before file.close() then it will not close the file(i.e file will not be closed) and it will lead to resource leakage . But when we use context manager then it will automatically close the file just because __exit__ method is called after the code block is executed whether error occured or not. but in normal code we can manage this by using finally block but it is not recommended as it is not pythonic way of doing things. try: file = open(\u0026#34;example.txt\u0026#34;,\u0026#34;r\u0026#34;) data = file.read() print(data) except: print(\u0026#34;Error Occured\u0026#34;) finally: file.close() This will work but it is not pythonic way of doing things.Just because we have to write whole try,except,finally block for just opening and closing the file. which make code more complex and lengthy.\n","permalink":"http://localhost:1313/posts/pages/python/python_filehandeling/","summary":"An in-depth look at File Handeling.","title":"Python Fundamentals: Understanding File Handeling (Part 9)"},{"content":"Python Fundamentals: Some Important Package to Know In Python programming, packages are collections of modules that provide additional functionality to your programs. Python has a rich ecosystem of packages that can help you perform a wide range of tasks, from data analysis and visualization to web development and machine learning. In this guide, we will explore some of the most important packages in Python that you should be familiar with.\n1.json The json package in Python provides functions for encoding and decoding JSON data. JSON (JavaScript Object Notation) is a lightweight data interchange format that is easy for humans to read and write and easy for machines to parse and generate. The json package allows you to work with JSON data in Python by converting Python objects to JSON strings and vice versa.\nConversion of Python dictionary to JSON string We can convert a Python dictionary to a JSON string using the json.dumps() function. This function takes a Python object as input and returns a JSON string representation of the object. Example:\nimport json # Create a Python dictionary data = { \u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34; } # Convert the dictionary to a JSON string json_string = json.dumps(data) print(json_string) Conversion of JSON string to Python dictionary We can convert a JSON string to a Python dictionary using the json.loads() function. This function takes a JSON string as input and returns a Python object (usually a dictionary) representing the JSON data. Example:\nimport json # JSON string json_string = \u0026#39;{\u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;}\u0026#39; # Convert the JSON string to a Python dictionary data = json.loads(json_string) print(data) 2.os The os package in Python provides functions for interacting with the operating system.You can get indepth knowladge of os using its own documentation.but the most common methods are:\nos.path.join(\u0026quot;C:\u0026quot;,\u0026quot;users\u0026quot;,\u0026quot;bin\u0026quot;): Join one or more path components intelligently. os.rename(\u0026quot;old\u0026quot;,\u0026quot;new\u0026quot;): Rename a file or directory. 3.time The time package in Python provides functions for working with time-related tasks. You can use the time package to get the current time, sleep for a specified duration, and measure the execution time of your code.\ntime.time(): Returns the current time in seconds since the epoch. time.sleep(seconds): Suspends the execution of the current thread for the given number of seconds. 4.uuid The uuid package in Python provides functions for generating and working with UUIDs (Universally Unique Identifiers). UUIDs are unique identifiers that are used to identify objects in a distributed computing environment. The uuid package allows you to generate UUIDs based on various algorithms and formats.\nGenerating a UUID You can generate a UUID using the uuid.uuid4() function, which generates a random UUID. Example:\nimport uuid # Generate a random UUID uuid_value = uuid.uuid4() print(uuid_value) 5.Datetime The datetime package in Python provides classes for working with dates and times. You can use the datetime package to create, manipulate, and format dates and times in your Python programs.\nCreating a datetime object You can create a datetime object using the datetime.datetime() constructor, which takes the year, month, day, hour, minute, second, and microsecond as input. Example:\nimport datetime # Create a datetime object dt = datetime.datetime(2022, 11, 27, 10, 30, 0) print(dt) Output:\n2022-11-27 10:30:00 get current date and time You can get the current date and time using the datetime.now() method. Example:\nimport datetime # Get the current date and time now = datetime.datetime.now() print(now) Output:\n2022-11-27 10:30:00 Formatting a datetime object some Properties of datetime object:\nyear: The year of the datetime object month: The month of the datetime object (1-12) day: The day of the datetime object (1-31) hour: The hour of the datetime object (0-23) minute: The minute of the datetime object (0-59) second: The second of the datetime object (0-59) import datetime # Create a datetime object dt = datetime.datetime.now() # Format the datetime object print(dt.month()) print(dt.day()) print(dt.year()) print(dt.hour()) print(dt.minute()) print(dt.second()) Output:\n11\r27\r2022\r10\r30\r0 ","permalink":"http://localhost:1313/posts/pages/python/python_extrapackage/","summary":"An in-depth look at frequently used important package.","title":"Python Fundamentals: Some Important Package to Know (Part 10)"},{"content":"Shared References in Python: How Changes Propagate Across Variables In Python, variables are references to objects in memory. When you assign a value to a variable, you are creating a reference to the object that holds that value. In some cases, multiple variables can refer to the same object in memory. This is known as a shared reference.\nMutability and Shared References in Python: How Changes Propagate Across Variables List Lists are mutable, so if two variables reference the same list, changes through one variable will affect the other.\n# Create a list list1 = [1, 2, 3] # Create a reference to the list list2 = list1 # Modify the list through one reference list2.append(4) # Check the original list print(list1) # Output: [1, 2, 3, 4] Dictionary Dictionaries are mutable as well. If two variables point to the same dictionary, any change made through one will reflect in the other.\n# Create a dictionary dict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30} # Create a reference to the dictionary dict2 = dict1 # Modify the dictionary through one reference dict2[\u0026#34;age\u0026#34;] = 31 # Check the original dictionary print(dict1) # Output: {\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 31} Set Sets are mutable, so changes made through one reference will affect the other if two variables point to the same set.\n# Create a set set1 = {1, 2, 3} # Create a reference to the set set2 = set1 # Modify the set through one reference set2.add(4) # Check the original set print(set1) # Output: {1, 2, 3, 4} Custom Objects\nclass Person: def __init__(self, name, age): self.name = name self.age = age # Create an instance of the Person class person1 = Person(\u0026#34;Alice\u0026#34;, 30) # Create a reference to the instance person2 = person1 # Modify the instance through one reference person2.age = 31 # Check the original instance print(person1.age) # Output: 31 Note: Mutable objects like lists, dictionaries, sets, and custom objects allow changes to propagate across variables that reference the same object. Immutable objects like integers, strings, and tuples do not exhibit this behavior.\n","permalink":"http://localhost:1313/posts/pages/python/python_shared_references/","summary":"An in-depth look at shared references in Python.","title":"Python Fundamentals : Shared References in Python (part 11)"},{"content":"Object oriented programming in python Object oriented programming is a programming paradigm that provides a means of structuring programs so that properties and behaviors are bundled into individual objects.\n1. Class and Object Class is a blueprint for creating objects (a particular data structure), providing initial values for state (member variables or attributes), and implementations of behavior (member functions or methods).\nObject is an instance of a class. When class is defined, only the description for the object is defined. Therefore, no memory or storage is allocated.\n1.1 Creating a class We can create a class using the class keyword followed by the class name. The class definition can contain class variables, instance variables, methods, and constructors.\nSyntax:\nclass ClassName: #code block Example:\nclass Person: name=\u0026#34;Nirajan\u0026#34; age=20 classes=\u0026#34;Bachelor\u0026#34; 1.2 Creating an object To create an object of a class, we use the class name followed by parentheses. This calls the constructor method of the class and returns an object.\nSyntax:\nobject_name = ClassName() Example:\nperson1 = Person() 1.3 Accessing class attributes We can access the attributes of a class using the dot operator (.) followed by the attribute name.\nSyntax:\nobject_name.attribute_name Example:\nprint(person1.name) # Output: Nirajan print(person1.age) # Output: 20 print(person1.classes) # Output: Bachelor 1.4 Modifying class attributes We can modify the attributes of a class using the dot operator (.) followed by the attribute name.\nSyntax:\nobject_name.attribute_name = new_value Example:\nperson1.age = 21 print(person1.age) # Output: 21 1.5 Creating a member function We can create a member function (method) inside a class using the def keyword followed by the function name. The first parameter of the method should be self, which refers to the current instance of the class.we will see about self in next part.\nSyntax:\nclass ClassName: def method_name(self, parameters): #code block Example:\nclass Person: name=\u0026#34;Nirajan\u0026#34; age=20 classes=\u0026#34;Bachelor\u0026#34; def display(self): print(f\u0026#34;Name: {self.name}\u0026#34;) print(f\u0026#34;Age: {self.age}\u0026#34;) print(f\u0026#34;Class: {self.classes}\u0026#34;) 1.6 Calling a member function We can call a member function of a class using the dot operator (.) followed by the function name and parentheses.\nSyntax:\nobject_name.method_name(arguments) Example:\nperson1.display() 1.7 Nested member function We can call a member function from another member function of the same class using the self keyword.\nSyntax:\nclass ClassName: def method1(self): #code block self.method2() def method2(self): #code block Example:\nclass Person: name=\u0026#34;Nirajan\u0026#34; age=20 classes=\u0026#34;Bachelor\u0026#34; def display(self): print(f\u0026#34;Name: {self.name}\u0026#34;) print(f\u0026#34;Age: {self.age}\u0026#34;) print(f\u0026#34;Class: {self.classes}\u0026#34;) self.greet() def greet(self): print(\u0026#34;Hello, Welcome to the class\u0026#34;) 1.8 self parameter The self parameter is a reference to the current instance of the class, and is used to access variables and methods of the class. It is the first parameter of any method in a class.\nSyntax:\nclass ClassName: def method_name(self, parameters): #code block Example:\nclass Person: name=\u0026#34;Nirajan\u0026#34; age=20 classes=\u0026#34;Bachelor\u0026#34; def display(self): print(f\u0026#34;Name: {self.name}\u0026#34;) print(f\u0026#34;Age: {self.age}\u0026#34;) print(f\u0026#34;Class: {self.classes}\u0026#34;) self.greet() def greet(self): print(\u0026#34;Hello, Welcome to the class\u0026#34;) 2. Constructor in Python A constructor is a special type of method (function) which is used to initialize the instance members of the class. It is called when an object of the class is created.\n2.1 Creating a constructor In Python, the constructor method is called __init__. It is a special method that is automatically called when an object is created.\nSyntax:\nclass ClassName: def __init__(self, parameters): #code block Example:\nclass Person: def __init__(self, name, age, classes): self.name = name self.age = age self.classes = classes def display(self): print(f\u0026#34;Name: {self.name}\u0026#34;) print(f\u0026#34;Age: {self.age}\u0026#34;) print(f\u0026#34;Class: {self.classes}\u0026#34;) 2.2 Creating an object with constructor When an object is created, the constructor method is automatically called with the arguments passed to the class.\nSyntax:\nobject_name = ClassName(arguments) Example:\nperson1 = Person(\u0026#34;Nirajan\u0026#34;, 20, \u0026#34;Bachelor\u0026#34;) 3. Getters and Setters in Python 3.1. Getters Getters are methods is implementes by using the @property decorator. They are specially used\nto act as an value ie data instead of a method. to access the value of a private attribute without directly accessing it. Syntax:\nclass ClassName: @property def method_name(self): #code block Example:\nclass Person: def __init__(self, name, age): self._name = name self._age = age @property def display(self): return f\u0026#34;Name: {self._name}, Age: {self._age}\u0026#34; person1 = Person(\u0026#34;Nirajan\u0026#34;, 20) print(person1.display) # Output: Name: Nirajan, Age: 20 3.2. Setters Setters are methods is implementes by using the @method_name.setter decorator. They are specially used\nto set the value of a private attribute without directly setting it. to perform validation before setting the value of an attribute. Syntax:\nclass ClassName: @method_name.setter def method_name(self, value): #code block Example:\nclass Person: def __init__(self, name, age): self._name = name self._age = age @property def display(self): return f\u0026#34;Name: {self._name}, Age: {self._age}\u0026#34; @display.setter def display(self, value): self._name, self._age = value.split(\u0026#34;,\u0026#34;) self._age = int(self._age) person1 = Person(\u0026#34;Nirajan\u0026#34;, 20) print(person1.display) # Output: Name: Nirajan, Age: 20 person1.display = \u0026#34;Alice, 30\u0026#34; print(person1.display) # Output: Name: Alice, Age: 30 4. Inheritance in Python Inheritance is a mechanism in which one class acquires the properties and behavior of another class. The class which inherits the properties and behavior is known as the child class, and the class whose properties and behavior are inherited is known as the parent class.\n4.1. Creating a child class To create a child class that inherits from a parent class, we specify the parent class in parentheses after the child class name.\nSyntax:\nclass ChildClassName(ParentClassName): #code block Example:\nclass Employee: def __init__(self,name,age,id): self.name=name self.age=age self.id=id def display(self): print(f\u0026#34;Name: {self.name}\u0026#34;) print(f\u0026#34;Age: {self.age}\u0026#34;) print(f\u0026#34;ID: {self.id}\u0026#34;) class Manager(Employee):# it has all the properties of Employee class so we can access the # properties of Employee class also its method using object of Manager class def task(self): self.display() print(\u0026#34;Assigning tasks to employees\u0026#34;) class Developer(Employee): # it has all the properties of Employee class so we can access # the properties of Employee class also its method using object of Developer class def task(self): self.display() print(\u0026#34;Developing software applications\u0026#34;) manager1 = Manager(\u0026#34;Alice\u0026#34;, 30, 101) manager1.task() developer1 = Developer(\u0026#34;Bob\u0026#34;, 25, 102) developer1.task() Note : Only public and protected members are inherited by the child class. Private members are not inherited by the child class.\n5.Ascess Specifiers in Python 5.1. Public members Public members are accessible from outside the class. They can be accessed using the dot operator (.) from outside the class.\nExample:\nclass Person: name = \u0026#34;Alice\u0026#34; # Public member person1 = Person() print(person1.name) # Output: Alice 5.2. Protected members Protected members are accessible within the class and its subclasses. They are denoted by a single underscore (_) before the member name.\nExample:\nclass Person: _age = 30 # Protected member class Student(Person): def display(self): print(self._age) # Accessing protected member student1 = Student() student1.display() # Output: 30 Example of protected variable and method\nclass Person: _name = \u0026#34;Alice\u0026#34; # Protected variable def _display(self): # Protected method print(f\u0026#34;Name: {self._name}\u0026#34;) class Student(Person): def display(self): self._display() # Accessing protected metho student1 = Student() student1.display() # Output: Name: Alice 5.3. Private members Private members are accessible only within the class. They are denoted by a double underscore (__) before the member name.\nExample:\nclass Person: __city = \u0026#34;New York\u0026#34; # Private member person1 = Person() print(person1.__city) # Error: \u0026#39;Person\u0026#39; object has no attribute \u0026#39;__city\u0026#39; Example of private variable and method\nclass Person: __name = \u0026#34;Alice\u0026#34; # Private variable def __display(self): # Private method print(f\u0026#34;Name: {self.__name}\u0026#34;) person1 = Person() print(person1.__name) # Error: \u0026#39;Person\u0026#39; object has no attribute \u0026#39;__name\u0026#39; person1.__display() # Error: \u0026#39;Person\u0026#39; object has no attribute \u0026#39;__display\u0026#39; Table of Access Specifiers in Python:\nAccess Specifier Accessible from class Accessible from subclass Accessible from outside class Public Yes Yes Yes Protected Yes Yes No Private Yes No No Static Method in Python Static Method is those method that can be called without creating an object of the class. They are defined using the @staticmethod decorator. They can be called using the class name . Syntax: class ClassName: @staticmethod def method_name(parameters): #code block Example:\nclass Calculator: @staticmethod def add(a, b): return a + b result = Calculator.add(5, 3) print(result) # Output: 8 #Can call using object also calculator = Calculator() result = calculator.add(5, 3) print(result) # Output: 8 #this is also valid but it is not recommended Class Method in Python They are defined using the @classmethod decorator.The useage of class method is to access the class variable and change class variable. ie when we change variable using class method it will change for all the object of the class.THey can be called using the class name. Syntax:\nclass ClassName: @classmethod def method_name(cls, parameters): #code block Example:\nclass copany : copany=\u0026#34;Google\u0026#34; @classmethod def change_company(cls,new_company): cls.copany=new_company print(copany.copany) #Output: Google copany.change_company(\u0026#34;Microsoft\u0026#34;) print(copany.copany) #Output: Microsoft c1=copany() print(c1.copany) #Output: Microsoft c1.change_company(\u0026#34;Apple\u0026#34;) c2=copany() print(c2.copany) #Output: Applex Dir and dict method in Python dir() method is used to return a list of attributes and methods of any object. It returns a list of valid attributes and methods of the object. Syntax:\ndir(object) Example:\nclass Person: name = \u0026#34;Alice\u0026#34; age = 30 person1 = Person() print(dir(person1)) # Output: [\u0026#39;__class__\u0026#39;, \u0026#39;__delattr__\u0026#39;, \u0026#39;__dict__\u0026#39;, \u0026#39;__dir__\u0026#39;, \u0026#39;__doc__\u0026#39;, \u0026#39;__eq__\u0026#39;, \u0026#39;__format__\u0026#39;, \u0026#39;__ge__\u0026#39;, \u0026#39;__getattribute__\u0026#39;, \u0026#39;__gt__\u0026#39;, \u0026#39;__hash__\u0026#39;, \u0026#39;__init__\u0026#39;, \u0026#39;__init_subclass__\u0026#39;, \u0026#39;__le__\u0026#39;, \u0026#39;__lt__\u0026#39;, \u0026#39;__module__\u0026#39;, \u0026#39;__ne__\u0026#39;, \u0026#39;__new__\u0026#39;, \u0026#39;__reduce__\u0026#39;, \u0026#39;__reduce_ex__\u0026#39;, \u0026#39;__repr__\u0026#39;, \u0026#39;__setattr__\u0026#39;, \u0026#39;__sizeof__\u0026#39;, \u0026#39;__str__\u0026#39;, \u0026#39;__subclasshook__\u0026#39;, \u0026#39;__weakref__\u0026#39;, \u0026#39;age\u0026#39;, \u0026#39;name\u0026#39;] Example:\nl=[1,2,3] print(dir(l)) # Output: [\u0026#39;__add__\u0026#39;, \u0026#39;__class__\u0026#39;, \u0026#39;__class_getitem__\u0026#39;, \u0026#39;__contains__\u0026#39;, \u0026#39;__delattr__\u0026#39;, \u0026#39;__delitem__\u0026#39;, \u0026#39;__dir__\u0026#39;, \u0026#39;__doc__\u0026#39;, \u0026#39;__eq__\u0026#39;, \u0026#39;__format__\u0026#39;, \u0026#39;__ge__\u0026#39;, \u0026#39;__getattribute__\u0026#39;, \u0026#39;__getitem__\u0026#39;, \u0026#39;__getstate__\u0026#39;, \u0026#39;__gt__\u0026#39;, \u0026#39;__hash__\u0026#39;, \u0026#39;__iadd__\u0026#39;, \u0026#39;__imul__\u0026#39;, \u0026#39;__init__\u0026#39;, \u0026#39;__init_subclass__\u0026#39;, \u0026#39;__iter__\u0026#39;, \u0026#39;__le__\u0026#39;, \u0026#39;__len__\u0026#39;, \u0026#39;__lt__\u0026#39;, \u0026#39;__mul__\u0026#39;, \u0026#39;__ne__\u0026#39;, \u0026#39;__new__\u0026#39;, \u0026#39;__reduce__\u0026#39;, \u0026#39;__reduce_ex__\u0026#39;, \u0026#39;__repr__\u0026#39;, \u0026#39;__reversed__\u0026#39;, \u0026#39;__rmul__\u0026#39;, \u0026#39;__setattr__\u0026#39;, \u0026#39;__setitem__\u0026#39;, \u0026#39;__sizeof__\u0026#39;, \u0026#39;__str__\u0026#39;, \u0026#39;__subclasshook__\u0026#39;, \u0026#39;append\u0026#39;, \u0026#39;clear\u0026#39;, \u0026#39;copy\u0026#39;, \u0026#39;count\u0026#39;, \u0026#39;extend\u0026#39;, \u0026#39;index\u0026#39;, \u0026#39;insert\u0026#39;, \u0026#39;pop\u0026#39;, \u0026#39;remove\u0026#39;, \u0026#39;reverse\u0026#39;, \u0026#39;sort\u0026#39;] __dict__ method is used to return a dictionary containing the attributes of an object. It returns a dictionary containing the attributes of the object.\nSyntax:\nobject.__dict__ Example:\nclass Person: name = \u0026#34;Alice\u0026#34; age = 30 person1 = Person() print(person1.__dict__) # Output: {\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 30} 9.super() method in Python When a parent class and a child class define a method with the same name, and we create an object of the child class, invoking the method on the child class object will execute the method defined in the child class, not the one in the parent class. To explicitly call the parent class\u0026rsquo;s method, we can use the super() function.\nTo explicitly invoke the parent class\u0026rsquo;s version of the method, the super() function is used. This is especially useful when the child class\u0026rsquo;s method needs to build upon or extend the functionality of the parent class\u0026rsquo;s method.\nSyntax:\nsuper().method_name() Example:\nclass Person: def display(self): print(\u0026#34;Person class\u0026#34;) class Student(Person): def display(self): super().display() print(\u0026#34;Student class\u0026#34;) student1 = Student() student1.display() # Output: # Person class # Student class Example:\nclass Person: def __init__(self,name,age): self.name=name self.age=age class Student(Person): def __init__(self,name,age,roll): super().__init__(name,age) self.roll=roll def display(self): print(f\u0026#34;Name: {self.name}\u0026#34;) print(f\u0026#34;Age: {self.age}\u0026#34;) print(f\u0026#34;Roll: {self.roll}\u0026#34;) student1 = Student(\u0026#34;Alice\u0026#34;, 30, 101) student1.display() # Output: # Name: Alice # Age: 30 # Roll: 101 Note: Use super for single inheritance only. For multiple inheritance, use the class name directly.\nMagic/dunder methods in Python Magic methods are special methods that have double underscores at the beginning and end of their names. They are also known as dunder methods (short for \u0026ldquo;double underscore\u0026rdquo;). Magic methods are used to define the behavior of objects. They are automatically called when certain operations are performed on objects. Some of the commonly used magic methods are:\n__init__: Constructor method, called when an object is created. __str__: Called by the str() built-in function to return a string representation of an object. __repr__: Called by the repr() built-in function to return an unambiguous string representation of an object. __add__: Called by the + operator to perform addition. __len__: Called by the len() built-in function to return the length of an object. __call__: Called when an object is called as a function. Note : All magic method can be seen using dir(objectname) method and we can override the magic method in our class.\nexample of all method:\nclass Person: def __init__(self, name, age): self.name = name self.age = age def __str__(self): return f\u0026#34;Name: {self.name}, Age: {self.age}\u0026#34; def __repr__(self): return f\u0026#34;Person(\u0026#39;{self.name}\u0026#39;, {self.age})\u0026#34; def __add__(self, other): return self.age + other.age def __len__(self): return len(self.name) def __call__(self): return f\u0026#34;Name: {self.name}, Age: {self.age}\u0026#34; person1 = Person(\u0026#34;Alice\u0026#34;, 30) person2 = Person(\u0026#34;Bob\u0026#34;, 25) print(person1) # Output: Name: Alice, Age: 30 print(repr(person1)) # Output: Person(\u0026#39;Alice\u0026#39;, 30) print(person1 + person2) # Output: 55 print(len(person1)) # Output: 5 print(person1()) # Output: Name: Alice, Age: 30 Method Overriding Method overriding is a feature of object-oriented programming that allows a subclass to provide a specific implementation of a method that is already provided by its parent class. When a method in a subclass has the same name, same parameters or signature, and same return type as a method in its parent class, then the method in the subclass is said to override the method in the parent class. Example:\nclass Person: def display(self): print(\u0026#34;Person class\u0026#34;) class Student(Person): def display(self): print(\u0026#34;Student class\u0026#34;) student1 = Student() student1.display() # Output: Student class We can also call the parent class\u0026rsquo;s method from the overridden method using the super() function.\nExample:\nclass Person: def display(self): print(\u0026#34;Person class\u0026#34;) class Student(Person): def display(self): super().display() #Or Person.display(self) print(\u0026#34;Student class\u0026#34;) student1 = Student() student1.display() # Output: # Person class # Student class Operator overloading in Python Operator overloading is a feature of object-oriented programming that allows us to define the behavior of operators for user-defined objects. It allows us to define the behavior of operators such as +, -, *, /, ==, !=, etc., for objects of a class. To overload an operator, we need to define a special method in the class that corresponds to the operator. These special methods are called magic methods or dunder methods.\nExample:\nclass Point: def __init__(self, x, y): self.x = x self.y = y def __add__(self, other): x = self.x + other.x y = self.y + other.y return Point(x, y) def __str__(self): return f\u0026#34;({self.x}, {self.y})\u0026#34; point1 = Point(1, 2) point2 = Point(3, 4) point3 = point1 + point2 print(point3) # Output: (4, 6) Types of Inheritance in Python Inheritance is a mechanism in which one class acquires the properties and behavior of another class. There are different types of inheritance in Python: Single Inheritance: In single inheritance, a class inherits from only one parent class. The pictorial representation of single inheritance is:\nA\r|\rB Syntax:\nclass ParentClass: #code block class ChildClass(ParentClass): #code block Example:\nclass Person: def __init__(self, name, age): self.name = name self.age = age def display(self): return f\u0026#34;Name: {self.name}, Age: {self.age}\u0026#34; def __str__(self): return f\u0026#34;Name: {self.name}, Age: {self.age}\u0026#34; def __repr__(self): return f\u0026#34;Person(\u0026#39;{self.name}\u0026#39;, {self.age})\u0026#34; def __call__(self): return f\u0026#34;Name: {self.name}, Age: {self.age}\u0026#34; class Student(Person): def __init__(self,naem,age,id): super().__init__(name,age) #or Person.__init__(self,name,age) self.id=id def display(self): print(f\u0026#34;ID: {self.id}\u0026#34;,super().display()) #or Person.display(self) student1 = Student(\u0026#34;Alice\u0026#34;, 30, 101) student1.display() # Output: # ID: 101 # Name: Alice, Age: 30 Multiple Inheritance: In multiple inheritance, a class inherits from more than one parent class. The pictorial representation of multiple inheritance is:\nA B\r\\ /\rC Syntax:\nclass ParentClass1: #code block class ParentClass2: #code block class ChildClass(ParentClass1, ParentClass2): #code block Example:\nclass Person: def __init__(self, name, age): self.name = name self.age = age def display(self): return f\u0026#34;Name: {self.name}, Age: {self.age}\u0026#34; class Address: def __init__(self,city,state): self.city=city self.state=state def display(self): return f\u0026#34;City: {self.city}, State: {self.state}\u0026#34; class Student(Person,Address): def __init__(self,name,age,id,city,state): Person.__init__(self,name,age) Address.__init__(self,city,state) self.id=id def display(self): print(f\u0026#34;ID: {self.id}\u0026#34;,Person.display(self),Address.display(self)) student1 = Student(\u0026#34;Alice\u0026#34;, 30, 101,\u0026#34;New York\u0026#34;,\u0026#34;New York\u0026#34;) student1.display() # Output: # ID: 101 # Name: Alice, Age: 30 # City: New York, State: New York Multilevel Inheritance: In multilevel inheritance, a class inherits from a parent class, and another class inherits from the child class. The pictorial representation of multilevel inheritance is:\nA\r|\rB\r|\rC Syntax:\nclass ParentClass: #code block class ChildClass(ParentClass): #code block class GrandChildClass(ChildClass): #code block Example:\nclass Person: def __init__(self, name, age): self.name = name self.age = age def display(self): return f\u0026#34;Name: {self.name}, Age: {self.age}\u0026#34; class Student(Person): def __init__(self,name,age,id): super().__init__(name,age) # or Person.__init__(self,name,age) self.id=id def display(self): print(f\u0026#34;ID: {self.id}\u0026#34;,super().display()) # print(f\u0026#34;ID: {self.id}\u0026#34;,Person.display(self)) class CollegeStudent(Student): def __init__(self,name,age,id,classes): super().__init__(name,age,id) #or Student.__init__(self,name,age,id) self.classes=classes def display(self): print(f\u0026#34;Class: {self.classes}\u0026#34;,super().display()) #or print(f\u0026#34;Class: {self.classes}\u0026#34;,Student.display(self)) student1 = CollegeStudent(\u0026#34;Alice\u0026#34;, 30, 101,\u0026#34;Bachelor\u0026#34;) student1.display() # Output: # Class: Bachelor # ID: 101 # Name: Alice, Age: 30 Hierarchical Inheritance: In hierarchical inheritance, more than one class inherits from a single parent class. The pictorial representation of hierarchical inheritance is:\nA\r/ \\\rB C Syntax:\nclass ParentClass: #code block class ChildClass1(ParentClass): #code block class ChildClass2(ParentClass): #code block Example:\nclass Person: def __init__(self, name, age): self.name = name self.age = age def display(self): return f\u0026#34;Name: {self.name}, Age: {self.age}\u0026#34; class Student(Person): def __init__(self,name,age,id): super().__init__(name,age) #or Person.__init__(self,name,age) self.id=id def display(self): print(f\u0026#34;ID: {self.id}\u0026#34;,super().display()) #or print(f\u0026#34;ID: {self.id}\u0026#34;,Person.display(self)) class Employee(Person): def __init__(self,name,age,emp_id): super().__init__(name,age) #or Person.__init__(self,name,age) self.emp_id=emp_id def display(self): print(f\u0026#34;Emp ID: {self.emp_id}\u0026#34;,super().display()) #or print(f\u0026#34;Emp ID: {self.emp_id}\u0026#34;,Person.display(self)) student1 = Student(\u0026#34;Alice\u0026#34;, 30, 101) student1.display() employee1 = Employee(\u0026#34;Bob\u0026#34;, 25, 201) employee1.display() # Output: # ID: 101 # Name: Alice, Age: 30 # Emp ID: 201 # Name: Bob, Age: 25 Note: Hybrid inheritance is a combination of two or more types of inheritance.\n14. MRO (Method Resolution Order) in Python Method Resolution Order (MRO) is the order in which methods are resolved in the inheritance hierarchy. It defines the order in which the base classes are searched when executing a method.\nfor example:\nclass C: f=\u0026#34;dirajan\u0026#34; class A(C): f=\u0026#34;nirajan\u0026#34; class B(C): f=\u0026#34;kirajan\u0026#34; class D(A,B): pass def display(self): print(self.f) d=D() print(D.__mro__) d.display() Output:\n(\u0026lt;class \u0026#39;__main__.D\u0026#39;\u0026gt;, \u0026lt;class \u0026#39;__main__.A\u0026#39;\u0026gt;, \u0026lt;class \u0026#39;__main__.B\u0026#39;\u0026gt;, \u0026lt;class \u0026#39;__main__.C\u0026#39;\u0026gt;, \u0026lt;class \u0026#39;object\u0026#39;\u0026gt;)\rnirajan It means it will search for the method in the order of D-\u0026gt;A-\u0026gt;B-\u0026gt;C-\u0026gt;object if the method is not found in the D it will search in A and so on. but if the method is found in the D it will not search in the A,B,C and object.\n15.Class Inside a Class in Python A class can be defined inside another class. The class inside the class is known as nested class. The nested class can access the attributes and methods of the outer class.\nSyntax:\nclass OuterClass: class InnerClass: #code block Example:\nclass OuterClass: def __init__(self): self.name = \u0026#34;Alice\u0026#34; self.age = 30 class InnerClass: def display(self, outer): print(f\u0026#34;Name: {outer.name}\u0026#34;) print(f\u0026#34;Age: {outer.age}\u0026#34;) outer1 = OuterClass() inner1 = outer1.InnerClass() inner1.display(outer1) # Output: # Name: Alice # Age: 30 16. Nested class in Python A class can be defined inside another class. The class inside the class is known as nested class. The nested class can access the attributes and methods of the outer class.\nSyntax:\nclass OuterClass: class InnerClass: #code block Creating an object of the nested class: Syntax:\nouter_object = OuterClass() inner_object = outer_object.InnerClass() Example:\nclass OuterClass: def __init__(self): self.name = \u0026#34;Alice\u0026#34; self.age = 30 class InnerClass: def display(self, outer): print(f\u0026#34;Name: {outer.name}\u0026#34;) print(f\u0026#34;Age: {outer.age}\u0026#34;) outer1 = OuterClass() inner1 = outer1.InnerClass() inner1.display(outer1) # Output: # Name: Alice # Age: 30 creating an object of the nested class inside the outer class:\nclass OuterClass: def __init__(self): self.name = \u0026#34;Alice\u0026#34; self.age = 30 self.inner = self.InnerClass() class InnerClass: def display(self, outer): print(f\u0026#34;Name: {outer.name}\u0026#34;) print(f\u0026#34;Age: {outer.age}\u0026#34;) outer1 = OuterClass() outer1.inner.display(outer1) # Output: # Name: Alice # Age: 30 ","permalink":"http://localhost:1313/posts/pages/python/python_object_oriented1/","summary":"This is the first part of series of Object Oriented Programming in Python","title":"Python Fundamentals: Exploring OOP (Part 12)"},{"content":"DOM (Document Object Model) Theory The DOM is a programming interface for HTML and XML documents. It represents the document as a tree structure where each node is an object representing a part of the document. This allows programming languages to interact with the document structure, style, and content.\n1. DOM Selection Methods a) document.getElementById() Selects an element by its ID attribute.\n\u0026lt;!-- HTML --\u0026gt; \u0026lt;div id=\u0026#34;myDiv\u0026#34;\u0026gt;Hello\u0026lt;/div\u0026gt; // JavaScript const element = document.getElementById(\u0026#39;myDiv\u0026#39;); console.log(element.innerText); // Output: // \u0026#34;Hello\u0026#34; b) document.getElementsByClassName() Returns a collection of elements with the specified class name.\n\u0026lt;!-- HTML --\u0026gt; \u0026lt;div class=\u0026#34;myClass\u0026#34;\u0026gt;Item 1\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;myClass\u0026#34;\u0026gt;Item 2\u0026lt;/div\u0026gt; // JavaScript const elements = document.getElementsByClassName(\u0026#39;myClass\u0026#39;); for (let i = 0; i \u0026lt; elements.length; i++) { console.log(elements[i].innerText); } // Output: // \u0026#34;Item 1\u0026#34; // \u0026#34;Item 2\u0026#34; c) document.getElementsByTagName() Returns a collection of elements with the specified tag name.\n\u0026lt;!-- HTML --\u0026gt; \u0026lt;p\u0026gt;Paragraph 1\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Paragraph 2\u0026lt;/p\u0026gt; // JavaScript const paragraphs = document.getElementsByTagName(\u0026#39;p\u0026#39;); for (let i = 0; i \u0026lt; paragraphs.length; i++) { console.log(paragraphs[i].innerText); // Output: // \u0026#34;Paragraph 1\u0026#34; // \u0026#34;Paragraph 2\u0026#34; d) document.querySelector() Returns the first element that matches the CSS selector.\n\u0026lt;!-- HTML --\u0026gt; \u0026lt;div class=\u0026#34;myClass\u0026#34;\u0026gt;First Element\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;myClass\u0026#34;\u0026gt;Second Element\u0026lt;/div\u0026gt; // JavaScript const firstElement = document.querySelector(\u0026#39;.myClass\u0026#39;); console.log(firstElement.innerText); // Output: // \u0026#34;First Element\u0026#34; e) document.querySelectorAll() Returns all elements that match the CSS selector.\n\u0026lt;!-- HTML --\u0026gt; \u0026lt;div class=\u0026#34;myClass\u0026#34;\u0026gt;First Element\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;myClass\u0026#34;\u0026gt;Second Element\u0026lt;/div\u0026gt; // JavaScript const allElements = document.querySelectorAll(\u0026#39;.myClass\u0026#39;); allElements.forEach(el =\u0026gt; console.log(el.innerText)); // Output: // \u0026#34;First Element\u0026#34; // \u0026#34;Second Element\u0026#34; 2. DOM Properties a) innerText Gets or sets the text content of an element.\n\u0026lt;!-- HTML --\u0026gt; \u0026lt;div id=\u0026#34;textElement\u0026#34;\u0026gt;Original Text\u0026lt;/div\u0026gt; // JavaScript const element = document.getElementById(\u0026#39;textElement\u0026#39;); element.innerText = \u0026#39;Hello World\u0026#39;; console.log(element.innerText); // Output: // \u0026#34;Hello World\u0026#34; b) innerHTML Gets or sets the HTML content of an element.\n\u0026lt;!-- HTML --\u0026gt; \u0026lt;div id=\u0026#34;htmlElement\u0026#34;\u0026gt;Original Content\u0026lt;/div\u0026gt; // JavaScript const element = document.getElementById(\u0026#39;htmlElement\u0026#39;); element.innerHTML = \u0026#39;\u0026lt;span\u0026gt;Hello World\u0026lt;/span\u0026gt;\u0026#39;; console.log(element.innerHTML); // Output: // \u0026#34;\u0026lt;span\u0026gt;Hello World\u0026lt;/span\u0026gt;\u0026#34; c) textContent Gets or sets the text content of a node and its descendants.\n\u0026lt;!-- HTML --\u0026gt; \u0026lt;div id=\u0026#34;contentElement\u0026#34;\u0026gt;Original Content\u0026lt;/div\u0026gt; // JavaScript const element = document.getElementById(\u0026#39;contentElement\u0026#39;); element.textContent = \u0026#39;Hello World\u0026#39;; console.log(element.textContent); // Output: // \u0026#34;Hello World\u0026#34; d) style Gets or sets inline styles of an element.\n\u0026lt;!-- HTML --\u0026gt; \u0026lt;div id=\u0026#34;styledElement\u0026#34;\u0026gt;Style Me\u0026lt;/div\u0026gt; // JavaScript const element = document.getElementById(\u0026#39;styledElement\u0026#39;); element.style.backgroundColor = \u0026#39;red\u0026#39;; element.style.fontSize = \u0026#39;16px\u0026#39;; // Result: Element with red background and font size of 16px 3. Events in JavaScript Events are actions that occur in a web page that can be detected by JavaScript.\nClick Event Example \u0026lt;!-- HTML --\u0026gt; \u0026lt;button id=\u0026#34;clickButton\u0026#34;\u0026gt;Click Me\u0026lt;/button\u0026gt; // JavaScript const button = document.getElementById(\u0026#39;clickButton\u0026#39;); button.addEventListener(\u0026#39;click\u0026#39;, function(e) { console.log(\u0026#39;Clicked!\u0026#39;); }); // Output when clicked: // \u0026#34;Clicked!\u0026#34; Mouse Over Event Example \u0026lt;!-- HTML --\u0026gt; \u0026lt;div id=\u0026#34;hoverElement\u0026#34;\u0026gt;Hover Over Me\u0026lt;/div\u0026gt; // JavaScript const element = document.getElementById(\u0026#39;hoverElement\u0026#39;); element.addEventListener(\u0026#39;mouseover\u0026#39;, function(e) { console.log(\u0026#39;Mouse over!\u0026#39;); }); // Output when hovered: // \u0026#34;Mouse over!\u0026#34; ","permalink":"http://localhost:1313/posts/pages/js/domevents/","summary":"A complete reference guide for DOM manipulation and Events","title":"Javascript : Dom and Events"},{"content":"Asynchronous Programming in JavaScript Asynchronous programming allows a program to perform multiple tasks simultaneously. It enables non-blocking operations, making it possible to execute long-running tasks without freezing the main program.\nFor example:\nconsole.log(\u0026#39;Start\u0026#39;); setTimeout(() =\u0026gt; { console.log(\u0026#39;This message is delayed by 2 seconds\u0026#39;); }, 2000); console.log(\u0026#39;End\u0026#39;); When you run this code, the output will be:\nStart\rEnd\rThis message is delayed by 2 seconds Explanation:\nconsole.log('Start'); is executed, and \u0026ldquo;Start\u0026rdquo; is printed. setTimeout() sets up a callback function to run after 2000 milliseconds (2 seconds) but does not block the next line. console.log('End'); is executed immediately after, and \u0026ldquo;End\u0026rdquo; is printed. After 2 seconds, the callback function in setTimeout() is executed, and \u0026ldquo;This message is delayed by 2 seconds\u0026rdquo; is printed. This demonstrates how asynchronous functions like setTimeout() work without blocking the execution of subsequent code.\nPromises Promises are a way to handle asynchronous operations in JavaScript. They represent a value that may be available now, in the future, or never. Promises can be in one of three states: pending, fulfilled, or rejected. They allow us to run code when the promise is fulfilled or rejected using the .then() and .catch() methods.\nSyntax to create a new Promise:\nconst promise = new Promise((resolve, reject) =\u0026gt; { // Perform an asynchronous operation // If successful, call resolve(value) // If an error occurs, call reject(error) }); Why We Use Promises Consider the following code:\nfunction main() { setTimeout(() =\u0026gt; { console.log(\u0026#34;Hello\u0026#34;); }, 1000); } main(); main(); main(); This code waits for 1 second and then logs \u0026ldquo;Hello\u0026rdquo; three times instantly. But what if we want to wait for the first to be completed before the second?\nThis can be solved using promises:\nfunction promise() { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { console.log(\u0026#34;Hello\u0026#34;); resolve(\u0026#34;Done\u0026#34;); }, 2000); }); } let data = promise(); When a promise is called, it returns a promise object instantly in a pending state. When the asynchronous operation completes, the promise is either fulfilled or rejected.\nHandling Promises To do a task when the promise is fulfilled (resolved):\ndata.then((data) =\u0026gt; { console.log(data); }); To do a task when the promise is rejected:\ndata.catch((err) =\u0026gt; { console.log(\u0026#34;Promise rejected\u0026#34;, err); }); Handling Multiple Promises function promise1() { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { console.log(\u0026#34;Promise 1 resolved\u0026#34;); resolve(\u0026#34;Done 1\u0026#34;); }, 2000); }); } function promise2() { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { console.log(\u0026#34;Promise 2 resolved\u0026#34;); resolve(\u0026#34;Done 2\u0026#34;); }, 2000); }); } function promise3() { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { console.log(\u0026#34;Promise 3 resolved\u0026#34;); resolve(\u0026#34;Done 3\u0026#34;); }, 2000); }); } let data1 = promise1(); let data2 = promise2(); let data3 = promise3(); How Promises Work:\npromise1 is called. promise2 is called immediately. promise3 is called immediately, regardless of whether the previous promises are resolved. To execute promises one by one:\nlet data1 = promise1(); data1.then((data) =\u0026gt; { console.log(data); return promise2(); }).then((data) =\u0026gt; { console.log(data); return promise3(); }).then((data) =\u0026gt; { console.log(data); }).catch((err) =\u0026gt; { console.log(\u0026#34;Error\u0026#34;, err); }); Here, the first promise will run, then the second, then the third, and so on, one by one.\nAsync and Await Async functions always return a promise. await is used to wait for a promise to be resolved, such that the code below it will not run until the promise is resolved.\nTo use await, we need to use an async function:\nasync function main() { console.log(\u0026#34;Hello\u0026#34;); } main(); Example with await:\nlet promise = new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { resolve(\u0026#34;Done\u0026#34;); }, 2000); }); async function main() { console.log(\u0026#34;Hello\u0026#34;); await promise; console.log(\u0026#34;Hello again\u0026#34;); } main(); console.log(\u0026#34;Hi\u0026#34;); What happens here is the main function is called, it prints \u0026ldquo;Hello\u0026rdquo;, then waits for 2 seconds to resolve. During that time, it prints \u0026ldquo;Hi\u0026rdquo;. When the promise is resolved, it prints \u0026ldquo;Hello again\u0026rdquo;.\nWhen await is called, the function pauses its execution until the promise is resolved. Then it continues the execution of the function, such that code below await will not run until the promise is resolved, but the code outside the function will run.\nasync function main() { console.log(\u0026#34;Hello\u0026#34;); await promise; await promise; await promise; console.log(\u0026#34;Hello again\u0026#34;); } Here, the first promise is resolved, then the second is resolved, and so on.\n","permalink":"http://localhost:1313/posts/pages/js/asyncronous/","summary":"A complete guide to asynchronous programming in JavaScript, covering promises and async/await.","title":"Asynchronous Programming in JavaScript"},{"content":"Basics of Vim Vim is a powerful text editor, often used in the command line, that is known for its efficiency and speed once mastered. Here are the basic commands and modes that you need to get started.\nOpening a File To open a file in Vim, use the following command:\nvim filename Replace filename with the name of the file you wish to open.\nBasic Modes in Vim Vim operates in different modes, and understanding these modes is crucial for using Vim effectively:\nNormal Mode: This is the default mode when you open a file. In this mode, you can navigate, delete, copy, and paste text. To return to Normal Mode from other modes, press Esc.\nInsert Mode: This mode allows you to insert text into the file. To enter Insert Mode, press i. After you\u0026rsquo;re done typing, press Esc to go back to Normal Mode.\nCommon Commands Here are some essential commands for working with files in Vim:\nSave the current file:\n:w This writes (saves) changes to the file.\nQuit Vim:\n:q To quit Vim. If there are unsaved changes, Vim will warn you. You can force quit without saving using:\n:q! Save changes and quit:\n:wq or\n:x These commands save changes and then exit Vim.\nTips for Beginners Press Esc frequently to return to Normal Mode, as it helps you avoid unintended actions while in other modes. Practice using both Normal and Insert modes to become comfortable with the flow of editing and saving files in Vim. Vim can be intimidating at first, but with practice, it becomes an extremely efficient tool for editing text files, especially in programming and development environments. ","permalink":"http://localhost:1313/posts/pages/linux/vim_basics_guide/","summary":"Learn the basics of using Vim, including navigation, saving, and quitting.","title":"Basics of Vim"},{"content":"Docker Cheat Sheet: Commands and Concepts This guide covers essential Docker commands, from creating containers, managing images, building Dockerfiles, to working with volumes.\n🚀 Creating and Running Containers 1. Run a Container from an Image To create and run a container from an image:\ndocker run image 2. Run a Container in Interactive Mode To run a container and open its terminal:\ndocker run -it image After the container starts, you can interact with it directly in the terminal. 3. Name a Container To give a container a specific name:\ndocker run --name container_name image 4. Port Mapping To map a port from your computer to the container:\ndocker run -p computer_port:container_port image Incoming traffic to computer_port will be forwarded to container_port in the container. 5. Run a Container in the Background (Detached Mode) To run the container in the background:\ndocker run -d image 6. Passing Environment Variables to a Container To pass environment variables to a container:\ndocker run -e key=value image 🛠️ Managing Containers 7. Start a Container To start an existing container:\ndocker start container_id 8. Stop a Container To stop a running container:\ndocker stop container_id 9. Remove a Container To remove a container:\ndocker rm container_id Note: The container must be stopped before removal. 10. Execute a Command in a Running Container To start a terminal session inside a running container:\ndocker exec -it container_id bash 11. View Running Containers To list all currently running containers:\ndocker ps 12. View All Containers (Running and Stopped) To see all containers, including those that are stopped:\ndocker ps -a 🧱 Building Docker Images 13. Creating a Dockerfile A Dockerfile is a script used to build Docker images. Here’s an example of common Dockerfile commands:\n# Set the base image for your container FROM base_image # Run commands during the image build process RUN command # Copy files from your local machine to the container COPY source /path/in/container # Set environment variables ENV key=value # Expose a port for the container EXPOSE 8080 # Define the command to run when the container starts CMD [\u0026#34;executable\u0026#34;] # Optionally, run commands automatically when the container starts ENTRYPOINT [\u0026#34;/path/to/script\u0026#34;] # Set the working directory in the container WORKDIR /app # Copy all files from the local directory to the container, excluding files listed in .dockerignore COPY . . 14. Building a Docker Image To build a Docker image from a Dockerfile:\ndocker build -t image_name /path/to/Dockerfile 📂 Managing Docker Files 15. Using the .dockerignore File The .dockerignore file helps exclude unnecessary files from being copied into the Docker image, improving build speed and reducing image size:\nnode_modules/ .git/ 16. COPY Command in Dockerfile The COPY command copies files from your local system to the container:\nCopy all files from the current directory to the container: COPY . /path/in/container Copy a specific file: COPY ./filename.extension /path/in/container Copy an entire folder: COPY ./foldername /path/in/container Copy contents of a folder (not the folder itself): COPY ./foldername/ /path/in/container 📦 Working with Volumes 17. Mounting Volumes Volumes allow data to persist even if the container is deleted. To mount a folder from your host to the container:\ndocker run -it -v /path/on/host:/path/in/container image Example: docker run -it -v /home/user/backup:/app/data ubuntu This will map /home/user/backup on your host to /app/data inside the container. Use Cases for Volumes: Data Persistence: Preserve data even after the container is removed. Backups: Easily back up container data to the host. Shared Data: Share data between multiple containers or between host and container. 💾 Publishing Docker Images 18. Pushing an Image to Docker Hub To publish an image to Docker Hub:\nTag the image with your Docker Hub username: docker tag image_name username/image_name Log in to Docker Hub: docker login Push the image to your repository: docker push username/image_name This guide gives you the essentials for working with Docker. With these commands, you\u0026rsquo;ll be able to manage containers, build images, use volumes, and more effectively.\n","permalink":"http://localhost:1313/posts/pages/docker/docker_basics/","summary":"A guide to understanding Docker commands and concepts.","title":"Docker Basic: Commands and Concepts"},{"content":"Docker Compose Documentation Introduction Docker Compose is a tool for defining and running multi-container Docker applications. With Docker Compose, you can use a YAML file to configure your application\u0026rsquo;s services and create and start all the services from your configuration with a single command.\nBasic docker-compose.yml Structure The docker-compose.yml file is where you define the services that make up your app. A typical file might look like this:\nversion: \u0026#39;3.8\u0026#39; services: service_name: image: image_name:tag ports: - \u0026#34;host_port:container_port\u0026#34; environment: - ENV_VAR=value volumes: - \u0026#34;host_path:container_path\u0026#34; depends_on: - dependency_service Example Configurations Example 1: Basic Setup with PostgreSQL and Redis version: \u0026#39;3.8\u0026#39; services: postgres: image: postgres ports: - \u0026#34;5432:5432\u0026#34; environment: POSTGRES_USER: postgres POSTGRES_DB: review POSTGRES_PASSWORD: password redis: image: redis ports: - \u0026#34;80:80\u0026#34; Example 2: Real-World Application version: \u0026#39;3\u0026#39; services: pythonapp: image: your-python-image:tag ports: - \u0026#34;8000:8000\u0026#34; volumes: - /Users/data:/src/bin/data depends_on: - db - redis db: image: postgres environment: POSTGRES_DB: mydatabase POSTGRES_USER: myuser POSTGRES_PASSWORD: mypassword redis: image: redis volumes: - /path/to/local/directory:/data Example 3: Building from Dockerfile version: \u0026#39;3\u0026#39; services: pythonapp: build: context: . dockerfile: Dockerfile ports: - \u0026#34;8000:8000\u0026#34; volumes: - /Users/desktop:/src/bin/desktop depends_on: - db - redis db: image: postgres environment: POSTGRES_DB: mydatabase POSTGRES_USER: myuser POSTGRES_PASSWORD: mypassword redis: image: redis volumes: - /path/to/local/directory:/data Example 4: Django Application with PostgreSQL and Redis version: \u0026#39;3.8\u0026#39; services: django-app: container_name: django-app image: django-app:latest # Replace with your actual Django image name/tag ports: - \u0026#34;8000:8000\u0026#34; # Expose Django app on port 8000 environment: - DEBUG=1 # Set Django debug mode to 1 for development - POSTGRES_HOST=postgres # PostgreSQL host - POSTGRES_DB_NAME=nirajan # PostgreSQL database name - POSTGRES_DB_PASSWORD=nirajan@9845 # PostgreSQL database password - REDIS_URL=redis://redis:6379/0 # Redis URL depends_on: - postgres - redis volumes: - static_volume:/code/static # Volume for Django static files - media_volume:/code/media # Volume for Django media files postgres: container_name: postgres image: postgres:latest environment: POSTGRES_DB: nirajan # Database name POSTGRES_USER: nirajan # Database username POSTGRES_PASSWORD: nirajan@9845 # Database password volumes: - postgres_data:/var/lib/postgresql/data redis: container_name: redis image: redis:latest ports: - \u0026#34;6379:6379\u0026#34; Service Names as Hostnames In Docker Compose, the names of the services defined in the docker-compose.yml file are used as hostnames for inter-service communication.\nService Names as Hostnames Each service name in the docker-compose.yml file acts as a hostname for that service. For example, in the configuration above:\nThe django-app service can connect to the postgres service using POSTGRES_HOST=postgres. The django-app service can connect to the redis service using REDIS_URL=redis://redis:6379/0. Example In the django-app service:\nPostgreSQL Host: POSTGRES_HOST=postgres — The Django app connects to the PostgreSQL service using the hostname postgres, which matches the name of the PostgreSQL service defined in Docker Compose. Redis Host: REDIS_URL=redis://redis:6379/0 — The Django app connects to the Redis service using the hostname redis, which matches the name of the Redis service defined in Docker Compose. Note: In Docker, services within a Docker Compose setup are typically connected to the same network by default. This allows containers to communicate with each other using service names as hostnames.\nDocker Compose Commands To start the containers defined in docker-compose.yml:\nsudo docker compose up To stop and remove all containers, networks, and volumes created by docker-compose up:\nsudo docker compose down To run the containers in the background (detached mode):\nsudo docker compose up -d Tips Use depends_on to specify dependencies between services. This ensures that the dependent services start in the correct order. Use volumes to persist data outside of your containers, which is especially useful for databases. Use environment variables to configure your services and avoid hardcoding sensitive information. Conclusion Docker Compose simplifies the process of managing multi-container Docker applications. By defining your services in a docker-compose.yml file, you can easily spin up your entire application stack with a single command. This guide provides a solid starting point for using Docker Compose to manage multi-container applications effectively.\n","permalink":"http://localhost:1313/posts/pages/docker/docker_compose/","summary":"Learn how to define and manage services in Docker Compose.","title":"Docker Compose Documentation"},{"content":"Docker CPU and Memory Limits When you want to control the CPU and memory usage of Docker containers, you can use specific options in both Docker CLI commands and Docker Compose files. Here\u0026rsquo;s a detailed guide on how to use these options:\nDocker CLI Commands Setting CPU Limits:\nOption: --cpus Usage: Specifies the number of CPUs that the container can use. Example: docker run --cpus=\u0026#34;1.5\u0026#34; my-image The --cpus option limits the container to 1.5 CPU cores. Setting Memory Limits:\nOption: --memory or -m\nUsage: Sets the maximum amount of memory the container can use.\nExample:\ndocker run --memory=\u0026#34;500m\u0026#34; my-image This command limits the container to 500MB of RAM. If the limit is exceeded, the container will be throttled or terminated.\nNote: The options take a positive integer followed by suffixes such as b, k, m, or g to indicate bytes, kilobytes, megabytes, or gigabytes.\nSoft Memory Limits:\nOption: --memory-reservation Example: docker run --memory=\u0026#34;1g\u0026#34; --memory-reservation=\u0026#34;512m\u0026#34; nginx This reserves 512MB of memory while setting a hard limit of 1GB. Docker Compose Configuration In Docker Compose, you can define resource limits under the deploy section for version 3.x or directly under the services section for version 2.x.\nSetting CPU and Memory Limits in Docker Compose (Version 2.x):\nversion: \u0026#39;2\u0026#39; services: my-service: image: my-image deploy: resources: limits: cpus: \u0026#39;1.5\u0026#39; memory: 500M This limits the service to 1.5 CPUs and 500MB of memory.\nSetting CPU and Memory Limits in Docker Compose (Version 3.x and above):\nversion: \u0026#39;3.8\u0026#39; services: my-service: image: my-image deploy: resources: limits: cpus: \u0026#39;1.5\u0026#39; memory: \u0026#39;500M\u0026#39; This limits the service to 1.5 CPUs and 500MB of memory.\nNotes: Swap Memory: You can enable swap memory using the --memory-swap option in CLI. For example:\ndocker run --memory=\u0026#34;512m\u0026#34; --memory-swap=\u0026#34;1g\u0026#34; nginx CPU Shares: Set CPU priorities between containers using --cpu-shares, with 1024 being the default.\nBy using these options, you can ensure that your Docker containers use resources efficiently, preventing them from overwhelming the host machine.\n","permalink":"http://localhost:1313/posts/pages/docker/docker_cpu_memory_limits_guide/","summary":"Control the CPU and memory usage of Docker containers with CLI and Docker Compose configurations.","title":"Docker CPU and Memory Limits"},{"content":"Docker Networking and Port Access In Docker, containers are isolated by default, meaning:\nContainers cannot access the host machine\u0026rsquo;s ports directly. Containers cannot access the ports of other containers directly. Container ports are not accessible from outside the host machine unless configured. 🛠️ Accessing Container Ports from Outside To access a container\u0026rsquo;s port from outside (e.g., from the host or another machine), you can use port mapping:\n1. Port Mapping docker run -p host_port:container_port imagename This command maps a container\u0026rsquo;s port to a port on the host machine. 2. Host Network To share the host\u0026rsquo;s network namespace with the container:\ndocker run --network host imagename 🌐 Accessing Container Ports from Another Container To allow inter-container communication, you need to create and use a custom Docker network.\nSteps: 1. Create a Docker Network docker network create my_network 2. Run Containers in the Same Network docker run --network my_network --name container1 imagename docker run --network my_network --name container2 imagename 3. Access One Container from Another Use the container name and port to access one container from another:\ncontainer1:port Example Scenario Create a Network docker network create my_network Run First Container docker run --network my_network --name webserver -d nginx Run Second Container docker run --network my_network --name client -it alpine /bin/sh Access Web Server from Client Inside the client container, use the following commands to access the web server: wget -qO- http://webserver or\ncurl http://webserver 📝 Important Notes Container-to-Container Access: Containers in the same custom network can communicate using their names as hostnames. Host Machine Access: Containers cannot directly access the host machine\u0026rsquo;s ports. External Access: Use port mapping or host networking to access container ports from outside the host machine. List Docker Networks To list all available Docker networks and verify the existence of custom networks:\ndocker network ls ","permalink":"http://localhost:1313/posts/pages/docker/docker_networking_guide/","summary":"Understanding Docker networking and inter-container communication.","title":"Docker Networking and Port Access"},{"content":" 1. Configure Git To set up your Git username and email globally on your machine:\ngit config --global user.name \u0026#34;username\u0026#34; # Set your Git username git config --global user.email \u0026#34;email\u0026#34; # Set your Git email git config --list # Display the current Git configuration (username and email) 2. Git Status and Git Clone Clone a remote repository to your local machine:\ngit clone \u0026lt;url\u0026gt; # Copy repository to the local machine Check the status of your local repository:\ngit status # Show the current status of the repository Git Status Breakdown: untracked: A new file that has not been added or committed. unstaged: A file that has been added but not committed. unchanged: No changes have been made. changed: Changes have been made but not yet added or committed. 3. Git Add and Commit Add specific files or all changes and commit them:\ngit add \u0026lt;filename\u0026gt; # Add a specific file to the staging area git add . # Add all changes (modified and untracked files) git commit -m \u0026#34;Your commit message\u0026#34; # Commit the changes with a message 4. Push Local Repo to Remote To upload your local repository changes to the remote repository:\ngit push [alias] [branch] # Push changes to a specific alias and branch git remote add \u0026lt;alias\u0026gt; \u0026lt;url\u0026gt; # Add a remote alias (e.g., \u0026#39;origin\u0026#39;) git push -u [alias] [branch] # Save the alias and branch for future pushes 5. Git Initialization Initialize a new Git repository:\ngit init # Initialize a new Git repository 6. Git Branches Manage Git branches with the following commands:\ngit branch # List all local branches git branch -m \u0026lt;oldbranch\u0026gt; \u0026lt;newbranch\u0026gt; # Rename a branch git checkout \u0026lt;branchname\u0026gt; # Switch to another branch git checkout -b \u0026lt;branchname\u0026gt; # Create and switch to a new branch git branch -d \u0026lt;branchname\u0026gt; # Delete a branch (ensure you\u0026#39;re not on it) git diff \u0026lt;branchname\u0026gt; # Compare the current branch with another 7. Git Merge Merge changes from one branch into another:\ngit merge \u0026lt;branchname\u0026gt; # Merge changes from \u0026lt;branchname\u0026gt; into the current branch 8. Pull Request and Syncing Changes To pull updates from the remote repository to your local one:\ngit pull # Pull the latest changes from the remote repository git pull [alias] [branch] # Pull changes from a specific alias and branch 9. Undoing Changes If You Have Only Added Changes: git reset \u0026lt;filename\u0026gt; # Unstage a file from the staging area git reset # Unstage all files that have been added If You Have Committed Changes: git reset HEAD~1 # Undo the last commit (one step back) git reset \u0026lt;commit_hash\u0026gt; # Reset to a specific commit hash git reset --hard \u0026lt;commit_hash\u0026gt; # Hard reset to a commit and reflect changes in your editor git log # View all commit hashes and logs 10. Forking Repositories When contributing to open-source projects, you can fork a repository, which creates a copy of the repo under your GitHub account. Afterward, you can make changes and submit a pull request:\n# Fork a repository on GitHub and clone it locally git clone \u0026lt;forked_repo_url\u0026gt; # Clone your forked repository Make changes, commit them, and push to your fork. Finally, create a pull request on GitHub to merge your changes into the original repository.\nIF ANY CONCEPT IS LAGGING THEN: Watch this helpful video\n","permalink":"http://localhost:1313/posts/pages/git/git-cheetsheet/","summary":"A brief tutorial on github recipe and git command","title":"Git Commands and Configuration Guide"},{"content":"How to Create Content for Hugo Using Markdown Hugo, a static site generator, uses Markdown (.md) files to generate content. In this guide, we will explain how you can create content for Hugo using Markdown.\n1. Front Matter Every Markdown file in Hugo requires front matter, which is metadata placed at the top of the file. It helps Hugo understand how to process the file.\nExample:\n--- title: \u0026#34;My First Hugo Post\u0026#34; date: 2024-10-18 tags: [\u0026#34;Hugo\u0026#34;, \u0026#34;Markdown\u0026#34;] summary: \u0026#34;A brief summary of the post.\u0026#34; --- 2. Headers Headers are used to organize content. Use one # for an H1 header, two ## for H2, and so on.\nExample:\n# H1 Header ## H2 Header ### H3 Header Output:\nH3 Header 3. Text Formatting Markdown supports several text formatting options:\nExample:\n**Bold Text** *Italic Text* ~~Strikethrough~~ Output: Bold Text\nItalic Text\nStrikethrough\n4. Spacing and Line Breaks In Markdown, you can create paragraphs by leaving a blank line between lines of text.\nExample:\nThis is the first paragraph. This is the second paragraph. Output: This is the first paragraph.\nThis is the second paragraph.\n5. Horizontal Rules You can create horizontal lines (dividers) using three or more dashes (---), asterisks (***), or underscores (___).\nExample:\n--- Output:\n6. Lists Create unordered lists with - or *, and ordered lists with numbers followed by periods.\nExample:\n- Item 1 - Item 2 1. First item 2. Second item Output:\nItem 1 Item 2 First item Second item 7. Links and Images Add links and images with square brackets [] and parentheses ().\nExample:\n[Hugo Documentation](https://gohugo.io) ![Hugo Logo](/images/hugo.webp) Output: Hugo Documentation\n8. Code Blocks For inline code, use backticks. For block code, use triple backticks.\nExample:\nInline code: `print(\u0026#34;Hello World\u0026#34;)` Output: Inline code: print(\u0026quot;Hello World\u0026quot;)\nExample:\nBlock Code: def hello(): print(\u0026#34;Hello, Hugo!\u0026#34;) def hello(): print(\u0026#34;Hello, Hugo!\u0026#34;) 9. Blockquotes Use the greater than symbol (\u0026gt;) to create blockquotes.\nExample:\n\u0026gt; This is a blockquote in Hugo. Output:\nThis is a blockquote in Hugo.\n10. Tables You can create tables using pipes | and dashes -.\nExample:\n| Column 1 | Column 2 | |----------|----------| | Row 1 | Data 1 | | Row 2 | Data 2 | Output:\nColumn 1 Column 2 Row 1 Data 1 Row 2 Data 2 11. Task Lists Create task lists by using square brackets []. An x in the brackets [x] marks a task as completed.\nExample:\n- [ ] Task 1 - [x] Task 2 (Completed) Output:\nTask 1 Task 2 (Completed) 12. Syntax Highlighting Hugo supports syntax highlighting for various programming languages. You can specify the language after the triple backticks(```).\nExample: Output:\ndef greet(): print(\u0026#34;Hello, Hugo!\u0026#34;) 12. Task Lists Create task lists by using square brackets []. An x in the brackets [x] marks a task as completed.\nExample:\n- [ ] Task 1 - [ ] Sub-task 1 - [x] Sub-task 2 (Completed) - [x] Task 2 (Completed) Output:\nTask 1 Sub-task 1 Sub-task 2 (Completed) Task 2 (Completed) 13. Escaping Special Characters To use special characters like #, escape them using a backslash \\.\nExample:\n\\# This is not a header Output: # This is not a header\n14. Backtick To display backtick use four space before it as\n``` 15. Consistency It\u0026rsquo;s important to maintain consistent formatting throughout your Markdown files to ensure a clean and readable structure.\nBy following these steps, you can effectively create well-formatted content for your Hugo site using Markdown.\n","permalink":"http://localhost:1313/posts/pages/hugo/markdown_hugo_content_guide/","summary":"A tutorial on creating content with Markdown in Hugo.","title":"How to Create Content for Hugo"},{"content":"JavaScript Reference Behavior: Objects and Arrays Introduction In JavaScript, both objects and arrays are considered reference types. This means that when you assign an object or an array to another variable, you’re not creating a new copy of that object or array. Instead, the new variable holds a reference to the original object or array in memory. Understanding this concept is crucial because it directly affects how data is manipulated and shared within your code.\nObject Reference Behavior 1. Overview When you work with objects in JavaScript, it\u0026rsquo;s essential to recognize that assigning an object to a new variable does not create a new object. Instead, it creates a reference to the original object. This means that any changes made through the new reference will affect the original object.\n2. Example const person = { name: \u0026#34;Alice\u0026#34;, address: { city: \u0026#34;Wonderland\u0026#34; } }; const newPerson = person.address; // newPerson now references the same object as person.address newPerson.city = \u0026#34;New Wonderland\u0026#34;; // modifying newPerson affects the original object console.log(person); // Output: { name: \u0026#39;Alice\u0026#39;, address: { city: \u0026#39;New Wonderland\u0026#39; } } ## JavaScript Reference Behavior: Objects and Arrays ### Introduction In JavaScript, both objects and arrays are considered reference types. This means that when you assign an object or an array to another variable, you’re not creating a new copy of that object or array. Instead, the new variable holds a reference to the original object or array in memory. Understanding this concept is crucial because it directly affects how data is manipulated and shared within your code. ### Object Reference Behavior #### 1. Overview When you work with objects in JavaScript, it\u0026#39;s essential to recognize that assigning an object to a new variable does not create a new object. Instead, it creates a reference to the original object. This means that any changes made through the new reference will affect the original object. #### 2. Example ```javascript const person = { name: \u0026#34;Alice\u0026#34;, address: { city: \u0026#34;Wonderland\u0026#34; } }; const newPerson = person.address; // newPerson now references the same object as person.address newPerson.city = \u0026#34;New Wonderland\u0026#34;; // modifying newPerson affects the original object console.log(person); // Output: { name: \u0026#39;Alice\u0026#39;, address: { city: \u0026#39;New Wonderland\u0026#39; } } 3. Explanation Object Reference: When you create const newPerson = person.address;, you\u0026rsquo;re not making a copy of the address object. Instead, newPerson references the same address object that person.address references. Thus, when you update newPerson.city = \u0026quot;New Wonderland\u0026quot;;, it directly modifies the person.address object because both newPerson and person.address are pointing to the same location in memory. Output: The console logs the person object, which now reflects the change: { name: 'Alice', address: { city: 'New Wonderland' } }. Array Reference Behavior 1. Overview Arrays in JavaScript behave similarly to objects in terms of reference handling. When you assign an array to another variable, you create a reference to the original array. As a result, any modifications through this reference will affect the original array.\n2. Example const numbers = [1, 2, 3]; const moreNumbers = numbers; // moreNumbers now references the same array as numbers moreNumbers[0] = 99; // modifying moreNumbers affects the original array console.log(numbers); // Output: [99, 2, 3] 3. Explanation Array Reference: When you create const moreNumbers = numbers;, you\u0026rsquo;re not creating a new array. Instead, moreNumbers becomes a reference to the same array that numbers references. Any changes to moreNumbers, such as moreNumbers[0] = 99, directly modify the numbers array because both variables point to the same array in memory. Output: The console logs the numbers array, which now reflects the change: [99, 2, 3]. Key Takeaways Reference Types: Both objects and arrays are reference types in JavaScript, meaning that variables assigned to them hold references to the same data in memory. Shared Modifications: Changes made to an object or array through one reference will affect all other references to that same object or array. Memory Efficiency: This reference behavior allows for memory-efficient data management but requires careful handling to avoid unintended side effects. JavaScript References with filter() and find() In JavaScript, the way references work with methods like filter() and find() is different, leading to distinct behaviors. Understanding these differences is crucial for working effectively with arrays and avoiding unintended side effects.\nfilter(): Creating a New Array 1. Overview The filter() method in JavaScript creates a new array that contains only the elements that satisfy the provided condition. This means that a new array is returned, and it does not affect the original array. However, if the elements in the array are objects, the references to these objects are retained, meaning any modifications to the objects in the new array will also affect the original array.\n2. Example const originalArray = [ { id: 1, name: \u0026#34;Alice\u0026#34; }, { id: 2, name: \u0026#34;Bob\u0026#34; }, { id: 3, name: \u0026#34;Charlie\u0026#34; } ]; const filteredArray = originalArray.filter(item =\u0026gt; item.id !== 2); // Modify an object in the filtered array filteredArray[0].name = \u0026#34;Alicia\u0026#34;; console.log(originalArray); // Output: [{ id: 1, name: \u0026#39;Alicia\u0026#39; }, { id: 2, name: \u0026#39;Bob\u0026#39; }, { id: 3, name: \u0026#39;Charlie\u0026#39; }] console.log(filteredArray); // Output: [{ id: 1, name: \u0026#39;Alicia\u0026#39; }, { id: 3, name: \u0026#39;Charlie\u0026#39; }] 3. Explanation New Array Creation: The filter() method creates a new array (filteredArray) that includes all elements from originalArray except the one with id 2. However, the objects within the new array are still references to the original objects in originalArray. Shared References: When you modify the name property of the first object in filteredArray (filteredArray[0].name = \u0026quot;Alicia\u0026quot;;), it also changes in originalArray because both arrays reference the same object in memory. Output: The original array shows that the name of the first object has been changed to \u0026ldquo;Alicia\u0026rdquo;, indicating that the object references are shared. find(): Returning a Single Element Reference 1. Overview The find() method returns the first element in the array that satisfies the provided condition. This element is not a copy but a reference to the original element in the array. As a result, any modification to this element directly affects the original array.\n2. Example const originalArray = [ { id: 1, name: \u0026#34;Alice\u0026#34; }, { id: 2, name: \u0026#34;Bob\u0026#34; }, { id: 3, name: \u0026#34;Charlie\u0026#34; } ]; const foundItem = originalArray.find(item =\u0026gt; item.id === 2); // Modify the found item foundItem.name = \u0026#34;Robert\u0026#34;; console.log(originalArray); // Output: [{ id: 1, name: \u0026#39;Alice\u0026#39; }, { id: 2, name: \u0026#39;Robert\u0026#39; }, { id: 3, name: \u0026#39;Charlie\u0026#39; }] console.log(foundItem); // Output: { id: 2, name: \u0026#39;Robert\u0026#39; } 3. Explanation Element Reference: The find() method returns a reference to the first element that meets the condition (item.id === 2). In this case, foundItem references the same object in memory as the element in originalArray with id: 2. Direct Modification: When you modify the name property of foundItem (foundItem.name = \u0026quot;Robert\u0026quot;;), it directly alters the corresponding object in originalArray because they are the same object in memory. Output: The original array now shows that the name of the object with id: 2 has been changed to \u0026ldquo;Robert\u0026rdquo;, demonstrating that the reference was modified. Key Differences Between filter() and find() New Array vs. Single Element: filter(): Returns a new array containing references to elements that meet the condition. find(): Returns a reference to the first element that meets the condition. Impact on Original Array: filter(): The original array remains unchanged, but the objects within the new array are still references to the original objects. find(): The original array can be directly modified through the returned element. Use Cases: Use filter() when you need a subset of the original array without altering it directly. Use find() when you need to retrieve and possibly modify a specific element from the array. Conclusion Understanding how references work with methods like filter() and find() is crucial in JavaScript. While filter() returns a new array that retains references to the original objects, find() returns a direct reference to a single element. Being aware of these behaviors helps prevent unintended modifications to your data.\n","permalink":"http://localhost:1313/posts/pages/js/referencebehavious/","summary":"Learn about reference types in JavaScript, including objects and arrays, and how methods like filter() and find() handle references.","title":"JavaScript Reference Behavior: Objects and Arrays"},{"content":"JavaScript Reference Guide 1. Console.log() Method Purpose: Prints output to the console, useful for debugging. Syntax: console.log(value); Example: const name = \u0026#39;John\u0026#39;; console.log(name); // Output: John 2. Variables: let, const let: Block-scoped variable that can be updated but not accessed before declaration.\nlet x = 10; if (true) { let x = 20; // Block-scoped console.log(x); // 20 } console.log(x); // 10 const: Block-scoped variable that cannot be reassigned and must be initialized when declared.\nconst pi = 3.14; // pi = 3.1415; // Error: Cannot reassign 3. JavaScript Data Types String\nExplanation: Represents a sequence of characters. Can be enclosed in single quotes, double quotes, or backticks (for template literals). Syntax: const str = 'Hello, World!'; Example: const greeting = \u0026#34;Hello, \u0026#34; + \u0026#34;World!\u0026#34;; // Output: Hello, World! Number\nExplanation: Represents both integer and floating-point numbers. JavaScript numbers range from -(2^53 - 1) to 2^53 - 1. Syntax: const num = 123; Example: const amount = 25; // Output: 25 BigInt\nExplanation: Represents integers with arbitrary precision. Denoted by appending an n to the end of the number. Syntax: const bigNum = 1234567890123456789012345678901234567890n; Example: const bigNumber = 1234567890123456789012345678901234567890n; Boolean\nExplanation: Represents a value that is either true or false. Syntax: const isTrue = true; Example: const isActive = Boolean(1); // Output: true Null\nExplanation: Represents the intentional absence of any value. Syntax: const emptyValue = null; Example: const noValue = null; Undefined\nExplanation: Represents a variable that has been declared but not assigned a value. Syntax: let uninitialized; Example: let value; console.log(value); // Output: undefined For Checking Data Type We Use: typeof variableName; 4. Explicit Type Conversion To String: String(value) or value.toString()\nlet str = String(123); // \u0026#39;123\u0026#39; To Number: Number(value), parseInt(value), or parseFloat(value)\nlet num = Number(\u0026#39;456\u0026#39;); // 456 To Boolean: Boolean(value)\nlet bool = Boolean(\u0026#39;hello\u0026#39;); // true 5. JavaScript Operators i) Comparison Operators Greater than: a \u0026gt; b Less than: a \u0026lt; b Greater than or equal to: a \u0026gt;= b Less than or equal to: a \u0026lt;= b Not equal to: a != b Equal to: a == b Strictly equal to: a === b Examples:\nconsole.log(\u0026#34;2\u0026#34; == 2); // true console.log(\u0026#34;2\u0026#34; === 2); // false ii) Logical Operators AND: operand1 \u0026amp;\u0026amp; operand2 OR: operand1 || operand2 NOT: !operand Examples:\nconsole.log(true \u0026amp;\u0026amp; false); // false console.log(true || false); // true console.log(!true); // false iii) Arithmetic Operators Addition: operand1 + operand2 Subtraction: operand1 - operand2 Multiplication: operand1 * operand2 Division: operand1 / operand2 Modulo: operand1 % operand2 Increment: operand++ Decrement: operand-- Examples:\nconsole.log(5 + 3); // 8 console.log(5 - 3); // 2 console.log(5 * 3); // 15 console.log(6 / 3); // 2 console.log(5 % 3); // 2 6. String Methods and Operations 1. Concatenation Explanation: Combines two or more strings into one. Syntax: string1 + string2 Returns: A new string combining the original strings. Example: let a = \u0026#39; My name is nirajan \u0026#39;; let b = \u0026#34;nirajan\u0026#34;; console.log(a + b + \u0026#34;Khatiwada\u0026#34;); // Output: \u0026#39; My name is nirajan nirajanKhatiwada\u0026#39; 2. Simple Form (String Boilerplate) Explanation: Uses template literals to embed expressions within a string. Syntax: ${expression} Returns: A new string with evaluated expressions. Example: let a = \u0026#39; My name is nirajan \u0026#39;; let b = \u0026#34;nirajan\u0026#34;; console.log(`${a}${b}khatiwada`); // Output: \u0026#39; My name is nirajan nirajankhatiwada\u0026#39; 3. Accessing Element of String Explanation: Retrieves the character at a specified index. Syntax: string[index] Returns: The character at the given index (or undefined if out of range). Example: let a = \u0026#39; My name is nirajan \u0026#39;; console.log(a[0]); // Output: \u0026#39; \u0026#39; 4. Finding Length of String Explanation: Gets the number of characters in the string. Syntax: string.length Returns: The length of the string as a number. Example: let a = \u0026#39; My name is nirajan \u0026#39;; console.log(a.length); // Output: 21 5. To Uppercase Explanation: Converts all characters in the string to uppercase. Syntax: string.toUpperCase() Returns: A new string with all characters in uppercase. Example: let a = \u0026#39; My name is nirajan \u0026#39;; console.log(a.toUpperCase()); // Output: \u0026#39; MY NAME IS NIRAJAN \u0026#39; 6. To Lowercase Explanation: Converts all characters in the string to lowercase. Syntax: string.toLowerCase() Returns: A new string with all characters in lowercase. Example: let a = \u0026#39; My name is nirajan \u0026#39;; console.log(a.toLowerCase()); // Output: \u0026#39; my name is nirajan \u0026#39; 8. String Slicing Explanation: Extracts a section of the string based on start and end indices. Syntax: string.slice(start, end) Returns: A new string containing the extracted section. Example: let a = \u0026#39; My name is nirajan \u0026#39;; console.log(a.slice(0, 4)); // Output: \u0026#39; My\u0026#39; 9. Trim Explanation: Removes whitespace from both ends of the string. Syntax: string.trim() Returns: A new string with whitespace removed from both ends. Example: let a = \u0026#39; My name is nirajan \u0026#39;; console.log(a.trim()); // Output: \u0026#39;My name is nirajan\u0026#39; 10. Replace Explanation: Replaces the first occurrence of a specified substring or pattern with a new substring. Syntax: string.replace(search, replacement) Returns: A new string with the specified substring replaced. Example: let a = \u0026#39; My name is nirajan \u0026#39;; console.log(a.replace(\u0026#34;nirajan\u0026#34;, \u0026#34;kirajan\u0026#34;)); // Output: \u0026#39; My name is kirajan \u0026#39; 11. Split Explanation: Splits the string into an array of substrings based on a separator. Syntax: string.split(separator, limit) Returns: An array of substrings. Example: let a = \u0026#39; My name is nirajan \u0026#39;; console.log(a.split(\u0026#34; \u0026#34;)); // Output: [\u0026#39; My\u0026#39;, \u0026#39;name\u0026#39;, \u0026#39;is\u0026#39;, \u0026#39;nirajan\u0026#39;] 7. Number Methods 1. toFixed() Explanation: Formats a number using fixed-point notation with a specified number of decimal places. Syntax: number.toFixed(digits); Returns: A string representing the number with the specified number of decimal places. Example: let c = 10.001; console.log(c.toFixed(10)); // Output: \u0026#39;10.0010000000\u0026#39; 2. Math.ceil() Explanation: Rounds a number up to the nearest integer. Syntax: Math.ceil(number); Returns: The smallest integer greater than or equal to the given number. Example: let a = 1.1000; console.log(Math.ceil(a)); // Output: 2 3. Math.floor() Explanation: Rounds a number down to the nearest integer. Syntax: Math.floor(number); Returns: The largest integer less than or equal to the given number. Example: console.log(Math.floor(a)); // Output: 1 4. Math.round() Explanation: Rounds a number to the nearest integer. Syntax: Math.round(number); Returns: The value of the number rounded to the nearest integer. Example: console.log(Math.round(a)); // Output: 1 5. Math.random() Explanation: Returns a pseudo-random floating-point number between 0 (inclusive) and 1 (exclusive). Syntax: Math.random(); Returns: A floating-point number between 0 (inclusive) and 1 (exclusive). Example: console.log(Math.random()); // Output: A random number between 0 and 1 8. Non-Primitive Data Types in JavaScript 1. Object Explanation: Objects are collections of key-value pairs. Keys are usually strings (or symbols) and values can be any data type. Syntax: let objectName = { key1: value1, key2: value2, // more key-value pairs }; Example: let data = { \u0026#34;name\u0026#34;: \u0026#34;nirajan\u0026#34;, \u0026#34;age\u0026#34;: 20 }; 2. Array Explanation: Arrays are ordered collections of values. Values can be of any data type and are accessed by their index. Syntax: let arrayName = [value1, value2, value3, ...]; Example: let a = [\u0026#34;nirajan\u0026#34;, \u0026#34;kirajan\u0026#34;, \u0026#34;birajan\u0026#34;]; 3. Function Explanation: Functions are blocks of code designed to perform a particular task. They can be invoked (called) to execute their code. Syntax: function functionName(parameters) { // code to be executed } Example: function outer() { console.log(\u0026#34;hi\u0026#34;); } outer(); // Output: hi 9. Array Methods 1. Indexing in Array Accessing Elements: Description: Arrays are zero-indexed, so the first element is at index 0. Returns: Value of the element at the specified index. Example: console.log(a[0]); // Output: 1 console.log(a[3]); // Output: 4 2. Slicing in Array Slicing: Description: Extracts a section of the array and returns it as a new array. Syntax: array.slice(startIndex, endIndex) Returns: A new array containing the elements from startIndex up to, but not including, endIndex. Example: console.log(a.slice(0, 2)); // Output: [1, 2] 3. Length of Array Description: Returns the number of elements in the array. Returns: Integer (length of the array). Example: console.log(a.length); // Output: 4 4. Push Description: Adds one or more elements to the end of the array. Returns: The new length of the array. Example: a.push(5); console.log(a); // Output: [1, 2, 3, 4, 5] 5. Pop Description: Removes the last element from the array. Returns: The removed element. Example: a.pop(); console.log(a); // Output: [1, 2, 3, 4] 6. Shift Description: Removes the first element from the array. Returns: The removed element. Example: a.shift(); console.log(a); // Output: [2, 3, 4] 7. Unshift Description: Adds one or more elements to the beginning of the array. Returns: The new length of the array. Example: a.unshift(0); console.log(a); // Output: [0, 1, 2, 3, 4] 8. Join Description: Joins all elements of an array into a string, separated by a specified separator. Returns: A string representing the array elements joined by the specified separator. Example: let data = a.join(\u0026#34; \u0026#34;); console.log(data); // Output: \u0026#34;1 2 3 4\u0026#34; 9. Concatenation of Two Arrays Description: Merges two or more arrays into one. Returns: A new array containing the elements of the original arrays. Example: let a2 = [5, 4, 1, 3, 4]; console.log(a.concat(a2)); // Output: [1, 2, 3, 4, 5, 4, 1, 3, 4] 10. Sort Description: Sorts the elements of an array in place. Returns: The sorted array. Example: a2.sort(); console.log(a2); // Output: [1, 3, 4, 4, 5] 11. Reverse Description: Reverses the order of the elements in the array. Returns: The reversed array. Example: a2.reverse(); console.log(a2); // Output: [5, 4, 4, 3, 1] 12. Removing Elements from a Specific Position Description: Changes the contents of an array by removing or replacing existing elements. Syntax: array.splice(index, numberOfElementsToRemove) Returns: An array containing the removed elements. Example: let newData = [1, 2, 3, 4]; newData.splice(1, 2); // Removes 2 elements starting at index 1 console.log(newData); // Output: [1, 4] 13. Inserting Elements at a Specific Position Description: Inserts elements into the array. Syntax: array.splice(index, 0, element1, element2, ...) Returns: An array containing the removed elements (empty if no elements were removed). Example: let lasrData = [1, 4]; lasrData.splice(1, 0, 2, 3); // Inserts elements 2 and 3 at index 1 console.log(lasrData); // Output: [1, 2, 3, 4] 14. Spread Operator (\u0026hellip;) Description: Spreads out elements of an array into another array or function arguments. Returns: A new array containing the elements spread from the original arrays. Example: let finalData = [...newData, ...lasrData]; console.log(finalData); // Output: [1, 4, 1, 2, 3, 4] 15. Array Destructuring Description: Allows unpacking values from arrays into distinct variables in a concise and readable way. Basic Syntax: const [var1, var2, var3] = array; Example: const numbers = [1, 2, 3]; const [first, second, third] = numbers; console.log(first); // Output: 1 console.log(second); // Output: 2 console.log(third); // Output: 3 10. Object in Js i. Defining an Object An object in JavaScript is a collection of key-value pairs. Each key (also known as a property) is a unique identifier, and the value can be anything: a string, number, array, function, or even another object. Example:\nconst myObject = { name: \u0026#34;Nirajan\u0026#34;, // String property class: \u0026#34;Bachelor\u0026#34;, // String property is_topper: \u0026#34;No\u0026#34;, // Boolean property (as a string) greet: function (from) { // Method (function inside an object) console.log(`Welcome ${this.name}. From ${from}`); } }; ii. Accessing There are two common ways to access properties in an object:\nDot Notation: console.log(myObject.name); // Output: nirajan This is the most common and preferred method when you know the property name in advance. Bracket Notation: console.log(myObject[\u0026#39;name\u0026#39;]); // Output: nirajan Bracket notation is useful when the property name is stored in a variable or when it contains special characters or spaces. iii. Modifying Object Properties You can modify an object\u0026rsquo;s properties using dot or bracket notation:\nDot Notation: Use when you know the property name.\nmyObject.name = \u0026#34;Kirajan\u0026#34;; // Modifies the \u0026#39;name\u0026#39; property Bracket Notation: Use when the property name is dynamic or contains special characters.\nmyObject[\u0026#39;class\u0026#39;] = \u0026#34;Master\u0026#39;s\u0026#34;; // Modifies the \u0026#39;class\u0026#39; property iv. Adding New Properties You can dynamically add new key-value pairs to an object.\nmyObject.lol = \u0026#34;lol\u0026#34;; console.log(myObject.lol); // Output: lol v. Using the this Keyword The this keyword inside an object’s method refers to the object itself, allowing you to access its properties. Example:\nconst person = { name: \u0026#34;Kirajan\u0026#34;, greet: function() { console.log(`Hello, my name is ${this.name}`); } }; person.greet(); // Output: Hello, my name is Kirajan vi. Objects Inside Objects Objects can contain other objects, allowing you to create complex data structures. Example:\nconst a = { details: { name: \u0026#34;Nirajan\u0026#34;, age: 20 } }; console.log(a.details.name); // Output: Nirajan vii. Spread Operator (\u0026hellip;) The spread operator lets you copy, merge, or combine objects efficiently.\nCopying Properties: const original = { name: \u0026#34;Kirajan\u0026#34;, class: \u0026#34;Bachelor\u0026#34; }; const copy = { ...original }; console.log(copy); // Output: { name: \u0026#34;Kirajan\u0026#34;, class: \u0026#34;Bachelor\u0026#34; } Merging Objects: const info1 = { name: \u0026#34;Kirajan\u0026#34;, class: \u0026#34;Bachelor\u0026#34; }; const info2 = { age: 21, is_topper: true }; const combined = { ...info1, ...info2 }; console.log(combined); // Output: { name: \u0026#34;Kirajan\u0026#34;, class: \u0026#34;Bachelor\u0026#34;, age: 21, is_topper: true } viii. Object Destructuring Destructuring allows you to extract properties from an object and assign them to variables. Example:\nconst lol = { name: \u0026#34;Nirajan\u0026#34;, class: 12, rollno: \u0026#34;11\u0026#34; }; const { name, rollno } = lol; console.log(name); // Output: Nirajan console.log(rollno); // Output: 11 Also, Renaming in Destructuring: const lol = { name: \u0026#34;Nirajan\u0026#34;, class: 12, rollno: \u0026#34;11\u0026#34; }; const { name: studentName, rollno: studentRollNo } = lol; console.log(studentName); // Output: Nirajan console.log(studentRollNo); // Output: 11 ix. Object Methods Objects can have methods—functions that are properties of the object. These methods can perform actions using the object’s data. Example:\nconst calculator = { add: function(a, b) { return a + b; }, subtract: function(a, b) { return a - b; } }; console.log(calculator.add(5, 3)); // Output: 8 console.log(calculator.subtract(5, 3)); // Output: 2 11. JavaScript Functions Function Definitions: Function Expression: const add1 = function(a, b) { return a + b; }; Creates a function and assigns it to a variable. You call the function using the variable name. Arrow Function: const add2 = (a, b) =\u0026gt; { return a + b; }; Provides a shorter syntax and does not have its own this context. Function Declaration: function add3(a, b) { return a + b; } Defines a function with a name. It is hoisted, so it can be called before its declaration. Comparison: add3 has its own this context, while add1 and add2 do not. Using the Spread Operator: function add(...data) { let sum = 0; for (let i = 0; i \u0026lt; data.length; i++) { sum += data[i]; } return sum; } console.log(add(1, 2, 3)); // Output: 6 The ...data syntax lets the function accept any number of arguments as an array.\nImmediately Invoked Function Expression (IIFE): ( function add(a, b) { console.log(a + b); } )(2, 3); // Output: 5 An IIFE is a function that runs immediately after its definition, creating a local scope to avoid affecting the global scope.\n12. Control Flow in JavaScript Conditional Statements: if-else Statement: Executes code blocks based on a condition. let a = 2; if (a === 1) { console.log(1); } else if (a === 2) { console.log(2); } else { console.log(\u0026#34;None\u0026#34;); } Truthy and Falsy Values: Falsy Values: Values that evaluate to false in a boolean context. console.log(Boolean(false)); // false console.log(Boolean(0)); // false console.log(Boolean(-0)); // false console.log(Boolean(0n)); // false console.log(Boolean(\u0026#34;\u0026#34;)); // false console.log(Boolean(null)); // false console.log(Boolean(undefined)); // false console.log(Boolean(NaN)); // false Truthy Values: Any value that is not falsy. console.log(Boolean(true)); // true console.log(Boolean(1)); // true console.log(Boolean(-1)); // true console.log(Boolean(\u0026#34;hello\u0026#34;)); // true console.log(Boolean(\u0026#34; \u0026#34;)); // true console.log(Boolean({})); // true console.log(Boolean([])); // true console.log(Boolean(function() {})); // true console.log(Boolean(Symbol())); // true console.log(Boolean(1n)); // true Nullish Coalescing Operator (??): Provides a default value when dealing with null or undefined. let val1 = null; let val2 = val1 ?? 10; console.log(val2); // Output: 10 Ternary Operator (?:): A shorthand for the if-else statement. let c = 10; let b = 10; let largest = (c \u0026gt; b) ? c : b; console.log(largest); // Output: 10 13. Loops in JavaScript For Loop // Syntax: for(initialization; condition; increment/decrement) { ... } for (let i = 0; i \u0026lt; 10; i++) { console.log(i); } While Loop // Syntax: while(condition) { ... } let i = 0; while (i \u0026lt; 10) { console.log(i); i++; } Do-While Loop // Syntax: do { ... } while(condition); let i = 0; do { console.log(i); i++; } while (i \u0026lt; 10); For-Of Loop Usage: Iterates over arrays and strings const array = [1, 2, 3]; for (const x of array) { console.log(x); } For-In Loop Usage: Iterates over the properties of an object, indices of an array, or characters of a string const obj = { \u0026#34;name\u0026#34;: \u0026#34;nirajan\u0026#34;, \u0026#34;lol\u0026#34;: \u0026#34;lol\u0026#34; }; const arr = [\u0026#34;nirajan\u0026#34;, \u0026#34;lol\u0026#34;]; const str = \u0026#34;mynameisnirajan\u0026#34;; for (const key in obj) { console.log(key); // Prints the keys of the object } for (const index in arr) { console.log(arr[index]); // Prints the values of the array } for (const index in str) { console.log(str[index]); // Prints the characters of the string } For-Each Loop Usage: Iterates over array elements const array = [1, 2, 3]; array.forEach((data) =\u0026gt; { console.log(data); }); Break and Continue Statements break: Exits the loop continue: Skips the current iteration and continues with the next iteration 14. Map, Filter, and Reduce in JavaScript i. filter() Purpose: Creates a new array with elements that pass a test. Example: To get all odd numbers from an array: const a = [1, 2, 3, 4, 5, 6]; const filtered = a.filter(num =\u0026gt; num % 2); // [1, 3, 5] ii. map() Method Purpose: map() creates a new array populated with the results of calling a provided function on every element in the calling array. It’s used to transform each element in the array. Example: Create an array of squares from an existing array. const a = [1, 2, 3, 4, 5, 6]; const squares = a.map((num) =\u0026gt; num * num); console.log(squares); // Output: [1, 4, 9, 16, 25, 36] Here, the function num * num is applied to each element, resulting in a new array of squared numbers. iii. reduce() Method Purpose: reduce() executes a reducer function on each element of the array, resulting in a single output value. It’s used to accumulate or combine values from the array into a single result. Example: Sum up all the numbers in the array. const a = [1, 2, 3, 4, 5, 6]; const sum = a.reduce((accumulator, currentValue) =\u0026gt; accumulator + currentValue, 0); console.log(sum); // Output: 21 Here, accumulator starts at 0 and currentValue iterates over each element, summing them up. iv. Method Chaining Purpose: You can chain filter(), map(), and other array methods together to perform multiple operations in a single, readable statement. Example: Filter out odd numbers and then square them. const a = [1, 2, 3, 4, 5, 6]; const result = a.filter((num) =\u0026gt; num % 2) .map((num) =\u0026gt; num * num); console.log(result); // Output: [1, 9, 25] Here, filter() first selects the odd numbers, and then map() squares those numbers, producing a new array with the squared values of the odd numbers. Summary filter(): Selects elements that meet a specific condition. map(): Transforms elements based on a function. reduce(): Reduces the array to a single value based on a function. Method Chaining: Combines multiple array operations in a concise and readable manner. These methods are powerful tools for processing and transforming arrays in JavaScript. 15. Importing and Exporting in JavaScript Default Export Only one default export is allowed per module. Use for the primary function, class, or object in a module. // utils.js export default function primaryFunction() { console.log(\u0026#34;This is the primary function\u0026#34;); } // main.js import primaryFunction from \u0026#39;./utils.js\u0026#39;; primaryFunction(); // Output: This is the primary function Named Export Allows multiple exports per module. Use to export multiple functions, variables, or objects. // utils.js function function1() { console.log(\u0026#34;This is function1\u0026#34;); } function function2() { console.log(\u0026#34;This is function2\u0026#34;); } export { function1, function2 }; // main.js import { function1, function2 } from \u0026#39;./utils.js\u0026#39;; function1(); // Output: This is function1 function2(); // Output: This is function2 Summary Default Export: One per module, no curly braces during import. Named Export: Multiple per module, use curly braces during import. 16. Error Handling Try-catch blocks are used to handle errors gracefully.\ntry { // Code that might throw an error let result = nonExistentFunction(); } catch (error) { // Code to handle the error console.log(\u0026#39;An error occurred:\u0026#39;, error.message); } finally { // Code that always executes console.log(\u0026#39;This always executes\u0026#39;); } // Output: // \u0026#34;An error occurred: nonExistentFunction is not defined\u0026#34; // \u0026#34;This always executes\u0026#34; 16.1. Custom Error Throwing You can throw custom errors using the throw statement.\nfunction divide(a, b) { if (b === 0) { throw new Error(\u0026#39;Division by zero is not allowed\u0026#39;); } return a / b; } try { console.log(divide(4, 2)); console.log(divide(4, 0)); } catch (error) { console.log(\u0026#39;Error:\u0026#39;, error.message); } // Output: // 2 // \u0026#34;Error: Division by zero is not allowed\u0026#34; 17. Timers setTimeout Schedules a function to be executed after a specified delay (in milliseconds).\nconst timeoutId = setTimeout(() =\u0026gt; { console.log(\u0026#39;Executed after 1 second\u0026#39;); }, 1000); setInterval Repeatedly executes a function at specified intervals (in milliseconds).\nconst intervalId = setInterval((a, b) =\u0026gt; { console.log(a); // Output: hi console.log(b); // Output: oi }, 20, \u0026#34;hi\u0026#34;, \u0026#34;oi\u0026#34;); clearInterval Stops a function from being executed repeatedly by clearing the interval.\nclearInterval(intervalId); clearTimeout Cancels a timeout previously established by setTimeout.\nclearTimeout(timeoutId); 18. Local Storage Local storage is a way to store data in the browser that persists even after the browser is closed.\nStoring Data localStorage.setItem(\u0026#39;name\u0026#39;, \u0026#39;Nirajan\u0026#39;); Retrieving Data const name = localStorage.getItem(\u0026#39;name\u0026#39;); console.log(name); // Output: Nirajan 19. JSON JSON (JavaScript Object Notation) is a lightweight data interchange format that is easy for humans to read and write and easy for machines to parse and generate.\nConverting Objects to JSON const person = { name: \u0026#39;Nirajan\u0026#39;, age: 20 }; const json = JSON.stringify(person); console.log(json); // Output: {\u0026#34;name\u0026#34;:\u0026#34;Nirajan\u0026#34;,\u0026#34;age\u0026#34;:20} Converting JSON to Objects const json = \u0026#39;{\u0026#34;name\u0026#34;:\u0026#34;Nirajan\u0026#34;,\u0026#34;age\u0026#34;:20}\u0026#39;; const person = JSON.parse(json); console.log(person.name); // Output: Nirajan 20. Fetch API Fetch is used to make HTTP requests and returns a promise that resolves to the response of the request.\nBasic Usage fetch(\u0026#39;https://api.example.com/data\u0026#39;) .then(response =\u0026gt; response.json()) .then(data =\u0026gt; console.log(data)) .catch(error =\u0026gt; console.error(\u0026#39;Error:\u0026#39;, error)); ","permalink":"http://localhost:1313/posts/pages/js/javascript/","summary":"A complete reference guide for JavaScript including data types, functions, DOM manipulation, and modern ES6+ features","title":"JavaScript Reference Guide"},{"content":" Linux Commands and Directories Guide Important Directories Default Web Server Root Directory\nLocation: /var/www/html\nThis is the standard location for serving web content on Apache.\nDownloads Folder\nLocation: /home/username/Downloads\nThis is where files downloaded from the internet are usually saved by default.\nDocuments Folder\nLocation: /home/username/Documents\nA common directory for storing personal documents and files.\nDesktop Folder\nLocation: /home/username/Desktop\nThis is the location for files and shortcuts displayed on your desktop screen.\nCommon Commands cd Change the current directory to another one.\nUsage: cd [directory]\nExample: cd /var/www/html changes to the web server root directory.\nls List files and directories in the current location or specified path.\nUsage: ls [options] [path]\nExample: ls -l lists files in a detailed format.\npwd Print the path of the current working directory.\nUsage: pwd\nThis command shows where you are in the filesystem.\nsudo su Switch to the superuser (root) account, allowing you to perform administrative tasks.\nUsage: sudo su\nAfter entering your password, you\u0026rsquo;ll have root access.\nsudo Execute a command with elevated privileges.\nUsage: sudo [command]\nExample: sudo apt update runs the update command as an administrator.\nmkdir Create a new directory.\nUsage: mkdir [directory name]\nExample: mkdir new_folder creates a directory named \u0026ldquo;new_folder\u0026rdquo;.\ndir List files and directories, similar to ls.\nUsage: dir [options] [path]\nThis command can be used interchangeably with ls.\nmv Move or rename files and directories.\nUsage: mv [source] [destination]\nExample: mv /home/username/Downloads/file.txt /home/username/Documents/ moves the file to a different directory.\ncp Copy files or directories.\nUsage: cp [source] [destination]\nExample: cp /home/username/Downloads/file.txt /home/username/Documents/ copies the file.\nrm Remove files or directories.\nUsage: rm [options] [file/directory]\nExample: To remove a directory and its contents, use rm -r [directory].\ntouch Create an empty file or update the timestamp of an existing file.\nUsage: touch [filename]\nExample: touch newfile.txt creates an empty file named \u0026ldquo;newfile.txt\u0026rdquo;.\ncat Display the contents of a file in the terminal.\nUsage: cat [filename]\nExample: cat file.txt shows the content of \u0026ldquo;file.txt\u0026rdquo;.\ngedit Open the Gedit text editor to edit files.\nUsage: gedit [filename]\nExample: gedit notes.txt opens \u0026ldquo;notes.txt\u0026rdquo; for editing.\nkill Terminate a process using its process ID (PID).\nUsage: kill [PID]\nExample: kill 1234 stops the process with the ID 1234.\ntop Display real-time information about system processes and resource usage.\nUsage: top\nThis command helps monitor system performance.\napt-get update Update the package lists for upgrades and new package installations.\nUsage: apt-get update\nThis command fetches the latest package information.\napt install path_of_.deb_file Install a .deb file package.\nUsage: apt install ./filename.deb\nExample: apt install ./main.deb installs the specified Debian package.\napt-get upgrade Upgrade all installed packages to their latest versions.\nUsage: apt-get upgrade\nThis command updates your installed software.\napt-get install package Install a specific software package.\nUsage: apt-get install [package]\nExample: apt-get install vim installs the Vim text editor.\nman Display the manual page for a command, providing detailed information.\nUsage: man [command]\nExample: man ls shows the manual for the ls command.\nwhoami Show the currently logged-in user\u0026rsquo;s username.\nUsage: whoami\nThis command is useful for confirming your user identity.\nzip Compress a directory and its contents into a zip file.\nUsage: zip -r [filename.zip] [foldername]\nExample: zip -r archive.zip myfolder creates a zip file of \u0026ldquo;myfolder\u0026rdquo;.\nunzip Extract files from a zip archive.\nUsage: unzip [filename]\nExample: unzip archive.zip extracts files from \u0026ldquo;archive.zip\u0026rdquo;.\napt install apache2 Install the Apache web server.\nUsage: apt install apache2\nThis command sets up Apache on your system.\nservice apache2 start Start the Apache web server.\nUsage: service apache2 start\nUse this to begin serving web content.\nservice apache2 restart Restart the Apache web server.\nUsage: service apache2 restart\nThis is useful for applying configuration changes.\nservice apache2 stop Stop the Apache web server.\nUsage: service apache2 stop\nUse this command to halt the server.\napt install redis Install the Redis database server.\nUsage: apt install redis\nThis sets up Redis for use.\nservice redis start Start the Redis server.\nUsage: service redis start\nThis command activates the Redis service.\nservice redis restart Restart the Redis server.\nUsage: service redis restart\nUse this to refresh the Redis service.\nservice redis stop Stop the Redis server.\nUsage: service redis stop\nThis halts the Redis service.\napt install mysql-server Install the MySQL server.\nUsage: apt install mysql-server\nThis command installs the MySQL database management system.\nchmod Change file or directory permissions.\nUsage: chmod [permissions] [file/folder]\nExample: chmod +rwx file.txt grants read, write, and execute permissions.\nTo remove permissions, use chmod -r file.txt.\nImportant Notes Folder Names with Spaces:\nIf a folder name contains spaces, enclose it in double quotes.\nmkdir \u0026quot;New Folder\u0026quot; creates a single folder named \u0026ldquo;New Folder\u0026rdquo;. mkdir New Folder creates two separate folders named \u0026ldquo;New\u0026rdquo; and \u0026ldquo;Folder\u0026rdquo;. Using Wildcards for Operations:\nTo perform operations on:\nAll files/folders: use *. Files with a specific extension (e.g., .exe): use *.exe. Files/folders starting with \u0026ldquo;hello\u0026rdquo;: use hello*. Use Relative Paths:\nPrefer using relative paths whenever possible to simplify navigation.\nExample: mv /home/username/Downloads/index.html /var/www/html/index.html moves a file to the web server directory. ","permalink":"http://localhost:1313/posts/pages/linux/linux_cheatsheet/","summary":"A practical guide to navigating and managing files in Linux.","title":"Linux Commands and Directories Guide"},{"content":"Learning Journey Topics I Have Learned So Far Docker Linux Celery Django Channels Git Celery Python Django JavaScript React Basics HTML CSS Tailwind Css What I Plan to Learn In third Semester Django Rest Framework (DRF) Django ORM Deep Dive React Advanced Git Advanced Docker Advanced WebSOcket Deep Dive in Django Celery Deep Dive Plan to learn in future WebSocket Deep Dive in Django Celery Deep Dive Redis for Cache Kafka Basics + Advanced Docker Advanced + Kubernetes Message Brokers Django Rest Framework (DRF) Django ORM Deep Dive React Advanced Git Advanced Django Docs+Advance Like class based views Additional Topics for Future Learning Real-time WebSocket usage in Django. Kafka streaming for handling large data volumes. Implementing Kubernetes for containerized applications. ","permalink":"http://localhost:1313/posts/pages/readinglist/my_reading/","summary":"A detailed overview of my learning journey and future plans.","title":"Learning Journey"},{"content":"Fetching data from server 21.1. Fetching data from server -fetch data using useeffect -set loading ","permalink":"http://localhost:1313/posts/pages/react/react11/","summary":"\u003ch2 id=\"fetching-data-from-server\"\u003eFetching data from server\u003c/h2\u003e\n\u003ch3 id=\"211-fetching-data-from-server\"\u003e21.1. Fetching data from server\u003c/h3\u003e\n\u003ch2 id=\"-set-loading\"\u003e-fetch data using useeffect\n-set loading\u003c/h2\u003e","title":""},{"content":"44. Optimizing Performance 44.1. memo memo is a higher-order function in React that optimizes functional components by preventing unnecessary re-renders. It returns a new component that behaves the same as the original one but only re-renders if its props change or internal state changes not every time the parent component re-renders.\nWhy Use memo? When a parent component re-renders, all its child components also re-render by default—even if their props remain unchanged. This behavior can lead to performance bottlenecks. Using memo, we can avoid these unnecessary re-renders for child components.\nExample:\nimport { memo } from \u0026#39;react\u0026#39;; const MyComponent = memo((props) =\u0026gt; { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;{props.title}\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ); }); export default MyComponent; In the above example, the MyComponent functional component is wrapped with the memo function. This ensures that the component will only re-render if its props have changed or if its satate has been change not every time the parent component re-renders.\nUse Case:\nBefore using memo: In this example, the Custom component re-renders unnecessarily whenever the parent component re-renders, even if its props haven\u0026rsquo;t changed or internal state hasn\u0026rsquo;t changed. Custom.js import { useState } from \u0026#39;react\u0026#39;; const Custom = ({ title }) =\u0026gt; { const [count, setCount] = useState(0); return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;{title}\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;{count}\u0026lt;/p\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;Increment\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); }; export default Custom; App.js\nimport { useState } from \u0026#39;react\u0026#39;; import Custom from \u0026#39;./Custom\u0026#39;; function App() { const [count, setCount] = useState(0); return ( \u0026lt;div\u0026gt; \u0026lt;Custom title=\u0026#34;Counter\u0026#34; /\u0026gt; \u0026lt;p\u0026gt;{count}\u0026lt;/p\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;Increment Parent Count\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; Problem: The Custom component re-renders whenever the count state in the App component changes, even though the title prop remains the same. This can cause unnecessary rendering and reduce performance.i.e child component re-renders even if the props are not changed when the parent component re-renders.\nAfter using memo: Using memo, we can optimize the Custom component to only re-render when its props change. Custom.jsx import { useState, memo } from \u0026#39;react\u0026#39;; const Custom = memo(({ title }) =\u0026gt; { const [count, setCount] = useState(0); return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;{title}\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;{count}\u0026lt;/p\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;Increment\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); }); export default Custom; App.js\nimport { useState } from \u0026#39;react\u0026#39;; import Custom from \u0026#39;./Custom\u0026#39;; function App() { const [count, setCount] = useState(0); return ( \u0026lt;div\u0026gt; \u0026lt;Custom title=\u0026#34;Counter\u0026#34; /\u0026gt; \u0026lt;p\u0026gt;{count}\u0026lt;/p\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;Increment Parent Count\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; After using memo the Custom component will only re-render when its props change or state change i.e when the title prop changes or the count state of the Custom component changes . It will not re-render when the count state of the App component changes, which optimizes performance in this scenario as that change does not affect the Custom component.\n44.2. useCallback In every rerender of a component, the functions defined inside the component are recreated. This can lead to performance issues, especially when passing functions as props to child components. useCallback is a hook in React that memoizes functions to prevent unnecessary re-creations.\nSyntax:\nuseCallback(fn, dependencies) fn: The function value that you want to cache. It can take any arguments and return any values. React will return (not call!) your function back to you during the initial render. On next renders, React will give you the same function again if the dependencies have not changed since the last render. Otherwise, it will give you the function that you have passed during the current render, and store it in case it can be reused later. React will not call your function. The function is returned to you so you can decide when and whether to call it. dependencies: An array of values that, when changed, will cause the function to be re-created. If the dependencies array is empty, the function will only be created once, and will not be re-created on subsequent renders. Whats the use of dependencies array in useCallback? just because dependency array the function is recreated with the new values of the dependencies.\nBefore using useCallback:\nimport { useState,memo } from \u0026#39;react\u0026#39;; const Child = memo(({ handleClick }) =\u0026gt; { return ( \u0026lt;button onClick={handleClick}\u0026gt;Click Me\u0026lt;/button\u0026gt; ); }); const Parent = () =\u0026gt; { const [count, setCount] = useState(0); const handleClick = () =\u0026gt; { setCount(count + 1); }; return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;{count}\u0026lt;/p\u0026gt; \u0026lt;Child handleClick={handleClick} /\u0026gt; \u0026lt;/div\u0026gt; ); }; In the above example, the handleClick function is re-created on every re-render of the Parent component. As a result, the reference to the handleClick function passed as a prop to the Child component changes on every re-render of the Parent component. This causes the Child component to re-render unnecessarily, even though the handleClick function remains logically the same After using useCallback:\nimport { useState, useCallback, memo } from \u0026#39;react\u0026#39;; const Child = memo(({ handleClick }) =\u0026gt; { return ( \u0026lt;button onClick={handleClick}\u0026gt;Click Me\u0026lt;/button\u0026gt; ); }); const Parent = () =\u0026gt; { const [count, setCount] = useState(0); const handleClick = useCallback(() =\u0026gt; { setCount(count + 1); }, [count]); return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;{count}\u0026lt;/p\u0026gt; \u0026lt;Child handleClick={handleClick} /\u0026gt; \u0026lt;/div\u0026gt; ); }; By using useCallback, the handleClick function is memoized and will only be re-created when the count state changes. The reference to the handleClick function remains the same across re-renders of the Parent component unless the dependencies specified in the dependency array (in this case, [count]) change. This ensures that the Child component only re-renders when the count state changes, and not when the handleClick function reference changes, thus improving performance.\n44.3. useMemo useMemo is a hook in React that memoizes the result of a function. It is similar to useCallback, but instead of memoizing a function, it memoizes the result of a function.\nSyntax:\nconst cachedValue = useMemo(calculateValue, dependencies) calculateValue: The function calculating the value that you want to cache. It should be pure, should take no arguments, and should return a value of any type. React will call your function during the initial render. On next renders, React will return the same value again if the dependencies have not changed since the last render. Otherwise, it will call calculateValue, return its result, and store it so it can be reused later. dependencies: An array of values that, when changed, will cause the function to be re-executed.\nreturn On the initial render, useMemo returns the result of calling calculateValue with no arguments.During next renders, it will either return an already stored value from the last render (if the dependencies haven’t changed), or call calculateValue again, and return the result that calculateValue has returned.\nBefore using useMemo:\nimport { useState, memo } from \u0026#39;react\u0026#39;; const fibonacci = (n) =\u0026gt; { if (n \u0026lt;= 1) { return n; } return fibonacci(n - 1) + fibonacci(n - 2); }; const Fib = ()=\u0026gt;{ const [count, setCount] = useState(1); const result = fibonacci(100000000000); return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;{result} and count is {count}\u0026lt;/p\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;Increase Count\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } In the above example, the fibonacci function is called on every re-render of the Fib component. This can lead to performance issues, especially when the function is computationally expensive. In this case, the fibonacci function is called with a large number, which can cause the component to freeze or crash.\nAfter using useMemo:\nimport { useState, useMemo } from \u0026#39;react\u0026#39;; const fibonacci = (n) =\u0026gt; { if (n \u0026lt;= 1) { return n; } return fibonacci(n - 1) + fibonacci(n - 2); }; const Fib = ()=\u0026gt;{ const [count, setCount] = useState(1); const result = useMemo(() =\u0026gt; fibonacci(100000000000), []); return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;{result} and count is {count}\u0026lt;/p\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;Increase Count\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } By using useMemo, the result of the fibonacci function is memoized and will only be re-calculated when the dependencies specified in the dependency array change. In this case, the fibonacci function is only called once during the initial render of the Fib component, and the result is stored and reused on subsequent renders. This optimizes performance by preventing unnecessary re-calculation of the fibonacci function on every re-render of the component.\n45.Key conside a scenarion where your base component state variable need to be initialized with the value of the props passed to the component. since the state variable is initialized with the props value, the state variable will not be updated when the props value changes as it is initialized only. to handle we can either use useEffect or we can use key prop.\nUsing useEffect:\nimport { useEffect, useState } from \u0026#39;react\u0026#39;; const Parent = () =\u0026gt; { const [value, setValue] = useState(0); return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={() =\u0026gt; setValue(value + 1)}\u0026gt;Increment\u0026lt;/button\u0026gt; \u0026lt;Child value={value} /\u0026gt; \u0026lt;/div\u0026gt; ); }; const Child = ({ value }) =\u0026gt; { const [stateValue, setStateValue] = useState(value); useEffect(() =\u0026gt; { setStateValue(value); }, [value]); return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;State Value: {stateValue}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Props Value: {value}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); }; stateValue is initialized with the value prop and const [stateValue, setStateValue] = useState(value); runs only once during initial render so useEffect is used to update the stateValue when the value prop changes.\nUsing key prop:\nimport { useState } from \u0026#39;react\u0026#39;; const Parent = () =\u0026gt; { const [value, setValue] = useState(0); return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={() =\u0026gt; setValue(value + 1)}\u0026gt;Increment\u0026lt;/button\u0026gt; \u0026lt;Child key={value} value={value} /\u0026gt; \u0026lt;/div\u0026gt; ); }; const Child = ({ value }) =\u0026gt; { const [stateValue, setStateValue] = useState(value); return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;State Value: {stateValue}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Props Value: {value}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); }; IN the above example,When a key changes between renders, React will create a new instance of the component. By using the key prop with the value prop, we ensure that a new instance of the Child component is created whenever the value prop changes. This allows the stateValue to be initialized with the new value prop on every render, without the need for useEffect.\nNote:The useState() hook us run only one time during the initial render of the component. If the state variable is initialized with a prop value, it will not be updated when the prop value changes. To handle this scenario, we can use the useEffect() hook to update the state variable when the prop value changes. Alternatively, we can use the key prop to create a new instance of the component whenever the prop value changes, allowing the state variable to be initialized with the new prop value on every render. Similar goes for useReducer() and useRef() hooks as well.\n","permalink":"http://localhost:1313/posts/pages/react/react10/","summary":"Learn how to optimize React applications using memo for component memoization, useCallback for function memoization, and useMemo for value memoization.","title":"React : 10"},{"content":"40. useEffect useEffect is a React hook that lets you perform side effects in functional components. Common use cases include:\nEstablishing a database connection when the DOM content loads. Updating the page title when the content changes. Note: The useEffect hook runs after the component has rendered.\n41. What to Put in useEffect Use useEffect for:\nNetwork requests Operations that take time to complete (e.g., fetching data, setting timers, etc.) 42. useEffect Syntax 42.1. Importing useEffect import React, { useEffect } from \u0026#39;react\u0026#39;; 42.2. useEffect Syntax useEffect(() =\u0026gt; { // code here return () =\u0026gt; { // cleanup code here }; }, [dependencies]); The first argument is a function containing the code to execute. The second argument is an array of dependencies. If any dependency changes, the function runs again. The return statement is optional and is used for cleanup tasks, such as removing event listeners or canceling subscriptions. This cleanup function is executed: Just before the the useEffect function runs again cause due to dependency change, with variables from the previous render. After the component unmounts (i.e., when removed from the DOM). Note: When your component is added to the DOM, React runs the setup function. After each re-render with changed dependencies, React first executes the cleanup function (if provided) with old values, then runs the setup function with new values.\nExample: useEffect(() =\u0026gt; { const id = setTimeout(() =\u0026gt; { console.log(count); }, 1000); return () =\u0026gt; { clearTimeout(id); }; }, [count]); In this example, the useEffect hook runs whenever the count variable changes. It sets a timeout to log the count value after 1 second, and the cleanup function clears the previous timeout before the next execution. Cleanup Function:\nUsed for tasks like removing event listeners or clearing timeouts. Ensures stale operations are cleared before new ones are executed. Executes when dependencies change or when the component unmounts. 43. Variations of useEffect 43.1. useEffect Without Dependencies Array useEffect(() =\u0026gt; { // code here }); The useEffect function runs after every re-render. 43.2. useEffect With Empty Dependencies Array useEffect(() =\u0026gt; { // code here }, []); The useEffect function runs only once after the initial render, making it ideal for tasks like loading local storage data. 43.3. useEffect With Multiple Dependencies useEffect(() =\u0026gt; { // code here }, [count, name]); The useEffect function runs when either count or name changes. Note: In all of the variation, useEffect always runs after the first render no matter what is passed in the dependencies array.\nExample: Loading Local Storage Data Correct Usage:\nimport React, { useState, useEffect } from \u0026#39;react\u0026#39;; const App = () =\u0026gt; { const [data, setData] = useState([]); useEffect(() =\u0026gt; { const data = localStorage.getItem(\u0026#39;data\u0026#39;); if (data) { setData(JSON.parse(data)); } }, []); return ( \u0026lt;div\u0026gt; {data.map((item, index) =\u0026gt; ( \u0026lt;p key={index}\u0026gt;{item}\u0026lt;/p\u0026gt; ))} \u0026lt;/div\u0026gt; ); }; Incorrect Usage:\nimport React, { useState } from \u0026#39;react\u0026#39;; const App = () =\u0026gt; { const [data, setData] = useState([]); const loadData = () =\u0026gt; { const data = localStorage.getItem(\u0026#39;data\u0026#39;); if (data) { setData(JSON.parse(data)); } }; loadData(); return ( \u0026lt;div\u0026gt; {data.map((item, index) =\u0026gt; ( \u0026lt;p key={index}\u0026gt;{item}\u0026lt;/p\u0026gt; ))} \u0026lt;/div\u0026gt; ); }; Problem: Calling loadData directly causes an infinite loop because it triggers a re-render, which calls loadData again. Solution: Use useEffect with an empty dependency array to ensure the function runs only once after the initial render. ","permalink":"http://localhost:1313/posts/pages/react/react9/","summary":"Learn how to use the useEffect hook in React for performing side effects in functional components.","title":"React : 9"},{"content":"38. Understanding the Concept of Prop Drilling Prop drilling refers to the process of passing data from a parent component to a deeply nested child component through all the intermediate components, even if those intermediate components don’t need the data themselves. Let’s break this down with an example.\nComponent Tree Imagine the following component hierarchy: Now, suppose we want to transfer some data from the Product component to the Cart component. Since Product and Cart are in separate branches of the component tree, they don’t have a direct connection.\nHow Prop Drilling Works To make this work, we need to store the shared state in a common ancestor, which is the App component in this case. Then, we have to pass the state down through all the intermediate components, even if those components don’t actually use the data.\nHere’s a visual representation of this:\nData flows from Product → Shop → App (common ancestor). The data then flows from App → Header → CardModel → Cart. This creates a lot of unnecessary overhead because the intermediate components (Shop, Header, and CardModel) don’t need the data but still have to handle it.\nProp drilling can quickly become cumbersome in large applications with deeply nested components. To solve this, we can use state management tools like Redux, Context API, or React Query, which allow us to manage and share state more effectively without passing it through every component.\n39. Introduction to React Context API Context API is a feature in React that allows you to share data between components without having to pass props down manually at every level. It provides a way to pass data through the component tree without having to pass props down manually at every level as shown in the image below.\nHow to use context API Create a context using the createContext function. import { createContext } from \u0026#39;react\u0026#39;; const CartContext = createContext(); export default CartContext; Wrap the parent component with the Provider component. Which Component to wrap? Wrap to the common ancestor of the components that need the context data. In the example below, we wrap the App component with the Provider component. For Example:\nimport CartContext from \u0026#39;./store/CartContext\u0026#39;; function App() { return ( \u0026lt;CartContext.Provider value={data}\u0026gt; \u0026lt;Header /\u0026gt; \u0026lt;Shop /\u0026gt; \u0026lt;/CartContext.Provider\u0026gt; ); } Explaination:Since we want to share the product Component data with the Cart Component SO in order to do that we wrap the first common ancestor of the Product and Cart Component i.e App Component with the Provider Component and pass the data to the value prop of the Provider Component.\nAccess the context data in the child component using the useContext hook. for example:\nimport { useContext } from \u0026#39;react\u0026#39;; import CartContext from \u0026#39;../store/CartContext\u0026#39;; function Cart() { const cartCtx = useContext(CartContext); return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Cart\u0026lt;/h1\u0026gt; {cartCtx.products.map(product =\u0026gt; ( \u0026lt;p key={product.id}\u0026gt;{product.name}\u0026lt;/p\u0026gt; ))} \u0026lt;/div\u0026gt; ); } What Whappen when the data is updated? When the data is updated in the Provider component, all the child components that are using the context data will be re-rendered automatically. Task: Design a simple application that has a component called App. App has two child components: Header and Shop. Header has one child, CartModel, and Shop has one child, Product. Pass the data from the Product component to the CartModel component using the Context API.\nStructure of the project\nsrc\r|_components\r|_App\r|_App.js\r|_Header\r|_Header.js\r|_CartModel.js\r|_Shop\r|_Shop.js\r|_Product.js\r|_store\r|_CartContext.js CartContext.js\nimport { createContext } from \u0026#39;react\u0026#39;; const CartContext = createContext(); export default CartContext; App.js\nimport CartContext from \u0026#39;../store/CartContext\u0026#39;; import Header from \u0026#39;../Header/Header\u0026#39;; import Shop from \u0026#39;../Shop/Shop\u0026#39;; import { useState } from \u0026#39;react\u0026#39;; function App() { const [cartProducts, setCartProducts] = useState([]); const addProductToCart = (product) =\u0026gt; { setCartProducts((prevProducts) =\u0026gt; [...prevProducts, product]); }; return ( \u0026lt;CartContext.Provider value={ { products: cartProducts, addProduct: addProductToCart } }\u0026gt; \u0026lt;Header /\u0026gt; \u0026lt;Shop /\u0026gt; \u0026lt;/CartContext.Provider\u0026gt; ); } export default App; Header.js\nimport CartModel from \u0026#39;./CartModel\u0026#39;; function Header() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Header\u0026lt;/h1\u0026gt; \u0026lt;CartModel /\u0026gt; \u0026lt;/div\u0026gt; ); } export default Header; CartModel.js\nimport { useContext } from \u0026#39;react\u0026#39;; import CartContext from \u0026#39;../../store/CartContext\u0026#39;; function CartModel() { const cartCtx = useContext(CartContext); return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;CartModel\u0026lt;/h1\u0026gt; {cartCtx.products.map(product =\u0026gt; ( \u0026lt;p key={product.id}\u0026gt;{product.name}\u0026lt;/p\u0026gt; ))} \u0026lt;/div\u0026gt; ); } export default CartModel; Shop.js\nimport Product from \u0026#39;./Product\u0026#39;; function Shop() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Shop\u0026lt;/h1\u0026gt; \u0026lt;Product /\u0026gt; \u0026lt;/div\u0026gt; ); } export default Shop; Product.js\nimport { useContext } from \u0026#39;react\u0026#39;; import CartContext from \u0026#39;../../store/CartContext\u0026#39;; function Product() { const cartCtx = useContext(CartContext); const product = { id: 1, name: \u0026#39;Laptop\u0026#39; }; return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Product\u0026lt;/h1\u0026gt; \u0026lt;button onClick={() =\u0026gt; cartCtx.addProduct(product)}\u0026gt;Add to Cart\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } export default Product; Outsoursing the Context Provider Since all the logic related to the context is in the App Component so we can outsource the context provider and its logic to a separate component in order to make the App Component more clean and readable.\nCartContext.js\nimport { createContext, useState } from \u0026#39;react\u0026#39;; const CartContext = createContext(); export const CartContextProvider = (props) =\u0026gt; { const [cartProducts, setCartProducts] = useState([]); const addProductToCart = (product) =\u0026gt; { setCartProducts((prevProducts) =\u0026gt; [...prevProducts, product]); }; const context = { products: cartProducts, addProduct: addProductToCart }; return ( \u0026lt;CartContext.Provider value={context}\u0026gt; {props.children} \u0026lt;/CartContext.Provider\u0026gt; ); }; App.js\nimport Header from \u0026#39;../Header/Header\u0026#39;; import Shop from \u0026#39;../Shop/Shop\u0026#39;; import { CartContextProvider } from \u0026#39;../store/CartContext\u0026#39;; function App() { return ( \u0026lt;CartContextProvider\u0026gt; \u0026lt;Header /\u0026gt; \u0026lt;Shop /\u0026gt; \u0026lt;/CartContextProvider\u0026gt; ); } export default App; Other Components remain the same.\n39.UseReducer Hook in React USe reducer is a hook that is used for state management in React. It is an alternative to useState. It is usually preferable when you have complex state logic that involves multiple sub-values or when the next state depends on the previous one.\nHow to use useReducer Hook Create a reducer function. A reducer function is a function that takes the current state and an action as arguments and returns a new state based on the action type.action . action:It contains the object that is sent by the dispatch function. For Example:\nconst counterReducer = (state, action) =\u0026gt; { if (action.type === \u0026#39;INCREMENT\u0026#39;) { return { counter: state.counter + 1 }; } if (action.type === \u0026#39;DECREMENT\u0026#39;) { return { counter: state.counter - 1 }; } return state; }; Here, the reducer function takes two arguments: state and action. It checks the action type and returns a new state based on the action type.\nUse the useReducer hook in the component. The useReducer hook takes two arguments: the reducer function and the initial state and returns the current state and a dispatch function as an array which is shown below. For Example: import { useReducer } from \u0026#39;react\u0026#39;; const [counterState, dispatchCounter] = useReducer(counterReducer, { counter: 0 }); Here, counterState is the current state and dispatchCounter is the dispatch function that is used to dispatch an action to the reducer function and { counter: 0 } is the initial state such that the counter is initialized to 0.\nDispatch an action to the reducer function. To dispatch an action to the reducer function, you need to call the dispatch function with an object that contains the action type and any additional data that is required by the reducer function. For Example: dispatchCounter({ type: \u0026#39;INCREMENT\u0026#39; }); To change the state, you need to call the dispatch function with an object that contains the action type.Here, the action type is \u0026lsquo;INCREMENT\u0026rsquo; which increments the counter by 1.\nTask: Design a simple counter application that has a component called Counter. The Counter component has two buttons: Increment and Decrement. Use the useReducer hook to manage the state of the counter.\nStructure of the project\nsrc\r|_components\r|_Counter\r|_Counter.js Counter.js\nimport { useReducer } from \u0026#39;react\u0026#39;; const counterReducer = (state, action) =\u0026gt; { if (action.type === \u0026#39;INCREMENT\u0026#39;) { return { counter: state.counter + 1 }; } if (action.type === \u0026#39;DECREMENT\u0026#39;) { return { counter: state.counter - 1 }; } return state; }; function Counter() { const [counterState, dispatchCounter] = useReducer(counterReducer, { counter: 0 }); const handleIncrement = () =\u0026gt; { dispatchCounter({ type: \u0026#39;INCREMENT\u0026#39; }); }; const handleDecrement = () =\u0026gt; { dispatchCounter({ type: \u0026#39;DECREMENT\u0026#39; }); }; return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Counter\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;{counterState.counter}\u0026lt;/p\u0026gt; \u0026lt;button onClick={handleIncrement}\u0026gt;Increment\u0026lt;/button\u0026gt; \u0026lt;button onClick={handleDecrement}\u0026gt;Decrement\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } If we use useState hook then the code will be like this:\nimport { useState } from \u0026#39;react\u0026#39;; function Counter() { const [counter, setCounter] = useState(0); const handleIncrement = () =\u0026gt; { setCounter(counter=\u0026gt;counter + 1); }; const handleDecrement = () =\u0026gt; { setCounter(counter=\u0026gt;counter - 1); }; return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Counter\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;{counter}\u0026lt;/p\u0026gt; \u0026lt;button onClick={handleIncrement}\u0026gt;Increment\u0026lt;/button\u0026gt; \u0026lt;button onClick={handleDecrement}\u0026gt;Decrement\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } What is the difference between useState and useReducer?\nuseState is a simple and straightforward way to manage state in React. It is suitable for managing simple state logic. useReducer is more powerful and flexible than useState. It is suitable for managing complex state logic that involves multiple sub-values or when the next state depends on the previous one. Looking the example case Scenario: Here using reducer we write all the logic in a single function and then we dispatch the action to the reducer function and then the reducer function returns the new state based on the action type. This makes the code more readable and maintainable.\nbut in the case of useState, we have to write the logic for each state change separately which makes the code more complex and difficult to maintain.\nNote: Always change in state variable will cause the re-rendering of the component.\n","permalink":"http://localhost:1313/posts/pages/react/react8/","summary":"Learn about prop drilling and how to use the Context API in React to manage and share state effectively.","title":"React : 8"},{"content":"1.1 When to use asyncio? Asyncio is a library to write concurrent code using the async/await syntax. It is a single-threaded, single-process design that is ideal for I/O-bound and high-level structured network code. It is not suitable for CPU-bound code, which is better handled by the multiprocessing module.It is used for :\n2.1 Coroutine Think of a coroutine like a regular Python function but with the superpower that it can pause its execution when it encounters an operation that could take a while to complete. When that long-running operation is complete, we can “wake up” our paused coroutine and finish executing any other code in that coroutine. While a paused coroutine is waiting for the operation it paused for to finish, we can run other code. This running of other code while waiting is what gives our application concur rency. We can also run several time-consuming operations concurrently, which can give our applications big performance improvements. To both create and pause a coroutine, we’ll need to learn to use Python’s async and await keywords. The async keyword will let us define a coroutine; the await key word will let us pause our coroutine when we have a long-running operation.\n2.2 Creating a coroutine with async creating a coroutine is straightforward and not much different from creating a nor mal Python function. The only difference is that, instead of using the def keyword, we use async def. The async keyword marks a function as a coroutine instead of a nor mal Python function.\nimport asyncio async def mero_coroutine(): print(\u0026#34;Hello From Asyncio\u0026#34;) The coroutine in the preceding listing does nothing yet other than print “Hello world!” It’s also worth noting that this coroutine does not perform any long-running operations; it just prints our message and returns. This means that, when we put the coroutine on the event loop, it will execute immediately because we don’t have any blocking I/O, and nothing is pausing execution yet. This syntax is simple, but we’re creating something very different from a plain Python function. To illustrate this, let’s create a function that adds one to an integer as well as a coroutine that does the same and compare the results of calling each. We’ll also use the type convenience function to look at the type returned by calling a corou tine as compared to calling our normal function.\ndef add_function(a,b): return a+b async def add_coroutine(a,b): return a+b function=add_function(1,2) coroutine=add_coroutine(1,2) print(type(function)) print(type(coroutine)) When we run this code, we’ll see output like the following\nMethod result is 3 and the type is \u0026lt;class \u0026#39;int\u0026#39;\u0026gt;\rCoroutine result is \u0026lt;coroutine object coroutine_add_one at 0x1071d6040\u0026gt; and the type is \u0026lt;class \u0026#39;coroutine\u0026#39;\u0026gt; Notice how when we call our normal add_one function it executes immediately and returns what we would expect, another integer. However, when we call coroutine_ add_one we don’t get our code in the coroutine executed at all. We get a coroutine object instead. This is an important point, as coroutines aren’t executed when we call them directly. Instead, we create a coroutine object that can be run later. To run a corou tine, we need to explicitly run it on an event loop. So how can we create an event loop and run our coroutine?\nIn versions of Python older than 3.7, we had to create an event loop if one did not already exist. However, the asyncio library has added several functions that abstract the event loop management. There is a convenience function, asyncio.run, we can use to run our coroutine. This is illustrated in the following listing.\nimport asyncio async def add_coroutine(a,b): return a+b res=asyncio.run(add_coroutine(1,2)) print(res) When we run this code, we’ll see output like the following:\n3 We’ve properly put our coroutine on the event loop, and we have executed it! asyncio.run is doing a few important things in this scenario. First, it creates a brand-new event. Once it successfully does so, it takes whichever coroutine we pass into it and runs it until it completes, returning the result. This function will also do some cleanup of anything that might be left running after the main coroutine fin ishes. Once everything has finished, it shuts down and closes the event loop. Possibly the most important thing about asyncio.run is that it is intended to be the main entry point into the asyncio application we have created. It only executes one coroutine, and that coroutine should launch all other aspects of our application. As we progress further, we will use this function as the entry point into nearly all our applications. The coroutine that asyncio.run executes will create and run other coroutines that will allow us to utilize the concurrent nature of asyncio.\n2.3 Pausing execution with the await keyword The example we saw in block 2.2 did not need to be a coroutine, as it executed only non-blocking Python code. The real benefit of asyncio is being able to pause execu tion to let the event loop run other tasks during a long-running operation. To pause execution, we use the await keyword. The await keyword is usually followed by a call to a coroutine (more specifically, an object known as an awaitable, which is not always a coroutine; we’ll learn more about awaitables later in the chapter). Using the await keyword will cause the coroutine following it to be run, unlike calling a coroutine directly, which produces a coroutine object. The await expression will also pause the coroutine where it is contained in until the coroutine we awaited finishes and returns a result. When the coroutine we awaited finishes, we’ll have access to the result it returned, and the containing coroutine will “wake up” to handle the result. We can use the await keyword by putting it in front of a coroutine call. Expanding on our earlier program, we can write a program where we call the add_coroutine function inside of a “main” async function and get the result\nimport asyncio async def add_one(number: int) -\u0026gt; int: return number + 1 async def main() -\u0026gt; None: one_plus_one = await add_one(1) # Pause, and wait for the result of add_one(1). two_plus_one = await add_one(2) # Pause, and wait for the result of add_one(2). print(one_plus_one) print(two_plus_one) asyncio.run(main()) Note: Coroutine will only run when we use await keyword. If we call the coroutine directly it will return a coroutine object.\nIn above code we pause execution twice. We first await the call to add_one(1). Once we have the result, the main function will be “unpaused,” and we will assign the return value from add_one(1) to the variable one_plus_one, which in this case will be two. We then do the same for add_one(2) and then print the results.We can visualize the execution flow of our application, as shown in figure\nAs it stands now, this code does not operate differently from normal, sequential code. We are, in effect, mimicking a normal call stack. Next, let’s look at a simple example of how to run other code by introducing a dummy sleep operation while we’re waiting.\n2.4 Introducing long-running coroutines with sleep Our previous examples did not use any slow operations and were used to help us learn the basic syntax of coroutines. To fully see the benefits and show how we can run mul tiple events simultaneously, we’ll need to introduce some long-running operations. Instead of making web API or database queries right away, which are nondeterministic as to how much time they will take, we’ll simulate long-running operations by specify ing how long we want to wait. We’ll do this with the asyncio.sleep function. We can use asyncio.sleep to make a coroutine “sleep” for a given number of sec onds. This will pause our coroutine for the time we give it, simulating what would hap pen if we had a long-running call to a database or web API. asyncio.sleep is itself a coroutine, so we must use it with the await keyword. If we call it just by itself, we’ll get a coroutine object. Since asyncio.sleep is a coroutine, this means that when a coroutine awaits it, other code will be able to run. Let’s examine a simple example, shown in the following listing, that sleeps for 1 sec ond and then prints a \u0026lsquo;Hello World!\u0026rsquo; message.\nimport asyncio async def hello_world_message(): await asyncio.sleep(1) print(\u0026#34;Hello World\u0026#34;) asyncio.run(hello_world_message()) When we run this application, our program will wait 1 second before printing our \u0026lsquo;Hello World!\u0026rsquo; message. Since hello_world_message is a coroutine and we pause it for 1 second with asyncio.sleep, we now have 1 second where we could be running other code concurrently.\nWe’ll be using sleep a lot in the next few examples, so let’s invest the time to cre ate a reusable coroutine that sleeps for us and prints out some useful information. We’ll call this coroutine delay. This is shown in the following listing\nimport asyncio async def delay(delaysecond): print(f\u0026#39;Sleeping for delay seconds : {delaysecond}\u0026#39;) await asyncio.sleep(delaysecond) print(f\u0026#39;finished sleeping for {delay_seconds} second(s)\u0026#39;) return delay_seconds delay will take in an integer of the duration in seconds that we’d like the function to sleep and will return that integer to the caller once it has finished sleeping. We’ll also print when sleep begins and ends. This will help us see what other code, if any, is run ning concurrently while our coroutines are paused.\nTo make referencing this utility function easier in future code listings, we’ll create a module that we’ll import in the remainder of this book when needed. We’ll also add to this module as we create additional reusable functions. We’ll call this module util, and we’ll put our delay function in a file called delay_functions.py. We’ll also add an init.py file with the following line, so we can nicely import the timer\nfrom util.delay_functions import delay From now on in this book, we’ll use from util import delay whenever we need to use the delay function. Now that we have a reusable delay coroutine, let’s combine it with the earlier coroutine add_one to see if we can get our simple addition to run concur rently while hello_world_message is paused.\nimport asyncio from util.delay_functions import delay async def add_one(number): return number + 1 async def hello_world_message(): await delay(1) print(\u0026#34;Hello World\u0026#34;) async def main() -\u0026gt; None: message = await hello_world_message() #pause until hello_world_message is finished one_plus_one = await add_one(1) #pause until add_one is finished print(one_plus_one) print(message) asyncio.run(main()) When we run this, 1 second passes before the results of both function calls are printed. What we really want is the value of add_one(1) to be printed immediately while hello_world_message()runs concurrently. So why isn’t this happening with this code? The answer is that await pauses our current coroutine and won’t execute any other code inside that coroutine until the await expression gives us a value. Since it will take 1 second for our hello_world_message function to give us a value, the main coroutine will be paused for 1 second. Our code behaves as if it were sequential in this case. This behavior is illustrated in figure\nWe can see that the main coroutine is paused for 1 second while hello_world_\nBoth main and hello_world paused while we wait for delay(1) to finish. After it has finished, main resumes and can execute add_one. We’d like to move away from this sequential model and run add_one concurrently with hello_world. To achieve this, we’ll need to introduce a concept called tasks.\n2.5 Running concurrently with task In Python\u0026rsquo;s asyncio, you can create tasks to run code concurrently. This is done using the asyncio.create_task function. When you create a task, it starts running in the background immediately, allowing your program to do other things while waiting for the task to finish.\nKey Points: Creating a Task:\nUse asyncio.create_task() with a coroutine function as its input. It returns a task object instantly. Awaiting a Task:\nYou can use await with the task object to pause your program until the task is done and get its result. Why Use Tasks?\nTasks allow other parts of your program to run without waiting for one operation to finish. Code Example: Creating and Using a Task import asyncio from util import delay # A custom function that simulates a delay async def main(): # Create a task that takes 3 seconds to complete sleep_for_three = asyncio.create_task(delay(3)) # Immediately print the type of the task object print(f\u0026#34;Task type: {type(sleep_for_three)}\u0026#34;) # Wait for the task to finish and get the result result = await sleep_for_three print(f\u0026#34;Task result: {result}\u0026#34;) # Run the main coroutine asyncio.run(main()) What’s Happening in the Code: Task Creation:\nasyncio.create_task(delay(3)) creates a task to run the delay(3) coroutine in the background. The task is of type \u0026lt;class '_asyncio.Task'\u0026gt;, which is different from a regular coroutine. Running Concurrently:\nAfter creating the task, the program does not wait for the task to finish. The print() statement runs immediately after the task is created. Waiting for the Task:\nThe await sleep_for_three line pauses the main coroutine until the task finishes. Once the task is complete, it returns its result, which is printed. Why Await is Important: If you don’t use await on a task, it might not get enough time to finish. When the asyncio.run function exits, the event loop stops, and any unfinished tasks are “cleaned up” without completing. Using await ensures the task has a chance to finish.\nNote : When we create task using asyncio.create_task it run the task immediately in the background. It does not wait for the task to finish and immediately return a task object such that our program can do other things while waiting for the task to finish.We can use await later on to pause the program until the task is done and get its result.\n2.6 Running multiple tasks concurrently Given that tasks are created instantly and are scheduled to run as soon as possible, this allows us to run many long-running tasks concurrently. We can do this by sequentially starting multiple tasks with our long-running coroutine.\nimport asyncio from util.delay_functions import delay async def main(): # Create two tasks that take 3 seconds to complete sleep_for_three=asyncio.create_task(delay(3)) sleep_again=asyncio.create_task(delay(3)) sleep_once_more=asyncio.create_task(delay(3)) await sleep_for_three await sleep_again await sleep_once_more asyncio.run(main()) In this code, we create three tasks that each sleep for 3 seconds. We then await each task in sequence. This will cause each task to run concurrently, and the total time to complete will be around 3 seconds, not 9 seconds. This is because we are not waiting for each task to finish before starting the next one. Lets breakdown\nStarting Three Tasks:\nThe program begins by creating three tasks, each of which takes 3 seconds to complete. The create_task function starts the tasks immediately but doesn\u0026rsquo;t wait for them to finish—it just sets them up to run in the background. The First Await Statement:\nWhen the code reaches the await sleep_for_three line, it pauses and gives control to the event loop. This pause allows the event loop to check for any tasks waiting to run and starts them “as soon as possible.” Tasks Run Simultaneously:\nAll three tasks begin running their sleep operations at the same time because the event loop handles them concurrently. This concurrency allows the program to complete the work in 3 seconds instead of 9. Concurrency in Action:\nWhile the sleep operations run concurrently, any other code in the tasks (like print statements) runs one at a time, not simultaneously. This means only the parts of the tasks that involve waiting (like sleeping) are parallelized. Time Saved:\nIf the tasks were executed one after another, the program would take 9 seconds (3 seconds × 3 tasks). By running the tasks concurrently, the program finishes in just 3 seconds, saving a lot of time. This is illustrated in figure NOTE This benefit compounds as we add more tasks; if we had launched 10 of these tasks, we would still take roughly 3 seconds, giving us a 10-fold speedup. This is the power of concurrency in asyncio.\nasyncio.gather function Gather function is a quick way to run multiple tasks concurrently and wait for all of them to complete. It takes in an iterable of awaitables and returns a single awaitable that will yield results in the order they were created. This is useful when we want to run multiple tasks concurrently and wait for all of them to finish before proceeding.\nimport asyncio from util.delay_functions import delay async def main(): # Create three tasks that take 3 seconds to complete and handel using asyncio.gather results = await asyncio.gather( delay(3), delay(3), delay(3) ) print(results) asyncio.run(main()) Note : For understanding You can use this logic . There is a task queue and event loop. When we only await coroutine there is only one task in the task queue and event loop .\ncoroutine need to await for running the task i.e keep in the task queue and eventloop if we directly run coroutine it will just give us coroutine object.\nWhen we use asyncio.createtask() there are as much task in the task queue as the number of tasks created and event loop will run all the tasks concurrently also when we await new coroutine it will be added to the task queue and event loop will run it concurrently.\nIt return a task object instantly and run all the task concurrently i.e keep in the task queue and event loop without awaiting but does not wait for the task to finish it need to be awaited to get the proper result.\nWhen we use asyncio.gather() it will run all the tasks concurrently and wait for all of them to finish before proceeding.\nIt need to be awaited to keep all the task in the task queue and event loop and wait for all of them to finish before proceeding.After finishing all the task it will return the result in the order they were created and jump to the next line of code of the main coroutine.\n3. Synchronization Premitives Locks Semaphores 3.1 Locks Locks are a synchronization primitive that allows us to limit access to a shared resource to only one coroutine at a time. This is useful when we have a resource that can only be accessed by one coroutine at a time, like a file or a database connection. Locks are created using the asyncio.Lock class and can be acquired using the acquire method and released using the release method.\n#basic example of lock\nimport asyncio async def locking(lock): print(\u0026#39;Waiting for the lock\u0026#39;) async with lock: print(\u0026#39;Acquired the lock\u0026#39;) await asyncio.sleep(2) print(\u0026#39;Released the lock\u0026#39;) async def main(): lock = asyncio.Lock() await asyncio.gather( locking(lock), locking(lock), locking(lock) ) asyncio.run(main()) Output:\nWaiting for the lock\rAcquired the lock\rWaiting for the lock\rWaiting for the lock\rReleased the lock\rAcquired the lock\rReleased the lock\rAcquired the lock\rReleased the lock In this example, we create a lock using asyncio.Lock and pass it to the locking coroutine. We then use the async with statement to acquire the lock and release it when we are done. When we run the program, we can see that only one coroutine can acquire the lock at a time, and the other coroutines have to wait until the lock is released.\n3.2 Semaphores Semaphores are a synchronization primitive that allows us to limit access to a shared resource to a fixed number of coroutines at a time. This is useful when we have a resource that can be accessed by a limited number of coroutines, like a connection pool or a web API. Semaphores are created using the asyncio.Semaphore class and can be acquired using the acquire method and released using the release method.\n#basic example of semaphore\nimport asyncio async def semaphoring(semaphore): async with semaphore: print(\u0026#39;Acquired the semaphore\u0026#39;) await asyncio.sleep(2) print(\u0026#39;Released the semaphore\u0026#39;) async def main(): semaphore = asyncio.Semaphore(2) await asyncio.gather( semaphoring(semaphore), semaphoring(semaphore), semaphoring(semaphore), semaphoring(semaphore) ) asyncio.run(main()) Output:\nAcquired the semaphore\rAcquired the semaphore\rAcquired the semaphore\rReleased the semaphore\rReleased the semaphore\rReleased the semaphore\rAcquired the semaphore\rReleased the semaphore In this example, we create a semaphore with a limit of 2 using asyncio.Semaphore and pass it to the semaphoring coroutine. We then use the async with statement to acquire the semaphore and release it when we are done. When we run the program, we can see that only two coroutines can acquire the semaphore at a time, and the other coroutines have to wait until the semaphore is released.\nSome popular asyncio libraries aiohttp: An HTTP client and server library for asyncio. fastapi: A modern web framework for building APIs with Python 3.6+ based on standard Python type hints. aiofiles: A file operations library for asyncio. ","permalink":"http://localhost:1313/posts/pages/asyncio/asyncio2/","summary":"how to write programs using this single-threaded concurrency model with asyncio","title":"Async io : Asyncio Basics (Day 2)"},{"content":"36. useRef Hook in React useRef is a hook that is specially designed to work with DOM elements. It allows you to create a reference to a DOM element and access it directly in your components so you can modify it or read its properties as needed.\nAnother important distinction is that useRef holds the same reference across re-renders of the component Similarly, useState also retains its value between renders. However, updating a state value with useState will always trigger a re-render, whereas updating the value of a useRef does not. Its explained in the below example in ## 2. Advanvced Usage\n1. Basic Usage 1. Import useRef import { useRef } from \u0026#39;react\u0026#39;; 2. Create a Reference const myRef = useRef(); 3. Attach to DOM Elements function MyComponent() { const myRef = useRef(); return ( \u0026lt;div ref={myRef}\u0026gt; \u0026lt;h1\u0026gt;useRef Example\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ); } 4. Accessing the Reference // Access the DOM element using .current const element = myRef.current; use myRef.current.value for input elements. use myRef.current.checked for checkbox elements. use myRef.current.focus() to focus on an element. use myRef.current.style to access the style object of an element.\nNote: While you can access DOM elements directly with useRef, it\u0026rsquo;s recommended to avoid manipulating them directly unless necessary.\nPractical Example: Form Input Here\u0026rsquo;s a complete example showing how to use useRef with form inputs:\nimport { useRef, useState } from \u0026#39;react\u0026#39;; function InputExample() { const inputRef = useRef(); const [inputValue, setInputValue] = useState(\u0026#39;\u0026#39;); const handleClick = () =\u0026gt; { setInputValue(inputRef.current.value); inputRef.current.value = \u0026#39;\u0026#39;; // Clear input after reading }; return ( \u0026lt;div\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; ref={inputRef} placeholder=\u0026#34;Type something...\u0026#34; /\u0026gt; \u0026lt;button onClick={handleClick}\u0026gt;Save Input\u0026lt;/button\u0026gt; \u0026lt;p\u0026gt;Saved value: {inputValue}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } Explanation:\nWe create a reference to the input element using useRef. When the button is clicked, we read the input value using inputRef.current.value and update the state. We clear the input field by setting inputRef.current.value to an empty string. 2. Advanced Usage of useRef and useState useRef and useState are both hooks used in React. Both hooks help us store values, but they behave differently: useState: The value is persistent across re-renders, but updating it triggers a re-render. useRef: The value is also persistent across re-renders, but updating it does not trigger a re-render. 2.1. Managing Previous Values in a Stopwatch Here’s an example of how to use useRef and useState to build a simple stopwatch in React:\nimport { useRef, useState } from \u0026#39;react\u0026#39;; function Stopwatch() { const timerRef = useRef(0); // To store the timer ID const [time, setTime] = useState(0); // To store the current time const [isRunning, setIsRunning] = useState(false); // To track if the stopwatch is running // Start the timer when the Start button is clicked const startTimer = () =\u0026gt; { if (!isRunning) { timerRef.current = setInterval(() =\u0026gt; { setTime((time) =\u0026gt; time + 1); // Increment the time every second }, 1000); setIsRunning(true); // Set the timer as running } }; // Stop the timer when the Stop button is clicked const stopTimer = () =\u0026gt; { clearInterval(timerRef.current); // Clear the interval to stop the timer setIsRunning(false); // Set the timer as not running }; // Reset the timer when the Reset button is clicked const resetTimer = () =\u0026gt; { clearInterval(timerRef.current); // Clear the interval to stop the timer setIsRunning(false); // Set the timer as not running setTime(0); // Reset the time to 0 }; return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Stopwatch\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;Time: {time} seconds\u0026lt;/p\u0026gt; \u0026lt;button onClick={startTimer}\u0026gt;Start\u0026lt;/button\u0026gt; \u0026lt;button onClick={stopTimer}\u0026gt;Stop\u0026lt;/button\u0026gt; \u0026lt;button onClick={resetTimer}\u0026gt;Reset\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } Explanation Creating useRef and useState variables:\ntimerRef: This holds the timer ID (returned by setInterval). We use useRef here because we don’t need the component to re-render when the timer ID changes. time: This stores the current time value of the stopwatch, and we use useState for this because we want the component to re-render whenever the time updates. isRunning: This tracks whether the stopwatch is running or not. Starting the timer (Start Button):\nWhen the \u0026ldquo;Start\u0026rdquo; button is clicked, we check if the timer is already running. If it isn’t, we start it by calling setInterval, which increments the time value every second. setInterval returns an interval ID that we store in timerRef.current. This ID will be used to stop the timer later. Stopping the timer (Stop Button):\nWhen the \u0026ldquo;Stop\u0026rdquo; button is clicked, we clear the interval using clearInterval(timerRef.current) to stop the timer. We also set isRunning to false to indicate that the timer is no longer running. Resetting the timer (Reset Button):\nWhen the \u0026ldquo;Reset\u0026rdquo; button is clicked, we clear the interval to stop the timer, set isRunning to false, and reset the time back to 0. Why useRef? Why not just use a regular variable?\nA regular variable inside the component would reset every time the component re-renders. Since the timer is being updated every second, this would cause issues because the value would be reset each time, and the timer wouldn’t function correctly. Why useRef over useState for the timer ID?\nWe use useRef to store the timer ID because updating it with useState would trigger a re-render every time the timer ID changes. Since the timer is running independently, we don’t need a re-render, so useRef is more efficient here. Key Takeaways useRef is useful for storing values that don’t require the component to re-render when they change. useState is used for values that should trigger a re-render when updated, like the time value in our stopwatch. useRef does not cause a re-render when its value changes, making it ideal for holding values like the interval ID that don’t need to affect the UI. Common Use Cases Storing previous values Managing focus, text selection, or media playback Integrating with third-party DOM libraries Accessing underlying DOM elements Isolation in Components: Any variable that is declared inside a component is isolated to that component. It is not shared with other components unless explicitly passed as props. This isolation helps maintain the encapsulation and modularity of components in React.\n37.Forwarding Refs in React Forwarding refs is a technique in React that allows you to pass a ref from a parent component to a child component. This is useful when you want to access the DOM element of a child component from a parent component.\n1. Basic Usage 1.Import useRef import { useRef } from \u0026#39;react\u0026#39;; 2. Create a Ref in the Parent Component const myRef= useRef(); 3. Pass the Ref to the Child Component \u0026lt;MyChildComponent ref={myRef} /\u0026gt; 4.Import forward ref in child component import React, { forwardRef } from \u0026#39;react\u0026#39;; 5. Using forwardRef to Forward the Ref const MyChildComponent = forwardRef((props, ref) =\u0026gt; { return \u0026lt;input ref={ref} /\u0026gt;; }); 6. Accessing the Ref in the Parent Component const element = myRef.current.value; Practical Example: Input Focus to take input from user and focus on the input field of the child component from the parent component.\nimport React, { useRef } from \u0026#39;react\u0026#39;; const InputComponent = forwardRef(({title}, ref) =\u0026gt; { return\u0026lt;\u0026gt; \u0026lt;h1\u0026gt;{title}\u0026lt;/h1\u0026gt; \u0026lt;input ref={ref}/\u0026gt; \u0026lt;/\u0026gt; }); function ParentComponent() { const inputRef = useRef(); const handleClick = () =\u0026gt; { inputRef.current.focus(); console.log(inputRef.current.value); }; return ( \u0026lt;div\u0026gt; \u0026lt;InputComponent ref={inputRef} title=\u0026#34;ENter the Input\u0026#34;/\u0026gt; \u0026lt;button onClick={handleClick}\u0026gt;Focus Input\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 38.useImperativeHandle in React In large-scale applications, we generally avoid using refs directly to access child components. Instead, we use the useImperativeHandle hook to expose specific methods from the child component to the parent component. This approach allows the developer working on the parent component to interact with the child component\u0026rsquo;s methods without needing to understand its internal implementation. Additionally, this separation enables the developer of the child component to modify or update the child component independently, without affecting the parent component. Since only the exposed methods are used by the parent, changes to the internal structure of the child component do not disrupt the parent-child interaction.This is specially used in forwardRef to expose methods of child component to parent component.\nBasic Usage 1.Pass a Ref to the Child Component import {useRef} from \u0026#39;react\u0026#39;; function App() { const childRef = useRef(); return \u0026lt;ChildComponent ref={childRef} /\u0026gt;; } =\u0026gt; Here, we create a ref using useRef and pass it to the ChildComponent using the ref prop.\n2. Use useImperativeHandle in the Child Component with forwardRef to expose methods import { useImperativeHandle, forwardRef } from \u0026#39;react\u0026#39;; const ChildComponent = forwardRef((props, ref) =\u0026gt; { useImperativeHandle(ref, () =\u0026gt; ({ focus: () =\u0026gt; { // Focus on the input element }, reset: () =\u0026gt; { // Reset the input element }, inputValue:\u0026#39;vaule\u0026#39; }),[dependencies]); return \u0026lt;input /\u0026gt;; }); In the ChildComponent, we use the useImperativeHandle hook to expose the focus and reset methods to the parent component. The ref object is passed as the first argument, and the second argument is a function that returns an object containing the methods to be exposed. dependencies is an optional array of values that, when changed, will trigger the re-evaluation of the function that returns the methods. If the dependencies array is not provided, the function will be called on every render and empty array will call only once in entire lifecycle.\n3. Access the Exposed Methods in the Parent Component function App() { const childRef = useRef(); const handleClick = () =\u0026gt; { childRef.current.focus(); }; const resetClick = () =\u0026gt; { childRef.current.reset(); }; return ( \u0026lt;\u0026gt; \u0026lt;ChildComponent ref={childRef} /\u0026gt; \u0026lt;button onClick={handleClick}\u0026gt;Focus Input\u0026lt;/button\u0026gt; \u0026lt;button onClick={resetClick}\u0026gt;Reset Input\u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; ); } In the parent component, we can access the exposed methods using the current property of the ref object. In this example, we call the focus method when the \u0026ldquo;Focus Input\u0026rdquo; button is clicked.\nPractical Example: Use forwardRef and useImperativeHandle to Expose Methods for reset the input field and get the value of the input field. import {useRef} from \u0026#39;react\u0026#39;; function App(){ const childRef = useRef(); const handleClick = () =\u0026gt; { childRef.current.focus(); }; const resetClick = () =\u0026gt; { childRef.current.reset(); }; const getValue = () =\u0026gt; { console.log(childRef.current.value); }; return ( \u0026lt;\u0026gt; \u0026lt;ChildComponent ref={childRef} /\u0026gt; \u0026lt;button onClick={handleClick}\u0026gt;Focus Input\u0026lt;/button\u0026gt; \u0026lt;button onClick={resetClick}\u0026gt;Reset Input\u0026lt;/button\u0026gt; \u0026lt;button onClick={getValue}\u0026gt;Get Value\u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; ); } export default App; import { useImperativeHandle, forwardRef,useRef } from \u0026#39;react\u0026#39;; const ChildComponent = forwardRef((props, ref) =\u0026gt; { const inputRef = useRef(); useImperativeHandle(ref, () =\u0026gt; ({ focus: () =\u0026gt; { inputRef.current.focus(); }, reset: () =\u0026gt; { inputRef.current.value = \u0026#39;\u0026#39;; }, value: inputRef.current.value }),[]); return \u0026lt;input ref={inputRef} /\u0026gt;; }); export default ChildComponent; =\u0026gt; By using useImperativeHandle, we can expose specific methods from the child component to the parent component, allowing for more controlled interactions between the components such as focusing on the input field, resetting the input field, and getting the value of the input field in this example. =\u0026gt; By using this approach, we can maintain a clear separation of concerns between the parent and child components, making it easier to manage and update the components independently.\n37. Portals in React Portals in React provide a way to render children components outside the DOM hierarchy of the parent component. This allows you to render a child component at a different location in the DOM, such as at the root level or inside a specific container, without affecting the parent\u0026rsquo;s layout or styles.\nImporting portal from react-dom import { createPortal } from \u0026#39;react-dom\u0026#39;; using createPortal const MyPortal = ({title}) =\u0026gt; { return createPortal( \u0026lt;\u0026gt; \u0026lt;h1\u0026gt;{title}\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;This is a portal\u0026lt;/p\u0026gt; \u0026lt;\u0026gt;, document.getElementById(\u0026#39;portal-root\u0026#39;)); }; =\u0026gt;When the MyPortal component is rendered, the content will be rendered inside the element with the id \u0026lsquo;portal-root\u0026rsquo;, which can be located anywhere in the DOM.\n","permalink":"http://localhost:1313/posts/pages/react/react7/","summary":"Learn about useRef hook, ref forwarding, useImperativeHandle and Portals in React for DOM manipulation and component interactions.","title":"React : Day 7"},{"content":"1. Some Important Concepts 1.1 Parallism vs Concurrency Parallism: Running multiple tasks at the same time. There are multiple Threads or Processes running at the same time. Concurrency: Switching between multiple tasks. When one task is waiting for I/O, another task can run. There is only one Thread or Process running at a time. 1.2 Synchronous vs Asynchronous Synchronous: Code is executed in sequence. Previous task/line must be completed before the next task/line execution starts. Asynchronous: Code is executed in parallel. Tasks can run concurrently. The next task can start before the previous task is completed. 1.3 Blocking vs Non-Blocking Blocking: The execution of the code is blocked until the task is completed. The next task can\u0026rsquo;t start until the previous task is completed. import time def task1(): print(\u0026#34;Task 1 started\u0026#34;) time.sleep(2) print(\u0026#34;Task 1 completed\u0026#34;) def task2(): print(\u0026#34;Task 2 started\u0026#34;) time.sleep(2) print(\u0026#34;Task 2 completed\u0026#34;) task1() task2() Non-Blocking: The excecution of the code is not blocked. The next task can start before the previous task is completed. import asyncio async def task1(): print(\u0026#34;Task 1 started\u0026#34;) await asyncio.sleep(2) print(\u0026#34;Task 1 completed\u0026#34;) async def task2(): print(\u0026#34;Task 2 started\u0026#34;) await asyncio.sleep(2) print(\u0026#34;Task 2 completed\u0026#34;) async def main(): await asyncio.gather(task1(), task2()) asyncio.run(main()) 1.4 I/O Bound vs CPU Bound I/O Bound: The program is waiting for input/output operations to complete. The program is not using the CPU much. CPU Bound: The program is using the CPU a lot. The program is not waiting for input/output operations to complete. import request response = request.get(\u0026#34;https://www.google.com\u0026#34;) # I/O Bound items = response.headers.items() # CPU Bound headers = [f\u0026#39;{key}: {header}\u0026#39; for key, header in items] # CPU Bound formatted_headers = \u0026#39;\\n\u0026#39;.join(headers) # CPU Bound with open(\u0026#39;headers.txt\u0026#39;, \u0026#39;w\u0026#39;) as file: # I/O Bound file.write(formatted_headers) # I/O Bound 2. How Concurrency is Achieved in Os level To better understand this, we’ll need to dive into how sockets work and, in particular, how non-blocking sockets work.\n2.1 Sockets A socket is a low-level abstraction for sending and receiving data over a network. It is the basis for how data is transferred to and from servers. Sockets support two main operations: sending bytes and receiving bytes. We write bytes to a socket, which will then get sent to a remote address, typically some type of server. Once we’ve sent those bytes, we wait for the server to write its response back to our socket. Once these bytes have been sent back to our socket, we can then read the result.\nIn the case of getting the contents from example.com as we saw earlier, we open a socket that connects to example.com’s server. We then write a request to get the contents to that socket and wait for the server to reply with the result: in this case, the HTML of the web page. We can visualize the flow of bytes to and from the server in figure 1.7\nSockets are blocking by default. Simply put, this means that when we are waiting for a server to reply with data, we halt our application or block it until we get data to read. Thus, our application stops running any other tasks until we get data from the server, an error happens, or there is a timeout. At the operating system level, we don’t need to do this blocking. Sockets can operate in non-blocking mode. In non-blocking mode, when we write bytes to a socket, we can just fire and forget the write or read, and our application can go on to perform other tasks. Later, we can have the operating system tell us that we received bytes and deal with it at that time. This lets the application do any number of things while we wait for bytes to come back to us. Instead of blocking and waiting for data to come to us, we become more reactive, letting the operating system inform us when there is data for us to act on. In the background, this is performed by a few different event notification systems, depending on which operating system we’re running. asyncio is abstracted enough that it switches between the different notification systems, depending on which one our operating system supports. The following are the event notification systems used by specific operating systems:\nkqueue—FreeBSD and MacOS epoll—Linux IOCP (I/O completion port)—Windows These systems keep track of our non-blocking sockets and notify us when they are ready for us to do something with them. This notification system is the basis of how asyncio can achieve concurrency.\nBut how do we keep track of multiple tasks that are waiting for data to come back to them? This is where the event loop comes in.\n2.2 Event Loop The event loop is the core of every asyncio application. In asyncio, the event loop keeps a queue of tasks.\n2.2.1 How the Event Loop Works The event loop works by keeping a queue of tasks instead of messages. Each task is a coroutine. When a task is added to the event loop, it will execute until it encounters an I/O operation (such as a web request). When a task hits an I/O-bound operation, it pauses and allows the event loop to run other tasks that are not waiting for I/O operations to complete. 2.2.2 Understanding Event Loops in Asynchronous Programming When working with event loops in asynchronous programming, the process can be understood as a sequence of steps that efficiently handle tasks without blocking the execution. Here\u0026rsquo;s a breakdown of how it works:\n2.2.2.1 Creating the Event Loop When an event loop is created, an empty queue of tasks is initialized. This queue will hold all the tasks that need to be executed.\n2.2.2.2 Adding Tasks to the Queue We add tasks to the event loop’s queue. These tasks are executed one at a time, based on their order in the queue.\n2.2.2.3 Processing Tasks Iteratively Each iteration of the event loop checks for tasks that need to be executed. It processes tasks sequentially, running them one by one.\n2.2.2.4 Handling I/O Operations If a task encounters an I/O operation (like reading from a file or making a network request), it cannot proceed immediately. In this case, the task is paused and put on hold.\n2.2.2.5 Pausing and Waiting for I/O Completion When a task is paused, the event loop instructs the operating system to monitor any associated sockets or resources for I/O completion. During this time, the event loop continues checking for and executing other tasks.\n2.2.2.6 Waking Up Paused Tasks On each iteration of the event loop, we check if any of the I/O operations have completed. If they have:\nThe paused task is woken up. The task resumes execution and completes its process. 2.2.2.7. Conclusion This cycle of pausing, waiting for I/O, and resuming tasks allows the event loop to run multiple tasks concurrently, making it an efficient way to handle asynchronous operations without blocking the program.\nBy continuously iterating and checking for completed I/O tasks, the event loop ensures that no task is left idle while waiting for I/O operations, enabling a smooth and efficient workflow.\nVisualizing the Event Loop with Asynchronous Tasks We can visualize how the event loop works with asynchronous tasks as shown in Figure 1.9: the main thread submits tasks to the event loop, which then runs them. When a task encounters an I/O operation, it pauses and allows other tasks to run. Once the I/O operation is complete, the paused task is resumed.\nExample: Submitting Multiple Asynchronous Tasks Let\u0026rsquo;s consider three tasks that each make an asynchronous web request. These tasks consist of:\nCPU-bound setup: Some code that prepares data for the web request. I/O-bound web request: The asynchronous part where we send the web request. CPU-bound post-processing: After the web request completes, we do some more CPU-intensive work. Now, let\u0026rsquo;s submit these tasks to the event loop simultaneously. Here’s how we can write this in pseudocode:\ndef make_request(): cpu_bound_setup() io_bound_web_request() cpu_bound_postprocess() task_one = make_request() task_two = make_request() task_three = make_request() First task starts executing code, and the other two are left waiting to run. Once the CPU-bound setup work is finished in Task 1, it hits an I/O-bound operation and will pause itself to say, “I’m waiting for I/O; any other tasks waiting to run can run.” Once this happens, Task 2 can begin executing. Task 2 starts its CPU-bound code and then pauses, waiting for I/O. At this time both Task 1 and Task 2 are waiting concurrently for their network request to complete. Since Tasks 1 and 2 are both paused waiting for I/O, we start running Task 3. Now imagine once Task 3 pauses to wait for its I/O to complete, the web request for Task 1 has finished. We’re now alerted by our operating system’s event notification system that this I/O has finished. We can now resume executing Task 1 while both Task 2 and Task 3 are waiting for their I/O to finish. In figure 1.10, we show the execution flow of the pseudocode we just described. If we look at any vertical slice of this diagram, we can see that only one CPU-bound piece of work is running at any given time; however, we have up to two I/O-bound operations happening concurrently. This overlapping of waiting for I/O per each task is where the real time savings of asyncio comes in.\n","permalink":"http://localhost:1313/posts/pages/asyncio/asyncio1/","summary":"An introduction to asynchronous programming in Python using asyncio.","title":"Async io : Async io Intro (Day 1)"},{"content":"34.Styling in CSS 34.1 Setting Inline Styles =\u0026gt; In react for inline styles we use the style attribute and pass an object with camelCase properties.\nimport React from \u0026#39;react\u0026#39;; const myStyle = { color: \u0026#39;blue\u0026#39;, backgroundColor: \u0026#39;yellow\u0026#39; } const MyComponent = () =\u0026gt; { return ( \u0026lt;div style={myStyle}\u0026gt; \u0026lt;h1\u0026gt;Inline Styles\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ) } or we can use the style attribute directly in the element.\nimport React from \u0026#39;react\u0026#39;; const MyComponent = () =\u0026gt; { return ( \u0026lt;div style={{color: \u0026#39;blue\u0026#39;, backgroundColor: \u0026#39;yellow\u0026#39;}}\u0026gt; \u0026lt;h1\u0026gt;Inline Styles\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ) } 34.2 Setting External Styles =\u0026gt; We can also use external CSS files in react. We can import the CSS file in the component file and use the class name in the\nimport React from \u0026#39;react\u0026#39;; import \u0026#39;./MyComponent.css\u0026#39;; const MyComponent = () =\u0026gt; { return ( \u0026lt;div className=\u0026#34;myStyle\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;External Styles\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ) } 34.3 Setting Inline Dynamic Styles =\u0026gt;You can also set the inline styles dynamically by using the state.\nimport React,{useState} from \u0026#39;react\u0026#39;; const App=()=\u0026gt;{ const [valid,setValid]=useState(true); function changeStyle(){ setValid(!valid); } const myStyle={ color:valid?\u0026#39;blue\u0026#39;:\u0026#39;red\u0026#39;, backgroundColor:valid?\u0026#39;yellow\u0026#39;:\u0026#39;green\u0026#39; } return( \u0026lt;div\u0026gt; \u0026lt;button onClick={changeStyle}\u0026gt;Change Style\u0026lt;/button\u0026gt; \u0026lt;div style={myStyle}\u0026gt; \u0026lt;h1\u0026gt;Inline Dynamic Styles\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) } export default App; or we can use the style attribute directly in the element.\nimport React,{useState} from \u0026#39;react\u0026#39;; const App=()=\u0026gt;{ const [valid,setValid]=useState(true); function changeStyle(){ setValid(!valid); } return( \u0026lt;div\u0026gt; \u0026lt;button onClick={changeStyle}\u0026gt;Change Style\u0026lt;/button\u0026gt; \u0026lt;div style={{color:valid?\u0026#39;blue\u0026#39;:\u0026#39;red\u0026#39;,backgroundColor:valid?\u0026#39;yellow\u0026#39;:\u0026#39;green\u0026#39;}}\u0026gt; \u0026lt;h1\u0026gt;Inline Dynamic Styles\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) } export default App; 34.4 Setting Css Classes Dynamically =\u0026gt; We can also set the CSS classes dynamically by using the state.\nimport React,{useState} from \u0026#39;react\u0026#39;; import \u0026#39;./MyComponent.css\u0026#39;; const App=()=\u0026gt;{ const [valid,setValid]=useState(true); const [active,setActive]=useState(true); function changeStyle(){ setValid(!valid); setActive(!active); } return( \u0026lt;div\u0026gt; \u0026lt;button onClick={changeStyle}\u0026gt;Change Style\u0026lt;/button\u0026gt; \u0026lt;div className={`div-control ${valid?\u0026#39;right\u0026#39;:\u0026#39;wrong\u0026#39;} ${active?\u0026#39;active\u0026#39;:\u0026#39;inactive\u0026#39;}`}\u0026gt; \u0026lt;h1\u0026gt;Setting Css Classes Dynamically\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) } export default App; 34.5 Css modules =\u0026gt; Every time we import Css file in react component they are regarded as global styles i.e One component style can affect another component style =\u0026gt;So, to avoid this we can use CSS modules. CSS modules are local by default. We can use CSS modules by naming the CSS file as filename.module.css. =\u0026gt; The CSS file is imported in the component file and the class name is used as an object.\nProblem1 =\u0026gt; Imagine that you have two components with the same class name. The styles of one component can affect the styles of another component.which is not good for the application to solve this problem we can use CSS modules.\nStructure of the project\nsrc\r|_components\r|_MyComponent\r|_MyComponent.js\r|_MyComponent.module.css Step 1: Create a CSS file with the name MyComponent.module.css\n.myStyle{ color: blue; background-color: yellow; } .right{ text-align: right; } Step 2: Import the CSS file in the component file as shown below.\nimport React from \u0026#39;react\u0026#39;; import styles from \u0026#39;./MyComponent.module.css\u0026#39;; step 3: Use the class name as shown below.\nconst MyComponent = () =\u0026gt; { return ( \u0026lt;div className={styles.myStyle}\u0026gt; \u0026lt;h1\u0026gt;CSS Modules\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ) } Combined code\nimport React from \u0026#39;react\u0026#39;; import styles from \u0026#39;./MyComponent.module.css\u0026#39;; const MyComponent = () =\u0026gt; { return ( \u0026lt;div className={styles.myStyle}\u0026gt; \u0026lt;h1\u0026gt;CSS Modules\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ) } export default MyComponent; 34.5.1 Combining multiple classes import React from \u0026#39;react\u0026#39;; import styles from \u0026#39;./MyComponent.module.css\u0026#39;; const MyComponent = () =\u0026gt; { return ( \u0026lt;div className={`${styles.myStyle} ${styles.right}`}\u0026gt; \u0026lt;h1\u0026gt;CSS Modules\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ) } export default MyComponent; 34.6 Dynamic CSS Modules =\u0026gt; We can also set the CSS classes dynamically by using the state.\nimport React,{useState} from \u0026#39;react\u0026#39;; import styles from \u0026#39;./MyComponent.module.css\u0026#39;; const MyComponent = () =\u0026gt; { const [valid,setValid]=useState(true); const [active,setActive]=useState(true); function changeStyle(){ setValid(!valid); setActive(!active); } return ( \u0026lt;div className={`${styles.myStyle} ${valid?styles.right:styles.wrong} ${active?styles.active:styles.inactive}`}\u0026gt; \u0026lt;h1\u0026gt;CSS Modules\u0026lt;/h1\u0026gt; \u0026lt;button onClick={changeStyle}\u0026gt;Change Style\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } export default MyComponent; ","permalink":"http://localhost:1313/posts/pages/react/react5/","summary":"Learn various methods to style React components including inline styles, external styles, dynamic styles, and CSS modules.","title":"React : Day 5"},{"content":"35. Debugging in react 35.1 Using console.log import React from \u0026#39;react\u0026#39;; const MyComponent = () =\u0026gt; { const name = \u0026#39;John Doe\u0026#39;; console.log(name); return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Debugging in React\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ) } export default MyComponent; 35.2 Strict Mode =\u0026gt; In Strict Mode,React will render components twice. It helps to idenify the issues in the code.\nimport React,{StrictMode} from \u0026#39;react\u0026#39;; const MyComponent = () =\u0026gt; { const name = \u0026#39;John Doe\u0026#39;; console.log(name); return ( \u0026lt;StrictMode\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Debugging in React\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/StrictMode\u0026gt; ) } export default MyComponent; You can wrap any component in StrictMode.Just difference is that it will render the component twice.\n=\u0026gt; We can wrap the entire application in StrictMode in the index.js file.\nimport React,{StrictMode} from \u0026#39;react\u0026#39;; import ReactDOM from \u0026#39;react-dom\u0026#39;; import App from \u0026#39;./App\u0026#39;; ReactDOM.render( \u0026lt;StrictMode\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/StrictMode\u0026gt;, document.getElementById(\u0026#39;root\u0026#39;) ); 35.3 React Developer Tools React Developer Tools is a Chrome extension that allows you to inspect the React component hierarchy in the Chrome Developer Tools. Videos\n","permalink":"http://localhost:1313/posts/pages/react/react6/","summary":"Learn how to debug React applications using console.log, Strict Mode, and React Developer Tools.","title":"React : Day 6"},{"content":"Python Fundamentals: A Beginner\u0026rsquo;s Guide (Part 1) 1. Virtual Environment A virtual environment is a feature in Python that allows you to install the same package with different versions on the same system. This enables you to work on multiple projects using different versions of the same package.\n1.1. Installing venv The venv module is included in the Python standard library, so you don\u0026rsquo;t need to install it separately. However, if you are using an older version of Python (before 3.3), you can install virtualenv using pip:\npip install virtualenv 1.2. Creating a Virtual Environment To create a virtual environment, you can use the venv module, which is included in the Python standard library. Here\u0026rsquo;s how you can create a virtual environment named myenv:\npython -m venv myenv This command creates a new directory named myenv that contains the necessary files for the virtual environment.\n1.3. Activating a Virtual Environment To activate the virtual environment, you may run the following command:\n# For Linux/Mac: source myenv/bin/activate # For Windows: myenv\\Scripts\\activate 2. Python Packages 2.1. List All the Python Packages To list or save all the installed packages in the current environment, you can use the following command using freeze:\npip freeze # To list all the installed packages pip freeze \u0026gt; requirements.txt # To save all the installed packages in a file 2.2. Installing Python Packages To install a Python package, you can use the pip install command followed by the package name. For example, to install the requests package, you can run:\npip install requests 2.3. Uninstalling Python Packages To uninstall a Python package, you can use the pip uninstall command followed by the package name. For example, to uninstall the requests package, you can run:\npip uninstall requests 2.4. Run Python Package/Script To run a python package or script, you can use the following command:\npython -m package_name 3. Python Basics 3.1. Running a Python Script To run a Python script, you can use the following command:\npython script.py 3.2. Python Indentation In Python, the code block (body of the function, loop, etc.) starts with a colon (:) and the line following the colon should be indented.\nif 5 \u0026gt; 2: print(\u0026#34;Five is greater than two!\u0026#34;) # Indented block 3.3. Python Comments There are two types of comments in Python:\n# This is a single line comment \u0026#34;\u0026#34;\u0026#34; This is a multiline comment This is a multiline comment This is a multiline comment This is a multiline comment \u0026#34;\u0026#34;\u0026#34; 3.4. Print Statement The print() function is used to display the output on the console. For example:\nprint(\u0026#34;Hello, World!\u0026#34;) 3.5. Data Types Python has the following data types:\nint float str bool list tuple set dict None a = 10 # int b = 10.5 # float c = \u0026#34;Hello\u0026#34; # str d = True # bool e = [1,2,3] # list f = (1,2,3) # tuple g = {1,2,3} # set h = {\u0026#34;name\u0026#34;:\u0026#34;John\u0026#34;,\u0026#34;age\u0026#34;:30} # dict i = None # None print(type(a)) # \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; Note:Use type() function to check the data type of a variable.As it return the class of the variable.\n3.6. Rules of Variable Declaration A variable name must start with a letter or the underscore character. A variable name cannot start with a number. A variable name can only contain alpha-numeric characters and underscores (A-z, 0-9, and _ ). Variable names are case-sensitive (age, Age, and AGE are three different variables). 3.7. Type Conversion You can convert one data type to another using the following functions:\nint(): To convert to an integer float(): To convert to a float str(): To convert to a string bool(): To convert to a boolean list(): To convert to a list tuple(): To convert to a tuple set(): To convert to a set dict(): To convert to a dictionary a = 10 #a=10 b = float(a) #b=10.0 c = str(a) #c=\u0026#39;10\u0026#39; d = bool(a) #d=True e = list(c) #e=[\u0026#39;1\u0026#39;,\u0026#39;0\u0026#39;] f = tuple(c) #f=(\u0026#39;1\u0026#39;,\u0026#39;0\u0026#39;) g = set(c) #g={\u0026#39;1\u0026#39;,\u0026#39;0\u0026#39;} h = dict(name=\u0026#34;John\u0026#34;,age=30) or dict([(\u0026#34;name\u0026#34;,\u0026#34;John\u0026#34;),(\u0026#34;age\u0026#34;,30)]) #h={\u0026#39;name\u0026#39;:\u0026#39;John\u0026#39;,\u0026#39;age\u0026#39;:30} Note: Python is dynamically typed, which means a variable\u0026rsquo;s data type can be changed.\n4. Operators 4.1. Arithmetic Operators +: Addition -: Subtraction *: Multiplication /: Division %: Modulus **: Power //: Floor Division a = 10 b = 3 print(a + b) # 13 print(a - b) # 7 print(a * b) # 30 print(a / b) # 3.3333333333333335 print(a % b) # 1 print(a ** b) # 1000 print(a // b) # 3 4.2. Assignment Operators =: Assign value +=: Add and assign -=: Subtract and assign *=: Multiply and assign /=: Divide and assign %=: Modulus and assign **=: Power and assign //=: Floor Division and assign a = 10 a += 5 # a = a + 5 a -= 5 # a = a - 5 a *= 5 # a = a * 5 a /= 5 # a = a / 5 a %= 5 # a = a % 5 a **= 5 # a = a ** 5 a //= 5 # a = a // 5 4.3. Comparison Operators ==: Equal to !=: Not equal to \u0026gt;: Greater than \u0026lt;: Less than \u0026gt;=: Greater than or equal to \u0026lt;=: Less than or equal to a = 10 b = 20 print(a == b) # False print(a != b) # True print(a \u0026gt; b) # False print(a \u0026lt; b) # True print(a \u0026gt;= b) # False print(a \u0026lt;= b) # True 4.4. Logical Operators and: Returns True if both statements are true or: Returns True if one of the statements is true not: Reverse the result, returns False if the result is true a = 10 b = 20 c = 30 print(a \u0026lt; b and b \u0026lt; c) # True print(a \u0026lt; b or b \u0026gt; c) # True print(not(a \u0026lt; b and b \u0026lt; c)) # False 4.5. Identity Operators is: Returns True if both variables are the same object is not: Returns True if both variables are not the same object a = [1,2,3] b = [1,2,3] print(a is b) # False print(a is not b) # True 4.6. Membership Operators in: Returns True if a sequence with the specified value is present in the object not in: Returns True if a sequence with the specified value is not present in the object a = [1,2,3] #Can be used in list , tuple , set , dict, string print(1 in a) # True print(4 not in a) # True 4.7. Bitwise Operators \u0026amp;: AND |: OR ^: XOR ~: NOT \u0026lt;\u0026lt;: Left Shift \u0026gt;\u0026gt;: Right Shift a = 10 b = 4 print(a \u0026amp; b) # 0 print(a | b) # 14 print(a ^ b) # 14 print(~a) # -11 print(a \u0026lt;\u0026lt; 2) # 40 print(a \u0026gt;\u0026gt; 2) # 2 Note: is vs ==\nis is used to compare the memory location of two objects. == is used to compare the values of two objects. # For Mutable objects (list, dict, set): a = [1,2,3] b = [1,2,3] print(a == b) # True print(a is b) # False # For immutable objects (int, float, string, tuple, None): a = 10 b = 10 print(a == b) # True print(a is b) # True c = None d = None print(c == d) # True print(c is d) # True 5.Taking User Input In Python, you can take user input using the input() function. Here\u0026rsquo;s an example:\nname = input(\u0026#34;Enter your name: \u0026#34;) print(\u0026#34;Hello, \u0026#34; + name) Note: The input() function always returns a string. If you want to convert it to another data type, you can use type conversion functions like int(), float(), etc.\n","permalink":"http://localhost:1313/posts/pages/python/python_basics/","summary":"A comprehensive guide to Python programming fundamentals covering core concepts for beginners","title":"Python Fundamentals: A Beginner's Guide (Part 1)"},{"content":"30. Sharing State Between React Components: Lifting State Up In React, components are the building blocks of a user interface. Each component can have its own state, but there are situations where multiple components need to share the same state. In such cases, the concept of \u0026ldquo;lifting state up\u0026rdquo; is used to manage the shared state in a common ancestor component.\u0026ldquo;Lifting state up\u0026rdquo; is a common pattern in React used when two or more components need to share data or state. Instead of managing the state in one of the components and creating a dependency between them, the state is \u0026ldquo;lifted up\u0026rdquo; to the closest common ancestor of the components that need the state.\nKey Concept When multiple components need to interact with the same state:\nThe closest common ancestor is identified. The state is moved to this common ancestor. This ancestor manages the state and passes it down to the child components as props. If any child needs to modify the state, the ancestor provides a function (passed as a prop) to handle the state update. Step-by-Step Procedure and Syntax Identify the Closest Common Ancestor:\nDetermine which component is the nearest common parent of all components that need to share the state. Lift the State Up:\nMove the state to the identified ancestor component. Use the useState hook (or class component state) to manage the state. const [state, setState] = useState(initialValue); Pass State Down as Props:\nPass the state to child components that need it via props. \u0026lt;ChildComponent state={state} /\u0026gt; Create State-Modifier Functions:\nDefine functions in the ancestor component to modify the state. const modifyStateHandler = (newData) =\u0026gt; { setState((prev) =\u0026gt; ({ ...prev, newData })); }; Pass Modifier Functions to Children:\nPass these functions to the child components as props so they can trigger state updates. \u0026lt;ChildComponent onModifyState={modifyStateHandler} /\u0026gt; Use Props in Child Components:\nAccess and use the state and modifier functions passed as props in the child components. function ChildComponent({ state, onModifyState }) { return ( \u0026lt;button onClick={() =\u0026gt; onModifyState(\u0026#34;new data\u0026#34;)}\u0026gt;Modify State\u0026lt;/button\u0026gt; ); } Example (Sharing State/Data Between Two Child Component) Parent Component (App.js) The parent component will hold the shared state and provide functions for updating it. It will pass the state and update functions as props to the child components.\nimport React, { useState } from \u0026#34;react\u0026#34;; import ChildOne from \u0026#34;./ChildOne\u0026#34;; import ChildTwo from \u0026#34;./ChildTwo\u0026#34;; const App = () =\u0026gt; { // Shared state const [sharedState, setSharedState] = useState(\u0026#34;Initial State\u0026#34;); // Function to update the state const updateState = (newState) =\u0026gt; { setSharedState(newState); }; return ( \u0026lt;div style={{ padding: \u0026#34;20px\u0026#34;, fontFamily: \u0026#34;Arial\u0026#34; }}\u0026gt; \u0026lt;h1\u0026gt;Parent Component\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;Shared State: {sharedState}\u0026lt;/p\u0026gt; \u0026lt;hr /\u0026gt; \u0026lt;ChildOne sharedState={sharedState} updateState={updateState} /\u0026gt; \u0026lt;hr /\u0026gt; \u0026lt;ChildTwo sharedState={sharedState} updateState={updateState} /\u0026gt; \u0026lt;/div\u0026gt; ); }; export default App; Child Component 1 (ChildOne.js) This component will display the shared state and allow the user to modify it through an input field.\nimport React from \u0026#34;react\u0026#34;; const ChildOne = ({ sharedState, updateState }) =\u0026gt; { const handleChange = (e) =\u0026gt; { updateState(e.target.value); }; return ( \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;Child Component One\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;Shared State: {sharedState}\u0026lt;/p\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; value={sharedState} onChange={handleChange} placeholder=\u0026#34;Update State\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; ); }; export default ChildOne; Child Component 2 (ChildTwo.js) This component will display the shared state and provide a button to reset it.\nimport React from \u0026#34;react\u0026#34;; import React from \u0026#34;react\u0026#34;; const ChildTwo = ({ sharedState, updateState }) =\u0026gt; { const handleReset = () =\u0026gt; { updateState(\u0026#34;Initial State\u0026#34;); }; return ( \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;Child Component Two\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;Shared State: {sharedState}\u0026lt;/p\u0026gt; \u0026lt;button onClick={handleReset}\u0026gt;Reset State\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); }; export default ChildTwo; Folder Structure src/ ├── App.js ├── ChildOne.js ├── ChildTwo.js ├── index.js Explanation:\nThe App component is the parent component that holds the shared state and passes it down to ChildOne and ChildTwo. ChildOne and ChildTwo are child components that receive the shared state and update functions as props. ChildOne allows the user to update the shared state through an input field, while ChildTwo provides a button to reset the state. Note: We cant directly pass data from one child component to another child component. We need to pass the data to the parent component and then pass it to the other child component. This is called lifting state up.\nExample (Sharing State/Data Between Two Sibling Components) Parent Component (App.js) import {usState} from \u0026#39;react\u0026#39;; import Expenses from \u0026#39;./Expenses\u0026#39;; import NewExpense from \u0026#39;./NewExpense\u0026#39;; const App=()=\u0026gt;{ const [expenses,setExpenses]=useState([ {id:1,title:\u0026#39;Car Insurance\u0026#39;,amount:294.67,date:new Date(2021,2,28)}, {id:2,title:\u0026#39;Health Insurance\u0026#39;,amount:394.67,date:new Date(2021,3,28)}, {id:3,title:\u0026#39;Home Insurance\u0026#39;,amount:494.67,date:new Date(2021,4,28)}, ]); const addExpenseHandler=(expense)=\u0026gt;{ setExpenses((prevExpenses)=\u0026gt;{ return [expense,...prevExpenses]; }); }; return ( \u0026lt;div\u0026gt; \u0026lt;NewExpense onAddExpense={addExpenseHandler}/\u0026gt; \u0026lt;Expenses items={expenses}/\u0026gt; \u0026lt;/div\u0026gt; ); }; export default App; NewExpense Component import ExpenseForm from \u0026#39;./ExpenseForm\u0026#39;; const NewExpense=(props)=\u0026gt;{ const saveExpenseDataHandler=(enteredExpenseData)=\u0026gt;{ const expenseData={ ...enteredExpenseData, id:Math.random().toString() }; props.onAddExpense(expenseData); }; return ( \u0026lt;div\u0026gt; \u0026lt;ExpenseForm onSaveExpenseData={saveExpenseDataHandler}/\u0026gt; \u0026lt;/div\u0026gt; ); }; export default NewExpense; Expenses function Expenses({iteam}){ return ( \u0026lt;\u0026gt; {items.map((expense)=\u0026gt;( \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;{expense.title}\u0026lt;/h2\u0026gt; \u0026lt;div\u0026gt;{expense.amount}\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;{expense.date.toISOString()}\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ))} \u0026lt;/div\u0026gt; ) } 31. Dynamically setting object keys In JavaScript, object keys are usually set statically, but there are situations where you may need to set object keys dynamically based on some conditions or variables. This can be achieved using the square bracket notation ([]) to set object keys dynamically.\nfor example:\nconst data=\u0026#34;name\u0026#34;; const person={ [data]:\u0026#39;John\u0026#39; }; console.log(person); // {name:\u0026#39;John\u0026#39;} If we dont use square bracket notation, then the key will be set as \u0026lsquo;data\u0026rsquo; instead of \u0026rsquo;name\u0026rsquo;.\nconst data=\u0026#34;name\u0026#34;; const person={ data:\u0026#39;John\u0026#39; }; console.log(person); // {data:\u0026#39;John\u0026#39;} 32.Using SAme State Variable to store multiple values =\u0026gt; We can use the same state variable to store multiple values by using an object.\nconst [userInput,setUserInput]=useState({ enteredTitle:\u0026#39;\u0026#39;, enteredAmount:\u0026#39;\u0026#39;, enteredDate:\u0026#39;\u0026#39; }); const titleChangeHandler=(event)=\u0026gt;{ setUserInput({ ...userInput, enteredTitle:event.target.value }); }; const amountChangeHandler=(event)=\u0026gt;{ setUserInput({ ...userInput, enteredAmount:event.target.value }); }; const dateChangeHandler=(event)=\u0026gt;{ setUserInput({ ...userInput, enteredDate:event.target.value }); }; return ( \u0026lt;div\u0026gt; Title:\u0026lt;input type=\u0026#34;text\u0026#34; value={userInput.enteredTitle} onChange={titleChangeHandler}/\u0026gt; Amount:\u0026lt;input type=\u0026#34;number\u0026#34; value={userInput.enteredAmount} onChange={amountChangeHandler}/\u0026gt; Date:\u0026lt;input type=\u0026#34;date\u0026#34; value={userInput.enteredDate} onChange={dateChangeHandler}/\u0026gt; The entered title is {userInput.enteredTitle} The entered amount is {userInput.enteredAmount} The entered date is {userInput.enteredDate} \u0026lt;/div\u0026gt; ); =\u0026gt; In the above code, we are using the same state variable userInput to store multiple values. We are using an object to store the values. We are using the spread operator to copy the existing values of the object and then updating the required value.\n33.Handeling page reloads when a form is submitted When a form is submitted, the page reloads by default. This is not what we want in a single page application. We want to stay on the same page and update the content of the page. We can do this by using the preventDefault() method on the event object. The preventDefault() method prevents the default behavior of the event object. In this case, it prevents the page from reloading when the form is submitted. const submitHandler=(event)=\u0026gt;{ event.preventDefault(); // code to handle form submission }; ","permalink":"http://localhost:1313/posts/pages/react/react4/","summary":"Learn how to share state between React components by lifting state up to a common ancestor.","title":"React : Day 4"},{"content":"1. Python Manupulation of Data Types We have already discussed the basic concepts of Python programming in the previous part of this series. In this part, we will dive deeper into operations and manipulations of different data types in Python.\n1.1.Numeric Operations 1.1.1. abs() Function The abs() function returns the absolute value of a number. For example:\nnum = -10 print(abs(num)) # Output: 10 1.1.2. round() Function The round() function rounds a number to the nearest integer. For example:\nnum = 3.14159 print(round(num)) # Output: 3 1.1.3. ord() Function The ord() function returns the Unicode code point of a character. For example:\nchar = \u0026#39;A\u0026#39; print(ord(char)) # Output: 65 1.2. String Operations String is a sequence of characters enclosed within single, double, or triple quotes. In Python, strings are immutable, meaning they cannot be changed once created. Here are some common string operations:\n1.2.1. Declaring a String we can declare a string using single, double, or triple quotes. For example:\nstr1 = \u0026#39;Hello, World!\u0026#39; #for single line string str2 = \u0026#34;Hello, World!\u0026#34; #for single line string str3 = \u0026#39;\u0026#39;\u0026#39;Hello, World! This is a multiline string.\u0026#39;\u0026#39;\u0026#39;#for multiline string 1.2.2. Text Decorators There are many text decorators available in Python to format strings among them we use \\n for a new line, \\t for a tab. For example:\nstr1 = \u0026#39;Hello, \\nWorld!\u0026#39; #for new line str2 = \u0026#34;Hello, \\tWorld!\u0026#34; #for tab 1.2.3. String Indexing The indexing of a string starts from 0 to n-1, where n is the length of the string. For example: for example: a=\u0026ldquo;hello\u0026rdquo;\na = H e l l o 0 1 2 3 4 0 -4 -3 -2 -1 1.2.4. Ascessing Characters in a String We can access characters in a string using the index using []. For example:\nstr = \u0026#34;Hello, World!\u0026#34; print(str[0]) # Output: H print(str[-1]) # Output: ! 1.2.5. String Concatenation We can concatenate two strings using the + operator and * operator . For example:\nstr1 = \u0026#34;Hello\u0026#34; str2 = \u0026#34;World\u0026#34; print(str1 + str2) # Output: HelloWorld print(str1 * 3) # Output: HelloHelloHello 1.2.6. String Slicing We can slice a string using the syntax variable[start:end:step] to get a substring.\nNote: The substring contains characters from index start to end-1, meaning the character at the end index is not included but character at the start index is included . The step refers to the increment or jump of the index\nFor example:\na = \u0026#34;hello\u0026#34; # Slice from index 1 to the end of the string print(a[1:]) # ello (Characters from index 1 to the end) # Slice from the beginning of the string to index 4 (doesn\u0026#39;t contain character at index 4) print(a[:4]) # hell (Characters from index 0 to 3) # Slice from index 1 to index 4 (doesn\u0026#39;t contain character at index 4) print(a[1:4]) # ell (Characters from index 1 to 3) # Full slice of the string with default values print(a[::]) # hello (Default start is 0, end is the string length, step is 1) # Defining a step value in slicing # Slice with a step of 2 print(a[::2]) # hlo (Start from index 0 to the end, select every 2nd character) # Reverse the string using a negative step print(a[::-1]) # olleh (Reverse the string by stepping backward) # Combining start, end, and step print(a[1:4:2]) # el #(Start from index 1 to 4 (doesn\u0026#39;t contain character at index 4), with a step of 2) 1.2.7. String Methods Python provides various built-in methods to manipulate strings. Some of the commonly used string methods are:\nlen() : Returns the length of the string. str = \u0026#34;Hello, World!\u0026#34; print(len(str)) # Output: 13 replace() : Replaces a substring with another substring. str = \u0026#34;Hello, World!\u0026#34; print(str.replace(\u0026#34;World\u0026#34;, \u0026#34;Universe\u0026#34;)) # Output: Hello, Universe! upper() : Converts the string to uppercase. str = \u0026#34;Hello, World!\u0026#34; print(str.upper()) # Output: HELLO, WORLD! lower() : Converts the string to lowercase. str = \u0026#34;Hello, World!\u0026#34; print(str.lower()) # Output: hello, world! split() : Splits the string into a list based on the delimiter. str = \u0026#34;Hello, World!\u0026#34; print(str.split(\u0026#34;,\u0026#34;)) # Output: [\u0026#39;Hello\u0026#39;, \u0026#39; World!\u0026#39;] capitalize() : Converts the first character of the string to uppercase.\nstr = \u0026#34;hello, world!\u0026#34; print(str.capitalize()) # Output: Hello, world! -find() : Returns the index of the first occurrence of a substring.\nstr = \u0026#34;Hello, World!\u0026#34; print(str.find(\u0026#34;World\u0026#34;)) # Output: 7 print(str.find(\u0026#34;e\u0026#34;)) # Output: 1 print(str.find(\u0026#34;Universe\u0026#34;)) # Output: -1 count() : Returns the number of occurrences of a substring. str = \u0026#34;Hello, World!\u0026#34; print(str.count(\u0026#34;l\u0026#34;)) # Output: 3 startswith() : Returns True if the string starts with a specified substring. str = \u0026#34;Hello, World!\u0026#34; print(str.startswith(\u0026#34;Hello\u0026#34;)) # Output: True endswith() : Returns True if the string ends with a specified substring. str = \u0026#34;Hello, World!\u0026#34; print(str.endswith(\u0026#34;World!\u0026#34;)) # Output: True strip() : Removes leading and trailing whitespaces from the string. We can also specify the characters to be removed. str = \u0026#34; Hello, World! \u0026#34; print(str.strip()) # Output: Hello, World! str = \u0026#34;!!!!!!!!Hello, World!!!!!\u0026#34; print(str.strip(\u0026#34;!\u0026#34;)) # Output: Hello, World! lstrip() : Removes leading whitespaces from the string.we can also specify the characters to be removed. str = \u0026#34; Hello, World! \u0026#34; print(str.lstrip()) # Output: Hello, World! str = \u0026#34;!!!!!!!!Hello, World!!!!!\u0026#34; print(str.lstrip(\u0026#34;!\u0026#34;)) # Output: Hello, World!!!!! rstrip() : Removes trailing whitespaces from the string.We can also specify the characters to be removed. str = \u0026#34; Hello, World! \u0026#34; print(str.rstrip()) # Output: Hello, World! str = \u0026#34;!!!!!!!!Hello, World!!!!!\u0026#34; print(str.rstrip(\u0026#34;!\u0026#34;)) # Output: !!!!!!!!Hello, World 1.2.8. f-Strings f-strings are a convenient way to format strings in Python. They allow you to embed expressions inside string literals, using curly braces {}. For example:\nname = \u0026#34;Alice\u0026#34; age = 30 print(f\u0026#34;My name is {name} and I am {age} years old.\u0026#34;) # Output: My name is Alice and I am 30 years old. 1.2.9. Raw Strings Raw strings are used to ignore escape characters in a string. They are prefixed with an r or R. For example:\npath=\u0026#34;C:\\Users\\Alice\\Documents\u0026#34; print(path) # Output: C:UsersAliceDocuments path = r\u0026#34;C:\\Users\\Alice\\Documents\u0026#34; print(path) # Output: C:\\Users\\Alice\\Documents Note:String is immutable in python.\na = \u0026#34;Hello\u0026#34; a[0] = \u0026#34;h\u0026#34; # Error: \u0026#39;str\u0026#39; object does not support item assignment #Instead To change the string value we can use the following method a=\u0026#39;k\u0026#39;+a[1::] # Output: \u0026#39;kello\u0026#39; 1.3. List Operations A list is a collection of items enclosed within square brackets []. Lists are mutable, meaning they can be changed after creation. Here are some common list operations: Key Points:\nList is mutable in python. List support indexing and slicing like string 1.3.1. Declaring a List We can declare a list by enclosing items within square brackets []. For example:\nlist1 = [1, 2, 3, 4, 5] list2 = [\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;] list3 = [1, \u0026#34;apple\u0026#34;, True, 3.14] 1.3.2 List Concatenation We can concatenate two or more lists using the + operator. For example:\nlist1 = [1, 2, 3] list2 = [4, 5, 6] print(list1 + list2) # Output: [1, 2, 3, 4, 5, 6] 1.3.3. Mutable property of List List is mutable in python and its example is shown below:\n#for string a = \u0026#34;Hello\u0026#34; a[0] = \u0026#34;h\u0026#34; # Error: \u0026#39;str\u0026#39; object does not support item assignment #for list list1 = [1, 2, 3] list1[0] = 10 print(list1) # Output: [10, 2, 3] 1.3.4. Built-in List Methods Python provides various built-in methods to manipulate lists. Some of the commonly used list methods are:\nlen() : Returns the length of the list. list1 = [1, 2, 3, 4, 5] print(len(list1)) # Output: 5 append() : Adds an element to the end of the list /Change orginal list does not return anything. list1 = [1, 2, 3] list1.append(4) print(list1) # Output: [1, 2, 3, 4] insert() : Inserts an element at a specified position in the list /Change orginal list does not return anything. list1 = [1, 2, 3] list1.insert(1, 4) print(list1) # Output: [1, 4, 2, 3] pop() : Removes the element at the specified position in the list and returns it. If no index is specified, it removes and returns the last element. list1 = [1, 2, 3] print(list1.pop(1)) # Output: 2 print(list1) # Output: [1, 3] print(list1.pop()) # Output: 3 print(list1) # Output: [1] remove() : Removes the first occurrence of the specified element from the list. list1 = [1, 2, 3, 2] list1.remove(2) print(list1) # Output: [1, 3, 2] -sort() : Sorts the list in ascending order.Does not return anything but change the original list.\nlist1 = [3, 1, 2] list1.sort() print(list1) # Output: [1, 2, 3] -reverse() : Reverses the order of the list. Does not return anything but change the original list.\nlist1 = [1, 2, 3] list1.reverse() print(list1) # Output: [3, 2, 1] -count() : Returns the number of occurrences of a specified element in the list.\nlist1 = [1, 2, 3, 2] print(list1.count(2)) # Output: 2 -index() : Returns the index of the first occurrence of the specified element in the list.\nlist1 = [1, 2, 3, 2] print(list1.index(2)) # Output: 1 1.3.5. List Comprehension List comprehension is a concise way to create lists from existing lists. There are 3 type of syntax.\nNot using if list1=[variable for variable in iterable] Using if only list1 = [variable for variable in iterable if condition] Using if else list1 = [variable if condition else variable for variable in iterable] Traditional way of creating list\nlist1 = [] for i in range(5): list1.append(i) print(list1) # Output: [0, 1, 2, 3, 4] Using list comprehension\nlist1 = [i for i in range(5)] print(list1) # Output: [0, 1, 2, 3, 4] list1 = [i for i in range(5) if i%2==0] print(list1) # Output: [0, 2, 4] list1 = [i if i%2==0 else i**2 for i in range(5)] print(list1) # Output: [0, 1, 2, 9, 4] Note: When you attempt to access an index that is out of range, Python will raise an IndexError so put it in try-except block to handle the error.\nNote: The indexing and slicing of list are similar to string.\n1.4 Dictionary Operations A dictionary is a collection of key-value pairs enclosed within curly braces {}. Dictionaries are mutable and unordered. Here are some common dictionary operations:\n1.4.1. Declaring a Dictionary We can declare a dictionary by specifying key-value pairs within curly braces {}. For example:\ndict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} dict2 = {1: \u0026#34;apple\u0026#34;, 2: \u0026#34;banana\u0026#34;, 3: \u0026#34;cherry\u0026#34;} dict3 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;, \u0026#34;hobbies\u0026#34;: [\u0026#34;reading\u0026#34;, \u0026#34;painting\u0026#34;]} 1.4.2. Accessing Dictionary Elements We can access dictionary elements using keys. For example:\ndict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} print(dict1[\u0026#34;name\u0026#34;]) # Output: Alice 1.4.3 Adding Dictionary Elements We can add new key-value pairs to a dictionary by specifying the key and value. For example:\ndict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30} dict1[\u0026#34;city\u0026#34;] = \u0026#34;New York\u0026#34; print(dict1) # Output: {\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 30, \u0026#39;city\u0026#39;: \u0026#39;New York\u0026#39;} 1.4.4. Updating Dictionary Elements We can update the value of an existing key in a dictionary. For example:\ndict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} dict1[\u0026#34;age\u0026#34;] = 35 print(dict1) # Output: {\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 35, \u0026#39;city\u0026#39;: \u0026#39;New York\u0026#39;} 1.4.5 Dictionary Methods Python provides various built-in methods to manipulate dictionaries. Some of the commonly used dictionary methods are:\nlen() : Returns the number of key-value pairs in the dictionary. dict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} print(len(dict1)) # Output: 3 keys() : Returns a list of all the keys in the dictionary. dict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} print(dict1.keys()) # Output: dict_keys([\u0026#39;name\u0026#39;, \u0026#39;age\u0026#39;, \u0026#39;city\u0026#39;]) values() : Returns a list of all the values in the dictionary. dict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} print(dict1.values()) # Output: dict_values([\u0026#39;Alice\u0026#39;, 30, \u0026#39;New York\u0026#39;]) items() : Returns a list of key-value pairs in the dictionary. dict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} print(dict1.items()) # Output: dict_items([(\u0026#39;name\u0026#39;, \u0026#39;Alice\u0026#39;), (\u0026#39;age\u0026#39;, 30), (\u0026#39;city\u0026#39;, \u0026#39;New York\u0026#39;)]) -pop() : Removes the element with the specified key and returns its value.\ndict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} print(dict1.pop(\u0026#34;age\u0026#34;)) # Output: 30 print(dict1) # Output: {\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;city\u0026#39;: \u0026#39;New York\u0026#39;} -get() : Returns the value of the specified key. If the key does not exist, it returns the specified default value.\ndict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} print(dict1.get(\u0026#34;age\u0026#34;)) # Output: 30 print(dict) # Output: {\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 30, \u0026#39;city\u0026#39;: \u0026#39;New York\u0026#39;} Note: When you attempt to access a key that does not exist in the dictionary, Python will raise a KeyError so put it in try-except block to handle the error or use get() method to avoid the error.\n1.4.6. Nested Dictionaries A dictionary can contain another dictionary as a value. This is known as a nested dictionary. For example:\ndict1 = { \u0026#34;person1\u0026#34;: {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30}, \u0026#34;person2\u0026#34;: {\u0026#34;name\u0026#34;: \u0026#34;Bob\u0026#34;, \u0026#34;age\u0026#34;: 25} } print(dict1[\u0026#34;person1\u0026#34;][\u0026#34;name\u0026#34;]) # Output: Alice 1.4.7. Dictionary Comprehension Dictionary comprehension is a concise way to create dictionaries. For example:\ndict1 = {x: x**2 for x in range(5)} # Output: {0: 0, 1: 1, 2: 4, 3: 9, 4: 16} #using if only dict1 = {x: x**2 for x in range(5) if x%2==0} # Output: {0: 0, 2: 4, 4: 16} #using if else dict1 = {x: x**2 if x%2==0 else x**3 for x in range(5)} # Output: {0: 0, 1: 1, 2: 4, 3: 27, 4: 16} 1.5. Tuple Operations A tuple is a collection of items enclosed within parentheses (). Tuples are immutable, meaning they similar to python as they cant be changed using indexing as a[0]=10 will give an error.\n1.5.1. Declaring a Tuple We can declare a tuple by enclosing items within parentheses (). For example:\ntuple1 = (1, 2, 3) tuple2 = (\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;) tuple3 = (1, \u0026#34;apple\u0026#34;, True, 3.14) 1.5.2. Accessing Tuple Elements We can access tuple elements using indexing . For example:\ntuple1 = (1, 2, 3) print(tuple1[0]) # Output: 1 1.5.3. Slice Tuple We can slice a tuple using the syntax variable[start:end:step] to get a sub-tuple. For example:\ntuple1 = (1, 2, 3, 4, 5) print(tuple1[1:4]) # Output: (2, 3, 4) 1.5.4. Tuple Methods Python provides various built-in methods to manipulate tuples. Some of the commonly used tuple methods are:\ncount() : Returns the number of occurrences of a specified element in the tuple. tuple1 = (1, 2, 3, 2) print(tuple1.count(2)) # Output: 2 index() : Returns the index of the first occurrence of the specified element in the tuple. tuple1 = (1, 2, 3, 2) print(tuple1.index(2)) # Output: 1 len() : Returns the length of the tuple. tuple1 = (1, 2, 3, 2) print(len(tuple1)) # Output: 4 1.5.5 concatenation of tuple We can concatenate two or more tuples using the + operator. For example:\ntuple1 = (1, 2, 3) tuple2 = (4, 5, 6) print(tuple1 + tuple2) # Output: (1, 2, 3, 4, 5, 6) 1.5.6. Tuple Unpacking Tuple unpacking allows us to assign multiple variables at once. For example:\ntuple1 = (1, 2, 3) a, b, c = tuple1 d,*e = tuple1 print(a) # Output: 1 print(b) # Output: 2 print(c) # Output: 3 print(d) # Output: 1 print(e) # Output: [2, 3] tuple1 = (1, 2, 3, 4, 5) a, *b, c = tuple1 print(a) # Output: 1 print(b) # Output: [2, 3, 4] print(c) # Output: 5 Note:Ascessing and slicing of tuple is similar to list and string.\n1.6. Boolean Operations Boolean is a data type that represents one of two values: True or False. Boolean values are used to evaluate conditions in programming. Here are some common boolean operations:\n1.6.1. Condition when variable is True When a variable has a non-zero value, it is considered True. a = 10 if a: print(\u0026#34;The value of a is True\u0026#34;) When a string is not empty, it is considered True. a = \u0026#34;Hello\u0026#34; if a: print(\u0026#34;The value of a is True\u0026#34;) When a list is not empty, it is considered True. a = [1, 2, 3] if a: print(\u0026#34;The value of a is True\u0026#34;) When a dictionary is not empty, it is considered True. a = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30} if a: print(\u0026#34;The value of a is True\u0026#34;) When a tuple is not empty, it is considered True. a = (1, 2, 3) if a: print(\u0026#34;The value of a is True\u0026#34;) When a set is not empty, it is considered True. a = {1, 2, 3} if a: print(\u0026#34;The value of a is True\u0026#34;) When a variable is explicitly set to True, it is considered True. a = True if a: print(\u0026#34;The value of a is True\u0026#34;) 1.6.2. Condition when variable is False Those which are not in the above condition are considered as False.\n1.7. Set Operations A set is a collection of unique items enclosed within curly braces {}. Main Uses of set are:\nTo remove duplicate elements from a list. To perform mathematical set operations like union, intersection, difference, etc. 1.7.1. Declaring a Set We can declare a set by enclosing items within curly braces {} or set(). For example:\nset1 = {1, 2, 3} set2 = {\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;} set3 = {1, \u0026#34;apple\u0026#34;, True, 3.14} #using set() set4 = set([1, 2, 3]) set5=set() 1.7.2. Set Methods Python provides various built-in methods to manipulate sets. Some of the commonly used set methods are:\n-len() : Returns the number of elements in the set.\nset1 = {1, 2, 3} print(len(set1)) # Output: 3 -add() : Adds an element to the set.Doesn\u0026rsquo;t return anything.\nset1 = {1, 2, 3} set1.add(4) print(set1) # Output: {1, 2, 3, 4} -clear() : Removes all elements from the set.Doesn\u0026rsquo;t return anything.\nset1 = {1, 2, 3} set1.clear() print(set1) # Output: set() -remove() : Removes the specified element from the set. If the element is not present, it raises an error.\nset1 = {1, 2, 3} set1.remove(2) print(set1) # Output: {1, 3} discard() : Removes the specified element from the set. If the element is not present, it does not raise an error.\nset1 = {1, 2, 3} set1.discard(2) print(set1) # Output: {1, 3} -union() : Returns a set containing the union of two sets.\nset1 = {1, 2, 3} set2 = {3, 4, 5} print(set1.union(set2)) # Output: {1, 2, 3, 4, 5} -intersection() : Returns a set containing the intersection of two sets.\nset1 = {1, 2, 3} set2 = {3, 4, 5} print(set1.intersection(set2)) # Output: {3} -difference() : Returns a set containing the difference between two sets.\nset1 = {1, 2, 3} set2 = {3, 4, 5} print(set1.difference(set2)) # Output: {1, 2} -symmetric_difference() : Returns a set containing the symmetric difference between two sets.\nset1 = {1, 2, 3} set2 = {3, 4, 5} print(set1.symmetric_difference(set2)) # Output: {1, 2, 4, 5} -issubset() : Returns True if all elements of a set are present in another set.\nset1 = {1, 2, 3} set2 = {1, 2, 3, 4, 5} print(set1.issubset(set2)) # Output: True 1.8 Used in All iterable 1.8.1. in Operator The in operator is used to check if an element is present in an iterable. For example:\n# in string str = \u0026#34;Hello, World!\u0026#34; print(\u0026#34;Hello\u0026#34; in str) # Output: True # in list list1 = [1, 2, 3, 4, 5] print(3 in list1) # Output: True # in tuple tuple1 = (1, 2, 3, 4, 5) print(6 in tuple1) # Output: False # in set set1 = {1, 2, 3, 4, 5} print(5 in set1) # Output: True # in dictionary dict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30} print(\u0026#34;name\u0026#34; in dict1) # Output: True 1.8.2. not in Operator The not in operator is used to check if an element is not present in an iterable. For example:\n# not in string str = \u0026#34;Hello, World!\u0026#34; print(\u0026#34;Alice\u0026#34; not in str) # Output: True # not in list list1 = [1, 2, 3, 4, 5] print(6 not in list1) # Output: True # not in tuple tuple1 = (1, 2, 3, 4, 5) print(5 not in tuple1) # Output: False # not in set set1 = {1, 2, 3, 4, 5} print(5 not in set1) # Output: False # not in dictionary dict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30} print(\u0026#34;name\u0026#34; not in dict1) # Output: False 1.8.3. len() Function The len() function is used to get the length of an iterable. For example:\n# for string str = \u0026#34;Hello, World!\u0026#34; print(len(str)) # Output: 13 # for list list1 = [1, 2, 3, 4, 5] print(len(list1)) # Output: 5 # for tuple tuple1 = (1, 2, 3, 4, 5) print(len(tuple1)) # Output: 5 # for set set1 = {1, 2, 3, 4, 5} print(len(set1)) # Output: 5 # for dictionary dict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30} print(len(dict1)) # Output: 2 1.8.4. max() and min() Functions The max() function is used to get the maximum value from an iterable, and the min() function is used to get the minimum value for list,string,set and tuples only. for dictionary you can use .keys() or .values() and use it. For example:\n# for list list1 = [1, 2, 3, 4, 5] print(max(list1)) # Output: 5 print(min(list1)) # Output: 1 # for tuple tuple1 = (1, 2, 3, 4, 5) print(max(tuple1)) # Output: 5 print(min(tuple1)) # Output: 1 # for string string = \u0026#34;Hello, World!\u0026#34; print(max(string)) # Output: r print(min(string)) # Output: \u0026#39; \u0026#39; # for set set1 = {1, 2, 3, 4, 5} print(max(set1)) # Output: 5 print(min(set1)) # Output: 1 1.8.5. join() Function The join() function is used to concatenate elements of an iterable with a separator. For example:\n# for list list1 = [\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;] print(\u0026#34;, \u0026#34;.join(list1)) # Output: apple, banana, cherry # for tuple tuple1 = (\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;) print(\u0026#34;, \u0026#34;.join(tuple1)) # Output: apple, banana, cherry # for set set1 = {\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;} print(\u0026#34;, \u0026#34;.join(set1)) # Output: apple, banana, cherry # for string string = \u0026#34;Hello, World!\u0026#34; print(\u0026#34;, \u0026#34;.join(string)) # Output: H, e, l, l, o, ,, , W, o, r, l, d, ! ","permalink":"http://localhost:1313/posts/pages/python/python_datatype_operations/","summary":"An in-depth look at Python data types, exploring their usage and importance in programming.","title":"Python Fundamentals: Understanding Data Types (Part 2)"},{"content":"22. Fragments in React Fragments are a way to group multiple elements in React without adding extra nodes to the DOM. Fragments are useful when you want to return multiple elements from a component, but you don\u0026rsquo;t want to add an extra div or span element to the DOM.\nFragments are represented by the \u0026lt;Fragment\u0026gt; tag or the shorthand syntax \u0026lt;\u0026gt;. You can use fragments to return multiple elements from a component without adding extra nodes to the DOM.\nWithout using fragments:\nfunction App() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Hello, World!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;Welcome to React\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } Here, the App component returns two elements, but they are wrapped in a div element. If you don\u0026rsquo;t want to add an extra div element to the DOM, you can use fragments.\nUsing fragments:\nfunction App() { return ( \u0026lt;\u0026gt; or \u0026lt;Fragment\u0026gt; \u0026lt;h1\u0026gt;Hello, World!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;Welcome to React\u0026lt;/p\u0026gt; \u0026lt;/\u0026gt; or \u0026lt;/Fragment\u0026gt; ); } 23. Passing jsx as props In React, you can pass JSX as props to other components. This allows you to create reusable components that can be used in different parts of your application.\nPassing JSX as props: function App() { const heading = \u0026lt;div\u0026gt;\u0026lt;h1\u0026gt;Hello, World!\u0026lt;/h1\u0026gt;\u0026lt;p\u0026gt;My name is nirajan Khatiwada\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;; return \u0026lt;Greeting message={heading} /\u0026gt;; } or function App() { return \u0026lt;Greeting message={\u0026lt;div\u0026gt;\u0026lt;h1\u0026gt;Hello, World!\u0026lt;/h1\u0026gt;\u0026lt;p\u0026gt;My name is nirajan Khatiwada\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;} /\u0026gt;; } Using props in the Greeting component: function Greeting(props) { return \u0026lt;div\u0026gt;{props.message}\u0026lt;/div\u0026gt;; } Passing built-in components as props: function App() { return \u0026lt;Greeting element=\u0026#34;button\u0026#34; /\u0026gt;; } 24. Isolation of Component in React Isolation of components is a key concept in React that allows you to create reusable components that are independent of each other. This means that each component should be self-contained and not rely on external data or state.\nfor example:\nfunction Button(props){ const [showText, setShowText] = useState(false); return ( \u0026lt;button onClick={() =\u0026gt; setShowText(!showText)}\u0026gt; {showText ? \u0026#39;Hide Text\u0026#39; : \u0026#39;Show Text\u0026#39;} \u0026lt;/button\u0026gt; ); } function App(){ return ( \u0026lt;div\u0026gt; \u0026lt;Button /\u0026gt; \u0026lt;Button /\u0026gt; \u0026lt;/div\u0026gt; ); } Here The component Button is isolated means one state of the component does not affect the other component. Each component is self-contained and does not rely on external data or state. for example, the showText state in one Button component does not affect the showText state in the other Button component.\n25. Taking User Input in React Using onChange event: function App() { const [name, setName] = useState(\u0026#39;\u0026#39;); const handleChange = (e) =\u0026gt; { setName(e.target.value); }; return ( \u0026lt;div\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; value={name} onChange={handleChange} /\u0026gt; \u0026lt;p\u0026gt;Hello, {name}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } Whats Happen Here\nHere, we have an input element that takes user input. When the user types in the input field,the onChange event is triggered for ervy keypress. The handleChange function is called with the event object as an argument for every keypress. The setName function is called with value of user input and it rerender the component with the updated value for every keypress. The value of the input field is set to the name state, and the name is displayed below the input field. Note: use onChange event to take user input in React and update the state accordingly to reflect the changes in the UI. If you use value as a prop in the input field, you must also provide an onChange event handler to update the state. Use this method if you want to update in real-time as the user types in the input field.\nOther method will be discussed in upcoming posts. 26.Rendering 2D Arrays in React In React, you can render 2D arrays by using nested map functions to iterate over the rows and columns of the array. This allows you to display tabular data or grid-like structures in your application.\nRendering a 2D array: function App() { const data = [ [\u0026#39;John\u0026#39;, \u0026#39;Doe\u0026#39;, 30], [\u0026#39;Jane\u0026#39;, \u0026#39;Smith\u0026#39;, 25], [\u0026#39;Alice\u0026#39;, \u0026#39;Brown\u0026#39;, 35], ]; return ( \u0026lt;table\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;First Name\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Last Name\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Age\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; {data.map((row, index) =\u0026gt; ( \u0026lt;tr key={index}\u0026gt; {row.map((cell, index) =\u0026gt; ( \u0026lt;td key={index}\u0026gt;{cell}\u0026lt;/td\u0026gt; ))} \u0026lt;/tr\u0026gt; ))} \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; ); } 27. Immutable update patterns in React In react while changing the state we shouldnot change the orginal state directly Instead, we should create a new copy of the state and update the copy with the new values. This is known as immutable update pattern.speciaaly when working with arrays and objects.\nThe Wrong way to update state: function App() { const [items, setItems] = useState([\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;cherry\u0026#39;]); const removeItem = (index) =\u0026gt; { items.splice(index, 1); setItems(items); }; return ( \u0026lt;div\u0026gt; \u0026lt;ul\u0026gt; {items.map((item, index) =\u0026gt; ( \u0026lt;li key={index}\u0026gt; {item} \u0026lt;button onClick={() =\u0026gt; removeItem(index)}\u0026gt;Remove\u0026lt;/button\u0026gt; \u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ); } The Correct way to update state: function App() { const [items, setItems] = useState([\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;cherry\u0026#39;]); const removeItem = (index) =\u0026gt; { const newItems = [...items]; newItems.splice(index, 1); setItems(newItems); }; return ( \u0026lt;div\u0026gt; \u0026lt;ul\u0026gt; {items.map((item, index) =\u0026gt; ( \u0026lt;li key={index}\u0026gt; {item} \u0026lt;button onClick={() =\u0026gt; removeItem(index)}\u0026gt;Remove\u0026lt;/button\u0026gt; \u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt;x x \u0026lt;/div\u0026gt; ); } Note: Always create a new copy of the state when updating arrays or objects in React. This ensures that the state is updated correctly and prevents unexpected behavior in your application. 28. Common Pattern for update,delete and add in React In React, you can use common patterns to update, delete, and add items to an array. These patterns involve creating new copies of the array and updating the state with the new values.\nAdd an item to an array: function App() { const [items, setItems] = useState([\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;cherry\u0026#39;]); const addItem = (item) =\u0026gt; { setItems([...items, item]); // or // const newItems = [...items]; // newItems.push(item); // setItems(newItems); }; return ( \u0026lt;div\u0026gt; \u0026lt;ul\u0026gt; {items.map((item, index) =\u0026gt; ( \u0026lt;li key={index}\u0026gt;{item}\u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;button onClick={() =\u0026gt; addItem(\u0026#39;orange\u0026#39;)}\u0026gt;Add Item\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } Deleting an item from an array: function App() { const [items, setItems] = useState([\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;cherry\u0026#39;]); const removeItem = (index) =\u0026gt; { const newItems = items.filter((item, i) =\u0026gt; i !== index); setItems(newItems); }; return ( \u0026lt;div\u0026gt; \u0026lt;ul\u0026gt; {items.map((item, index) =\u0026gt; ( \u0026lt;li key={index}\u0026gt; {item} \u0026lt;button onClick={() =\u0026gt; removeItem(index)}\u0026gt;Remove\u0026lt;/button\u0026gt; \u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ); } Updating an data of an array using map: function App() { const [items, setItems] = useState([ { id: 1, name: \u0026#39;apple\u0026#39;, price: 1 }, { id: 2, name: \u0026#39;banana\u0026#39;, price: 2 }, { id: 3, name: \u0026#39;cherry\u0026#39;, price: 3 }, ]); const updateItem = (id, price) =\u0026gt; { const newItems = items.map((item) =\u0026gt; item.id === id ? { ...item, price: price } : item ); setItems(newItems); }; return ( \u0026lt;div\u0026gt; \u0026lt;ul\u0026gt; {items.map((item) =\u0026gt; ( \u0026lt;li key={item.id}\u0026gt; {item.name} - ${item.price}{\u0026#39; \u0026#39;} \u0026lt;button onClick={() =\u0026gt; updateItem(item.id, item.price + 1)}\u0026gt; Increase Price \u0026lt;/button\u0026gt; \u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ); } Updating an data of an array using find: function App() { const [items, setItems] = useState([ { id: 1, name: \u0026#39;apple\u0026#39;, price: 1 }, { id: 2, name: \u0026#39;banana\u0026#39;, price: 2 }, { id: 3, name: \u0026#39;cherry\u0026#39;, price: 3 }, ]); const updateItem = (id, price) =\u0026gt; { const newItems= [...items]; const newItem = newItems.find((item) =\u0026gt; item.id === id); if (newItem) { newItem.price = price; setItems(newItems); } }; return ( \u0026lt;div\u0026gt; \u0026lt;ul\u0026gt; {items.map((item) =\u0026gt; ( \u0026lt;li key={item.id}\u0026gt; {item.name} - ${item.price}{\u0026#39; \u0026#39;} \u0026lt;button onClick={() =\u0026gt; updateItem(item.id, item.price + 1)}\u0026gt; Increase Price \u0026lt;/button\u0026gt; \u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ); } Note: Always prefer map over find when updating an array of objects in React. This ensures that the state is updated correctly and prevents unexpected behavior in your application.\n29.Updating object in react In React, you can update an object in state by creating a new copy of the object and updating the copy with the new values. This ensures that the state is updated correctly and prevents unexpected behavior in your application.\nUpdating an object in state: function App() { const [person, setPerson] = useState({ name: \u0026#39;John\u0026#39;, age: 30 }); const updatePerson = () =\u0026gt; { setPerson({ ...person, age: person.age + 1 }); }; return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;Name: {person.name}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Age: {person.age}\u0026lt;/p\u0026gt; \u0026lt;button onClick={updatePerson}\u0026gt;Increase Age\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } use list if you want to show the list of items and use object if you want to show the details of the item to identify which one is clicked or update you can pass the index or id of the item to the function. Or you can hardcode the value to update the object or list.\n","permalink":"http://localhost:1313/posts/pages/react/react3/","summary":"A comprehensive guide covering React\u0026rsquo;s advanced concepts including Fragments, JSX Props, Component Isolation, and proper state management patterns","title":"React : Day 3"},{"content":"Python Control Structures: Mastering Loops and Conditionals In Python programming, control structures are essential for managing the flow of execution in your code. They allow you to make decisions, repeat tasks, and create complex algorithms. In this guide, we will explore two fundamental control structures in Python: loops and conditionals.\n1. Conditional Statements Conditional statements in Python allow you to execute specific blocks of code based on certain conditions. The most common conditional statements are if, elif, and else.\n1.1. The if Statement The if statement is used to check a condition and execute a block of code if the condition is true.\nExample:\nx = 10 if x \u0026gt; 5: print(\u0026#34;x is greater than 5\u0026#34;) Output:\nx is greater than 5 1.2. The elif Statement The elif statement allows you to check multiple conditions after the initial if statement. If the previous conditions are false, the elif block is evaluated.\nExample:\nx = 5 if x \u0026gt; 5: print(\u0026#34;x is greater than 5\u0026#34;) elif x == 5: print(\u0026#34;x is equal to 5\u0026#34;) Output:\nx is equal to 5 1.3. The else Statement The else statement is used to execute a block of code when all the previous conditions are false.\nExample:\nx = 3 if x \u0026gt; 5: print(\u0026#34;x is greater than 5\u0026#34;) elif x == 5: print(\u0026#34;x is equal to 5\u0026#34;) else: print(\u0026#34;x is less than 5\u0026#34;) Output:\nx is less than 5 2. Loops Loops in Python allow you to execute a block of code repeatedly. There are two main types of loops in Python: for loops and while loops.\n2.1. The while Loop The while loop executes a block of code as long as a specified condition is true.\nSyntax:\nwhile condition: # Code block else: # Optional else block Example:\ncount = 0 while count \u0026lt; 5: print(count) count += 1 else: print(\u0026#34;Loop completed\u0026#34;) 2.2. The for Loop The for loop is used to iterate over a sequence (such as a list, tuple, or string) and execute a block of code for each item in the sequence.\nSyntax:\nfor item in sequence: # Code block else: # Optional else block Example:\nfruits = [\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;] for fruit in fruits: print(fruit) else: print(\u0026#34;No more fruits\u0026#34;) 2.3 Using For Loops with different data types 2.3.1. For Loop with Strings Example:\nfor char in \u0026#34;Python\u0026#34;: print(char) Output:\np\ry\rt\rh\ro\rn 2.3.2. For Loop with Lists Example:\nnumbers = [1, 2, 3, 4, 5] for num in numbers: print(num) Output:\n1\r2\r3\r4\r5 2.3.3. For Loop with tuples Example:\nfruits = (\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;) for fruit in fruits: print(fruit) Output:\napple\rbanana\rcherry Tuple unpacking can also be used in for loops to iterate over multiple values in a tuple.\ncoordinates = [(1, 2), (3, 4), (5, 6)] for x, y in coordinates: print(f\u0026#34;X: {x}, Y: {y}\u0026#34;) Output:\nX: 1, Y: 2\rX: 3, Y: 4\rX: 5, Y: 6 2.3.4. For Loop with Sets Example:\ncolors = {\u0026#34;red\u0026#34;, \u0026#34;green\u0026#34;, \u0026#34;blue\u0026#34;} for color in colors: print(color) Output:\nred\rgreen\rblue 2.3.5. For Loop with Dictionaries Example:\nperson = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} for key, value in person.items(): print(f\u0026#34;{key}: {value}\u0026#34;) Output:\nname: Alice\rage: 30\rcity: New York 2.4. break , pass and continue statements in loops 2.4.1. The break Statement The break statement is used to exit a loop prematurely. It terminates the current loop and resumes execution at the next statement after the loop.\nExample:\nfor num in [1, 2, 3, 4, 5]: if num == 3: break print(num) Output:\n1\r2 2.4.2. The continue Statement The continue statement is used to skip the rest of the code inside a loop for the current iteration and jump to the next iteration.\nExample:\nfor num in [1, 2, 3, 4, 5]: if num == 3: continue print(num) Output:\n1\r2\r4\r5 2.4.3. The pass Statement The pass statement is a null operation that does nothing. It is used when a statement is required syntactically but you do not want any code to execute.\nExample:\nfor num in [1, 2, 3, 4, 5]: pass ","permalink":"http://localhost:1313/posts/pages/python/python_control_structure/","summary":"A detailed examination of Python\u0026rsquo;s control structures, focusing on loops and conditionals to enhance your programming skills.","title":"Python Fundamentals: Mastering Control Structures (Part 3)"},{"content":"17. Hooks in React Anythong that start with prefix use is considered as a hook in react\n17.1. Rules of Hooks Only Call Hook inside a component function correct:\nfunction App() { const [val, setVal] = useState(0); } Incorrect:\nconst [val, setVal] = useState(0); function App() { } Only Call Hooks at the Top Level Hook must not be called inside code statement (e.g., inside an if statement, loop, or nested function). correct: function App() { const [val, setVal] = useState(0); } incorrect:\nfunction App() { if (true) { const [val, setVal] = useState(0); } } 3.Hook can be used inside other custom hooks too\n18. useState Hook useState is a React hook that allows you to manage component-specific state. It provides a way to declare state variables in functional components and ensure that changes to these variables cause the component or child component to re-render while the parent component remains unaffected from where the component whose set state is triggered.\nfor example:\nfunction App() { return ( \u0026lt;div\u0026gt; \u0026lt;MemoComp /\u0026gt; \u0026lt;/div\u0026gt; ); } function MemoComp() { const [data, setData] = useState(\u0026#34;No data\u0026#34;); function handle() { setData(\u0026#34;data\u0026#34;); } return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;{data}\u0026lt;/p\u0026gt; \u0026lt;button onClick={handle}\u0026gt;Click me\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } When button is clicked the handle function is called and the setData function is called which updates the data state variable. This cause the MemoComp and its child component to re-render with a new value of data.\n18.1. Syntax const [state, setState] = useState(initialState); 18.2. Managing State State management in React involves handling data and telling React to re-execute a function using the useState hook. This ensures that state updates lead to new state values. Example:\nconst [countes, setcountes] = useState(0); countes is the state variable that holds the current state value. setcountes is the function that updates the state variable. useState(0) is the initial state value. How it works: Initially, the state variable countes is set to 0. When the setcountes function is called, it updates the state variable to a new value. This triggers a re-render of the component, updating the UI with the new state value.\n18.3 Updating State Based on Previous State Suppose the age is 42. The handler calls setAge(age + 1) three times.\nfunction handleClick() { setAge(age + 1); // setAge(42 + 1) setAge(age + 1); // setAge(42 + 1) setAge(age + 1); // setAge(42 + 1) } if the initial age is 42, after calling this function, the age will be 43, not 45.\nTo solve this problem, we use an updater function to pass setAge calls.\nfunction handleClick() { setAge(a =\u0026gt; a + 1); // setAge(42 =\u0026gt; 43) setAge(a =\u0026gt; a + 1); // setAge(43 =\u0026gt; 44) setAge(a =\u0026gt; a + 1); // setAge(44 =\u0026gt; 45) } After this age will be 45 so use updater function when you want to update value based on previous value \u0026amp; it\u0026rsquo;s always recommended to use updater function in.\nIt is mostly used in:\nCounters Toggles Incrementing or decrementing a value 18.4. Pitfalls in useState In React state updates are asynchronous meaning they don\u0026rsquo;t immediately reflect in the current execution cycle. When you call a state setter function like setSelectedValue, React schedules the state update for the next render. This can lead to unexpected behavior if you try to access the updated state immediately after setting it.\nExample: function clickHandler(data) { setSelectedValue(`${data} is being clicked`); console.log(selectedTopic); // logs the old state, not updated one } Why It Happens State updates are asynchronous: React batches state updates and applies them during the next render cycle to optimize performance. Therefore, the state change you request won’t be immediately reflected in the current execution.\nLogging state immediately: Since the update happens after the current execution cycle, logging the state/selected topic immediately after calling setSelectedValue will show the old value (before the update).\nThis can be fixed using useEffect which is read later.\nNote: Always use the state variable when you want to reflect the changes in the UI.\n19. An Example demostrating useState Hook import {useState} from \u0026#39;react\u0026#39;; function App(){ const [count,setCount] = useState(0); return(){ \u0026lt;div\u0026gt; {count} \u0026lt;/div\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;Increment\u0026lt;/button\u0026gt; } } export default App; In the above example, we have a functional component App that uses the useState hook to manage the state of the count variable. The initial value of count is set to 0 using useState(0). The setCount function is used to update the value of count when the button is clicked. The count value is displayed in the UI, and clicking the button increments the count value by 1.\n20.Conditional Rendering in React Conditional rendering is a technique used to render different components or elements based on certain conditions. In React, conditional rendering can be achieved using ternary operators, and logical operators like \u0026amp;\u0026amp; .\n20.1. Ternary Operator The ternary operator is a concise way to write conditional statements in JavaScript. It consists of a condition followed by a question mark ?, an expression to execute if the condition is true, a colon :, and an expression to execute if the condition is false.\nExample:\nfunction App() { const isLoggedIn = true; return ( \u0026lt;div\u0026gt; {isLoggedIn ? \u0026lt;p\u0026gt;Welcome, User!\u0026lt;/p\u0026gt; : \u0026lt;p\u0026gt;Please log in\u0026lt;/p\u0026gt;} \u0026lt;/div\u0026gt; ); } Also We can write jsx code in variable and use it in return statement\nfunction App() { const isLoggedIn = true; const welcomeMessage=\u0026lt;p\u0026gt;Welcome, User!\u0026lt;/p\u0026gt;; const loginMessage=\u0026lt;p\u0026gt;Please log in\u0026lt;/p\u0026gt;; return ( \u0026lt;div\u0026gt; {isLoggedIn ? welcomeMessage : loginMessage} \u0026lt;/div\u0026gt; ); } 20.2. Logical \u0026amp;\u0026amp; Operator The logical \u0026amp;\u0026amp; operator is another way to conditionally render elements in React. The \u0026amp;\u0026amp; operator works by evaluating the expression on the left side of the \u0026amp;\u0026amp; operator. If the expression is true, the expression on the right side of the \u0026amp;\u0026amp; operator is executed. If the expression is false, the right side is not executed.\nExample:\nfunction App() { const isLoggedIn = true; return ( \u0026lt;div\u0026gt; {isLoggedIn \u0026amp;\u0026amp; \u0026lt;p\u0026gt;Welcome, User!\u0026lt;/p\u0026gt;} {isLoggedIn \u0026amp;\u0026amp; \u0026lt;button\u0026gt;Logout\u0026lt;/button\u0026gt;} {!isLoggedIn \u0026amp;\u0026amp; \u0026lt;p\u0026gt;Please log in\u0026lt;/p\u0026gt;} \u0026lt;/div\u0026gt; ); } Also We can write jsx code in variable and use it in return statement\nfunction App() { const isLoggedIn = true; const welcomeMessage=\u0026lt;p\u0026gt;Welcome, User!\u0026lt;/p\u0026gt;; const logoutButton=\u0026lt;button\u0026gt;Logout\u0026lt;/button\u0026gt;; const loginMessage=\u0026lt;p\u0026gt;Please log in\u0026lt;/p\u0026gt;; return ( \u0026lt;div\u0026gt; {isLoggedIn \u0026amp;\u0026amp; welcomeMessage} {isLoggedIn \u0026amp;\u0026amp; logoutButton} {!isLoggedIn \u0026amp;\u0026amp; loginMessage} \u0026lt;/div\u0026gt; ); } 21.Outputting list data dynamically In react we use map function to output list data dynamically as using map.\n21.1. Have a list of data You typically store the list in an array, which might come from a state, props, or external data source like an API\nconst data = [ { id: 1, name: \u0026#34;John\u0026#34; }, { id: 2, name: \u0026#34;Doe\u0026#34; }, { id: 3, name: \u0026#34;Jane\u0026#34; }, ]; 21.2 Using map function to output list data const listItems = data.map((item) =\u0026gt; \u0026lt;li key={item.id}\u0026gt;{item.name}\u0026lt;/li\u0026gt;); Key is used to uniquely identify each element in the list. It helps React identify which items have changed, are added, or are removed.It can be number or string.\n21.3. Rendering the list Use {} to embed the transformed list inside your component’s JSX.\n\u0026lt;ul\u0026gt;{listItems}\u0026lt;/ul\u0026gt;; 21.4. Putting it all together function App() { const data = [ { id: 1, name: \u0026#34;John\u0026#34; }, { id: 2, name: \u0026#34;Doe\u0026#34; }, { id: 3, name: \u0026#34;Jane\u0026#34; }, ]; const listItems = data.map((item) =\u0026gt; \u0026lt;li key={item.id}\u0026gt;{item.name}\u0026lt;/li\u0026gt;); return \u0026lt;ul\u0026gt;{listItems}\u0026lt;/ul\u0026gt;; } 21.5 Another form function App() { const data = [ { id: 1, name: \u0026#34;John\u0026#34; }, { id: 2, name: \u0026#34;Doe\u0026#34; }, { id: 3, name: \u0026#34;Jane\u0026#34; }, ]; return \u0026lt;ul\u0026gt;{data.map((item) =\u0026gt; \u0026lt;li key={item.id}\u0026gt;{item.name}\u0026lt;/li\u0026gt;); }\u0026lt;/ul\u0026gt;; } When will Rerender Occur?\nWhen state varaible or props value changes ","permalink":"http://localhost:1313/posts/pages/react/react1/","summary":"A detailed guide to help you understand and use hooks in React effectively.","title":"React : Day 2"},{"content":"Python Fundamentals: Exploring Advanced Operations (Part 4) In Python programming, advanced operations allow you to perform complex tasks efficiently. These operations include working with ranges, enumerations, zip functions, and more. In this guide, we will explore various advanced operations in Python to enhance your programming skills.\n1. Ranges Ranges in Python are used to generate a sequence of numbers. They are commonly used in loops to iterate over a specific range of values. Ranges can be created using the range() function.\n1.1. Creating a Range To create a range of numbers, you can use the range() function with the desired start, stop, and step values where start number is in inclusive and stop number is exclusive.\nExample:\n# Generate a range of numbers from 0 to 9 for i in range(10): print(i) Output:\n0\r1\r2\r3\r4\r5\r6\r7\r8\r9 Example:\n# Generate a range of numbers from 1 to 10 with a step of 2 for i in range(0, 10,2): print(i) Output:\n0\r2\r4\r6\r8 1.2 Enumerate Function The enumerate() function in Python is used to iterate over a sequence while keeping track of the index and value of each item. It returns a tuple containing the index and the value of the item.\nExample:\n# Enumerate a list of fruits fruits = [\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;cherry\u0026#39;] for index, fruit in enumerate(fruits): print(index, fruit) Output:\n0 apple\r1 banana\r2 cherry Example:\na=\u0026#34;nirajan\u0026#34; for index, char in enumerate(a): print(index, char) Output:\n0 n\r1 i\r2 r\r3 a\r4 j\r5 a\r6 n 1.3. Zip Function The zip() function in Python is used to combine multiple iterables (such as lists) element-wise. It returns an iterator of tuples where the i-th tuple contains the i-th element from each of the input iterables.\nExample:\n# Zip two lists together names = [\u0026#39;Alice\u0026#39;, \u0026#39;Bob\u0026#39;, \u0026#39;Charlie\u0026#39;] ages = [25, 30, 35] for name, age in zip(names, ages): print(name, age) Output:\nAlice 25\rBob 30\rCharlie 35 Example:\na=[1,2,3] b=[4,5,6] c=[7,8,9] print(list(zip(a,b,c))) Output:\n[(1, 4, 7), (2, 5, 8), (3, 6, 9)] 1.5 Sorted Function The sorted() function in Python is used to sort a list of elements. It returns a new sorted list without modifying the original list.The main feature of the sorted() function is that it can take a key argument that specifies a function to be called on each list element prior to making comparisons.\nExample:\n# Sort a list of numbers numbers = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5] sorted_numbers = sorted(numbers) print(sorted_numbers) Output:\n[1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] Example:\n# Sort a list of strings based on the length of the string fruits = [\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;cherry\u0026#39;, \u0026#39;date\u0026#39;] sorted_fruits = sorted(fruits, key=len) print(sorted_fruits) Output:\n[\u0026#39;date\u0026#39;, \u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;cherry\u0026#39;] Example:\n#Sort an dictionary based on the value d = {\u0026#39;apple\u0026#39;: 10, \u0026#39;banana\u0026#39;: 5, \u0026#39;cherry\u0026#39;: 15} sorted_d = sorted(d.items(), key=lambda x: x[1]) print(sorted_d) Output:\n[(\u0026#39;banana\u0026#39;, 5), (\u0026#39;apple\u0026#39;, 10), (\u0026#39;cherry\u0026#39;, 15)] Example:\n#Sort a list of tuples based on the second element t = [(1, 2), (3, 1), (5, 6)] sorted_t = sorted(t, key=lambda x: x[1]) print(sorted_t) Output:\n[(3, 1), (1, 2), (5, 6)] #2. Import in Python In Python, the import statement is used to import modules or packages into your script. It allows you to use functions, classes, and variables defined in other modules in your code.\n2.1. Importing Modules To import a module in Python, you can use the import keyword followed by the module name. You can then access the functions, classes, and variables defined in the module using dot notation.\nExample:\n# Import the math module import math # Calculate the square root of a number x = 16 print(math.sqrt(x)) Output:\n4.0 Example:\n# Import the datetime module import datetime # Get the current date and time now = datetime.datetime.now() print(now) Output:\n2024-11-17 10:30:00 2.2. Importing Specific Functions You can import specific functions or variables from a module using the from keyword. This allows you to use the imported functions directly without using the module name.\nExample:\n# Import the pi constant from the math module from math import pi # Print the value of pi print(pi) Output:\n3.141592653589793 Example:\n# Import the date class from the datetime module from datetime import date # Get the current date today = date.today() print(today) Output:\n2024-11-17 2.3. Aliasing Modules You can alias a module or package by using the as keyword. This allows you to refer to the module by a different name in your code.\nExample:\n# Import the math module and alias it as m import math as m # Calculate the square root of a number x = 25 print(m.sqrt(x)) Output:\n5.0 Example:\n# Import the datetime module using import and from and alias it as dt from datetime import datetime as dt now = dt.now() print(now) Output:\n2024-11-17 10:30:00 2.4. Importing All Functions You can import all functions and variables from a module using the * operator. This imports all the functions and variables defined in the module.\nExample:\n# Import all functions from the math module from math import * # Calculate the square root of a number x = 36 print(sqrt(x)) Output:\n6.0 The General Syntax is\nfrom module_name.submodule_name.submodule_name... import funtion_name or variable_name or filename as alias_name\nrandom module The random module in Python is used to generate random numbers. It provides various functions to generate random integers, floating-point numbers, and sequences.\n1. Generating Random Numbers The random module provides functions to generate random numbers within a specified range which can contain both integers starting and ending number.\nExample:\nfrom random import randint # Generate a random integer between 1 and 10 random_number = randint(1, 10) print(random_number) Output:\n5 2.Shuffling a List The random module provides a function to shuffle the elements of a list randomly. It modifies the original list in place.\nExample:\nfrom random import shuffle # Shuffle a list of numbers numbers = [1, 2, 3, 4, 5] shuffle(numbers) print(numbers) Output:\n[3, 1, 5, 2, 4] ","permalink":"http://localhost:1313/posts/pages/python/python_advanced_operations/","summary":"An in-depth exploration of advanced Python operations to enhance your programming skills.","title":"Python Fundamentals: Exploring Advanced Operations (Part 4)"},{"content":"Python Fundamentals: Understanding Functions In Python programming, functions are essential building blocks that allow you to organize and reuse code effectively. Functions help break down complex problems into smaller, manageable tasks, making your code more readable and maintainable. In this guide, we will explore the fundamentals of Python functions, including their syntax, parameters, return values, and more.\n1. Defining Functions A function in Python is defined using the def keyword followed by the function name and parentheses. You can also specify parameters inside the parentheses if the function requires input values.\nSyntax:\ndef function_name(parameters): # Function body # Statements Example:\ndef greet(): print(\u0026#34;Hello, World!\u0026#34;) 2. Calling Functions To call a function in Python, you simply write the function name followed by parentheses. If the function requires input values, you can pass them inside the parentheses.\nSyntax:\nfunction_name(arguments) Example:\ngreet() 3. return Statement The return statement in Python is used to exit a function and return a value to the caller. You can use the return statement to send a result back to the calling code.\nSyntax:\ndef function_name(parameters): # Function body return value Demostration using all:\ndef add_numbers(a, b): return a + b result = add_numbers(5, 3) print(result) 4. Args , Default Args and Kwargs 4.1. Args Using Args you can pass any number of arguments to a function. The arguments are passed as a tuple.\nSyntax:\ndef function_name(*args): # Function body Example:\ndef display_args(*args): print(args) display_args(1, 2, 3, 4, 5) Output:\n(1, 2, 3, 4, 5) 4.2. Default Args Default arguments are used when you do not pass a value for an argument in the function call. If a value is not provided, the default value is used.\nSyntax:\ndef function_name(arg=value): # Function body Example:\ndef add(a,b,c=0): return a+b+c result = add(5,3) print(result) result = add(5,3,2) print(result) Output:\n8\r10 4.3. Kwargs Using Kwargs you can pass any number of keyword arguments to a function. The arguments are passed as a dictionary.\nSyntax:\ndef function_name(**kwargs): # Function body Example:\ndef display_kwargs(**kwargs): print(kwargs) display_kwargs(name=\u0026#34;Alice\u0026#34;, age=30, city=\u0026#34;New York\u0026#34;) Output:\n{\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 30, \u0026#39;city\u0026#39;: \u0026#39;New York\u0026#39;} 4.4. Combination of Args and Kwargs Example:\ndef display_args_kwargs(*args, **kwargs): print(args) print(kwargs) display_args_kwargs(1, 2, 3, name=\u0026#34;Alice\u0026#34;, age=30) Output:\n(1, 2, 3)\r{\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 30} 4.5. Unpacking Args and Kwargs Example:\ndef display_args_kwargs(*args, **kwargs): print(args) print(kwargs) args = (1, 2, 3) kwargs = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30} display_args_kwargs(*args, **kwargs) Output:\n(1, 2, 3)\r{\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 30} 5. Lambda Functions Lambda functions, also known as anonymous functions, are small, single-expression functions that do not require a name. They are defined using the lambda keyword.\nSyntax:\nlambda arguments: expression Example:\nadd = lambda a, b: a + b result = add(5, 3) print(result) Output:\n8 6.Map and filter functions 6.1. Map Function The map() function in Python applies a given function to each item of an iterable (such as a list, tuple, or set) and returns a new iterable with the results.\nSyntax:\nmap(function, iterable) Example:\nnumbers = [1, 2, 3, 4, 5] squared = map(lambda x: x ** 2, numbers) print(list(squared)) Output:\n[1, 4, 9, 16, 25] 6.2. Filter Function The filter() function in Python filters elements from an iterable based on a given function. It returns an iterator with the elements that satisfy the condition.\nSyntax:\nfilter(function, iterable) Example:\nnumbers = [1, 2, 3, 4, 5] even = filter(lambda x: x % 2 == 0, numbers) print(list(even)) Output:\n[2, 4] 7.Local and Global Variables 7.1. Local Variables Local variables are defined within a function and are only accessible within that function. They are created when the function is called and destroyed when the function exits.\nExample:\ndef display(): message = \u0026#34;Hello, World!\u0026#34; print(message) display() # Trying to access the local variable outside the function will result in an error print(message) # NameError: name \u0026#39;message\u0026#39; is not defined 7.2. Global Variables Global variables are defined outside any function and can be accessed from any part of the code. You can use the global keyword to modify a global variable inside a function.\nExample:\nmessage = \u0026#34;Hello, World!\u0026#34; def display(): print(message) display() # Modifying a global variable inside a function def change_message(): global message message = \u0026#34;Hello, Python!\u0026#34; change_message() print(message) Output:\nHello, World!\rHello, Python! 7.3. Local vs. Global Variables If a local variable has the same name as a global variable, the local variable takes precedence within the function scope.\nExample:\nmessage = \u0026#34;Hello, World!\u0026#34; def display(): message = \u0026#34;Hello, Python!\u0026#34; print(message) display() print(message) Output:\nHello, Python!\rHello, World! ","permalink":"http://localhost:1313/posts/pages/python/python_function/","summary":"An in-depth exploration of Python functions, their usage, and importance in programming.","title":"Python Fundamentals: Understanding Functions (Part 5)"},{"content":"1. Create A React Project To create a React app we use Vite and its command is:\nnpm create vite@latest 2. Component In a React application, one page is broken down into multiple components. Components allow:\nReusability: For example, we can create one component for cards and use it to create multiple cards with different data. Related code lives together: Related items (JS code) are stored together. Separation of logic: Different components handle different data and logic. Diagram 3. Folder Structure my-app/\r├─ node_modules/\r├─ public/\r│ ├─ index.html\r│ ├─ image.png\r│ └─ favicon.ico\r├─ src/\r│ ├─ index.js\r│ ├─ App.js\r│ ├─ App.css\r│ └─ index.css\r├─ package.json\r└─ README.md node_module: Contains all the files of installed packages.\npublic: All static files are kept in this folder. For example, if image.png is in public, we can access it in the browser as 127.0.0.1:8000/image.png.\nindex.html: It is the page that is served to us and its content is managed by React using the DOM.Modify this file if you want to change the title or favicon.\npackage.json: Contains all the configuration of the project, package list, versions, and all related information.\nsrc: This is the folder where all the code is written.\nsrc/index.js React runs this file first.Code of index.js\nThe DOM selects the element of index.html whose id is root because of this code: document.getElementById('root') Then render() renders the \u0026lt;App/\u0026gt; component so that the root element will contain the data of the \u0026lt;App/\u0026gt; component. All changes are done in the index.html root element using the DOM. Remember that we never edit this file (code). src/App.js : This is where we will write all the SPA code. We start coding from App.jsx and link components as required.\nsrc/index.css : This CSS file is used by main.jsx, so it applies to the whole page. You can remove it if needed by removing its import in main.jsx.\n*** src/App.css:*** This CSS file is used by App.jsx, so it applies to all App components.\nRemember: Component functions must follow two rules:\nThe name should start with an uppercase letter (e.g., Head, MyHead). The function must return renderable content. The function must return a value that can be rendered (displayed on screen) by React. In most cases, return JSX. Example of a simple component:\nfunction App() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Hello world\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ); } As we know, App.jsx is provided by default when we create a React app. We can modify it and tailor it to our requirements\n4. Making Custom Components function FunctionName() { return ( \u0026lt;tagname\u0026gt; content \u0026lt;/tagname\u0026gt; ); } Important Note:\nTags that don\u0026rsquo;t have ending tags, such as \u0026lt;br\u0026gt; and \u0026lt;hr\u0026gt;, should be written as \u0026lt;br/\u0026gt; and \u0026lt;hr/\u0026gt;. class is replaced by className. For example, \u0026lt;body class=\u0026quot;data\u0026quot;\u0026gt; is written as \u0026lt;body className=\u0026quot;data\u0026quot;\u0026gt;. During a return in React, we cannot return multiple elements directly. Instead, we need to wrap them inside a single parent element like \u0026lt;div\u0026gt;, \u0026lt;\u0026gt;\u0026lt;/\u0026gt;. For Example :\nWrong Way: function component1() { return ( \u0026lt;div\u0026gt; Hi \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; Hello \u0026lt;/div\u0026gt; ); } right way: function component1() { return ( \u0026lt;div\u0026gt; {/* or \u0026lt;\u0026gt; */} \u0026lt;div\u0026gt; Hi \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; Hello \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; {/* or \u0026lt;/\u0026gt; */} ); } 5.Using One Component Inside Another Component To use one component inside another in React, follow the steps\nCreate a component. function Comp1() { return \u0026lt;div\u0026gt; Component \u0026lt;/div\u0026gt; } Use the component inside another component. function Comp2() { return ( \u0026lt;div\u0026gt; \u0026lt;Comp1 /\u0026gt; or \u0026lt;Comp1\u0026gt; \u0026lt;Comp1 /\u0026gt; content \u0026lt;/div\u0026gt; ) } Here, Comp1 is used inside Comp2.We can use Comp1 multiple times inside Comp2 as needed. Note: For proper management, create a components folder, create one file for each component, and export from there. Then, import and use it in another component.\nExample structure:\nsrc/\r├─ Assets/\r├─ App.jsx\r└─ Components/\r├─ Comp1.jsx\r└─ Comp2.jsx Task: Break Down a Component into Multiple Components\nfunction App() { return ( \u0026lt;\u0026gt; \u0026lt;header\u0026gt; I am header \u0026lt;/header\u0026gt; \u0026lt;main\u0026gt; I am main content \u0026lt;/main\u0026gt; \u0026lt;footer\u0026gt; I am footer \u0026lt;/footer\u0026gt; \u0026lt;/\u0026gt; ); } Solution: components/Header.jsx\nfunction Header() { return ( \u0026lt;header\u0026gt; I am header \u0026lt;/header\u0026gt; ); } export default Header; components/Footer.jsx\nfunction Footer() { return ( \u0026lt;footer\u0026gt; I am footer \u0026lt;/footer\u0026gt; ); } export default Footer; Finally, App.jsx\nimport Header from \u0026#39;./components/Header\u0026#39;; import Footer from \u0026#39;./components/Footer\u0026#39;; function App() { return ( \u0026lt;\u0026gt; \u0026lt;Header /\u0026gt; \u0026lt;main\u0026gt; I am main content \u0026lt;/main\u0026gt; \u0026lt;Footer /\u0026gt; \u0026lt;/\u0026gt; ); } export default App; structure:\nsrc/\r├─ Assets/\r├─ App.jsx\r└─ components/\r├─ Header.jsx\r└─ Footer.jsx Note: You Can Always break down a component as many times as you want. The main goal is to make the code more readable and maintainable.\n6. Some Component Hierarchies Examples THis is the simple example of a component hierarchy. 7. Embedding JavaScript code in JSX In JSX, we can embed JavaScript code using curly braces {}. We can write any JavaScript code inside the curly braces. For example, we can write a variable, function, or any JavaScript expression but of single line.\nfunction componentName() { return ( \u0026lt;div\u0026gt; { JavaScript code } \u0026lt;/div\u0026gt; ); } Example:\nfunction App() { const name = \u0026#39;John Doe\u0026#39;; return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt; Hello, {name} \u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ); } Where To Write Javascript Logic?\nWe can write JavaScript logic inside the component function. We can write JavaScript logic outside the component function and use it inside the component function. 7.1 Using JavaScript Logic Outside Component Function syntax:\n// Multiple lines of JavaScript code function ComponentName() { return ( \u0026lt;div\u0026gt; {/* JSX code */} \u0026lt;/div\u0026gt; ); } 7.2 Using JavaScript Logic Inside Component Function syntax:\nfunction ComponentName() { // Multiple lines of JavaScript code return ( \u0026lt;div\u0026gt; {/* JSX code */} \u0026lt;/div\u0026gt; ); } When to use Inside Component Function Outside Component Function Use Case When the logic is specific to the component and not used anywhere else. When the logic is used in multiple components. Advantages Logic is specific to the component. Logic can be reused in multiple components. Disadvantages Logic cannot be reused in other components. Logic is not specific to the component. Combined Example Task1: Create a component that generate random number between 1 to 10 and display in every page reload\nfunction RandomNumber(){ return \u0026lt;\u0026gt; \u0026lt;h1\u0026gt;Random Number: {Math.floor(Math.random() * 10) + 1}\u0026lt;/h1\u0026gt; } export default RandomNumber; This can be done in another ways which is more readable and maintainable\nfunction RandomNumber(){ const randomNumber = Math.floor(Math.random() * 10) + 1; return \u0026lt;h1\u0026gt;Random Number: {randomNumber}\u0026lt;/h1\u0026gt; } export default RandomNumber; Task2 : Create a component that generate random element from an array and display on each page reload\nconst elements = [\u0026#39;Earth\u0026#39;, \u0026#39;Water\u0026#39;, \u0026#39;Fire\u0026#39;, \u0026#39;Air\u0026#39;]; function generateRandomElement(){ return elements[Math.floor(Math.random() * elements.length)]; } function RandomElement(){ const randomElement = generateRandomElement(); return \u0026lt;h1\u0026gt;Random Element: {randomElement}\u0026lt;/h1\u0026gt; } export default RandomElement; This can be done by putting the logic inside the component function\nconst elements = [\u0026#39;Earth\u0026#39;, \u0026#39;Water\u0026#39;, \u0026#39;Fire\u0026#39;, \u0026#39;Air\u0026#39;]; function generateRandomElement(){ return elements[Math.floor(Math.random() * elements.length)]; } function RandomElement(){ const randomElement = elements[Math.floor(Math.random() * elements.length)]; return \u0026lt;h1\u0026gt;Random Element: {randomElement}\u0026lt;/h1\u0026gt; } export default RandomElement; The most optimal way is using this\nconst elements = [\u0026#39;Earth\u0026#39;, \u0026#39;Water\u0026#39;, \u0026#39;Fire\u0026#39;, \u0026#39;Air\u0026#39;]; function RandomElement(){ const randomElement = elements[Math.floor(Math.random() * elements.length)]; return \u0026lt;h1\u0026gt;Random Element: {randomElement}\u0026lt;/h1\u0026gt; } export default RandomElement; 8.Loading Images in React step 1: put the images in assets folder that need to be loaded step 2: import the image in the component where it is needed as shown below import imageName from Location Note: Location is the path of the image from the current file location and imageName can be set to any name\nstep 3: use the image in the component as shown below \u0026lt;img src={imageName} alt=\u0026#34;description\u0026#34; /\u0026gt; Note: imageName is the location of the image as src/Assets/logo.png\nTask: Load an image in a Header component with the image name logo.png and description logo. structure:\nsrc/\r├─ Assets/\r└─ logo.png\r├─ App.jsx\r└─ components/\r├─ Header.jsx import logo from \u0026#39;../Assets/logo.png\u0026#39;; function Header() { return ( \u0026lt;header\u0026gt; \u0026lt;img src={logo} alt=\u0026#34;logo\u0026#34; /\u0026gt; \u0026lt;/header\u0026gt; ); } 9.Importing CSS in React step 1: create a css file in the src folder step 2: import the css file in the component where it is needed as shown below import cssfileLocation Note: style.css is the name of the css file\nfor example:\nimport \u0026#39;./style.css\u0026#39; function App() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt; Hello world \u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ); } 9.1 Managing CSS in React Create css file in same directory as of your component src/ ├─ App.jsx └─ components/ ├─ Header.jsx └─ Header.css -Import the css file in the component where it is needed as shown below\r```jsx\rimport \u0026#39;./Header.css\u0026#39; 10.Props in React Props are used to pass data from parent component to child component. It is used to reuse the same component with different data. Props are passed as attributes to the component. Prop accept any type of value like string, number, array, object, function,compenent,jsx bool etc. 10.1 Passing Props from Parent to Child Component Parent Component function ParentComponent() { return ( \u0026lt;ChildComponent prop1={value1} prop2={value2} /\u0026gt; ); } 10.2 Receiving Props in Child Component Child Component function ChildComponent(props) { console.log(props); // will print object of props {prop1: value1, prop2:value2} return ( \u0026lt;\u0026gt; {props.prop1} {props.prop2} \u0026lt;/\u0026gt; ); } This approach is not recommended because it is not clear what props are being passed to the component. Instead, we can destructure the props as shown below.\n10.3 Destructuring Props Child Component function ChildComponent({prop1, prop2}) { return ( \u0026lt;\u0026gt; {prop1} {prop2} \u0026lt;/\u0026gt; ); } Task: Create a card cmponent and use multiple cards in the App component to make card section\nfunction Card({title, description, image}) { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;{title}\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;{description}\u0026lt;/p\u0026gt; \u0026lt;img src={image} alt=\u0026#34;description\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; ); } export default Card; import Card from \u0026#39;./components/Card\u0026#39;; function App() { return ( \u0026lt;div\u0026gt; \u0026lt;Card title=\u0026#34;Card 1\u0026#34; description=\u0026#34;This is card 1\u0026#34; image={image1} /\u0026gt; \u0026lt;Card title=\u0026#34;Card 2\u0026#34; description=\u0026#34;This is card 2\u0026#34; image={image2} /\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; 11. Children Props in React Children props are used to pass data between opening and closing tags of a component. 11.1 Passing Children Props Parent Component function ParentComponent() { return ( \u0026lt;ChildComponent\u0026gt; \u0026lt;h1\u0026gt; Hello \u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt; World \u0026lt;/p\u0026gt; \u0026lt;/ChildComponent\u0026gt; ); } 11.2 Receiving Children Props Child Component function ChildComponent({ children }) { return ( \u0026lt;div\u0026gt; {children} \u0026lt;/div\u0026gt; ); } 11.3 Output \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt; Hello \u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt; World \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; 12.Using Props and Children Props Together Task: Create a card component that accepts title, description, and children props. Use the card component in the App component to make a card section.\nfunction Card({ title, description, children }) { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;{title}\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;{description}\u0026lt;/p\u0026gt; {children} \u0026lt;/div\u0026gt; ); } export default Card; import Card from \u0026#39;./components/Card\u0026#39;; function App() { return ( \u0026lt;div\u0026gt; \u0026lt;Card title=\u0026#34;Card 1\u0026#34; description=\u0026#34;This is card 1\u0026#34;\u0026gt; \u0026lt;h1\u0026gt; Hello \u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt; World \u0026lt;/p\u0026gt; \u0026lt;/Card\u0026gt; \u0026lt;Card title=\u0026#34;Card 2\u0026#34; description=\u0026#34;This is card 2\u0026#34;\u0026gt; \u0026lt;h1\u0026gt; Hello \u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt; World \u0026lt;/p\u0026gt; \u0026lt;/Card\u0026gt; \u0026lt;/div\u0026gt; ); } 13. Making a Button Component 13.1 Using Props function App() { return ( \u0026lt;div\u0026gt; \u0026lt;Button text=\u0026#34;Click me\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; ); } function Button({ text}) { return ( \u0026lt;button\u0026gt; {text} \u0026lt;/button\u0026gt; ); } export default Button; 13.2 Using Children Props function App() { return ( \u0026lt;div\u0026gt; \u0026lt;Button\u0026gt;Click me\u0026lt;/Button\u0026gt; \u0026lt;/div\u0026gt; ); } function Button({ children }) { return ( \u0026lt;button\u0026gt; {children} \u0026lt;/button\u0026gt; ); } export default Button; 14. Reacting to Events In React, we can add event listeners like onClick, onMouseOver, onMouseOut, etc to buildin components lie button, div, etc using syntax \u0026lt;InbuiltComponent eventlistener={functionName} /\u0026gt; Note: functionName is the name of the function that will be called when the event is triggered.\nThere are Many eventlisteners that can be used in React like onClick, onMouseOver, onMouseOut etc.\nYou can check the full list of event listeners in the React documentation also note that the event listener will always start with on followed by the event name.\nWe can call the handle function in two ways:\n14.1 The First Way function App() { function handleClick() { console.log(\u0026#39;Button clicked\u0026#39;); } return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={handleClick}\u0026gt;Click me\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 14.2 The Second Way function App() { return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={() =\u0026gt; {console.log(\u0026#39;Button clicked\u0026#39;)}}\u0026gt;Click me\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 15. Event Listeners in Custom Components since by default when we add event listeners to custom component it doesnot work just because it is passed as prop but on simple tweaking we can make it work\nDesign Pattern for applying event listeners in custom components\nfunction App(){ function handleClick(){ console.log(\u0026#39;Button clicked\u0026#39;); } return ( \u0026lt;div\u0026gt; \u0026lt;Button onClick={handleClick} /\u0026gt; \u0026lt;/div\u0026gt; ); } The onclick method is passed as a prop to the button component and then used in the button component as shown below\nfunction Button({onClick}){ return ( \u0026lt;button onClick={onClick}\u0026gt;Click me\u0026lt;/button\u0026gt; ); } 16. Passing Arguments to Event Functions To pass Custom arguments to event functions, we can use the arrow function syntax as shown below \u0026lt;inbuildComponent eventListener={() =\u0026gt; functionName(argument)} /\u0026gt; Example function App() { function handleClick(name) { console.log(\u0026#39;Button clicked by\u0026#39;, name); } return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={() =\u0026gt; handleClick(\u0026#39;John\u0026#39;)}\u0026gt;Click me\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } ","permalink":"http://localhost:1313/posts/pages/react/react/","summary":"A detailed reference guide to help you quickly set up and manage React projects, components, and folder structures.","title":"React : Day 1"},{"content":"Python Fundamentals: Understanding Error Handling In Python programming, error handling is an essential concept that allows you to gracefully manage exceptions and errors that may occur during program execution. By handling errors effectively, you can prevent your program from crashing and provide meaningful feedback to users. In this guide, we will explore the fundamentals of error handling in Python, including exceptions, try-except blocks, and best practices.\n1. Exceptions In Python, exceptions are events that occur during the execution of a program that disrupt the normal flow of code. When an exception occurs, the interpreter raises an exception object that can be caught and handled by the program. Exceptions can be caused by various reasons, such as invalid input, file not found, or division by zero.\n2.What May Cause Exceptions Exceptions can be caused by various reasons, such as:\nDivision by zero Invalid input File not found Syntax errors Out of Index of list, tuple , String Key Error in dictionary 3.Types of Exceptions Commonly used exceptions in Python include:\nZeroDivisionError: Raised when division or modulo by zero occurs. ValueError: Raised when a function receives an argument of the correct type but an inappropriate value. TypeError: Raised when an operation or function is applied to an object of an inappropriate type. IndexError: Raised when a sequence subscript is out of range. KeyError: Raised when a dictionary key is not found. SyntaxError: Raised when the parser encounters a syntax error. Note: All exceptions in Python are subclasses of the Exception class.\n3.Handling Exceptions To handle exceptions in Python, you can use the try-except block, which allows you to catch and handle exceptions gracefully. The try block contains the code that may raise an exception, and the except block handles the exception if it occurs.The program control will transfer the control to the except block if any exception occurs in the try block but if there is not exception then the control will not transfer to the except block.\n4.1. Using try-except Block Here\u0026rsquo;s an example of using the try-except block to handle exceptions in Python:\nsyntax:\ntry: # Code that may raise an exception except ExceptionType as e: # Handle the exception Example:\ntry: x = 10 / 0 except Exception as e: print(\u0026#34;Error: Division by zero\u0026#34;) Output:\nError: Division by zero Note: if you don\u0026rsquo;t know the type of exception you can use Exception to catch all exceptions.\nIf you dont handel exception then it will show error and stop the program.\n4.2. Finally Block The finally block is used to execute code that should always run, regardless of whether an exception occurs or not. The finally block is typically used to release resources or clean up operations that need to be performed after the try block, regardless of the outcome Any how the finally block will run. if yout return from the try block then also the finally block will run.\nsyntax:\ntry: # Code that may raise an exception except ExceptionType as e: # Handle the exception finally: # Code that always runs Example:\ntry: x = 10 / 0 except Exception as e: print(\u0026#34;Error: Division by zero\u0026#34;) finally: print(\u0026#34;Cleanup code\u0026#34;) Output:\nError: Division by zero\rCleanup code 3.5. Raising Exceptions You can raise exceptions in Python using the raise statement. This allows you to create custom exceptions and raise them when needed. You can also raise built-in exceptions to indicate errors or exceptional conditions.\nsyntax:\nraise ExceptionType(\u0026#34;Error message\u0026#34;) Example:\nx = -1 if x \u0026lt; 0: raise ValueError(\u0026#34;Value cannot be negative\u0026#34;) Output:\nValueError: Value cannot be negative 3.6. Multiple except Blocks You can use multiple except blocks to handle different types of exceptions in Python. This allows you to catch and handle specific exceptions based on their type.\nsyntax:\ntry: # Code that may raise an exception except ExceptionType1 as e: # Handle ExceptionType1 except ExceptionType2 as e: # Handle ExceptionType2 Example:\ntry: x = 10 / 0 except ZeroDivisionError as e: print(\u0026#34;Error: Division by zero\u0026#34;) except ValueError as e: print(\u0026#34;Error: Invalid value\u0026#34;) Output:\nError: Division by zero 3.7. Custom Exceptions You can create custom exceptions in Python by defining a new exception class that inherits from the Exception class. Custom exceptions allow you to define specific error conditions for your application and raise them when needed.\nsyntax:\nclass CustomException(Exception): pass Example:\n#Will read about class in oop section class CustomError(Exception): def __init__(self,message,value): self.message=message self.value=value def __str__(self): return f\u0026#34;{self.message}\\nError code:{self.value}\u0026#34; try: x = -1 if x \u0026lt; 0: raise CustomError(\u0026#34;Value cannot be negative\u0026#34;,1001) except CustomError as e: print(e) Note: Custom exceptions should inherit from the Exception class or one of its subclasses. You can simply use:\ntry: #code except: #code try: #code except Exception as e: #code try: #code except Exception: #code try: #code except: #code finally: #code ","permalink":"http://localhost:1313/posts/pages/python/python_error_handeling/","summary":"An in-depth exploration of Python error handling, exceptions, and best practices.","title":"Python Fundamentals: Understanding Error Handling (Part 6)"},{"content":"Python Fundamentals: Packages, Generators, and Decorators In this guide, we will explore advanced Python topics including packages, generators, and decorators. These concepts are essential for writing efficient and maintainable Python code. Let\u0026rsquo;s dive in!\n1. Python Packages Python packages are a way of organizing and structuring your code into reusable modules. Packages allow you to group related modules together, making it easier to manage and maintain your codebase. In this section, we will explore how to create and use Python packages.\n1.1. Creating a Package To create a Python package, you need to organize your code into a directory structure with a special file called __init__.py. This file tells Python that the directory is a package and allows you to import modules from the package.\nExample directory structure:\nmy_package/\r│\r├── __init__.py\r├── module1.py\r└── module2.py 1.2. Using a Package To use a Python package, you can import modules from the package using the import statement. You can import specific modules or the entire package.\nExample:\n# Importing a specific module from my_package import module1 # Using a function from the imported module module1.my_function() # Importing the entire package import my_package # Using a function from a module within the package my_package.module2.another_function() #Importing Function from a module from my_package.module1 import my_function my_function() Note : init.py file can be empty or contain initialization code for the package. It will automatically run when the package is imported.\n1.3 Creating a Subpackage You can create subpackages within a package to further organize your code. Subpackages are simply packages within packages, allowing you to create a hierarchical structure for your codebase.\nExample directory structure:\nmy_package/\r│\r├── __init__.py\r├── module1.py\r└── subpackage/\r├── __init__.py\r├── module3.py\r└── module4.py 1.4. Using a Subpackage To use a subpackage, you can import modules from the subpackage using the dot notation.\nExample:\n# Importing a module from a subpackage from my_package.subpackage import module3 # Using a function from the imported module module3.another_function() # Importing the entire subpackage import my_package.subpackage # Using a function from a module within the subpackage my_package.subpackage.module4.some_function() #Importing Function from a module from my_package.subpackage.module3 import another_function another_function() 1.5. name == \u0026ldquo;main\u0026rdquo; We use the __name__ variable to check if a script is being run as the main program or being imported as a module. When a script is run as the main program, __name__ is set to \u0026quot;__main__\u0026quot;. This allows you to include code that should only run when the script is executed directly.\nFor Example:\nStructure:\nMain Directory/\r├── main.py\r└── package/\r├── __init__.py\r└── module1.py module1.py:\ndef my_function(): print(\u0026#34;Hello from module1\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: my_function() When you run module1.py directly, the my_function() will be executed. However, if you import module1 into another script, the my_function() will not be executed.\nFor Example:\nfrom package import module1 print(\u0026#34;Imported module1\u0026#34;) Output:\nImported module1 When use Dont use if __name__ == \u0026quot;__main__\u0026quot;: in module1.py:\ndef my_function(): print(\u0026#34;Hello from module1\u0026#34;) my_function() also,\nfrom package import module1 print(\u0026#34;Imported module1\u0026#34;) Output:\nHello from module1\rImported module1 2. Python Generators Using generator we can instantly return all the values using the yield keyword without storing them in memory. This is useful when working with large datasets or infinite sequences.\n2.1. Creating a Generator To create a generator in Python, you can use a function with the yield keyword. When a function contains the yield keyword, it becomes a generator function. The yield keyword suspends the function\u0026rsquo;s execution and returns a value to the caller.\nExample:\ndef my_generator(): yield 1 yield 2 yield 3 # Using the generator gen = my_generator() print(next(gen)) # Output: 1 print(next(gen)) # Output: 2 print(next(gen)) # Output: 3 Example:\n#using generator in loop def generate(n): for i in range(n): yield i for i in generate(10): print(i) 3. Python Decorators Decorators are a powerful feature in Python that allows you to modify or extend the behavior of functions or methods. Decorators are functions that take another function as an argument and return a new function that extends the behavior of the original function.\n3.1. Creating a Decorator To create a decorator in Python, you can define a function that takes another function as an argument and returns a new function that extends the behavior of the original function.\nSyntax:\ndef my_decorator(func): def wrapper(): # Code to execute before calling the decorated function func() # Code to execute after return wrapper Example:\ndef my_decorator(func): def wrapper(): print(\u0026#34;Before function call\u0026#34;) func() print(\u0026#34;After function call\u0026#34;) return wrapper @my_decorator def say_hello(): print(\u0026#34;Hello!\u0026#34;) say_hello() #call to my_decorator(say_hello)() just because we use @my_decorator Output:\nBefore function call\rHello!\rAfter function call Example For decorator :\ndef Add_Wrapper(func): def wrapper(a,b,c): print(\u0026#34;Status code is\u0026#34;,c) return func(a,b) return wrapper @Add_Wrapper def add(a,b): return a+b print(add(2,3,200)) Output:\nStatus code is 200\r5 3.2. Decorator with Arguments You can also create decorators that accept arguments by defining a decorator function that takes arguments and returns a decorator function.\nSyntax:\ndef my_decorator_with_args(arg1, arg2): def decorator(func): def wrapper(): # Code to execute before calling the decorated function func() # Code to execute after return wrapper return decorator Example:\ndef my_decorator_with_args(arg1, arg2): def decorator(func): def wrapper(): print(f\u0026#34;Decorator arguments: {arg1}, {arg2}\u0026#34;) func() return wrapper return decorator @my_decorator_with_args(\u0026#34;arg1\u0026#34;, \u0026#34;arg2\u0026#34;) def say_hello(): print(\u0026#34;Hello!\u0026#34;) say_hello() Output:\nDecorator arguments: arg1, arg2\rHello! ","permalink":"http://localhost:1313/posts/pages/python/python_advanced_topics/","summary":"An in-depth exploration of Python packages, generators, and decorators.","title":"Python Fundamentals: Packages, Generators, and Decorators (Part 7)"},{"content":"Python Fundamentals: Understanding request In this guide, we will explore request package in python. This package is used to make HTTP requests in python. Let\u0026rsquo;s dive in!\n1. Python request Python request is a simple and elegant HTTP library for Python. It provides methods for sending HTTP requests and handling the responses. The requests library allows you to send HTTP requests using a simple and intuitive API, and it also provides support for handling cookies, sessions, and authentication.\n1.1. Installing requests To use the requests library in your Python project, you need to install it using pip. You can install the requests library by running the following command in your terminal:\npip install requests 1.2. Types of requests The requests library supports various types of HTTP requests, including GET, POST, PUT, DELETE, and more. You can use these methods to interact with web services and APIs.\nExample:\nimport requests # Send a GET request response = requests.get(\u0026#39;https://api.github.com\u0026#39;) # Send a POST request response = requests.post(\u0026#39;https://httpbin.org/post\u0026#39;) # Send a PUT request response = requests.put(\u0026#39;https://httpbin.org/put\u0026#39;) # Send a DELETE request response = requests.delete(\u0026#39;https://httpbin.org/delete\u0026#39;) 1.3 Parameters for requests The requests library allows you to pass various parameters when making HTTP requests. These parameters include headers, query parameters, request body, and more.\nHeaders: You can pass custom headers in your request using the headers parameter. Example: import requests # Send a GET request with custom headers headers = {\u0026#39;User-Agent\u0026#39;: \u0026#39;Mozilla/5.0\u0026#39;} response = requests.get(\u0026#39;https://api.github.com\u0026#39;, headers=headers) # Send a POST request with custom headers response = requests.post(\u0026#39;https://httpbin.org/post\u0026#39;, headers=headers) #similarly for PUT and DELETE cookie: You can pass cookies in your request using the cookies parameter. Example: import requests # Send a GET request with cookies cookies = {\u0026#39;session_id\u0026#39;: \u0026#39;12345\u0026#39;} response = requests.get(\u0026#39;https://api.github.com\u0026#39;, cookies=cookies) # Send a POST request with cookies response = requests.post(\u0026#39;https://httpbin.org/post\u0026#39;, cookies=cookies) #similarly for PUT and DELETE file: You can upload files in your request using the files parameter. Example: import requests # Upload a file in a POST request files = {\u0026#39;file\u0026#39;: open(\u0026#39;file.txt\u0026#39;, \u0026#39;rb\u0026#39;)} response = requests.post(\u0026#39;https://httpbin.org/post\u0026#39;, files=files) #similarly for PUT and DELETE params: You can pass query parameters in your request using the params parameter. Example: import requests # Send a GET request with query parameters params = {\u0026#39;key1\u0026#39;: \u0026#39;value1\u0026#39;, \u0026#39;key2\u0026#39;: \u0026#39;value2\u0026#39;} response = requests.get(\u0026#39;https://api.github.com\u0026#39;, params=params) # Send a POST request with query parameters response = requests.post(\u0026#39;https://httpbin.org/post\u0026#39;, params=params) #similarly for PUT and DELETE data: You can pass data in your request body using the data parameter. Example: import requests # Send a POST request with data data = {\u0026#39;key1\u0026#39;: \u0026#39;value1\u0026#39;, \u0026#39;key2\u0026#39;: \u0026#39;value2\u0026#39;} response = requests.post(\u0026#39;https://httpbin.org/post\u0026#39;, data=data) #similarly for PUT and DELETE json: You can pass JSON data in your request body using the json parameter. Example: import requests # Send a POST request with JSON data data = {\u0026#39;key1\u0026#39;: \u0026#39;value1\u0026#39;, \u0026#39;key2\u0026#39;: \u0026#39;value2\u0026#39;} response = requests.post(\u0026#39;https://httpbin.org/post\u0026#39;, json=data) #similarly for PUT and DELETE Note: The requests library provides a wide range of parameters and options for making HTTP requests. You can refer to the official documentation for more details.\n** Note ** : While using json it will automatically set the content type to application/json and dump the data to json format but while using data it will set the content type to application/x-www-form-urlencoded and encode the data to urlencoded format.\n1.4. Handling responses The requests library provides methods for handling the responses returned by HTTP requests. You can access the response content, status code, headers, and more.\nResponse content: You can access the response content using the text attribute. Example: import requests # Send a GET request response = requests.get(\u0026#39;https://api.github.com\u0026#39;) # Get the response content content = response.text print(content) Response Content in bytes: You can access the response content in bytes using the content attribute. Example: import requests # Send a GET request response = requests.get(\u0026#39;https://api.github.com\u0026#39;) # Get the response content in bytes content = response.content print(content) json: You can access the response content as JSON using the json method. Example:\nimport requests # Send a GET request response = requests.get(\u0026#39;https://api.github.com\u0026#39;) # Get the response content as JSON data = response.json() print(data) Status code: You can access the response status code using the status_code attribute. Example: import requests # Send a GET request response = requests.get(\u0026#39;https://api.github.com\u0026#39;) # Get the response status code status_code = response.status_code print(status_code) Headers: You can access the response headers using the headers attribute. Example: import requests # Send a GET request response = requests.get(\u0026#39;https://api.github.com\u0026#39;) # Get the response headers headers = response.headers print(headers) Cookies: You can access the response cookies using the cookies attribute. Example: import requests # Send a GET request response = requests.get(\u0026#39;https://api.github.com\u0026#39;) # Get the response cookies cookies = response.cookies print(cookies) ","permalink":"http://localhost:1313/posts/pages/python/python_request/","summary":"An in-depth exploration of Python request.","title":"Python Fundamentals: Understanding request (Part 8)"},{"content":"Python Fundamentals: Understanding File Handeling In Python programming, file handling is an essential operation that allows you to read, write, and manipulate files on your system. Files are used to store data permanently, and Python provides various functions and methods to work with files efficiently. In this guide, we will explore the basics of file handling in Python, including opening, reading, writing, and closing files.\n1.Context Manager Python provides a built-in way to manage resources and ensure that they are properly released when they are no longer needed. This is done using the with statement and is known as a context manager. When working with files, it is recommended to use the with statement to ensure that the file is properly closed after use.\n1.1. Using the with Statement The with statement in Python is used to create a context manager that automatically takes care of resource management. When working with files, the with statement ensures that the file is properly closed after use, even if an error occurs during file operations.\nExample:\nwith open(\u0026#34;example.txt\u0026#34;, \u0026#34;r\u0026#34;) as file: data = file.read() print(data) 2. Opening a File Before you can read or write to a file, you need to open it using the open() function. The open() function takes two arguments: the file path and the mode in which you want to open the file.\n2.1. Modes for Opening Files Python supports various modes for opening files, depending on the operations you want to perform. Some common modes include:\nr: Read mode. Opens the file for reading. The file must exist. w: Write mode. Opens the file for writing. If the file exists, it will be truncated. If the file does not exist, a new file will be created. a: Append mode. Opens the file for writing. If the file exists, the data will be appended to the end. If the file does not exist, a new file will be created. b: Binary mode. Opens the file in binary mode.use for image,video,etc as it will not convert the data to text .You can add b to any mode to open the file in binary mode like rb,wb,ab. t: Text mode. Opens the file in text mode (default). 2.2. Opening a File To open a file, you can use the open() function with the desired file path and mode. You can also specify additional parameters such as encoding, buffering, and newline characters.\nExample:\n# Open a file in read mode with open(\u0026#34;example.txt\u0026#34;, \u0026#34;r\u0026#34;) as file: data = file.read() print(data) 3. Reading from a File Once you have opened a file, you can read its contents using various methods provided by Python. The most common methods for reading from a file is read().\n# Open a file in read mode with open(\u0026#34;example.txt\u0026#34;, \u0026#34;r\u0026#34;) as file: data = file.read() print(data) 4. Writing to a File To write data to a file, you can use the write() method provided by Python. You can write text data to a file using the write() method.\nUsing w mode: # Open a file in write mode with open(\u0026#34;example.txt\u0026#34;, \u0026#34;w\u0026#34;) as file: file.write(\u0026#34;Hello, World!\u0026#34;) Using a mode: # Open a file in append mode with open(\u0026#34;example.txt\u0026#34;, \u0026#34;a\u0026#34;) as file: file.write(\u0026#34;Hello, World!\u0026#34;) 5.Context Manager Reference\nUse of Context Manager: In any programming language, the usage of resources like file operations or database connections is very common. But these resources are limited in supply. Therefore, the main problem lies in making sure to release these resources after usage. If they are not released then it will lead to resource leakage and may cause the system to either slow down or crash. It would be very helpful if users have a mechanism for the automatic setup and teardown of resources. In Python, it can be achieved by the usage of context managers which facilitate the proper handling of resources.\nWhat is happened When the with statement is executed, it will automatically call the __enter__ before entering the code block, and __exit__ after exiting the code block.\nHow to create a context manager To create a context manager, you need to define a class that implements the __enter__ and __exit__ methods. The __enter__ method is called when the with statement is executed, and the __exit__ method is called after the code block is executed.\nSyntax:\nclass MyContextManager: def __init__(self,params): # Code to initialize resources def __enter__(self): # Code to setup resources return self def __exit__(self, exc_type, exc_value, traceback): # Code to release resources Example:\n#implementatio of own file handeling context manager class MeroHandle: def __init__(self,filename,mode): self.filename = filename self.mode = mode def __enter__(self): self.file = open(self.filename,self.mode) return self.file def __exit__(self,exc_type,exc_value,traceback): self.file.close() #using the context manager with MeroHandle(\u0026#34;example.txt\u0026#34;,\u0026#34;r\u0026#34;) as file: data = file.read() print(data) Normal way of file handeling try: file = open(\u0026#34;example.txt\u0026#34;,\u0026#34;r\u0026#34;) data = file.read() print(data) file.close() except: print(\u0026#34;Error Occured\u0026#34;) Advantage of context manager Over normal code When we use normal code shown above then when error occured in try block before file.close() then it will not close the file(i.e file will not be closed) and it will lead to resource leakage . But when we use context manager then it will automatically close the file just because __exit__ method is called after the code block is executed whether error occured or not. but in normal code we can manage this by using finally block but it is not recommended as it is not pythonic way of doing things. try: file = open(\u0026#34;example.txt\u0026#34;,\u0026#34;r\u0026#34;) data = file.read() print(data) except: print(\u0026#34;Error Occured\u0026#34;) finally: file.close() This will work but it is not pythonic way of doing things.Just because we have to write whole try,except,finally block for just opening and closing the file. which make code more complex and lengthy.\n","permalink":"http://localhost:1313/posts/pages/python/python_filehandeling/","summary":"An in-depth look at File Handeling.","title":"Python Fundamentals: Understanding File Handeling (Part 9)"},{"content":"Python Fundamentals: Some Important Package to Know In Python programming, packages are collections of modules that provide additional functionality to your programs. Python has a rich ecosystem of packages that can help you perform a wide range of tasks, from data analysis and visualization to web development and machine learning. In this guide, we will explore some of the most important packages in Python that you should be familiar with.\n1.json The json package in Python provides functions for encoding and decoding JSON data. JSON (JavaScript Object Notation) is a lightweight data interchange format that is easy for humans to read and write and easy for machines to parse and generate. The json package allows you to work with JSON data in Python by converting Python objects to JSON strings and vice versa.\nConversion of Python dictionary to JSON string We can convert a Python dictionary to a JSON string using the json.dumps() function. This function takes a Python object as input and returns a JSON string representation of the object. Example:\nimport json # Create a Python dictionary data = { \u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34; } # Convert the dictionary to a JSON string json_string = json.dumps(data) print(json_string) Conversion of JSON string to Python dictionary We can convert a JSON string to a Python dictionary using the json.loads() function. This function takes a JSON string as input and returns a Python object (usually a dictionary) representing the JSON data. Example:\nimport json # JSON string json_string = \u0026#39;{\u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;}\u0026#39; # Convert the JSON string to a Python dictionary data = json.loads(json_string) print(data) 2.os The os package in Python provides functions for interacting with the operating system.You can get indepth knowladge of os using its own documentation.but the most common methods are:\nos.path.join(\u0026quot;C:\u0026quot;,\u0026quot;users\u0026quot;,\u0026quot;bin\u0026quot;): Join one or more path components intelligently. os.rename(\u0026quot;old\u0026quot;,\u0026quot;new\u0026quot;): Rename a file or directory. 3.time The time package in Python provides functions for working with time-related tasks. You can use the time package to get the current time, sleep for a specified duration, and measure the execution time of your code.\ntime.time(): Returns the current time in seconds since the epoch. time.sleep(seconds): Suspends the execution of the current thread for the given number of seconds. 4.uuid The uuid package in Python provides functions for generating and working with UUIDs (Universally Unique Identifiers). UUIDs are unique identifiers that are used to identify objects in a distributed computing environment. The uuid package allows you to generate UUIDs based on various algorithms and formats.\nGenerating a UUID You can generate a UUID using the uuid.uuid4() function, which generates a random UUID. Example:\nimport uuid # Generate a random UUID uuid_value = uuid.uuid4() print(uuid_value) 5.Datetime The datetime package in Python provides classes for working with dates and times. You can use the datetime package to create, manipulate, and format dates and times in your Python programs.\nCreating a datetime object You can create a datetime object using the datetime.datetime() constructor, which takes the year, month, day, hour, minute, second, and microsecond as input. Example:\nimport datetime # Create a datetime object dt = datetime.datetime(2022, 11, 27, 10, 30, 0) print(dt) Output:\n2022-11-27 10:30:00 get current date and time You can get the current date and time using the datetime.now() method. Example:\nimport datetime # Get the current date and time now = datetime.datetime.now() print(now) Output:\n2022-11-27 10:30:00 Formatting a datetime object some Properties of datetime object:\nyear: The year of the datetime object month: The month of the datetime object (1-12) day: The day of the datetime object (1-31) hour: The hour of the datetime object (0-23) minute: The minute of the datetime object (0-59) second: The second of the datetime object (0-59) import datetime # Create a datetime object dt = datetime.datetime.now() # Format the datetime object print(dt.month()) print(dt.day()) print(dt.year()) print(dt.hour()) print(dt.minute()) print(dt.second()) Output:\n11\r27\r2022\r10\r30\r0 ","permalink":"http://localhost:1313/posts/pages/python/python_extrapackage/","summary":"An in-depth look at frequently used important package.","title":"Python Fundamentals: Some Important Package to Know (Part 10)"},{"content":"Shared References in Python: How Changes Propagate Across Variables In Python, variables are references to objects in memory. When you assign a value to a variable, you are creating a reference to the object that holds that value. In some cases, multiple variables can refer to the same object in memory. This is known as a shared reference.\nMutability and Shared References in Python: How Changes Propagate Across Variables List Lists are mutable, so if two variables reference the same list, changes through one variable will affect the other.\n# Create a list list1 = [1, 2, 3] # Create a reference to the list list2 = list1 # Modify the list through one reference list2.append(4) # Check the original list print(list1) # Output: [1, 2, 3, 4] Dictionary Dictionaries are mutable as well. If two variables point to the same dictionary, any change made through one will reflect in the other.\n# Create a dictionary dict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30} # Create a reference to the dictionary dict2 = dict1 # Modify the dictionary through one reference dict2[\u0026#34;age\u0026#34;] = 31 # Check the original dictionary print(dict1) # Output: {\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 31} Set Sets are mutable, so changes made through one reference will affect the other if two variables point to the same set.\n# Create a set set1 = {1, 2, 3} # Create a reference to the set set2 = set1 # Modify the set through one reference set2.add(4) # Check the original set print(set1) # Output: {1, 2, 3, 4} Custom Objects\nclass Person: def __init__(self, name, age): self.name = name self.age = age # Create an instance of the Person class person1 = Person(\u0026#34;Alice\u0026#34;, 30) # Create a reference to the instance person2 = person1 # Modify the instance through one reference person2.age = 31 # Check the original instance print(person1.age) # Output: 31 Note: Mutable objects like lists, dictionaries, sets, and custom objects allow changes to propagate across variables that reference the same object. Immutable objects like integers, strings, and tuples do not exhibit this behavior.\n","permalink":"http://localhost:1313/posts/pages/python/python_shared_references/","summary":"An in-depth look at shared references in Python.","title":"Python Fundamentals : Shared References in Python (part 11)"},{"content":"Object oriented programming in python Object oriented programming is a programming paradigm that provides a means of structuring programs so that properties and behaviors are bundled into individual objects.\n1. Class and Object Class is a blueprint for creating objects (a particular data structure), providing initial values for state (member variables or attributes), and implementations of behavior (member functions or methods).\nObject is an instance of a class. When class is defined, only the description for the object is defined. Therefore, no memory or storage is allocated.\n1.1 Creating a class We can create a class using the class keyword followed by the class name. The class definition can contain class variables, instance variables, methods, and constructors.\nSyntax:\nclass ClassName: #code block Example:\nclass Person: name=\u0026#34;Nirajan\u0026#34; age=20 classes=\u0026#34;Bachelor\u0026#34; 1.2 Creating an object To create an object of a class, we use the class name followed by parentheses. This calls the constructor method of the class and returns an object.\nSyntax:\nobject_name = ClassName() Example:\nperson1 = Person() 1.3 Accessing class attributes We can access the attributes of a class using the dot operator (.) followed by the attribute name.\nSyntax:\nobject_name.attribute_name Example:\nprint(person1.name) # Output: Nirajan print(person1.age) # Output: 20 print(person1.classes) # Output: Bachelor 1.4 Modifying class attributes We can modify the attributes of a class using the dot operator (.) followed by the attribute name.\nSyntax:\nobject_name.attribute_name = new_value Example:\nperson1.age = 21 print(person1.age) # Output: 21 1.5 Creating a member function We can create a member function (method) inside a class using the def keyword followed by the function name. The first parameter of the method should be self, which refers to the current instance of the class.we will see about self in next part.\nSyntax:\nclass ClassName: def method_name(self, parameters): #code block Example:\nclass Person: name=\u0026#34;Nirajan\u0026#34; age=20 classes=\u0026#34;Bachelor\u0026#34; def display(self): print(f\u0026#34;Name: {self.name}\u0026#34;) print(f\u0026#34;Age: {self.age}\u0026#34;) print(f\u0026#34;Class: {self.classes}\u0026#34;) 1.6 Calling a member function We can call a member function of a class using the dot operator (.) followed by the function name and parentheses.\nSyntax:\nobject_name.method_name(arguments) Example:\nperson1.display() 1.7 Nested member function We can call a member function from another member function of the same class using the self keyword.\nSyntax:\nclass ClassName: def method1(self): #code block self.method2() def method2(self): #code block Example:\nclass Person: name=\u0026#34;Nirajan\u0026#34; age=20 classes=\u0026#34;Bachelor\u0026#34; def display(self): print(f\u0026#34;Name: {self.name}\u0026#34;) print(f\u0026#34;Age: {self.age}\u0026#34;) print(f\u0026#34;Class: {self.classes}\u0026#34;) self.greet() def greet(self): print(\u0026#34;Hello, Welcome to the class\u0026#34;) 1.8 self parameter The self parameter is a reference to the current instance of the class, and is used to access variables and methods of the class. It is the first parameter of any method in a class.\nSyntax:\nclass ClassName: def method_name(self, parameters): #code block Example:\nclass Person: name=\u0026#34;Nirajan\u0026#34; age=20 classes=\u0026#34;Bachelor\u0026#34; def display(self): print(f\u0026#34;Name: {self.name}\u0026#34;) print(f\u0026#34;Age: {self.age}\u0026#34;) print(f\u0026#34;Class: {self.classes}\u0026#34;) self.greet() def greet(self): print(\u0026#34;Hello, Welcome to the class\u0026#34;) 2. Constructor in Python A constructor is a special type of method (function) which is used to initialize the instance members of the class. It is called when an object of the class is created.\n2.1 Creating a constructor In Python, the constructor method is called __init__. It is a special method that is automatically called when an object is created.\nSyntax:\nclass ClassName: def __init__(self, parameters): #code block Example:\nclass Person: def __init__(self, name, age, classes): self.name = name self.age = age self.classes = classes def display(self): print(f\u0026#34;Name: {self.name}\u0026#34;) print(f\u0026#34;Age: {self.age}\u0026#34;) print(f\u0026#34;Class: {self.classes}\u0026#34;) 2.2 Creating an object with constructor When an object is created, the constructor method is automatically called with the arguments passed to the class.\nSyntax:\nobject_name = ClassName(arguments) Example:\nperson1 = Person(\u0026#34;Nirajan\u0026#34;, 20, \u0026#34;Bachelor\u0026#34;) 3. Getters and Setters in Python 3.1. Getters Getters are methods is implementes by using the @property decorator. They are specially used\nto act as an value ie data instead of a method. to access the value of a private attribute without directly accessing it. Syntax:\nclass ClassName: @property def method_name(self): #code block Example:\nclass Person: def __init__(self, name, age): self._name = name self._age = age @property def display(self): return f\u0026#34;Name: {self._name}, Age: {self._age}\u0026#34; person1 = Person(\u0026#34;Nirajan\u0026#34;, 20) print(person1.display) # Output: Name: Nirajan, Age: 20 3.2. Setters Setters are methods is implementes by using the @method_name.setter decorator. They are specially used\nto set the value of a private attribute without directly setting it. to perform validation before setting the value of an attribute. Syntax:\nclass ClassName: @method_name.setter def method_name(self, value): #code block Example:\nclass Person: def __init__(self, name, age): self._name = name self._age = age @property def display(self): return f\u0026#34;Name: {self._name}, Age: {self._age}\u0026#34; @display.setter def display(self, value): self._name, self._age = value.split(\u0026#34;,\u0026#34;) self._age = int(self._age) person1 = Person(\u0026#34;Nirajan\u0026#34;, 20) print(person1.display) # Output: Name: Nirajan, Age: 20 person1.display = \u0026#34;Alice, 30\u0026#34; print(person1.display) # Output: Name: Alice, Age: 30 4. Inheritance in Python Inheritance is a mechanism in which one class acquires the properties and behavior of another class. The class which inherits the properties and behavior is known as the child class, and the class whose properties and behavior are inherited is known as the parent class.\n4.1. Creating a child class To create a child class that inherits from a parent class, we specify the parent class in parentheses after the child class name.\nSyntax:\nclass ChildClassName(ParentClassName): #code block Example:\nclass Employee: def __init__(self,name,age,id): self.name=name self.age=age self.id=id def display(self): print(f\u0026#34;Name: {self.name}\u0026#34;) print(f\u0026#34;Age: {self.age}\u0026#34;) print(f\u0026#34;ID: {self.id}\u0026#34;) class Manager(Employee):# it has all the properties of Employee class so we can access the # properties of Employee class also its method using object of Manager class def task(self): self.display() print(\u0026#34;Assigning tasks to employees\u0026#34;) class Developer(Employee): # it has all the properties of Employee class so we can access # the properties of Employee class also its method using object of Developer class def task(self): self.display() print(\u0026#34;Developing software applications\u0026#34;) manager1 = Manager(\u0026#34;Alice\u0026#34;, 30, 101) manager1.task() developer1 = Developer(\u0026#34;Bob\u0026#34;, 25, 102) developer1.task() Note : Only public and protected members are inherited by the child class. Private members are not inherited by the child class.\n5.Ascess Specifiers in Python 5.1. Public members Public members are accessible from outside the class. They can be accessed using the dot operator (.) from outside the class.\nExample:\nclass Person: name = \u0026#34;Alice\u0026#34; # Public member person1 = Person() print(person1.name) # Output: Alice 5.2. Protected members Protected members are accessible within the class and its subclasses. They are denoted by a single underscore (_) before the member name.\nExample:\nclass Person: _age = 30 # Protected member class Student(Person): def display(self): print(self._age) # Accessing protected member student1 = Student() student1.display() # Output: 30 Example of protected variable and method\nclass Person: _name = \u0026#34;Alice\u0026#34; # Protected variable def _display(self): # Protected method print(f\u0026#34;Name: {self._name}\u0026#34;) class Student(Person): def display(self): self._display() # Accessing protected metho student1 = Student() student1.display() # Output: Name: Alice 5.3. Private members Private members are accessible only within the class. They are denoted by a double underscore (__) before the member name.\nExample:\nclass Person: __city = \u0026#34;New York\u0026#34; # Private member person1 = Person() print(person1.__city) # Error: \u0026#39;Person\u0026#39; object has no attribute \u0026#39;__city\u0026#39; Example of private variable and method\nclass Person: __name = \u0026#34;Alice\u0026#34; # Private variable def __display(self): # Private method print(f\u0026#34;Name: {self.__name}\u0026#34;) person1 = Person() print(person1.__name) # Error: \u0026#39;Person\u0026#39; object has no attribute \u0026#39;__name\u0026#39; person1.__display() # Error: \u0026#39;Person\u0026#39; object has no attribute \u0026#39;__display\u0026#39; Table of Access Specifiers in Python:\nAccess Specifier Accessible from class Accessible from subclass Accessible from outside class Public Yes Yes Yes Protected Yes Yes No Private Yes No No Static Method in Python Static Method is those method that can be called without creating an object of the class. They are defined using the @staticmethod decorator. They can be called using the class name . Syntax: class ClassName: @staticmethod def method_name(parameters): #code block Example:\nclass Calculator: @staticmethod def add(a, b): return a + b result = Calculator.add(5, 3) print(result) # Output: 8 #Can call using object also calculator = Calculator() result = calculator.add(5, 3) print(result) # Output: 8 #this is also valid but it is not recommended Class Method in Python They are defined using the @classmethod decorator.The useage of class method is to access the class variable and change class variable. ie when we change variable using class method it will change for all the object of the class.THey can be called using the class name. Syntax:\nclass ClassName: @classmethod def method_name(cls, parameters): #code block Example:\nclass copany : copany=\u0026#34;Google\u0026#34; @classmethod def change_company(cls,new_company): cls.copany=new_company print(copany.copany) #Output: Google copany.change_company(\u0026#34;Microsoft\u0026#34;) print(copany.copany) #Output: Microsoft c1=copany() print(c1.copany) #Output: Microsoft c1.change_company(\u0026#34;Apple\u0026#34;) c2=copany() print(c2.copany) #Output: Applex Dir and dict method in Python dir() method is used to return a list of attributes and methods of any object. It returns a list of valid attributes and methods of the object. Syntax:\ndir(object) Example:\nclass Person: name = \u0026#34;Alice\u0026#34; age = 30 person1 = Person() print(dir(person1)) # Output: [\u0026#39;__class__\u0026#39;, \u0026#39;__delattr__\u0026#39;, \u0026#39;__dict__\u0026#39;, \u0026#39;__dir__\u0026#39;, \u0026#39;__doc__\u0026#39;, \u0026#39;__eq__\u0026#39;, \u0026#39;__format__\u0026#39;, \u0026#39;__ge__\u0026#39;, \u0026#39;__getattribute__\u0026#39;, \u0026#39;__gt__\u0026#39;, \u0026#39;__hash__\u0026#39;, \u0026#39;__init__\u0026#39;, \u0026#39;__init_subclass__\u0026#39;, \u0026#39;__le__\u0026#39;, \u0026#39;__lt__\u0026#39;, \u0026#39;__module__\u0026#39;, \u0026#39;__ne__\u0026#39;, \u0026#39;__new__\u0026#39;, \u0026#39;__reduce__\u0026#39;, \u0026#39;__reduce_ex__\u0026#39;, \u0026#39;__repr__\u0026#39;, \u0026#39;__setattr__\u0026#39;, \u0026#39;__sizeof__\u0026#39;, \u0026#39;__str__\u0026#39;, \u0026#39;__subclasshook__\u0026#39;, \u0026#39;__weakref__\u0026#39;, \u0026#39;age\u0026#39;, \u0026#39;name\u0026#39;] Example:\nl=[1,2,3] print(dir(l)) # Output: [\u0026#39;__add__\u0026#39;, \u0026#39;__class__\u0026#39;, \u0026#39;__class_getitem__\u0026#39;, \u0026#39;__contains__\u0026#39;, \u0026#39;__delattr__\u0026#39;, \u0026#39;__delitem__\u0026#39;, \u0026#39;__dir__\u0026#39;, \u0026#39;__doc__\u0026#39;, \u0026#39;__eq__\u0026#39;, \u0026#39;__format__\u0026#39;, \u0026#39;__ge__\u0026#39;, \u0026#39;__getattribute__\u0026#39;, \u0026#39;__getitem__\u0026#39;, \u0026#39;__getstate__\u0026#39;, \u0026#39;__gt__\u0026#39;, \u0026#39;__hash__\u0026#39;, \u0026#39;__iadd__\u0026#39;, \u0026#39;__imul__\u0026#39;, \u0026#39;__init__\u0026#39;, \u0026#39;__init_subclass__\u0026#39;, \u0026#39;__iter__\u0026#39;, \u0026#39;__le__\u0026#39;, \u0026#39;__len__\u0026#39;, \u0026#39;__lt__\u0026#39;, \u0026#39;__mul__\u0026#39;, \u0026#39;__ne__\u0026#39;, \u0026#39;__new__\u0026#39;, \u0026#39;__reduce__\u0026#39;, \u0026#39;__reduce_ex__\u0026#39;, \u0026#39;__repr__\u0026#39;, \u0026#39;__reversed__\u0026#39;, \u0026#39;__rmul__\u0026#39;, \u0026#39;__setattr__\u0026#39;, \u0026#39;__setitem__\u0026#39;, \u0026#39;__sizeof__\u0026#39;, \u0026#39;__str__\u0026#39;, \u0026#39;__subclasshook__\u0026#39;, \u0026#39;append\u0026#39;, \u0026#39;clear\u0026#39;, \u0026#39;copy\u0026#39;, \u0026#39;count\u0026#39;, \u0026#39;extend\u0026#39;, \u0026#39;index\u0026#39;, \u0026#39;insert\u0026#39;, \u0026#39;pop\u0026#39;, \u0026#39;remove\u0026#39;, \u0026#39;reverse\u0026#39;, \u0026#39;sort\u0026#39;] __dict__ method is used to return a dictionary containing the attributes of an object. It returns a dictionary containing the attributes of the object.\nSyntax:\nobject.__dict__ Example:\nclass Person: name = \u0026#34;Alice\u0026#34; age = 30 person1 = Person() print(person1.__dict__) # Output: {\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 30} 9.super() method in Python When a parent class and a child class define a method with the same name, and we create an object of the child class, invoking the method on the child class object will execute the method defined in the child class, not the one in the parent class. To explicitly call the parent class\u0026rsquo;s method, we can use the super() function.\nTo explicitly invoke the parent class\u0026rsquo;s version of the method, the super() function is used. This is especially useful when the child class\u0026rsquo;s method needs to build upon or extend the functionality of the parent class\u0026rsquo;s method.\nSyntax:\nsuper().method_name() Example:\nclass Person: def display(self): print(\u0026#34;Person class\u0026#34;) class Student(Person): def display(self): super().display() print(\u0026#34;Student class\u0026#34;) student1 = Student() student1.display() # Output: # Person class # Student class Example:\nclass Person: def __init__(self,name,age): self.name=name self.age=age class Student(Person): def __init__(self,name,age,roll): super().__init__(name,age) self.roll=roll def display(self): print(f\u0026#34;Name: {self.name}\u0026#34;) print(f\u0026#34;Age: {self.age}\u0026#34;) print(f\u0026#34;Roll: {self.roll}\u0026#34;) student1 = Student(\u0026#34;Alice\u0026#34;, 30, 101) student1.display() # Output: # Name: Alice # Age: 30 # Roll: 101 Note: Use super for single inheritance only. For multiple inheritance, use the class name directly.\nMagic/dunder methods in Python Magic methods are special methods that have double underscores at the beginning and end of their names. They are also known as dunder methods (short for \u0026ldquo;double underscore\u0026rdquo;). Magic methods are used to define the behavior of objects. They are automatically called when certain operations are performed on objects. Some of the commonly used magic methods are:\n__init__: Constructor method, called when an object is created. __str__: Called by the str() built-in function to return a string representation of an object. __repr__: Called by the repr() built-in function to return an unambiguous string representation of an object. __add__: Called by the + operator to perform addition. __len__: Called by the len() built-in function to return the length of an object. __call__: Called when an object is called as a function. Note : All magic method can be seen using dir(objectname) method and we can override the magic method in our class.\nexample of all method:\nclass Person: def __init__(self, name, age): self.name = name self.age = age def __str__(self): return f\u0026#34;Name: {self.name}, Age: {self.age}\u0026#34; def __repr__(self): return f\u0026#34;Person(\u0026#39;{self.name}\u0026#39;, {self.age})\u0026#34; def __add__(self, other): return self.age + other.age def __len__(self): return len(self.name) def __call__(self): return f\u0026#34;Name: {self.name}, Age: {self.age}\u0026#34; person1 = Person(\u0026#34;Alice\u0026#34;, 30) person2 = Person(\u0026#34;Bob\u0026#34;, 25) print(person1) # Output: Name: Alice, Age: 30 print(repr(person1)) # Output: Person(\u0026#39;Alice\u0026#39;, 30) print(person1 + person2) # Output: 55 print(len(person1)) # Output: 5 print(person1()) # Output: Name: Alice, Age: 30 Method Overriding Method overriding is a feature of object-oriented programming that allows a subclass to provide a specific implementation of a method that is already provided by its parent class. When a method in a subclass has the same name, same parameters or signature, and same return type as a method in its parent class, then the method in the subclass is said to override the method in the parent class. Example:\nclass Person: def display(self): print(\u0026#34;Person class\u0026#34;) class Student(Person): def display(self): print(\u0026#34;Student class\u0026#34;) student1 = Student() student1.display() # Output: Student class We can also call the parent class\u0026rsquo;s method from the overridden method using the super() function.\nExample:\nclass Person: def display(self): print(\u0026#34;Person class\u0026#34;) class Student(Person): def display(self): super().display() #Or Person.display(self) print(\u0026#34;Student class\u0026#34;) student1 = Student() student1.display() # Output: # Person class # Student class Operator overloading in Python Operator overloading is a feature of object-oriented programming that allows us to define the behavior of operators for user-defined objects. It allows us to define the behavior of operators such as +, -, *, /, ==, !=, etc., for objects of a class. To overload an operator, we need to define a special method in the class that corresponds to the operator. These special methods are called magic methods or dunder methods.\nExample:\nclass Point: def __init__(self, x, y): self.x = x self.y = y def __add__(self, other): x = self.x + other.x y = self.y + other.y return Point(x, y) def __str__(self): return f\u0026#34;({self.x}, {self.y})\u0026#34; point1 = Point(1, 2) point2 = Point(3, 4) point3 = point1 + point2 print(point3) # Output: (4, 6) Types of Inheritance in Python Inheritance is a mechanism in which one class acquires the properties and behavior of another class. There are different types of inheritance in Python: Single Inheritance: In single inheritance, a class inherits from only one parent class. The pictorial representation of single inheritance is:\nA\r|\rB Syntax:\nclass ParentClass: #code block class ChildClass(ParentClass): #code block Example:\nclass Person: def __init__(self, name, age): self.name = name self.age = age def display(self): return f\u0026#34;Name: {self.name}, Age: {self.age}\u0026#34; def __str__(self): return f\u0026#34;Name: {self.name}, Age: {self.age}\u0026#34; def __repr__(self): return f\u0026#34;Person(\u0026#39;{self.name}\u0026#39;, {self.age})\u0026#34; def __call__(self): return f\u0026#34;Name: {self.name}, Age: {self.age}\u0026#34; class Student(Person): def __init__(self,naem,age,id): super().__init__(name,age) #or Person.__init__(self,name,age) self.id=id def display(self): print(f\u0026#34;ID: {self.id}\u0026#34;,super().display()) #or Person.display(self) student1 = Student(\u0026#34;Alice\u0026#34;, 30, 101) student1.display() # Output: # ID: 101 # Name: Alice, Age: 30 Multiple Inheritance: In multiple inheritance, a class inherits from more than one parent class. The pictorial representation of multiple inheritance is:\nA B\r\\ /\rC Syntax:\nclass ParentClass1: #code block class ParentClass2: #code block class ChildClass(ParentClass1, ParentClass2): #code block Example:\nclass Person: def __init__(self, name, age): self.name = name self.age = age def display(self): return f\u0026#34;Name: {self.name}, Age: {self.age}\u0026#34; class Address: def __init__(self,city,state): self.city=city self.state=state def display(self): return f\u0026#34;City: {self.city}, State: {self.state}\u0026#34; class Student(Person,Address): def __init__(self,name,age,id,city,state): Person.__init__(self,name,age) Address.__init__(self,city,state) self.id=id def display(self): print(f\u0026#34;ID: {self.id}\u0026#34;,Person.display(self),Address.display(self)) student1 = Student(\u0026#34;Alice\u0026#34;, 30, 101,\u0026#34;New York\u0026#34;,\u0026#34;New York\u0026#34;) student1.display() # Output: # ID: 101 # Name: Alice, Age: 30 # City: New York, State: New York Multilevel Inheritance: In multilevel inheritance, a class inherits from a parent class, and another class inherits from the child class. The pictorial representation of multilevel inheritance is:\nA\r|\rB\r|\rC Syntax:\nclass ParentClass: #code block class ChildClass(ParentClass): #code block class GrandChildClass(ChildClass): #code block Example:\nclass Person: def __init__(self, name, age): self.name = name self.age = age def display(self): return f\u0026#34;Name: {self.name}, Age: {self.age}\u0026#34; class Student(Person): def __init__(self,name,age,id): super().__init__(name,age) # or Person.__init__(self,name,age) self.id=id def display(self): print(f\u0026#34;ID: {self.id}\u0026#34;,super().display()) # print(f\u0026#34;ID: {self.id}\u0026#34;,Person.display(self)) class CollegeStudent(Student): def __init__(self,name,age,id,classes): super().__init__(name,age,id) #or Student.__init__(self,name,age,id) self.classes=classes def display(self): print(f\u0026#34;Class: {self.classes}\u0026#34;,super().display()) #or print(f\u0026#34;Class: {self.classes}\u0026#34;,Student.display(self)) student1 = CollegeStudent(\u0026#34;Alice\u0026#34;, 30, 101,\u0026#34;Bachelor\u0026#34;) student1.display() # Output: # Class: Bachelor # ID: 101 # Name: Alice, Age: 30 Hierarchical Inheritance: In hierarchical inheritance, more than one class inherits from a single parent class. The pictorial representation of hierarchical inheritance is:\nA\r/ \\\rB C Syntax:\nclass ParentClass: #code block class ChildClass1(ParentClass): #code block class ChildClass2(ParentClass): #code block Example:\nclass Person: def __init__(self, name, age): self.name = name self.age = age def display(self): return f\u0026#34;Name: {self.name}, Age: {self.age}\u0026#34; class Student(Person): def __init__(self,name,age,id): super().__init__(name,age) #or Person.__init__(self,name,age) self.id=id def display(self): print(f\u0026#34;ID: {self.id}\u0026#34;,super().display()) #or print(f\u0026#34;ID: {self.id}\u0026#34;,Person.display(self)) class Employee(Person): def __init__(self,name,age,emp_id): super().__init__(name,age) #or Person.__init__(self,name,age) self.emp_id=emp_id def display(self): print(f\u0026#34;Emp ID: {self.emp_id}\u0026#34;,super().display()) #or print(f\u0026#34;Emp ID: {self.emp_id}\u0026#34;,Person.display(self)) student1 = Student(\u0026#34;Alice\u0026#34;, 30, 101) student1.display() employee1 = Employee(\u0026#34;Bob\u0026#34;, 25, 201) employee1.display() # Output: # ID: 101 # Name: Alice, Age: 30 # Emp ID: 201 # Name: Bob, Age: 25 Note: Hybrid inheritance is a combination of two or more types of inheritance.\n14. MRO (Method Resolution Order) in Python Method Resolution Order (MRO) is the order in which methods are resolved in the inheritance hierarchy. It defines the order in which the base classes are searched when executing a method.\nfor example:\nclass C: f=\u0026#34;dirajan\u0026#34; class A(C): f=\u0026#34;nirajan\u0026#34; class B(C): f=\u0026#34;kirajan\u0026#34; class D(A,B): pass def display(self): print(self.f) d=D() print(D.__mro__) d.display() Output:\n(\u0026lt;class \u0026#39;__main__.D\u0026#39;\u0026gt;, \u0026lt;class \u0026#39;__main__.A\u0026#39;\u0026gt;, \u0026lt;class \u0026#39;__main__.B\u0026#39;\u0026gt;, \u0026lt;class \u0026#39;__main__.C\u0026#39;\u0026gt;, \u0026lt;class \u0026#39;object\u0026#39;\u0026gt;)\rnirajan It means it will search for the method in the order of D-\u0026gt;A-\u0026gt;B-\u0026gt;C-\u0026gt;object if the method is not found in the D it will search in A and so on. but if the method is found in the D it will not search in the A,B,C and object.\n15.Class Inside a Class in Python A class can be defined inside another class. The class inside the class is known as nested class. The nested class can access the attributes and methods of the outer class.\nSyntax:\nclass OuterClass: class InnerClass: #code block Example:\nclass OuterClass: def __init__(self): self.name = \u0026#34;Alice\u0026#34; self.age = 30 class InnerClass: def display(self, outer): print(f\u0026#34;Name: {outer.name}\u0026#34;) print(f\u0026#34;Age: {outer.age}\u0026#34;) outer1 = OuterClass() inner1 = outer1.InnerClass() inner1.display(outer1) # Output: # Name: Alice # Age: 30 16. Nested class in Python A class can be defined inside another class. The class inside the class is known as nested class. The nested class can access the attributes and methods of the outer class.\nSyntax:\nclass OuterClass: class InnerClass: #code block Creating an object of the nested class: Syntax:\nouter_object = OuterClass() inner_object = outer_object.InnerClass() Example:\nclass OuterClass: def __init__(self): self.name = \u0026#34;Alice\u0026#34; self.age = 30 class InnerClass: def display(self, outer): print(f\u0026#34;Name: {outer.name}\u0026#34;) print(f\u0026#34;Age: {outer.age}\u0026#34;) outer1 = OuterClass() inner1 = outer1.InnerClass() inner1.display(outer1) # Output: # Name: Alice # Age: 30 creating an object of the nested class inside the outer class:\nclass OuterClass: def __init__(self): self.name = \u0026#34;Alice\u0026#34; self.age = 30 self.inner = self.InnerClass() class InnerClass: def display(self, outer): print(f\u0026#34;Name: {outer.name}\u0026#34;) print(f\u0026#34;Age: {outer.age}\u0026#34;) outer1 = OuterClass() outer1.inner.display(outer1) # Output: # Name: Alice # Age: 30 ","permalink":"http://localhost:1313/posts/pages/python/python_object_oriented1/","summary":"This is the first part of series of Object Oriented Programming in Python","title":"Python Fundamentals: Exploring OOP (Part 12)"},{"content":"DOM (Document Object Model) Theory The DOM is a programming interface for HTML and XML documents. It represents the document as a tree structure where each node is an object representing a part of the document. This allows programming languages to interact with the document structure, style, and content.\n1. DOM Selection Methods a) document.getElementById() Selects an element by its ID attribute.\n\u0026lt;!-- HTML --\u0026gt; \u0026lt;div id=\u0026#34;myDiv\u0026#34;\u0026gt;Hello\u0026lt;/div\u0026gt; // JavaScript const element = document.getElementById(\u0026#39;myDiv\u0026#39;); console.log(element.innerText); // Output: // \u0026#34;Hello\u0026#34; b) document.getElementsByClassName() Returns a collection of elements with the specified class name.\n\u0026lt;!-- HTML --\u0026gt; \u0026lt;div class=\u0026#34;myClass\u0026#34;\u0026gt;Item 1\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;myClass\u0026#34;\u0026gt;Item 2\u0026lt;/div\u0026gt; // JavaScript const elements = document.getElementsByClassName(\u0026#39;myClass\u0026#39;); for (let i = 0; i \u0026lt; elements.length; i++) { console.log(elements[i].innerText); } // Output: // \u0026#34;Item 1\u0026#34; // \u0026#34;Item 2\u0026#34; c) document.getElementsByTagName() Returns a collection of elements with the specified tag name.\n\u0026lt;!-- HTML --\u0026gt; \u0026lt;p\u0026gt;Paragraph 1\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Paragraph 2\u0026lt;/p\u0026gt; // JavaScript const paragraphs = document.getElementsByTagName(\u0026#39;p\u0026#39;); for (let i = 0; i \u0026lt; paragraphs.length; i++) { console.log(paragraphs[i].innerText); // Output: // \u0026#34;Paragraph 1\u0026#34; // \u0026#34;Paragraph 2\u0026#34; d) document.querySelector() Returns the first element that matches the CSS selector.\n\u0026lt;!-- HTML --\u0026gt; \u0026lt;div class=\u0026#34;myClass\u0026#34;\u0026gt;First Element\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;myClass\u0026#34;\u0026gt;Second Element\u0026lt;/div\u0026gt; // JavaScript const firstElement = document.querySelector(\u0026#39;.myClass\u0026#39;); console.log(firstElement.innerText); // Output: // \u0026#34;First Element\u0026#34; e) document.querySelectorAll() Returns all elements that match the CSS selector.\n\u0026lt;!-- HTML --\u0026gt; \u0026lt;div class=\u0026#34;myClass\u0026#34;\u0026gt;First Element\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;myClass\u0026#34;\u0026gt;Second Element\u0026lt;/div\u0026gt; // JavaScript const allElements = document.querySelectorAll(\u0026#39;.myClass\u0026#39;); allElements.forEach(el =\u0026gt; console.log(el.innerText)); // Output: // \u0026#34;First Element\u0026#34; // \u0026#34;Second Element\u0026#34; 2. DOM Properties a) innerText Gets or sets the text content of an element.\n\u0026lt;!-- HTML --\u0026gt; \u0026lt;div id=\u0026#34;textElement\u0026#34;\u0026gt;Original Text\u0026lt;/div\u0026gt; // JavaScript const element = document.getElementById(\u0026#39;textElement\u0026#39;); element.innerText = \u0026#39;Hello World\u0026#39;; console.log(element.innerText); // Output: // \u0026#34;Hello World\u0026#34; b) innerHTML Gets or sets the HTML content of an element.\n\u0026lt;!-- HTML --\u0026gt; \u0026lt;div id=\u0026#34;htmlElement\u0026#34;\u0026gt;Original Content\u0026lt;/div\u0026gt; // JavaScript const element = document.getElementById(\u0026#39;htmlElement\u0026#39;); element.innerHTML = \u0026#39;\u0026lt;span\u0026gt;Hello World\u0026lt;/span\u0026gt;\u0026#39;; console.log(element.innerHTML); // Output: // \u0026#34;\u0026lt;span\u0026gt;Hello World\u0026lt;/span\u0026gt;\u0026#34; c) textContent Gets or sets the text content of a node and its descendants.\n\u0026lt;!-- HTML --\u0026gt; \u0026lt;div id=\u0026#34;contentElement\u0026#34;\u0026gt;Original Content\u0026lt;/div\u0026gt; // JavaScript const element = document.getElementById(\u0026#39;contentElement\u0026#39;); element.textContent = \u0026#39;Hello World\u0026#39;; console.log(element.textContent); // Output: // \u0026#34;Hello World\u0026#34; d) style Gets or sets inline styles of an element.\n\u0026lt;!-- HTML --\u0026gt; \u0026lt;div id=\u0026#34;styledElement\u0026#34;\u0026gt;Style Me\u0026lt;/div\u0026gt; // JavaScript const element = document.getElementById(\u0026#39;styledElement\u0026#39;); element.style.backgroundColor = \u0026#39;red\u0026#39;; element.style.fontSize = \u0026#39;16px\u0026#39;; // Result: Element with red background and font size of 16px 3. Events in JavaScript Events are actions that occur in a web page that can be detected by JavaScript.\nClick Event Example \u0026lt;!-- HTML --\u0026gt; \u0026lt;button id=\u0026#34;clickButton\u0026#34;\u0026gt;Click Me\u0026lt;/button\u0026gt; // JavaScript const button = document.getElementById(\u0026#39;clickButton\u0026#39;); button.addEventListener(\u0026#39;click\u0026#39;, function(e) { console.log(\u0026#39;Clicked!\u0026#39;); }); // Output when clicked: // \u0026#34;Clicked!\u0026#34; Mouse Over Event Example \u0026lt;!-- HTML --\u0026gt; \u0026lt;div id=\u0026#34;hoverElement\u0026#34;\u0026gt;Hover Over Me\u0026lt;/div\u0026gt; // JavaScript const element = document.getElementById(\u0026#39;hoverElement\u0026#39;); element.addEventListener(\u0026#39;mouseover\u0026#39;, function(e) { console.log(\u0026#39;Mouse over!\u0026#39;); }); // Output when hovered: // \u0026#34;Mouse over!\u0026#34; ","permalink":"http://localhost:1313/posts/pages/js/domevents/","summary":"A complete reference guide for DOM manipulation and Events","title":"Javascript : Dom and Events"},{"content":"Asynchronous Programming in JavaScript Asynchronous programming allows a program to perform multiple tasks simultaneously. It enables non-blocking operations, making it possible to execute long-running tasks without freezing the main program.\nFor example:\nconsole.log(\u0026#39;Start\u0026#39;); setTimeout(() =\u0026gt; { console.log(\u0026#39;This message is delayed by 2 seconds\u0026#39;); }, 2000); console.log(\u0026#39;End\u0026#39;); When you run this code, the output will be:\nStart\rEnd\rThis message is delayed by 2 seconds Explanation:\nconsole.log('Start'); is executed, and \u0026ldquo;Start\u0026rdquo; is printed. setTimeout() sets up a callback function to run after 2000 milliseconds (2 seconds) but does not block the next line. console.log('End'); is executed immediately after, and \u0026ldquo;End\u0026rdquo; is printed. After 2 seconds, the callback function in setTimeout() is executed, and \u0026ldquo;This message is delayed by 2 seconds\u0026rdquo; is printed. This demonstrates how asynchronous functions like setTimeout() work without blocking the execution of subsequent code.\nPromises Promises are a way to handle asynchronous operations in JavaScript. They represent a value that may be available now, in the future, or never. Promises can be in one of three states: pending, fulfilled, or rejected. They allow us to run code when the promise is fulfilled or rejected using the .then() and .catch() methods.\nSyntax to create a new Promise:\nconst promise = new Promise((resolve, reject) =\u0026gt; { // Perform an asynchronous operation // If successful, call resolve(value) // If an error occurs, call reject(error) }); Why We Use Promises Consider the following code:\nfunction main() { setTimeout(() =\u0026gt; { console.log(\u0026#34;Hello\u0026#34;); }, 1000); } main(); main(); main(); This code waits for 1 second and then logs \u0026ldquo;Hello\u0026rdquo; three times instantly. But what if we want to wait for the first to be completed before the second?\nThis can be solved using promises:\nfunction promise() { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { console.log(\u0026#34;Hello\u0026#34;); resolve(\u0026#34;Done\u0026#34;); }, 2000); }); } let data = promise(); When a promise is called, it returns a promise object instantly in a pending state. When the asynchronous operation completes, the promise is either fulfilled or rejected.\nHandling Promises To do a task when the promise is fulfilled (resolved):\ndata.then((data) =\u0026gt; { console.log(data); }); To do a task when the promise is rejected:\ndata.catch((err) =\u0026gt; { console.log(\u0026#34;Promise rejected\u0026#34;, err); }); Handling Multiple Promises function promise1() { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { console.log(\u0026#34;Promise 1 resolved\u0026#34;); resolve(\u0026#34;Done 1\u0026#34;); }, 2000); }); } function promise2() { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { console.log(\u0026#34;Promise 2 resolved\u0026#34;); resolve(\u0026#34;Done 2\u0026#34;); }, 2000); }); } function promise3() { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { console.log(\u0026#34;Promise 3 resolved\u0026#34;); resolve(\u0026#34;Done 3\u0026#34;); }, 2000); }); } let data1 = promise1(); let data2 = promise2(); let data3 = promise3(); How Promises Work:\npromise1 is called. promise2 is called immediately. promise3 is called immediately, regardless of whether the previous promises are resolved. To execute promises one by one:\nlet data1 = promise1(); data1.then((data) =\u0026gt; { console.log(data); return promise2(); }).then((data) =\u0026gt; { console.log(data); return promise3(); }).then((data) =\u0026gt; { console.log(data); }).catch((err) =\u0026gt; { console.log(\u0026#34;Error\u0026#34;, err); }); Here, the first promise will run, then the second, then the third, and so on, one by one.\nAsync and Await Async functions always return a promise. await is used to wait for a promise to be resolved, such that the code below it will not run until the promise is resolved.\nTo use await, we need to use an async function:\nasync function main() { console.log(\u0026#34;Hello\u0026#34;); } main(); Example with await:\nlet promise = new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { resolve(\u0026#34;Done\u0026#34;); }, 2000); }); async function main() { console.log(\u0026#34;Hello\u0026#34;); await promise; console.log(\u0026#34;Hello again\u0026#34;); } main(); console.log(\u0026#34;Hi\u0026#34;); What happens here is the main function is called, it prints \u0026ldquo;Hello\u0026rdquo;, then waits for 2 seconds to resolve. During that time, it prints \u0026ldquo;Hi\u0026rdquo;. When the promise is resolved, it prints \u0026ldquo;Hello again\u0026rdquo;.\nWhen await is called, the function pauses its execution until the promise is resolved. Then it continues the execution of the function, such that code below await will not run until the promise is resolved, but the code outside the function will run.\nasync function main() { console.log(\u0026#34;Hello\u0026#34;); await promise; await promise; await promise; console.log(\u0026#34;Hello again\u0026#34;); } Here, the first promise is resolved, then the second is resolved, and so on.\n","permalink":"http://localhost:1313/posts/pages/js/asyncronous/","summary":"A complete guide to asynchronous programming in JavaScript, covering promises and async/await.","title":"Asynchronous Programming in JavaScript"},{"content":"Basics of Vim Vim is a powerful text editor, often used in the command line, that is known for its efficiency and speed once mastered. Here are the basic commands and modes that you need to get started.\nOpening a File To open a file in Vim, use the following command:\nvim filename Replace filename with the name of the file you wish to open.\nBasic Modes in Vim Vim operates in different modes, and understanding these modes is crucial for using Vim effectively:\nNormal Mode: This is the default mode when you open a file. In this mode, you can navigate, delete, copy, and paste text. To return to Normal Mode from other modes, press Esc.\nInsert Mode: This mode allows you to insert text into the file. To enter Insert Mode, press i. After you\u0026rsquo;re done typing, press Esc to go back to Normal Mode.\nCommon Commands Here are some essential commands for working with files in Vim:\nSave the current file:\n:w This writes (saves) changes to the file.\nQuit Vim:\n:q To quit Vim. If there are unsaved changes, Vim will warn you. You can force quit without saving using:\n:q! Save changes and quit:\n:wq or\n:x These commands save changes and then exit Vim.\nTips for Beginners Press Esc frequently to return to Normal Mode, as it helps you avoid unintended actions while in other modes. Practice using both Normal and Insert modes to become comfortable with the flow of editing and saving files in Vim. Vim can be intimidating at first, but with practice, it becomes an extremely efficient tool for editing text files, especially in programming and development environments. ","permalink":"http://localhost:1313/posts/pages/linux/vim_basics_guide/","summary":"Learn the basics of using Vim, including navigation, saving, and quitting.","title":"Basics of Vim"},{"content":"Docker Cheat Sheet: Commands and Concepts This guide covers essential Docker commands, from creating containers, managing images, building Dockerfiles, to working with volumes.\n🚀 Creating and Running Containers 1. Run a Container from an Image To create and run a container from an image:\ndocker run image 2. Run a Container in Interactive Mode To run a container and open its terminal:\ndocker run -it image After the container starts, you can interact with it directly in the terminal. 3. Name a Container To give a container a specific name:\ndocker run --name container_name image 4. Port Mapping To map a port from your computer to the container:\ndocker run -p computer_port:container_port image Incoming traffic to computer_port will be forwarded to container_port in the container. 5. Run a Container in the Background (Detached Mode) To run the container in the background:\ndocker run -d image 6. Passing Environment Variables to a Container To pass environment variables to a container:\ndocker run -e key=value image 🛠️ Managing Containers 7. Start a Container To start an existing container:\ndocker start container_id 8. Stop a Container To stop a running container:\ndocker stop container_id 9. Remove a Container To remove a container:\ndocker rm container_id Note: The container must be stopped before removal. 10. Execute a Command in a Running Container To start a terminal session inside a running container:\ndocker exec -it container_id bash 11. View Running Containers To list all currently running containers:\ndocker ps 12. View All Containers (Running and Stopped) To see all containers, including those that are stopped:\ndocker ps -a 🧱 Building Docker Images 13. Creating a Dockerfile A Dockerfile is a script used to build Docker images. Here’s an example of common Dockerfile commands:\n# Set the base image for your container FROM base_image # Run commands during the image build process RUN command # Copy files from your local machine to the container COPY source /path/in/container # Set environment variables ENV key=value # Expose a port for the container EXPOSE 8080 # Define the command to run when the container starts CMD [\u0026#34;executable\u0026#34;] # Optionally, run commands automatically when the container starts ENTRYPOINT [\u0026#34;/path/to/script\u0026#34;] # Set the working directory in the container WORKDIR /app # Copy all files from the local directory to the container, excluding files listed in .dockerignore COPY . . 14. Building a Docker Image To build a Docker image from a Dockerfile:\ndocker build -t image_name /path/to/Dockerfile 📂 Managing Docker Files 15. Using the .dockerignore File The .dockerignore file helps exclude unnecessary files from being copied into the Docker image, improving build speed and reducing image size:\nnode_modules/ .git/ 16. COPY Command in Dockerfile The COPY command copies files from your local system to the container:\nCopy all files from the current directory to the container: COPY . /path/in/container Copy a specific file: COPY ./filename.extension /path/in/container Copy an entire folder: COPY ./foldername /path/in/container Copy contents of a folder (not the folder itself): COPY ./foldername/ /path/in/container 📦 Working with Volumes 17. Mounting Volumes Volumes allow data to persist even if the container is deleted. To mount a folder from your host to the container:\ndocker run -it -v /path/on/host:/path/in/container image Example: docker run -it -v /home/user/backup:/app/data ubuntu This will map /home/user/backup on your host to /app/data inside the container. Use Cases for Volumes: Data Persistence: Preserve data even after the container is removed. Backups: Easily back up container data to the host. Shared Data: Share data between multiple containers or between host and container. 💾 Publishing Docker Images 18. Pushing an Image to Docker Hub To publish an image to Docker Hub:\nTag the image with your Docker Hub username: docker tag image_name username/image_name Log in to Docker Hub: docker login Push the image to your repository: docker push username/image_name This guide gives you the essentials for working with Docker. With these commands, you\u0026rsquo;ll be able to manage containers, build images, use volumes, and more effectively.\n","permalink":"http://localhost:1313/posts/pages/docker/docker_basics/","summary":"A guide to understanding Docker commands and concepts.","title":"Docker Basic: Commands and Concepts"},{"content":"Docker Compose Documentation Introduction Docker Compose is a tool for defining and running multi-container Docker applications. With Docker Compose, you can use a YAML file to configure your application\u0026rsquo;s services and create and start all the services from your configuration with a single command.\nBasic docker-compose.yml Structure The docker-compose.yml file is where you define the services that make up your app. A typical file might look like this:\nversion: \u0026#39;3.8\u0026#39; services: service_name: image: image_name:tag ports: - \u0026#34;host_port:container_port\u0026#34; environment: - ENV_VAR=value volumes: - \u0026#34;host_path:container_path\u0026#34; depends_on: - dependency_service Example Configurations Example 1: Basic Setup with PostgreSQL and Redis version: \u0026#39;3.8\u0026#39; services: postgres: image: postgres ports: - \u0026#34;5432:5432\u0026#34; environment: POSTGRES_USER: postgres POSTGRES_DB: review POSTGRES_PASSWORD: password redis: image: redis ports: - \u0026#34;80:80\u0026#34; Example 2: Real-World Application version: \u0026#39;3\u0026#39; services: pythonapp: image: your-python-image:tag ports: - \u0026#34;8000:8000\u0026#34; volumes: - /Users/data:/src/bin/data depends_on: - db - redis db: image: postgres environment: POSTGRES_DB: mydatabase POSTGRES_USER: myuser POSTGRES_PASSWORD: mypassword redis: image: redis volumes: - /path/to/local/directory:/data Example 3: Building from Dockerfile version: \u0026#39;3\u0026#39; services: pythonapp: build: context: . dockerfile: Dockerfile ports: - \u0026#34;8000:8000\u0026#34; volumes: - /Users/desktop:/src/bin/desktop depends_on: - db - redis db: image: postgres environment: POSTGRES_DB: mydatabase POSTGRES_USER: myuser POSTGRES_PASSWORD: mypassword redis: image: redis volumes: - /path/to/local/directory:/data Example 4: Django Application with PostgreSQL and Redis version: \u0026#39;3.8\u0026#39; services: django-app: container_name: django-app image: django-app:latest # Replace with your actual Django image name/tag ports: - \u0026#34;8000:8000\u0026#34; # Expose Django app on port 8000 environment: - DEBUG=1 # Set Django debug mode to 1 for development - POSTGRES_HOST=postgres # PostgreSQL host - POSTGRES_DB_NAME=nirajan # PostgreSQL database name - POSTGRES_DB_PASSWORD=nirajan@9845 # PostgreSQL database password - REDIS_URL=redis://redis:6379/0 # Redis URL depends_on: - postgres - redis volumes: - static_volume:/code/static # Volume for Django static files - media_volume:/code/media # Volume for Django media files postgres: container_name: postgres image: postgres:latest environment: POSTGRES_DB: nirajan # Database name POSTGRES_USER: nirajan # Database username POSTGRES_PASSWORD: nirajan@9845 # Database password volumes: - postgres_data:/var/lib/postgresql/data redis: container_name: redis image: redis:latest ports: - \u0026#34;6379:6379\u0026#34; Service Names as Hostnames In Docker Compose, the names of the services defined in the docker-compose.yml file are used as hostnames for inter-service communication.\nService Names as Hostnames Each service name in the docker-compose.yml file acts as a hostname for that service. For example, in the configuration above:\nThe django-app service can connect to the postgres service using POSTGRES_HOST=postgres. The django-app service can connect to the redis service using REDIS_URL=redis://redis:6379/0. Example In the django-app service:\nPostgreSQL Host: POSTGRES_HOST=postgres — The Django app connects to the PostgreSQL service using the hostname postgres, which matches the name of the PostgreSQL service defined in Docker Compose. Redis Host: REDIS_URL=redis://redis:6379/0 — The Django app connects to the Redis service using the hostname redis, which matches the name of the Redis service defined in Docker Compose. Note: In Docker, services within a Docker Compose setup are typically connected to the same network by default. This allows containers to communicate with each other using service names as hostnames.\nDocker Compose Commands To start the containers defined in docker-compose.yml:\nsudo docker compose up To stop and remove all containers, networks, and volumes created by docker-compose up:\nsudo docker compose down To run the containers in the background (detached mode):\nsudo docker compose up -d Tips Use depends_on to specify dependencies between services. This ensures that the dependent services start in the correct order. Use volumes to persist data outside of your containers, which is especially useful for databases. Use environment variables to configure your services and avoid hardcoding sensitive information. Conclusion Docker Compose simplifies the process of managing multi-container Docker applications. By defining your services in a docker-compose.yml file, you can easily spin up your entire application stack with a single command. This guide provides a solid starting point for using Docker Compose to manage multi-container applications effectively.\n","permalink":"http://localhost:1313/posts/pages/docker/docker_compose/","summary":"Learn how to define and manage services in Docker Compose.","title":"Docker Compose Documentation"},{"content":"Docker CPU and Memory Limits When you want to control the CPU and memory usage of Docker containers, you can use specific options in both Docker CLI commands and Docker Compose files. Here\u0026rsquo;s a detailed guide on how to use these options:\nDocker CLI Commands Setting CPU Limits:\nOption: --cpus Usage: Specifies the number of CPUs that the container can use. Example: docker run --cpus=\u0026#34;1.5\u0026#34; my-image The --cpus option limits the container to 1.5 CPU cores. Setting Memory Limits:\nOption: --memory or -m\nUsage: Sets the maximum amount of memory the container can use.\nExample:\ndocker run --memory=\u0026#34;500m\u0026#34; my-image This command limits the container to 500MB of RAM. If the limit is exceeded, the container will be throttled or terminated.\nNote: The options take a positive integer followed by suffixes such as b, k, m, or g to indicate bytes, kilobytes, megabytes, or gigabytes.\nSoft Memory Limits:\nOption: --memory-reservation Example: docker run --memory=\u0026#34;1g\u0026#34; --memory-reservation=\u0026#34;512m\u0026#34; nginx This reserves 512MB of memory while setting a hard limit of 1GB. Docker Compose Configuration In Docker Compose, you can define resource limits under the deploy section for version 3.x or directly under the services section for version 2.x.\nSetting CPU and Memory Limits in Docker Compose (Version 2.x):\nversion: \u0026#39;2\u0026#39; services: my-service: image: my-image deploy: resources: limits: cpus: \u0026#39;1.5\u0026#39; memory: 500M This limits the service to 1.5 CPUs and 500MB of memory.\nSetting CPU and Memory Limits in Docker Compose (Version 3.x and above):\nversion: \u0026#39;3.8\u0026#39; services: my-service: image: my-image deploy: resources: limits: cpus: \u0026#39;1.5\u0026#39; memory: \u0026#39;500M\u0026#39; This limits the service to 1.5 CPUs and 500MB of memory.\nNotes: Swap Memory: You can enable swap memory using the --memory-swap option in CLI. For example:\ndocker run --memory=\u0026#34;512m\u0026#34; --memory-swap=\u0026#34;1g\u0026#34; nginx CPU Shares: Set CPU priorities between containers using --cpu-shares, with 1024 being the default.\nBy using these options, you can ensure that your Docker containers use resources efficiently, preventing them from overwhelming the host machine.\n","permalink":"http://localhost:1313/posts/pages/docker/docker_cpu_memory_limits_guide/","summary":"Control the CPU and memory usage of Docker containers with CLI and Docker Compose configurations.","title":"Docker CPU and Memory Limits"},{"content":"Docker Networking and Port Access In Docker, containers are isolated by default, meaning:\nContainers cannot access the host machine\u0026rsquo;s ports directly. Containers cannot access the ports of other containers directly. Container ports are not accessible from outside the host machine unless configured. 🛠️ Accessing Container Ports from Outside To access a container\u0026rsquo;s port from outside (e.g., from the host or another machine), you can use port mapping:\n1. Port Mapping docker run -p host_port:container_port imagename This command maps a container\u0026rsquo;s port to a port on the host machine. 2. Host Network To share the host\u0026rsquo;s network namespace with the container:\ndocker run --network host imagename 🌐 Accessing Container Ports from Another Container To allow inter-container communication, you need to create and use a custom Docker network.\nSteps: 1. Create a Docker Network docker network create my_network 2. Run Containers in the Same Network docker run --network my_network --name container1 imagename docker run --network my_network --name container2 imagename 3. Access One Container from Another Use the container name and port to access one container from another:\ncontainer1:port Example Scenario Create a Network docker network create my_network Run First Container docker run --network my_network --name webserver -d nginx Run Second Container docker run --network my_network --name client -it alpine /bin/sh Access Web Server from Client Inside the client container, use the following commands to access the web server: wget -qO- http://webserver or\ncurl http://webserver 📝 Important Notes Container-to-Container Access: Containers in the same custom network can communicate using their names as hostnames. Host Machine Access: Containers cannot directly access the host machine\u0026rsquo;s ports. External Access: Use port mapping or host networking to access container ports from outside the host machine. List Docker Networks To list all available Docker networks and verify the existence of custom networks:\ndocker network ls ","permalink":"http://localhost:1313/posts/pages/docker/docker_networking_guide/","summary":"Understanding Docker networking and inter-container communication.","title":"Docker Networking and Port Access"},{"content":" 1. Configure Git To set up your Git username and email globally on your machine:\ngit config --global user.name \u0026#34;username\u0026#34; # Set your Git username git config --global user.email \u0026#34;email\u0026#34; # Set your Git email git config --list # Display the current Git configuration (username and email) 2. Git Status and Git Clone Clone a remote repository to your local machine:\ngit clone \u0026lt;url\u0026gt; # Copy repository to the local machine Check the status of your local repository:\ngit status # Show the current status of the repository Git Status Breakdown: untracked: A new file that has not been added or committed. unstaged: A file that has been added but not committed. unchanged: No changes have been made. changed: Changes have been made but not yet added or committed. 3. Git Add and Commit Add specific files or all changes and commit them:\ngit add \u0026lt;filename\u0026gt; # Add a specific file to the staging area git add . # Add all changes (modified and untracked files) git commit -m \u0026#34;Your commit message\u0026#34; # Commit the changes with a message 4. Push Local Repo to Remote To upload your local repository changes to the remote repository:\ngit push [alias] [branch] # Push changes to a specific alias and branch git remote add \u0026lt;alias\u0026gt; \u0026lt;url\u0026gt; # Add a remote alias (e.g., \u0026#39;origin\u0026#39;) git push -u [alias] [branch] # Save the alias and branch for future pushes 5. Git Initialization Initialize a new Git repository:\ngit init # Initialize a new Git repository 6. Git Branches Manage Git branches with the following commands:\ngit branch # List all local branches git branch -m \u0026lt;oldbranch\u0026gt; \u0026lt;newbranch\u0026gt; # Rename a branch git checkout \u0026lt;branchname\u0026gt; # Switch to another branch git checkout -b \u0026lt;branchname\u0026gt; # Create and switch to a new branch git branch -d \u0026lt;branchname\u0026gt; # Delete a branch (ensure you\u0026#39;re not on it) git diff \u0026lt;branchname\u0026gt; # Compare the current branch with another 7. Git Merge Merge changes from one branch into another:\ngit merge \u0026lt;branchname\u0026gt; # Merge changes from \u0026lt;branchname\u0026gt; into the current branch 8. Pull Request and Syncing Changes To pull updates from the remote repository to your local one:\ngit pull # Pull the latest changes from the remote repository git pull [alias] [branch] # Pull changes from a specific alias and branch 9. Undoing Changes If You Have Only Added Changes: git reset \u0026lt;filename\u0026gt; # Unstage a file from the staging area git reset # Unstage all files that have been added If You Have Committed Changes: git reset HEAD~1 # Undo the last commit (one step back) git reset \u0026lt;commit_hash\u0026gt; # Reset to a specific commit hash git reset --hard \u0026lt;commit_hash\u0026gt; # Hard reset to a commit and reflect changes in your editor git log # View all commit hashes and logs 10. Forking Repositories When contributing to open-source projects, you can fork a repository, which creates a copy of the repo under your GitHub account. Afterward, you can make changes and submit a pull request:\n# Fork a repository on GitHub and clone it locally git clone \u0026lt;forked_repo_url\u0026gt; # Clone your forked repository Make changes, commit them, and push to your fork. Finally, create a pull request on GitHub to merge your changes into the original repository.\nIF ANY CONCEPT IS LAGGING THEN: Watch this helpful video\n","permalink":"http://localhost:1313/posts/pages/git/git-cheetsheet/","summary":"A brief tutorial on github recipe and git command","title":"Git Commands and Configuration Guide"},{"content":"How to Create Content for Hugo Using Markdown Hugo, a static site generator, uses Markdown (.md) files to generate content. In this guide, we will explain how you can create content for Hugo using Markdown.\n1. Front Matter Every Markdown file in Hugo requires front matter, which is metadata placed at the top of the file. It helps Hugo understand how to process the file.\nExample:\n--- title: \u0026#34;My First Hugo Post\u0026#34; date: 2024-10-18 tags: [\u0026#34;Hugo\u0026#34;, \u0026#34;Markdown\u0026#34;] summary: \u0026#34;A brief summary of the post.\u0026#34; --- 2. Headers Headers are used to organize content. Use one # for an H1 header, two ## for H2, and so on.\nExample:\n# H1 Header ## H2 Header ### H3 Header Output:\nH3 Header 3. Text Formatting Markdown supports several text formatting options:\nExample:\n**Bold Text** *Italic Text* ~~Strikethrough~~ Output: Bold Text\nItalic Text\nStrikethrough\n4. Spacing and Line Breaks In Markdown, you can create paragraphs by leaving a blank line between lines of text.\nExample:\nThis is the first paragraph. This is the second paragraph. Output: This is the first paragraph.\nThis is the second paragraph.\n5. Horizontal Rules You can create horizontal lines (dividers) using three or more dashes (---), asterisks (***), or underscores (___).\nExample:\n--- Output:\n6. Lists Create unordered lists with - or *, and ordered lists with numbers followed by periods.\nExample:\n- Item 1 - Item 2 1. First item 2. Second item Output:\nItem 1 Item 2 First item Second item 7. Links and Images Add links and images with square brackets [] and parentheses ().\nExample:\n[Hugo Documentation](https://gohugo.io) ![Hugo Logo](/images/hugo.webp) Output: Hugo Documentation\n8. Code Blocks For inline code, use backticks. For block code, use triple backticks.\nExample:\nInline code: `print(\u0026#34;Hello World\u0026#34;)` Output: Inline code: print(\u0026quot;Hello World\u0026quot;)\nExample:\nBlock Code: def hello(): print(\u0026#34;Hello, Hugo!\u0026#34;) def hello(): print(\u0026#34;Hello, Hugo!\u0026#34;) 9. Blockquotes Use the greater than symbol (\u0026gt;) to create blockquotes.\nExample:\n\u0026gt; This is a blockquote in Hugo. Output:\nThis is a blockquote in Hugo.\n10. Tables You can create tables using pipes | and dashes -.\nExample:\n| Column 1 | Column 2 | |----------|----------| | Row 1 | Data 1 | | Row 2 | Data 2 | Output:\nColumn 1 Column 2 Row 1 Data 1 Row 2 Data 2 11. Task Lists Create task lists by using square brackets []. An x in the brackets [x] marks a task as completed.\nExample:\n- [ ] Task 1 - [x] Task 2 (Completed) Output:\nTask 1 Task 2 (Completed) 12. Syntax Highlighting Hugo supports syntax highlighting for various programming languages. You can specify the language after the triple backticks(```).\nExample: Output:\ndef greet(): print(\u0026#34;Hello, Hugo!\u0026#34;) 12. Task Lists Create task lists by using square brackets []. An x in the brackets [x] marks a task as completed.\nExample:\n- [ ] Task 1 - [ ] Sub-task 1 - [x] Sub-task 2 (Completed) - [x] Task 2 (Completed) Output:\nTask 1 Sub-task 1 Sub-task 2 (Completed) Task 2 (Completed) 13. Escaping Special Characters To use special characters like #, escape them using a backslash \\.\nExample:\n\\# This is not a header Output: # This is not a header\n14. Backtick To display backtick use four space before it as\n``` 15. Consistency It\u0026rsquo;s important to maintain consistent formatting throughout your Markdown files to ensure a clean and readable structure.\nBy following these steps, you can effectively create well-formatted content for your Hugo site using Markdown.\n","permalink":"http://localhost:1313/posts/pages/hugo/markdown_hugo_content_guide/","summary":"A tutorial on creating content with Markdown in Hugo.","title":"How to Create Content for Hugo"},{"content":"JavaScript Reference Behavior: Objects and Arrays Introduction In JavaScript, both objects and arrays are considered reference types. This means that when you assign an object or an array to another variable, you’re not creating a new copy of that object or array. Instead, the new variable holds a reference to the original object or array in memory. Understanding this concept is crucial because it directly affects how data is manipulated and shared within your code.\nObject Reference Behavior 1. Overview When you work with objects in JavaScript, it\u0026rsquo;s essential to recognize that assigning an object to a new variable does not create a new object. Instead, it creates a reference to the original object. This means that any changes made through the new reference will affect the original object.\n2. Example const person = { name: \u0026#34;Alice\u0026#34;, address: { city: \u0026#34;Wonderland\u0026#34; } }; const newPerson = person.address; // newPerson now references the same object as person.address newPerson.city = \u0026#34;New Wonderland\u0026#34;; // modifying newPerson affects the original object console.log(person); // Output: { name: \u0026#39;Alice\u0026#39;, address: { city: \u0026#39;New Wonderland\u0026#39; } } ## JavaScript Reference Behavior: Objects and Arrays ### Introduction In JavaScript, both objects and arrays are considered reference types. This means that when you assign an object or an array to another variable, you’re not creating a new copy of that object or array. Instead, the new variable holds a reference to the original object or array in memory. Understanding this concept is crucial because it directly affects how data is manipulated and shared within your code. ### Object Reference Behavior #### 1. Overview When you work with objects in JavaScript, it\u0026#39;s essential to recognize that assigning an object to a new variable does not create a new object. Instead, it creates a reference to the original object. This means that any changes made through the new reference will affect the original object. #### 2. Example ```javascript const person = { name: \u0026#34;Alice\u0026#34;, address: { city: \u0026#34;Wonderland\u0026#34; } }; const newPerson = person.address; // newPerson now references the same object as person.address newPerson.city = \u0026#34;New Wonderland\u0026#34;; // modifying newPerson affects the original object console.log(person); // Output: { name: \u0026#39;Alice\u0026#39;, address: { city: \u0026#39;New Wonderland\u0026#39; } } 3. Explanation Object Reference: When you create const newPerson = person.address;, you\u0026rsquo;re not making a copy of the address object. Instead, newPerson references the same address object that person.address references. Thus, when you update newPerson.city = \u0026quot;New Wonderland\u0026quot;;, it directly modifies the person.address object because both newPerson and person.address are pointing to the same location in memory. Output: The console logs the person object, which now reflects the change: { name: 'Alice', address: { city: 'New Wonderland' } }. Array Reference Behavior 1. Overview Arrays in JavaScript behave similarly to objects in terms of reference handling. When you assign an array to another variable, you create a reference to the original array. As a result, any modifications through this reference will affect the original array.\n2. Example const numbers = [1, 2, 3]; const moreNumbers = numbers; // moreNumbers now references the same array as numbers moreNumbers[0] = 99; // modifying moreNumbers affects the original array console.log(numbers); // Output: [99, 2, 3] 3. Explanation Array Reference: When you create const moreNumbers = numbers;, you\u0026rsquo;re not creating a new array. Instead, moreNumbers becomes a reference to the same array that numbers references. Any changes to moreNumbers, such as moreNumbers[0] = 99, directly modify the numbers array because both variables point to the same array in memory. Output: The console logs the numbers array, which now reflects the change: [99, 2, 3]. Key Takeaways Reference Types: Both objects and arrays are reference types in JavaScript, meaning that variables assigned to them hold references to the same data in memory. Shared Modifications: Changes made to an object or array through one reference will affect all other references to that same object or array. Memory Efficiency: This reference behavior allows for memory-efficient data management but requires careful handling to avoid unintended side effects. JavaScript References with filter() and find() In JavaScript, the way references work with methods like filter() and find() is different, leading to distinct behaviors. Understanding these differences is crucial for working effectively with arrays and avoiding unintended side effects.\nfilter(): Creating a New Array 1. Overview The filter() method in JavaScript creates a new array that contains only the elements that satisfy the provided condition. This means that a new array is returned, and it does not affect the original array. However, if the elements in the array are objects, the references to these objects are retained, meaning any modifications to the objects in the new array will also affect the original array.\n2. Example const originalArray = [ { id: 1, name: \u0026#34;Alice\u0026#34; }, { id: 2, name: \u0026#34;Bob\u0026#34; }, { id: 3, name: \u0026#34;Charlie\u0026#34; } ]; const filteredArray = originalArray.filter(item =\u0026gt; item.id !== 2); // Modify an object in the filtered array filteredArray[0].name = \u0026#34;Alicia\u0026#34;; console.log(originalArray); // Output: [{ id: 1, name: \u0026#39;Alicia\u0026#39; }, { id: 2, name: \u0026#39;Bob\u0026#39; }, { id: 3, name: \u0026#39;Charlie\u0026#39; }] console.log(filteredArray); // Output: [{ id: 1, name: \u0026#39;Alicia\u0026#39; }, { id: 3, name: \u0026#39;Charlie\u0026#39; }] 3. Explanation New Array Creation: The filter() method creates a new array (filteredArray) that includes all elements from originalArray except the one with id 2. However, the objects within the new array are still references to the original objects in originalArray. Shared References: When you modify the name property of the first object in filteredArray (filteredArray[0].name = \u0026quot;Alicia\u0026quot;;), it also changes in originalArray because both arrays reference the same object in memory. Output: The original array shows that the name of the first object has been changed to \u0026ldquo;Alicia\u0026rdquo;, indicating that the object references are shared. find(): Returning a Single Element Reference 1. Overview The find() method returns the first element in the array that satisfies the provided condition. This element is not a copy but a reference to the original element in the array. As a result, any modification to this element directly affects the original array.\n2. Example const originalArray = [ { id: 1, name: \u0026#34;Alice\u0026#34; }, { id: 2, name: \u0026#34;Bob\u0026#34; }, { id: 3, name: \u0026#34;Charlie\u0026#34; } ]; const foundItem = originalArray.find(item =\u0026gt; item.id === 2); // Modify the found item foundItem.name = \u0026#34;Robert\u0026#34;; console.log(originalArray); // Output: [{ id: 1, name: \u0026#39;Alice\u0026#39; }, { id: 2, name: \u0026#39;Robert\u0026#39; }, { id: 3, name: \u0026#39;Charlie\u0026#39; }] console.log(foundItem); // Output: { id: 2, name: \u0026#39;Robert\u0026#39; } 3. Explanation Element Reference: The find() method returns a reference to the first element that meets the condition (item.id === 2). In this case, foundItem references the same object in memory as the element in originalArray with id: 2. Direct Modification: When you modify the name property of foundItem (foundItem.name = \u0026quot;Robert\u0026quot;;), it directly alters the corresponding object in originalArray because they are the same object in memory. Output: The original array now shows that the name of the object with id: 2 has been changed to \u0026ldquo;Robert\u0026rdquo;, demonstrating that the reference was modified. Key Differences Between filter() and find() New Array vs. Single Element: filter(): Returns a new array containing references to elements that meet the condition. find(): Returns a reference to the first element that meets the condition. Impact on Original Array: filter(): The original array remains unchanged, but the objects within the new array are still references to the original objects. find(): The original array can be directly modified through the returned element. Use Cases: Use filter() when you need a subset of the original array without altering it directly. Use find() when you need to retrieve and possibly modify a specific element from the array. Conclusion Understanding how references work with methods like filter() and find() is crucial in JavaScript. While filter() returns a new array that retains references to the original objects, find() returns a direct reference to a single element. Being aware of these behaviors helps prevent unintended modifications to your data.\n","permalink":"http://localhost:1313/posts/pages/js/referencebehavious/","summary":"Learn about reference types in JavaScript, including objects and arrays, and how methods like filter() and find() handle references.","title":"JavaScript Reference Behavior: Objects and Arrays"},{"content":"JavaScript Reference Guide 1. Console.log() Method Purpose: Prints output to the console, useful for debugging. Syntax: console.log(value); Example: const name = \u0026#39;John\u0026#39;; console.log(name); // Output: John 2. Variables: let, const let: Block-scoped variable that can be updated but not accessed before declaration.\nlet x = 10; if (true) { let x = 20; // Block-scoped console.log(x); // 20 } console.log(x); // 10 const: Block-scoped variable that cannot be reassigned and must be initialized when declared.\nconst pi = 3.14; // pi = 3.1415; // Error: Cannot reassign 3. JavaScript Data Types String\nExplanation: Represents a sequence of characters. Can be enclosed in single quotes, double quotes, or backticks (for template literals). Syntax: const str = 'Hello, World!'; Example: const greeting = \u0026#34;Hello, \u0026#34; + \u0026#34;World!\u0026#34;; // Output: Hello, World! Number\nExplanation: Represents both integer and floating-point numbers. JavaScript numbers range from -(2^53 - 1) to 2^53 - 1. Syntax: const num = 123; Example: const amount = 25; // Output: 25 BigInt\nExplanation: Represents integers with arbitrary precision. Denoted by appending an n to the end of the number. Syntax: const bigNum = 1234567890123456789012345678901234567890n; Example: const bigNumber = 1234567890123456789012345678901234567890n; Boolean\nExplanation: Represents a value that is either true or false. Syntax: const isTrue = true; Example: const isActive = Boolean(1); // Output: true Null\nExplanation: Represents the intentional absence of any value. Syntax: const emptyValue = null; Example: const noValue = null; Undefined\nExplanation: Represents a variable that has been declared but not assigned a value. Syntax: let uninitialized; Example: let value; console.log(value); // Output: undefined For Checking Data Type We Use: typeof variableName; 4. Explicit Type Conversion To String: String(value) or value.toString()\nlet str = String(123); // \u0026#39;123\u0026#39; To Number: Number(value), parseInt(value), or parseFloat(value)\nlet num = Number(\u0026#39;456\u0026#39;); // 456 To Boolean: Boolean(value)\nlet bool = Boolean(\u0026#39;hello\u0026#39;); // true 5. JavaScript Operators i) Comparison Operators Greater than: a \u0026gt; b Less than: a \u0026lt; b Greater than or equal to: a \u0026gt;= b Less than or equal to: a \u0026lt;= b Not equal to: a != b Equal to: a == b Strictly equal to: a === b Examples:\nconsole.log(\u0026#34;2\u0026#34; == 2); // true console.log(\u0026#34;2\u0026#34; === 2); // false ii) Logical Operators AND: operand1 \u0026amp;\u0026amp; operand2 OR: operand1 || operand2 NOT: !operand Examples:\nconsole.log(true \u0026amp;\u0026amp; false); // false console.log(true || false); // true console.log(!true); // false iii) Arithmetic Operators Addition: operand1 + operand2 Subtraction: operand1 - operand2 Multiplication: operand1 * operand2 Division: operand1 / operand2 Modulo: operand1 % operand2 Increment: operand++ Decrement: operand-- Examples:\nconsole.log(5 + 3); // 8 console.log(5 - 3); // 2 console.log(5 * 3); // 15 console.log(6 / 3); // 2 console.log(5 % 3); // 2 6. String Methods and Operations 1. Concatenation Explanation: Combines two or more strings into one. Syntax: string1 + string2 Returns: A new string combining the original strings. Example: let a = \u0026#39; My name is nirajan \u0026#39;; let b = \u0026#34;nirajan\u0026#34;; console.log(a + b + \u0026#34;Khatiwada\u0026#34;); // Output: \u0026#39; My name is nirajan nirajanKhatiwada\u0026#39; 2. Simple Form (String Boilerplate) Explanation: Uses template literals to embed expressions within a string. Syntax: ${expression} Returns: A new string with evaluated expressions. Example: let a = \u0026#39; My name is nirajan \u0026#39;; let b = \u0026#34;nirajan\u0026#34;; console.log(`${a}${b}khatiwada`); // Output: \u0026#39; My name is nirajan nirajankhatiwada\u0026#39; 3. Accessing Element of String Explanation: Retrieves the character at a specified index. Syntax: string[index] Returns: The character at the given index (or undefined if out of range). Example: let a = \u0026#39; My name is nirajan \u0026#39;; console.log(a[0]); // Output: \u0026#39; \u0026#39; 4. Finding Length of String Explanation: Gets the number of characters in the string. Syntax: string.length Returns: The length of the string as a number. Example: let a = \u0026#39; My name is nirajan \u0026#39;; console.log(a.length); // Output: 21 5. To Uppercase Explanation: Converts all characters in the string to uppercase. Syntax: string.toUpperCase() Returns: A new string with all characters in uppercase. Example: let a = \u0026#39; My name is nirajan \u0026#39;; console.log(a.toUpperCase()); // Output: \u0026#39; MY NAME IS NIRAJAN \u0026#39; 6. To Lowercase Explanation: Converts all characters in the string to lowercase. Syntax: string.toLowerCase() Returns: A new string with all characters in lowercase. Example: let a = \u0026#39; My name is nirajan \u0026#39;; console.log(a.toLowerCase()); // Output: \u0026#39; my name is nirajan \u0026#39; 8. String Slicing Explanation: Extracts a section of the string based on start and end indices. Syntax: string.slice(start, end) Returns: A new string containing the extracted section. Example: let a = \u0026#39; My name is nirajan \u0026#39;; console.log(a.slice(0, 4)); // Output: \u0026#39; My\u0026#39; 9. Trim Explanation: Removes whitespace from both ends of the string. Syntax: string.trim() Returns: A new string with whitespace removed from both ends. Example: let a = \u0026#39; My name is nirajan \u0026#39;; console.log(a.trim()); // Output: \u0026#39;My name is nirajan\u0026#39; 10. Replace Explanation: Replaces the first occurrence of a specified substring or pattern with a new substring. Syntax: string.replace(search, replacement) Returns: A new string with the specified substring replaced. Example: let a = \u0026#39; My name is nirajan \u0026#39;; console.log(a.replace(\u0026#34;nirajan\u0026#34;, \u0026#34;kirajan\u0026#34;)); // Output: \u0026#39; My name is kirajan \u0026#39; 11. Split Explanation: Splits the string into an array of substrings based on a separator. Syntax: string.split(separator, limit) Returns: An array of substrings. Example: let a = \u0026#39; My name is nirajan \u0026#39;; console.log(a.split(\u0026#34; \u0026#34;)); // Output: [\u0026#39; My\u0026#39;, \u0026#39;name\u0026#39;, \u0026#39;is\u0026#39;, \u0026#39;nirajan\u0026#39;] 7. Number Methods 1. toFixed() Explanation: Formats a number using fixed-point notation with a specified number of decimal places. Syntax: number.toFixed(digits); Returns: A string representing the number with the specified number of decimal places. Example: let c = 10.001; console.log(c.toFixed(10)); // Output: \u0026#39;10.0010000000\u0026#39; 2. Math.ceil() Explanation: Rounds a number up to the nearest integer. Syntax: Math.ceil(number); Returns: The smallest integer greater than or equal to the given number. Example: let a = 1.1000; console.log(Math.ceil(a)); // Output: 2 3. Math.floor() Explanation: Rounds a number down to the nearest integer. Syntax: Math.floor(number); Returns: The largest integer less than or equal to the given number. Example: console.log(Math.floor(a)); // Output: 1 4. Math.round() Explanation: Rounds a number to the nearest integer. Syntax: Math.round(number); Returns: The value of the number rounded to the nearest integer. Example: console.log(Math.round(a)); // Output: 1 5. Math.random() Explanation: Returns a pseudo-random floating-point number between 0 (inclusive) and 1 (exclusive). Syntax: Math.random(); Returns: A floating-point number between 0 (inclusive) and 1 (exclusive). Example: console.log(Math.random()); // Output: A random number between 0 and 1 8. Non-Primitive Data Types in JavaScript 1. Object Explanation: Objects are collections of key-value pairs. Keys are usually strings (or symbols) and values can be any data type. Syntax: let objectName = { key1: value1, key2: value2, // more key-value pairs }; Example: let data = { \u0026#34;name\u0026#34;: \u0026#34;nirajan\u0026#34;, \u0026#34;age\u0026#34;: 20 }; 2. Array Explanation: Arrays are ordered collections of values. Values can be of any data type and are accessed by their index. Syntax: let arrayName = [value1, value2, value3, ...]; Example: let a = [\u0026#34;nirajan\u0026#34;, \u0026#34;kirajan\u0026#34;, \u0026#34;birajan\u0026#34;]; 3. Function Explanation: Functions are blocks of code designed to perform a particular task. They can be invoked (called) to execute their code. Syntax: function functionName(parameters) { // code to be executed } Example: function outer() { console.log(\u0026#34;hi\u0026#34;); } outer(); // Output: hi 9. Array Methods 1. Indexing in Array Accessing Elements: Description: Arrays are zero-indexed, so the first element is at index 0. Returns: Value of the element at the specified index. Example: console.log(a[0]); // Output: 1 console.log(a[3]); // Output: 4 2. Slicing in Array Slicing: Description: Extracts a section of the array and returns it as a new array. Syntax: array.slice(startIndex, endIndex) Returns: A new array containing the elements from startIndex up to, but not including, endIndex. Example: console.log(a.slice(0, 2)); // Output: [1, 2] 3. Length of Array Description: Returns the number of elements in the array. Returns: Integer (length of the array). Example: console.log(a.length); // Output: 4 4. Push Description: Adds one or more elements to the end of the array. Returns: The new length of the array. Example: a.push(5); console.log(a); // Output: [1, 2, 3, 4, 5] 5. Pop Description: Removes the last element from the array. Returns: The removed element. Example: a.pop(); console.log(a); // Output: [1, 2, 3, 4] 6. Shift Description: Removes the first element from the array. Returns: The removed element. Example: a.shift(); console.log(a); // Output: [2, 3, 4] 7. Unshift Description: Adds one or more elements to the beginning of the array. Returns: The new length of the array. Example: a.unshift(0); console.log(a); // Output: [0, 1, 2, 3, 4] 8. Join Description: Joins all elements of an array into a string, separated by a specified separator. Returns: A string representing the array elements joined by the specified separator. Example: let data = a.join(\u0026#34; \u0026#34;); console.log(data); // Output: \u0026#34;1 2 3 4\u0026#34; 9. Concatenation of Two Arrays Description: Merges two or more arrays into one. Returns: A new array containing the elements of the original arrays. Example: let a2 = [5, 4, 1, 3, 4]; console.log(a.concat(a2)); // Output: [1, 2, 3, 4, 5, 4, 1, 3, 4] 10. Sort Description: Sorts the elements of an array in place. Returns: The sorted array. Example: a2.sort(); console.log(a2); // Output: [1, 3, 4, 4, 5] 11. Reverse Description: Reverses the order of the elements in the array. Returns: The reversed array. Example: a2.reverse(); console.log(a2); // Output: [5, 4, 4, 3, 1] 12. Removing Elements from a Specific Position Description: Changes the contents of an array by removing or replacing existing elements. Syntax: array.splice(index, numberOfElementsToRemove) Returns: An array containing the removed elements. Example: let newData = [1, 2, 3, 4]; newData.splice(1, 2); // Removes 2 elements starting at index 1 console.log(newData); // Output: [1, 4] 13. Inserting Elements at a Specific Position Description: Inserts elements into the array. Syntax: array.splice(index, 0, element1, element2, ...) Returns: An array containing the removed elements (empty if no elements were removed). Example: let lasrData = [1, 4]; lasrData.splice(1, 0, 2, 3); // Inserts elements 2 and 3 at index 1 console.log(lasrData); // Output: [1, 2, 3, 4] 14. Spread Operator (\u0026hellip;) Description: Spreads out elements of an array into another array or function arguments. Returns: A new array containing the elements spread from the original arrays. Example: let finalData = [...newData, ...lasrData]; console.log(finalData); // Output: [1, 4, 1, 2, 3, 4] 15. Array Destructuring Description: Allows unpacking values from arrays into distinct variables in a concise and readable way. Basic Syntax: const [var1, var2, var3] = array; Example: const numbers = [1, 2, 3]; const [first, second, third] = numbers; console.log(first); // Output: 1 console.log(second); // Output: 2 console.log(third); // Output: 3 10. Object in Js i. Defining an Object An object in JavaScript is a collection of key-value pairs. Each key (also known as a property) is a unique identifier, and the value can be anything: a string, number, array, function, or even another object. Example:\nconst myObject = { name: \u0026#34;Nirajan\u0026#34;, // String property class: \u0026#34;Bachelor\u0026#34;, // String property is_topper: \u0026#34;No\u0026#34;, // Boolean property (as a string) greet: function (from) { // Method (function inside an object) console.log(`Welcome ${this.name}. From ${from}`); } }; ii. Accessing There are two common ways to access properties in an object:\nDot Notation: console.log(myObject.name); // Output: nirajan This is the most common and preferred method when you know the property name in advance. Bracket Notation: console.log(myObject[\u0026#39;name\u0026#39;]); // Output: nirajan Bracket notation is useful when the property name is stored in a variable or when it contains special characters or spaces. iii. Modifying Object Properties You can modify an object\u0026rsquo;s properties using dot or bracket notation:\nDot Notation: Use when you know the property name.\nmyObject.name = \u0026#34;Kirajan\u0026#34;; // Modifies the \u0026#39;name\u0026#39; property Bracket Notation: Use when the property name is dynamic or contains special characters.\nmyObject[\u0026#39;class\u0026#39;] = \u0026#34;Master\u0026#39;s\u0026#34;; // Modifies the \u0026#39;class\u0026#39; property iv. Adding New Properties You can dynamically add new key-value pairs to an object.\nmyObject.lol = \u0026#34;lol\u0026#34;; console.log(myObject.lol); // Output: lol v. Using the this Keyword The this keyword inside an object’s method refers to the object itself, allowing you to access its properties. Example:\nconst person = { name: \u0026#34;Kirajan\u0026#34;, greet: function() { console.log(`Hello, my name is ${this.name}`); } }; person.greet(); // Output: Hello, my name is Kirajan vi. Objects Inside Objects Objects can contain other objects, allowing you to create complex data structures. Example:\nconst a = { details: { name: \u0026#34;Nirajan\u0026#34;, age: 20 } }; console.log(a.details.name); // Output: Nirajan vii. Spread Operator (\u0026hellip;) The spread operator lets you copy, merge, or combine objects efficiently.\nCopying Properties: const original = { name: \u0026#34;Kirajan\u0026#34;, class: \u0026#34;Bachelor\u0026#34; }; const copy = { ...original }; console.log(copy); // Output: { name: \u0026#34;Kirajan\u0026#34;, class: \u0026#34;Bachelor\u0026#34; } Merging Objects: const info1 = { name: \u0026#34;Kirajan\u0026#34;, class: \u0026#34;Bachelor\u0026#34; }; const info2 = { age: 21, is_topper: true }; const combined = { ...info1, ...info2 }; console.log(combined); // Output: { name: \u0026#34;Kirajan\u0026#34;, class: \u0026#34;Bachelor\u0026#34;, age: 21, is_topper: true } viii. Object Destructuring Destructuring allows you to extract properties from an object and assign them to variables. Example:\nconst lol = { name: \u0026#34;Nirajan\u0026#34;, class: 12, rollno: \u0026#34;11\u0026#34; }; const { name, rollno } = lol; console.log(name); // Output: Nirajan console.log(rollno); // Output: 11 Also, Renaming in Destructuring: const lol = { name: \u0026#34;Nirajan\u0026#34;, class: 12, rollno: \u0026#34;11\u0026#34; }; const { name: studentName, rollno: studentRollNo } = lol; console.log(studentName); // Output: Nirajan console.log(studentRollNo); // Output: 11 ix. Object Methods Objects can have methods—functions that are properties of the object. These methods can perform actions using the object’s data. Example:\nconst calculator = { add: function(a, b) { return a + b; }, subtract: function(a, b) { return a - b; } }; console.log(calculator.add(5, 3)); // Output: 8 console.log(calculator.subtract(5, 3)); // Output: 2 11. JavaScript Functions Function Definitions: Function Expression: const add1 = function(a, b) { return a + b; }; Creates a function and assigns it to a variable. You call the function using the variable name. Arrow Function: const add2 = (a, b) =\u0026gt; { return a + b; }; Provides a shorter syntax and does not have its own this context. Function Declaration: function add3(a, b) { return a + b; } Defines a function with a name. It is hoisted, so it can be called before its declaration. Comparison: add3 has its own this context, while add1 and add2 do not. Using the Spread Operator: function add(...data) { let sum = 0; for (let i = 0; i \u0026lt; data.length; i++) { sum += data[i]; } return sum; } console.log(add(1, 2, 3)); // Output: 6 The ...data syntax lets the function accept any number of arguments as an array.\nImmediately Invoked Function Expression (IIFE): ( function add(a, b) { console.log(a + b); } )(2, 3); // Output: 5 An IIFE is a function that runs immediately after its definition, creating a local scope to avoid affecting the global scope.\n12. Control Flow in JavaScript Conditional Statements: if-else Statement: Executes code blocks based on a condition. let a = 2; if (a === 1) { console.log(1); } else if (a === 2) { console.log(2); } else { console.log(\u0026#34;None\u0026#34;); } Truthy and Falsy Values: Falsy Values: Values that evaluate to false in a boolean context. console.log(Boolean(false)); // false console.log(Boolean(0)); // false console.log(Boolean(-0)); // false console.log(Boolean(0n)); // false console.log(Boolean(\u0026#34;\u0026#34;)); // false console.log(Boolean(null)); // false console.log(Boolean(undefined)); // false console.log(Boolean(NaN)); // false Truthy Values: Any value that is not falsy. console.log(Boolean(true)); // true console.log(Boolean(1)); // true console.log(Boolean(-1)); // true console.log(Boolean(\u0026#34;hello\u0026#34;)); // true console.log(Boolean(\u0026#34; \u0026#34;)); // true console.log(Boolean({})); // true console.log(Boolean([])); // true console.log(Boolean(function() {})); // true console.log(Boolean(Symbol())); // true console.log(Boolean(1n)); // true Nullish Coalescing Operator (??): Provides a default value when dealing with null or undefined. let val1 = null; let val2 = val1 ?? 10; console.log(val2); // Output: 10 Ternary Operator (?:): A shorthand for the if-else statement. let c = 10; let b = 10; let largest = (c \u0026gt; b) ? c : b; console.log(largest); // Output: 10 13. Loops in JavaScript For Loop // Syntax: for(initialization; condition; increment/decrement) { ... } for (let i = 0; i \u0026lt; 10; i++) { console.log(i); } While Loop // Syntax: while(condition) { ... } let i = 0; while (i \u0026lt; 10) { console.log(i); i++; } Do-While Loop // Syntax: do { ... } while(condition); let i = 0; do { console.log(i); i++; } while (i \u0026lt; 10); For-Of Loop Usage: Iterates over arrays and strings const array = [1, 2, 3]; for (const x of array) { console.log(x); } For-In Loop Usage: Iterates over the properties of an object, indices of an array, or characters of a string const obj = { \u0026#34;name\u0026#34;: \u0026#34;nirajan\u0026#34;, \u0026#34;lol\u0026#34;: \u0026#34;lol\u0026#34; }; const arr = [\u0026#34;nirajan\u0026#34;, \u0026#34;lol\u0026#34;]; const str = \u0026#34;mynameisnirajan\u0026#34;; for (const key in obj) { console.log(key); // Prints the keys of the object } for (const index in arr) { console.log(arr[index]); // Prints the values of the array } for (const index in str) { console.log(str[index]); // Prints the characters of the string } For-Each Loop Usage: Iterates over array elements const array = [1, 2, 3]; array.forEach((data) =\u0026gt; { console.log(data); }); Break and Continue Statements break: Exits the loop continue: Skips the current iteration and continues with the next iteration 14. Map, Filter, and Reduce in JavaScript i. filter() Purpose: Creates a new array with elements that pass a test. Example: To get all odd numbers from an array: const a = [1, 2, 3, 4, 5, 6]; const filtered = a.filter(num =\u0026gt; num % 2); // [1, 3, 5] ii. map() Method Purpose: map() creates a new array populated with the results of calling a provided function on every element in the calling array. It’s used to transform each element in the array. Example: Create an array of squares from an existing array. const a = [1, 2, 3, 4, 5, 6]; const squares = a.map((num) =\u0026gt; num * num); console.log(squares); // Output: [1, 4, 9, 16, 25, 36] Here, the function num * num is applied to each element, resulting in a new array of squared numbers. iii. reduce() Method Purpose: reduce() executes a reducer function on each element of the array, resulting in a single output value. It’s used to accumulate or combine values from the array into a single result. Example: Sum up all the numbers in the array. const a = [1, 2, 3, 4, 5, 6]; const sum = a.reduce((accumulator, currentValue) =\u0026gt; accumulator + currentValue, 0); console.log(sum); // Output: 21 Here, accumulator starts at 0 and currentValue iterates over each element, summing them up. iv. Method Chaining Purpose: You can chain filter(), map(), and other array methods together to perform multiple operations in a single, readable statement. Example: Filter out odd numbers and then square them. const a = [1, 2, 3, 4, 5, 6]; const result = a.filter((num) =\u0026gt; num % 2) .map((num) =\u0026gt; num * num); console.log(result); // Output: [1, 9, 25] Here, filter() first selects the odd numbers, and then map() squares those numbers, producing a new array with the squared values of the odd numbers. Summary filter(): Selects elements that meet a specific condition. map(): Transforms elements based on a function. reduce(): Reduces the array to a single value based on a function. Method Chaining: Combines multiple array operations in a concise and readable manner. These methods are powerful tools for processing and transforming arrays in JavaScript. 15. Importing and Exporting in JavaScript Default Export Only one default export is allowed per module. Use for the primary function, class, or object in a module. // utils.js export default function primaryFunction() { console.log(\u0026#34;This is the primary function\u0026#34;); } // main.js import primaryFunction from \u0026#39;./utils.js\u0026#39;; primaryFunction(); // Output: This is the primary function Named Export Allows multiple exports per module. Use to export multiple functions, variables, or objects. // utils.js function function1() { console.log(\u0026#34;This is function1\u0026#34;); } function function2() { console.log(\u0026#34;This is function2\u0026#34;); } export { function1, function2 }; // main.js import { function1, function2 } from \u0026#39;./utils.js\u0026#39;; function1(); // Output: This is function1 function2(); // Output: This is function2 Summary Default Export: One per module, no curly braces during import. Named Export: Multiple per module, use curly braces during import. 16. Error Handling Try-catch blocks are used to handle errors gracefully.\ntry { // Code that might throw an error let result = nonExistentFunction(); } catch (error) { // Code to handle the error console.log(\u0026#39;An error occurred:\u0026#39;, error.message); } finally { // Code that always executes console.log(\u0026#39;This always executes\u0026#39;); } // Output: // \u0026#34;An error occurred: nonExistentFunction is not defined\u0026#34; // \u0026#34;This always executes\u0026#34; 16.1. Custom Error Throwing You can throw custom errors using the throw statement.\nfunction divide(a, b) { if (b === 0) { throw new Error(\u0026#39;Division by zero is not allowed\u0026#39;); } return a / b; } try { console.log(divide(4, 2)); console.log(divide(4, 0)); } catch (error) { console.log(\u0026#39;Error:\u0026#39;, error.message); } // Output: // 2 // \u0026#34;Error: Division by zero is not allowed\u0026#34; 17. Timers setTimeout Schedules a function to be executed after a specified delay (in milliseconds).\nconst timeoutId = setTimeout(() =\u0026gt; { console.log(\u0026#39;Executed after 1 second\u0026#39;); }, 1000); setInterval Repeatedly executes a function at specified intervals (in milliseconds).\nconst intervalId = setInterval((a, b) =\u0026gt; { console.log(a); // Output: hi console.log(b); // Output: oi }, 20, \u0026#34;hi\u0026#34;, \u0026#34;oi\u0026#34;); clearInterval Stops a function from being executed repeatedly by clearing the interval.\nclearInterval(intervalId); clearTimeout Cancels a timeout previously established by setTimeout.\nclearTimeout(timeoutId); 18. Local Storage Local storage is a way to store data in the browser that persists even after the browser is closed.\nStoring Data localStorage.setItem(\u0026#39;name\u0026#39;, \u0026#39;Nirajan\u0026#39;); Retrieving Data const name = localStorage.getItem(\u0026#39;name\u0026#39;); console.log(name); // Output: Nirajan 19. JSON JSON (JavaScript Object Notation) is a lightweight data interchange format that is easy for humans to read and write and easy for machines to parse and generate.\nConverting Objects to JSON const person = { name: \u0026#39;Nirajan\u0026#39;, age: 20 }; const json = JSON.stringify(person); console.log(json); // Output: {\u0026#34;name\u0026#34;:\u0026#34;Nirajan\u0026#34;,\u0026#34;age\u0026#34;:20} Converting JSON to Objects const json = \u0026#39;{\u0026#34;name\u0026#34;:\u0026#34;Nirajan\u0026#34;,\u0026#34;age\u0026#34;:20}\u0026#39;; const person = JSON.parse(json); console.log(person.name); // Output: Nirajan 20. Fetch API Fetch is used to make HTTP requests and returns a promise that resolves to the response of the request.\nBasic Usage fetch(\u0026#39;https://api.example.com/data\u0026#39;) .then(response =\u0026gt; response.json()) .then(data =\u0026gt; console.log(data)) .catch(error =\u0026gt; console.error(\u0026#39;Error:\u0026#39;, error)); ","permalink":"http://localhost:1313/posts/pages/js/javascript/","summary":"A complete reference guide for JavaScript including data types, functions, DOM manipulation, and modern ES6+ features","title":"JavaScript Reference Guide"},{"content":" Linux Commands and Directories Guide Important Directories Default Web Server Root Directory\nLocation: /var/www/html\nThis is the standard location for serving web content on Apache.\nDownloads Folder\nLocation: /home/username/Downloads\nThis is where files downloaded from the internet are usually saved by default.\nDocuments Folder\nLocation: /home/username/Documents\nA common directory for storing personal documents and files.\nDesktop Folder\nLocation: /home/username/Desktop\nThis is the location for files and shortcuts displayed on your desktop screen.\nCommon Commands cd Change the current directory to another one.\nUsage: cd [directory]\nExample: cd /var/www/html changes to the web server root directory.\nls List files and directories in the current location or specified path.\nUsage: ls [options] [path]\nExample: ls -l lists files in a detailed format.\npwd Print the path of the current working directory.\nUsage: pwd\nThis command shows where you are in the filesystem.\nsudo su Switch to the superuser (root) account, allowing you to perform administrative tasks.\nUsage: sudo su\nAfter entering your password, you\u0026rsquo;ll have root access.\nsudo Execute a command with elevated privileges.\nUsage: sudo [command]\nExample: sudo apt update runs the update command as an administrator.\nmkdir Create a new directory.\nUsage: mkdir [directory name]\nExample: mkdir new_folder creates a directory named \u0026ldquo;new_folder\u0026rdquo;.\ndir List files and directories, similar to ls.\nUsage: dir [options] [path]\nThis command can be used interchangeably with ls.\nmv Move or rename files and directories.\nUsage: mv [source] [destination]\nExample: mv /home/username/Downloads/file.txt /home/username/Documents/ moves the file to a different directory.\ncp Copy files or directories.\nUsage: cp [source] [destination]\nExample: cp /home/username/Downloads/file.txt /home/username/Documents/ copies the file.\nrm Remove files or directories.\nUsage: rm [options] [file/directory]\nExample: To remove a directory and its contents, use rm -r [directory].\ntouch Create an empty file or update the timestamp of an existing file.\nUsage: touch [filename]\nExample: touch newfile.txt creates an empty file named \u0026ldquo;newfile.txt\u0026rdquo;.\ncat Display the contents of a file in the terminal.\nUsage: cat [filename]\nExample: cat file.txt shows the content of \u0026ldquo;file.txt\u0026rdquo;.\ngedit Open the Gedit text editor to edit files.\nUsage: gedit [filename]\nExample: gedit notes.txt opens \u0026ldquo;notes.txt\u0026rdquo; for editing.\nkill Terminate a process using its process ID (PID).\nUsage: kill [PID]\nExample: kill 1234 stops the process with the ID 1234.\ntop Display real-time information about system processes and resource usage.\nUsage: top\nThis command helps monitor system performance.\napt-get update Update the package lists for upgrades and new package installations.\nUsage: apt-get update\nThis command fetches the latest package information.\napt install path_of_.deb_file Install a .deb file package.\nUsage: apt install ./filename.deb\nExample: apt install ./main.deb installs the specified Debian package.\napt-get upgrade Upgrade all installed packages to their latest versions.\nUsage: apt-get upgrade\nThis command updates your installed software.\napt-get install package Install a specific software package.\nUsage: apt-get install [package]\nExample: apt-get install vim installs the Vim text editor.\nman Display the manual page for a command, providing detailed information.\nUsage: man [command]\nExample: man ls shows the manual for the ls command.\nwhoami Show the currently logged-in user\u0026rsquo;s username.\nUsage: whoami\nThis command is useful for confirming your user identity.\nzip Compress a directory and its contents into a zip file.\nUsage: zip -r [filename.zip] [foldername]\nExample: zip -r archive.zip myfolder creates a zip file of \u0026ldquo;myfolder\u0026rdquo;.\nunzip Extract files from a zip archive.\nUsage: unzip [filename]\nExample: unzip archive.zip extracts files from \u0026ldquo;archive.zip\u0026rdquo;.\napt install apache2 Install the Apache web server.\nUsage: apt install apache2\nThis command sets up Apache on your system.\nservice apache2 start Start the Apache web server.\nUsage: service apache2 start\nUse this to begin serving web content.\nservice apache2 restart Restart the Apache web server.\nUsage: service apache2 restart\nThis is useful for applying configuration changes.\nservice apache2 stop Stop the Apache web server.\nUsage: service apache2 stop\nUse this command to halt the server.\napt install redis Install the Redis database server.\nUsage: apt install redis\nThis sets up Redis for use.\nservice redis start Start the Redis server.\nUsage: service redis start\nThis command activates the Redis service.\nservice redis restart Restart the Redis server.\nUsage: service redis restart\nUse this to refresh the Redis service.\nservice redis stop Stop the Redis server.\nUsage: service redis stop\nThis halts the Redis service.\napt install mysql-server Install the MySQL server.\nUsage: apt install mysql-server\nThis command installs the MySQL database management system.\nchmod Change file or directory permissions.\nUsage: chmod [permissions] [file/folder]\nExample: chmod +rwx file.txt grants read, write, and execute permissions.\nTo remove permissions, use chmod -r file.txt.\nImportant Notes Folder Names with Spaces:\nIf a folder name contains spaces, enclose it in double quotes.\nmkdir \u0026quot;New Folder\u0026quot; creates a single folder named \u0026ldquo;New Folder\u0026rdquo;. mkdir New Folder creates two separate folders named \u0026ldquo;New\u0026rdquo; and \u0026ldquo;Folder\u0026rdquo;. Using Wildcards for Operations:\nTo perform operations on:\nAll files/folders: use *. Files with a specific extension (e.g., .exe): use *.exe. Files/folders starting with \u0026ldquo;hello\u0026rdquo;: use hello*. Use Relative Paths:\nPrefer using relative paths whenever possible to simplify navigation.\nExample: mv /home/username/Downloads/index.html /var/www/html/index.html moves a file to the web server directory. ","permalink":"http://localhost:1313/posts/pages/linux/linux_cheatsheet/","summary":"A practical guide to navigating and managing files in Linux.","title":"Linux Commands and Directories Guide"},{"content":"Learning Journey Topics I Have Learned So Far Docker Linux Celery Django Channels Git Celery Python Django JavaScript React Basics HTML CSS Tailwind Css What I Plan to Learn In third Semester Django Rest Framework (DRF) Django ORM Deep Dive React Advanced Git Advanced Docker Advanced WebSOcket Deep Dive in Django Celery Deep Dive Plan to learn in future WebSocket Deep Dive in Django Celery Deep Dive Redis for Cache Kafka Basics + Advanced Docker Advanced + Kubernetes Message Brokers Django Rest Framework (DRF) Django ORM Deep Dive React Advanced Git Advanced Django Docs+Advance Like class based views Additional Topics for Future Learning Real-time WebSocket usage in Django. Kafka streaming for handling large data volumes. Implementing Kubernetes for containerized applications. ","permalink":"http://localhost:1313/posts/pages/readinglist/my_reading/","summary":"A detailed overview of my learning journey and future plans.","title":"Learning Journey"},{"content":"Fetching data from server 21.1. Fetching data from server -fetch data using useeffect -set loading -handelling http response\n","permalink":"http://localhost:1313/posts/pages/react/react11/","summary":"\u003ch2 id=\"fetching-data-from-server\"\u003eFetching data from server\u003c/h2\u003e\n\u003ch3 id=\"211-fetching-data-from-server\"\u003e21.1. Fetching data from server\u003c/h3\u003e\n\u003cp\u003e-fetch data using useeffect\n-set loading\n-handelling http response\u003c/p\u003e","title":""},{"content":"44. Optimizing Performance 44.1. memo memo is a higher-order function in React that optimizes functional components by preventing unnecessary re-renders. It returns a new component that behaves the same as the original one but only re-renders if its props change or internal state changes not every time the parent component re-renders.\nWhy Use memo? When a parent component re-renders, all its child components also re-render by default—even if their props remain unchanged. This behavior can lead to performance bottlenecks. Using memo, we can avoid these unnecessary re-renders for child components.\nExample:\nimport { memo } from \u0026#39;react\u0026#39;; const MyComponent = memo((props) =\u0026gt; { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;{props.title}\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ); }); export default MyComponent; In the above example, the MyComponent functional component is wrapped with the memo function. This ensures that the component will only re-render if its props have changed or if its satate has been change not every time the parent component re-renders.\nUse Case:\nBefore using memo: In this example, the Custom component re-renders unnecessarily whenever the parent component re-renders, even if its props haven\u0026rsquo;t changed or internal state hasn\u0026rsquo;t changed. Custom.js import { useState } from \u0026#39;react\u0026#39;; const Custom = ({ title }) =\u0026gt; { const [count, setCount] = useState(0); return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;{title}\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;{count}\u0026lt;/p\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;Increment\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); }; export default Custom; App.js\nimport { useState } from \u0026#39;react\u0026#39;; import Custom from \u0026#39;./Custom\u0026#39;; function App() { const [count, setCount] = useState(0); return ( \u0026lt;div\u0026gt; \u0026lt;Custom title=\u0026#34;Counter\u0026#34; /\u0026gt; \u0026lt;p\u0026gt;{count}\u0026lt;/p\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;Increment Parent Count\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; Problem: The Custom component re-renders whenever the count state in the App component changes, even though the title prop remains the same. This can cause unnecessary rendering and reduce performance.i.e child component re-renders even if the props are not changed when the parent component re-renders.\nAfter using memo: Using memo, we can optimize the Custom component to only re-render when its props change. Custom.jsx import { useState, memo } from \u0026#39;react\u0026#39;; const Custom = memo(({ title }) =\u0026gt; { const [count, setCount] = useState(0); return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;{title}\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;{count}\u0026lt;/p\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;Increment\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); }); export default Custom; App.js\nimport { useState } from \u0026#39;react\u0026#39;; import Custom from \u0026#39;./Custom\u0026#39;; function App() { const [count, setCount] = useState(0); return ( \u0026lt;div\u0026gt; \u0026lt;Custom title=\u0026#34;Counter\u0026#34; /\u0026gt; \u0026lt;p\u0026gt;{count}\u0026lt;/p\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;Increment Parent Count\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; After using memo the Custom component will only re-render when its props change or state change i.e when the title prop changes or the count state of the Custom component changes . It will not re-render when the count state of the App component changes, which optimizes performance in this scenario as that change does not affect the Custom component.\n44.2. useCallback In every rerender of a component, the functions defined inside the component are recreated. This can lead to performance issues, especially when passing functions as props to child components. useCallback is a hook in React that memoizes functions to prevent unnecessary re-creations.\nSyntax:\nuseCallback(fn, dependencies) fn: The function value that you want to cache. It can take any arguments and return any values. React will return (not call!) your function back to you during the initial render. On next renders, React will give you the same function again if the dependencies have not changed since the last render. Otherwise, it will give you the function that you have passed during the current render, and store it in case it can be reused later. React will not call your function. The function is returned to you so you can decide when and whether to call it. dependencies: An array of values that, when changed, will cause the function to be re-created. If the dependencies array is empty, the function will only be created once, and will not be re-created on subsequent renders. Whats the use of dependencies array in useCallback? just because dependency array the function is recreated with the new values of the dependencies.\nBefore using useCallback:\nimport { useState,memo } from \u0026#39;react\u0026#39;; const Child = memo(({ handleClick }) =\u0026gt; { return ( \u0026lt;button onClick={handleClick}\u0026gt;Click Me\u0026lt;/button\u0026gt; ); }); const Parent = () =\u0026gt; { const [count, setCount] = useState(0); const handleClick = () =\u0026gt; { setCount(count + 1); }; return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;{count}\u0026lt;/p\u0026gt; \u0026lt;Child handleClick={handleClick} /\u0026gt; \u0026lt;/div\u0026gt; ); }; In the above example, the handleClick function is re-created on every re-render of the Parent component. As a result, the reference to the handleClick function passed as a prop to the Child component changes on every re-render of the Parent component. This causes the Child component to re-render unnecessarily, even though the handleClick function remains logically the same After using useCallback:\nimport { useState, useCallback, memo } from \u0026#39;react\u0026#39;; const Child = memo(({ handleClick }) =\u0026gt; { return ( \u0026lt;button onClick={handleClick}\u0026gt;Click Me\u0026lt;/button\u0026gt; ); }); const Parent = () =\u0026gt; { const [count, setCount] = useState(0); const handleClick = useCallback(() =\u0026gt; { setCount(count + 1); }, [count]); return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;{count}\u0026lt;/p\u0026gt; \u0026lt;Child handleClick={handleClick} /\u0026gt; \u0026lt;/div\u0026gt; ); }; By using useCallback, the handleClick function is memoized and will only be re-created when the count state changes. The reference to the handleClick function remains the same across re-renders of the Parent component unless the dependencies specified in the dependency array (in this case, [count]) change. This ensures that the Child component only re-renders when the count state changes, and not when the handleClick function reference changes, thus improving performance.\n44.3. useMemo useMemo is a hook in React that memoizes the result of a function. It is similar to useCallback, but instead of memoizing a function, it memoizes the result of a function.\nSyntax:\nconst cachedValue = useMemo(calculateValue, dependencies) calculateValue: The function calculating the value that you want to cache. It should be pure, should take no arguments, and should return a value of any type. React will call your function during the initial render. On next renders, React will return the same value again if the dependencies have not changed since the last render. Otherwise, it will call calculateValue, return its result, and store it so it can be reused later. dependencies: An array of values that, when changed, will cause the function to be re-executed.\nreturn On the initial render, useMemo returns the result of calling calculateValue with no arguments.During next renders, it will either return an already stored value from the last render (if the dependencies haven’t changed), or call calculateValue again, and return the result that calculateValue has returned.\nBefore using useMemo:\nimport { useState, memo } from \u0026#39;react\u0026#39;; const fibonacci = (n) =\u0026gt; { if (n \u0026lt;= 1) { return n; } return fibonacci(n - 1) + fibonacci(n - 2); }; const Fib = ()=\u0026gt;{ const [count, setCount] = useState(1); const result = fibonacci(100000000000); return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;{result} and count is {count}\u0026lt;/p\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;Increase Count\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } In the above example, the fibonacci function is called on every re-render of the Fib component. This can lead to performance issues, especially when the function is computationally expensive. In this case, the fibonacci function is called with a large number, which can cause the component to freeze or crash.\nAfter using useMemo:\nimport { useState, useMemo } from \u0026#39;react\u0026#39;; const fibonacci = (n) =\u0026gt; { if (n \u0026lt;= 1) { return n; } return fibonacci(n - 1) + fibonacci(n - 2); }; const Fib = ()=\u0026gt;{ const [count, setCount] = useState(1); const result = useMemo(() =\u0026gt; fibonacci(100000000000), []); return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;{result} and count is {count}\u0026lt;/p\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;Increase Count\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } By using useMemo, the result of the fibonacci function is memoized and will only be re-calculated when the dependencies specified in the dependency array change. In this case, the fibonacci function is only called once during the initial render of the Fib component, and the result is stored and reused on subsequent renders. This optimizes performance by preventing unnecessary re-calculation of the fibonacci function on every re-render of the component.\n45.Key conside a scenarion where your base component state variable need to be initialized with the value of the props passed to the component. since the state variable is initialized with the props value, the state variable will not be updated when the props value changes as it is initialized only. to handle we can either use useEffect or we can use key prop.\nUsing useEffect:\nimport { useEffect, useState } from \u0026#39;react\u0026#39;; const Parent = () =\u0026gt; { const [value, setValue] = useState(0); return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={() =\u0026gt; setValue(value + 1)}\u0026gt;Increment\u0026lt;/button\u0026gt; \u0026lt;Child value={value} /\u0026gt; \u0026lt;/div\u0026gt; ); }; const Child = ({ value }) =\u0026gt; { const [stateValue, setStateValue] = useState(value); useEffect(() =\u0026gt; { setStateValue(value); }, [value]); return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;State Value: {stateValue}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Props Value: {value}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); }; stateValue is initialized with the value prop and const [stateValue, setStateValue] = useState(value); runs only once during initial render so useEffect is used to update the stateValue when the value prop changes.\nUsing key prop:\nimport { useState } from \u0026#39;react\u0026#39;; const Parent = () =\u0026gt; { const [value, setValue] = useState(0); return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={() =\u0026gt; setValue(value + 1)}\u0026gt;Increment\u0026lt;/button\u0026gt; \u0026lt;Child key={value} value={value} /\u0026gt; \u0026lt;/div\u0026gt; ); }; const Child = ({ value }) =\u0026gt; { const [stateValue, setStateValue] = useState(value); return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;State Value: {stateValue}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Props Value: {value}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); }; IN the above example,When a key changes between renders, React will create a new instance of the component. By using the key prop with the value prop, we ensure that a new instance of the Child component is created whenever the value prop changes. This allows the stateValue to be initialized with the new value prop on every render, without the need for useEffect.\nNote:The useState() hook us run only one time during the initial render of the component. If the state variable is initialized with a prop value, it will not be updated when the prop value changes. To handle this scenario, we can use the useEffect() hook to update the state variable when the prop value changes. Alternatively, we can use the key prop to create a new instance of the component whenever the prop value changes, allowing the state variable to be initialized with the new prop value on every render. Similar goes for useReducer() and useRef() hooks as well.\n","permalink":"http://localhost:1313/posts/pages/react/react10/","summary":"Learn how to optimize React applications using memo for component memoization, useCallback for function memoization, and useMemo for value memoization.","title":"React : 10"},{"content":"40. useEffect useEffect is a React hook that lets you perform side effects in functional components. Common use cases include:\nEstablishing a database connection when the DOM content loads. Updating the page title when the content changes. Note: The useEffect hook runs after the component has rendered.\n41. What to Put in useEffect Use useEffect for:\nNetwork requests Operations that take time to complete (e.g., fetching data, setting timers, etc.) 42. useEffect Syntax 42.1. Importing useEffect import React, { useEffect } from \u0026#39;react\u0026#39;; 42.2. useEffect Syntax useEffect(() =\u0026gt; { // code here return () =\u0026gt; { // cleanup code here }; }, [dependencies]); The first argument is a function containing the code to execute. The second argument is an array of dependencies. If any dependency changes, the function runs again. The return statement is optional and is used for cleanup tasks, such as removing event listeners or canceling subscriptions. This cleanup function is executed: Just before the the useEffect function runs again cause due to dependency change, with variables from the previous render. After the component unmounts (i.e., when removed from the DOM). Note: When your component is added to the DOM, React runs the setup function. After each re-render with changed dependencies, React first executes the cleanup function (if provided) with old values, then runs the setup function with new values.\nExample: useEffect(() =\u0026gt; { const id = setTimeout(() =\u0026gt; { console.log(count); }, 1000); return () =\u0026gt; { clearTimeout(id); }; }, [count]); In this example, the useEffect hook runs whenever the count variable changes. It sets a timeout to log the count value after 1 second, and the cleanup function clears the previous timeout before the next execution. Cleanup Function:\nUsed for tasks like removing event listeners or clearing timeouts. Ensures stale operations are cleared before new ones are executed. Executes when dependencies change or when the component unmounts. 43. Variations of useEffect 43.1. useEffect Without Dependencies Array useEffect(() =\u0026gt; { // code here }); The useEffect function runs after every re-render. 43.2. useEffect With Empty Dependencies Array useEffect(() =\u0026gt; { // code here }, []); The useEffect function runs only once after the initial render, making it ideal for tasks like loading local storage data. 43.3. useEffect With Multiple Dependencies useEffect(() =\u0026gt; { // code here }, [count, name]); The useEffect function runs when either count or name changes. Note: In all of the variation, useEffect always runs after the first render no matter what is passed in the dependencies array.\nExample: Loading Local Storage Data Correct Usage:\nimport React, { useState, useEffect } from \u0026#39;react\u0026#39;; const App = () =\u0026gt; { const [data, setData] = useState([]); useEffect(() =\u0026gt; { const data = localStorage.getItem(\u0026#39;data\u0026#39;); if (data) { setData(JSON.parse(data)); } }, []); return ( \u0026lt;div\u0026gt; {data.map((item, index) =\u0026gt; ( \u0026lt;p key={index}\u0026gt;{item}\u0026lt;/p\u0026gt; ))} \u0026lt;/div\u0026gt; ); }; Incorrect Usage:\nimport React, { useState } from \u0026#39;react\u0026#39;; const App = () =\u0026gt; { const [data, setData] = useState([]); const loadData = () =\u0026gt; { const data = localStorage.getItem(\u0026#39;data\u0026#39;); if (data) { setData(JSON.parse(data)); } }; loadData(); return ( \u0026lt;div\u0026gt; {data.map((item, index) =\u0026gt; ( \u0026lt;p key={index}\u0026gt;{item}\u0026lt;/p\u0026gt; ))} \u0026lt;/div\u0026gt; ); }; Problem: Calling loadData directly causes an infinite loop because it triggers a re-render, which calls loadData again. Solution: Use useEffect with an empty dependency array to ensure the function runs only once after the initial render. ","permalink":"http://localhost:1313/posts/pages/react/react9/","summary":"Learn how to use the useEffect hook in React for performing side effects in functional components.","title":"React : 9"},{"content":"38. Understanding the Concept of Prop Drilling Prop drilling refers to the process of passing data from a parent component to a deeply nested child component through all the intermediate components, even if those intermediate components don’t need the data themselves. Let’s break this down with an example.\nComponent Tree Imagine the following component hierarchy: Now, suppose we want to transfer some data from the Product component to the Cart component. Since Product and Cart are in separate branches of the component tree, they don’t have a direct connection.\nHow Prop Drilling Works To make this work, we need to store the shared state in a common ancestor, which is the App component in this case. Then, we have to pass the state down through all the intermediate components, even if those components don’t actually use the data.\nHere’s a visual representation of this:\nData flows from Product → Shop → App (common ancestor). The data then flows from App → Header → CardModel → Cart. This creates a lot of unnecessary overhead because the intermediate components (Shop, Header, and CardModel) don’t need the data but still have to handle it.\nProp drilling can quickly become cumbersome in large applications with deeply nested components. To solve this, we can use state management tools like Redux, Context API, or React Query, which allow us to manage and share state more effectively without passing it through every component.\n39. Introduction to React Context API Context API is a feature in React that allows you to share data between components without having to pass props down manually at every level. It provides a way to pass data through the component tree without having to pass props down manually at every level as shown in the image below.\nHow to use context API Create a context using the createContext function. import { createContext } from \u0026#39;react\u0026#39;; const CartContext = createContext(); export default CartContext; Wrap the parent component with the Provider component. Which Component to wrap? Wrap to the common ancestor of the components that need the context data. In the example below, we wrap the App component with the Provider component. For Example:\nimport CartContext from \u0026#39;./store/CartContext\u0026#39;; function App() { return ( \u0026lt;CartContext.Provider value={data}\u0026gt; \u0026lt;Header /\u0026gt; \u0026lt;Shop /\u0026gt; \u0026lt;/CartContext.Provider\u0026gt; ); } Explaination:Since we want to share the product Component data with the Cart Component SO in order to do that we wrap the first common ancestor of the Product and Cart Component i.e App Component with the Provider Component and pass the data to the value prop of the Provider Component.\nAccess the context data in the child component using the useContext hook. for example:\nimport { useContext } from \u0026#39;react\u0026#39;; import CartContext from \u0026#39;../store/CartContext\u0026#39;; function Cart() { const cartCtx = useContext(CartContext); return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Cart\u0026lt;/h1\u0026gt; {cartCtx.products.map(product =\u0026gt; ( \u0026lt;p key={product.id}\u0026gt;{product.name}\u0026lt;/p\u0026gt; ))} \u0026lt;/div\u0026gt; ); } What Whappen when the data is updated? When the data is updated in the Provider component, all the child components that are using the context data will be re-rendered automatically. Task: Design a simple application that has a component called App. App has two child components: Header and Shop. Header has one child, CartModel, and Shop has one child, Product. Pass the data from the Product component to the CartModel component using the Context API.\nStructure of the project\nsrc\r|_components\r|_App\r|_App.js\r|_Header\r|_Header.js\r|_CartModel.js\r|_Shop\r|_Shop.js\r|_Product.js\r|_store\r|_CartContext.js CartContext.js\nimport { createContext } from \u0026#39;react\u0026#39;; const CartContext = createContext(); export default CartContext; App.js\nimport CartContext from \u0026#39;../store/CartContext\u0026#39;; import Header from \u0026#39;../Header/Header\u0026#39;; import Shop from \u0026#39;../Shop/Shop\u0026#39;; import { useState } from \u0026#39;react\u0026#39;; function App() { const [cartProducts, setCartProducts] = useState([]); const addProductToCart = (product) =\u0026gt; { setCartProducts((prevProducts) =\u0026gt; [...prevProducts, product]); }; return ( \u0026lt;CartContext.Provider value={ { products: cartProducts, addProduct: addProductToCart } }\u0026gt; \u0026lt;Header /\u0026gt; \u0026lt;Shop /\u0026gt; \u0026lt;/CartContext.Provider\u0026gt; ); } export default App; Header.js\nimport CartModel from \u0026#39;./CartModel\u0026#39;; function Header() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Header\u0026lt;/h1\u0026gt; \u0026lt;CartModel /\u0026gt; \u0026lt;/div\u0026gt; ); } export default Header; CartModel.js\nimport { useContext } from \u0026#39;react\u0026#39;; import CartContext from \u0026#39;../../store/CartContext\u0026#39;; function CartModel() { const cartCtx = useContext(CartContext); return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;CartModel\u0026lt;/h1\u0026gt; {cartCtx.products.map(product =\u0026gt; ( \u0026lt;p key={product.id}\u0026gt;{product.name}\u0026lt;/p\u0026gt; ))} \u0026lt;/div\u0026gt; ); } export default CartModel; Shop.js\nimport Product from \u0026#39;./Product\u0026#39;; function Shop() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Shop\u0026lt;/h1\u0026gt; \u0026lt;Product /\u0026gt; \u0026lt;/div\u0026gt; ); } export default Shop; Product.js\nimport { useContext } from \u0026#39;react\u0026#39;; import CartContext from \u0026#39;../../store/CartContext\u0026#39;; function Product() { const cartCtx = useContext(CartContext); const product = { id: 1, name: \u0026#39;Laptop\u0026#39; }; return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Product\u0026lt;/h1\u0026gt; \u0026lt;button onClick={() =\u0026gt; cartCtx.addProduct(product)}\u0026gt;Add to Cart\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } export default Product; Outsoursing the Context Provider Since all the logic related to the context is in the App Component so we can outsource the context provider and its logic to a separate component in order to make the App Component more clean and readable.\nCartContext.js\nimport { createContext, useState } from \u0026#39;react\u0026#39;; const CartContext = createContext(); export const CartContextProvider = (props) =\u0026gt; { const [cartProducts, setCartProducts] = useState([]); const addProductToCart = (product) =\u0026gt; { setCartProducts((prevProducts) =\u0026gt; [...prevProducts, product]); }; const context = { products: cartProducts, addProduct: addProductToCart }; return ( \u0026lt;CartContext.Provider value={context}\u0026gt; {props.children} \u0026lt;/CartContext.Provider\u0026gt; ); }; App.js\nimport Header from \u0026#39;../Header/Header\u0026#39;; import Shop from \u0026#39;../Shop/Shop\u0026#39;; import { CartContextProvider } from \u0026#39;../store/CartContext\u0026#39;; function App() { return ( \u0026lt;CartContextProvider\u0026gt; \u0026lt;Header /\u0026gt; \u0026lt;Shop /\u0026gt; \u0026lt;/CartContextProvider\u0026gt; ); } export default App; Other Components remain the same.\n39.UseReducer Hook in React USe reducer is a hook that is used for state management in React. It is an alternative to useState. It is usually preferable when you have complex state logic that involves multiple sub-values or when the next state depends on the previous one.\nHow to use useReducer Hook Create a reducer function. A reducer function is a function that takes the current state and an action as arguments and returns a new state based on the action type.action . action:It contains the object that is sent by the dispatch function. For Example:\nconst counterReducer = (state, action) =\u0026gt; { if (action.type === \u0026#39;INCREMENT\u0026#39;) { return { counter: state.counter + 1 }; } if (action.type === \u0026#39;DECREMENT\u0026#39;) { return { counter: state.counter - 1 }; } return state; }; Here, the reducer function takes two arguments: state and action. It checks the action type and returns a new state based on the action type.\nUse the useReducer hook in the component. The useReducer hook takes two arguments: the reducer function and the initial state and returns the current state and a dispatch function as an array which is shown below. For Example: import { useReducer } from \u0026#39;react\u0026#39;; const [counterState, dispatchCounter] = useReducer(counterReducer, { counter: 0 }); Here, counterState is the current state and dispatchCounter is the dispatch function that is used to dispatch an action to the reducer function and { counter: 0 } is the initial state such that the counter is initialized to 0.\nDispatch an action to the reducer function. To dispatch an action to the reducer function, you need to call the dispatch function with an object that contains the action type and any additional data that is required by the reducer function. For Example: dispatchCounter({ type: \u0026#39;INCREMENT\u0026#39; }); To change the state, you need to call the dispatch function with an object that contains the action type.Here, the action type is \u0026lsquo;INCREMENT\u0026rsquo; which increments the counter by 1.\nTask: Design a simple counter application that has a component called Counter. The Counter component has two buttons: Increment and Decrement. Use the useReducer hook to manage the state of the counter.\nStructure of the project\nsrc\r|_components\r|_Counter\r|_Counter.js Counter.js\nimport { useReducer } from \u0026#39;react\u0026#39;; const counterReducer = (state, action) =\u0026gt; { if (action.type === \u0026#39;INCREMENT\u0026#39;) { return { counter: state.counter + 1 }; } if (action.type === \u0026#39;DECREMENT\u0026#39;) { return { counter: state.counter - 1 }; } return state; }; function Counter() { const [counterState, dispatchCounter] = useReducer(counterReducer, { counter: 0 }); const handleIncrement = () =\u0026gt; { dispatchCounter({ type: \u0026#39;INCREMENT\u0026#39; }); }; const handleDecrement = () =\u0026gt; { dispatchCounter({ type: \u0026#39;DECREMENT\u0026#39; }); }; return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Counter\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;{counterState.counter}\u0026lt;/p\u0026gt; \u0026lt;button onClick={handleIncrement}\u0026gt;Increment\u0026lt;/button\u0026gt; \u0026lt;button onClick={handleDecrement}\u0026gt;Decrement\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } If we use useState hook then the code will be like this:\nimport { useState } from \u0026#39;react\u0026#39;; function Counter() { const [counter, setCounter] = useState(0); const handleIncrement = () =\u0026gt; { setCounter(counter=\u0026gt;counter + 1); }; const handleDecrement = () =\u0026gt; { setCounter(counter=\u0026gt;counter - 1); }; return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Counter\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;{counter}\u0026lt;/p\u0026gt; \u0026lt;button onClick={handleIncrement}\u0026gt;Increment\u0026lt;/button\u0026gt; \u0026lt;button onClick={handleDecrement}\u0026gt;Decrement\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } What is the difference between useState and useReducer?\nuseState is a simple and straightforward way to manage state in React. It is suitable for managing simple state logic. useReducer is more powerful and flexible than useState. It is suitable for managing complex state logic that involves multiple sub-values or when the next state depends on the previous one. Looking the example case Scenario: Here using reducer we write all the logic in a single function and then we dispatch the action to the reducer function and then the reducer function returns the new state based on the action type. This makes the code more readable and maintainable.\nbut in the case of useState, we have to write the logic for each state change separately which makes the code more complex and difficult to maintain.\nNote: Always change in state variable will cause the re-rendering of the component.\n","permalink":"http://localhost:1313/posts/pages/react/react8/","summary":"Learn about prop drilling and how to use the Context API in React to manage and share state effectively.","title":"React : 8"},{"content":"1.1 When to use asyncio? Asyncio is a library to write concurrent code using the async/await syntax. It is a single-threaded, single-process design that is ideal for I/O-bound and high-level structured network code. It is not suitable for CPU-bound code, which is better handled by the multiprocessing module.It is used for :\n2.1 Coroutine Think of a coroutine like a regular Python function but with the superpower that it can pause its execution when it encounters an operation that could take a while to complete. When that long-running operation is complete, we can “wake up” our paused coroutine and finish executing any other code in that coroutine. While a paused coroutine is waiting for the operation it paused for to finish, we can run other code. This running of other code while waiting is what gives our application concur rency. We can also run several time-consuming operations concurrently, which can give our applications big performance improvements. To both create and pause a coroutine, we’ll need to learn to use Python’s async and await keywords. The async keyword will let us define a coroutine; the await key word will let us pause our coroutine when we have a long-running operation.\n2.2 Creating a coroutine with async creating a coroutine is straightforward and not much different from creating a nor mal Python function. The only difference is that, instead of using the def keyword, we use async def. The async keyword marks a function as a coroutine instead of a nor mal Python function.\nimport asyncio async def mero_coroutine(): print(\u0026#34;Hello From Asyncio\u0026#34;) The coroutine in the preceding listing does nothing yet other than print “Hello world!” It’s also worth noting that this coroutine does not perform any long-running operations; it just prints our message and returns. This means that, when we put the coroutine on the event loop, it will execute immediately because we don’t have any blocking I/O, and nothing is pausing execution yet. This syntax is simple, but we’re creating something very different from a plain Python function. To illustrate this, let’s create a function that adds one to an integer as well as a coroutine that does the same and compare the results of calling each. We’ll also use the type convenience function to look at the type returned by calling a corou tine as compared to calling our normal function.\ndef add_function(a,b): return a+b async def add_coroutine(a,b): return a+b function=add_function(1,2) coroutine=add_coroutine(1,2) print(type(function)) print(type(coroutine)) When we run this code, we’ll see output like the following\nMethod result is 3 and the type is \u0026lt;class \u0026#39;int\u0026#39;\u0026gt;\rCoroutine result is \u0026lt;coroutine object coroutine_add_one at 0x1071d6040\u0026gt; and the type is \u0026lt;class \u0026#39;coroutine\u0026#39;\u0026gt; Notice how when we call our normal add_one function it executes immediately and returns what we would expect, another integer. However, when we call coroutine_ add_one we don’t get our code in the coroutine executed at all. We get a coroutine object instead. This is an important point, as coroutines aren’t executed when we call them directly. Instead, we create a coroutine object that can be run later. To run a corou tine, we need to explicitly run it on an event loop. So how can we create an event loop and run our coroutine?\nIn versions of Python older than 3.7, we had to create an event loop if one did not already exist. However, the asyncio library has added several functions that abstract the event loop management. There is a convenience function, asyncio.run, we can use to run our coroutine. This is illustrated in the following listing.\nimport asyncio async def add_coroutine(a,b): return a+b res=asyncio.run(add_coroutine(1,2)) print(res) When we run this code, we’ll see output like the following:\n3 We’ve properly put our coroutine on the event loop, and we have executed it! asyncio.run is doing a few important things in this scenario. First, it creates a brand-new event. Once it successfully does so, it takes whichever coroutine we pass into it and runs it until it completes, returning the result. This function will also do some cleanup of anything that might be left running after the main coroutine fin ishes. Once everything has finished, it shuts down and closes the event loop. Possibly the most important thing about asyncio.run is that it is intended to be the main entry point into the asyncio application we have created. It only executes one coroutine, and that coroutine should launch all other aspects of our application. As we progress further, we will use this function as the entry point into nearly all our applications. The coroutine that asyncio.run executes will create and run other coroutines that will allow us to utilize the concurrent nature of asyncio.\n2.3 Pausing execution with the await keyword The example we saw in block 2.2 did not need to be a coroutine, as it executed only non-blocking Python code. The real benefit of asyncio is being able to pause execu tion to let the event loop run other tasks during a long-running operation. To pause execution, we use the await keyword. The await keyword is usually followed by a call to a coroutine (more specifically, an object known as an awaitable, which is not always a coroutine; we’ll learn more about awaitables later in the chapter). Using the await keyword will cause the coroutine following it to be run, unlike calling a coroutine directly, which produces a coroutine object. The await expression will also pause the coroutine where it is contained in until the coroutine we awaited finishes and returns a result. When the coroutine we awaited finishes, we’ll have access to the result it returned, and the containing coroutine will “wake up” to handle the result. We can use the await keyword by putting it in front of a coroutine call. Expanding on our earlier program, we can write a program where we call the add_coroutine function inside of a “main” async function and get the result\nimport asyncio async def add_one(number: int) -\u0026gt; int: return number + 1 async def main() -\u0026gt; None: one_plus_one = await add_one(1) # Pause, and wait for the result of add_one(1). two_plus_one = await add_one(2) # Pause, and wait for the result of add_one(2). print(one_plus_one) print(two_plus_one) asyncio.run(main()) Note: Coroutine will only run when we use await keyword. If we call the coroutine directly it will return a coroutine object.\nIn above code we pause execution twice. We first await the call to add_one(1). Once we have the result, the main function will be “unpaused,” and we will assign the return value from add_one(1) to the variable one_plus_one, which in this case will be two. We then do the same for add_one(2) and then print the results.We can visualize the execution flow of our application, as shown in figure\nAs it stands now, this code does not operate differently from normal, sequential code. We are, in effect, mimicking a normal call stack. Next, let’s look at a simple example of how to run other code by introducing a dummy sleep operation while we’re waiting.\n2.4 Introducing long-running coroutines with sleep Our previous examples did not use any slow operations and were used to help us learn the basic syntax of coroutines. To fully see the benefits and show how we can run mul tiple events simultaneously, we’ll need to introduce some long-running operations. Instead of making web API or database queries right away, which are nondeterministic as to how much time they will take, we’ll simulate long-running operations by specify ing how long we want to wait. We’ll do this with the asyncio.sleep function. We can use asyncio.sleep to make a coroutine “sleep” for a given number of sec onds. This will pause our coroutine for the time we give it, simulating what would hap pen if we had a long-running call to a database or web API. asyncio.sleep is itself a coroutine, so we must use it with the await keyword. If we call it just by itself, we’ll get a coroutine object. Since asyncio.sleep is a coroutine, this means that when a coroutine awaits it, other code will be able to run. Let’s examine a simple example, shown in the following listing, that sleeps for 1 sec ond and then prints a \u0026lsquo;Hello World!\u0026rsquo; message.\nimport asyncio async def hello_world_message(): await asyncio.sleep(1) print(\u0026#34;Hello World\u0026#34;) asyncio.run(hello_world_message()) When we run this application, our program will wait 1 second before printing our \u0026lsquo;Hello World!\u0026rsquo; message. Since hello_world_message is a coroutine and we pause it for 1 second with asyncio.sleep, we now have 1 second where we could be running other code concurrently.\nWe’ll be using sleep a lot in the next few examples, so let’s invest the time to cre ate a reusable coroutine that sleeps for us and prints out some useful information. We’ll call this coroutine delay. This is shown in the following listing\nimport asyncio async def delay(delaysecond): print(f\u0026#39;Sleeping for delay seconds : {delaysecond}\u0026#39;) await asyncio.sleep(delaysecond) print(f\u0026#39;finished sleeping for {delay_seconds} second(s)\u0026#39;) return delay_seconds delay will take in an integer of the duration in seconds that we’d like the function to sleep and will return that integer to the caller once it has finished sleeping. We’ll also print when sleep begins and ends. This will help us see what other code, if any, is run ning concurrently while our coroutines are paused.\nTo make referencing this utility function easier in future code listings, we’ll create a module that we’ll import in the remainder of this book when needed. We’ll also add to this module as we create additional reusable functions. We’ll call this module util, and we’ll put our delay function in a file called delay_functions.py. We’ll also add an init.py file with the following line, so we can nicely import the timer\nfrom util.delay_functions import delay From now on in this book, we’ll use from util import delay whenever we need to use the delay function. Now that we have a reusable delay coroutine, let’s combine it with the earlier coroutine add_one to see if we can get our simple addition to run concur rently while hello_world_message is paused.\nimport asyncio from util.delay_functions import delay async def add_one(number): return number + 1 async def hello_world_message(): await delay(1) print(\u0026#34;Hello World\u0026#34;) async def main() -\u0026gt; None: message = await hello_world_message() #pause until hello_world_message is finished one_plus_one = await add_one(1) #pause until add_one is finished print(one_plus_one) print(message) asyncio.run(main()) When we run this, 1 second passes before the results of both function calls are printed. What we really want is the value of add_one(1) to be printed immediately while hello_world_message()runs concurrently. So why isn’t this happening with this code? The answer is that await pauses our current coroutine and won’t execute any other code inside that coroutine until the await expression gives us a value. Since it will take 1 second for our hello_world_message function to give us a value, the main coroutine will be paused for 1 second. Our code behaves as if it were sequential in this case. This behavior is illustrated in figure\nWe can see that the main coroutine is paused for 1 second while hello_world_\nBoth main and hello_world paused while we wait for delay(1) to finish. After it has finished, main resumes and can execute add_one. We’d like to move away from this sequential model and run add_one concurrently with hello_world. To achieve this, we’ll need to introduce a concept called tasks.\n2.5 Running concurrently with task In Python\u0026rsquo;s asyncio, you can create tasks to run code concurrently. This is done using the asyncio.create_task function. When you create a task, it starts running in the background immediately, allowing your program to do other things while waiting for the task to finish.\nKey Points: Creating a Task:\nUse asyncio.create_task() with a coroutine function as its input. It returns a task object instantly. Awaiting a Task:\nYou can use await with the task object to pause your program until the task is done and get its result. Why Use Tasks?\nTasks allow other parts of your program to run without waiting for one operation to finish. Code Example: Creating and Using a Task import asyncio from util import delay # A custom function that simulates a delay async def main(): # Create a task that takes 3 seconds to complete sleep_for_three = asyncio.create_task(delay(3)) # Immediately print the type of the task object print(f\u0026#34;Task type: {type(sleep_for_three)}\u0026#34;) # Wait for the task to finish and get the result result = await sleep_for_three print(f\u0026#34;Task result: {result}\u0026#34;) # Run the main coroutine asyncio.run(main()) What’s Happening in the Code: Task Creation:\nasyncio.create_task(delay(3)) creates a task to run the delay(3) coroutine in the background. The task is of type \u0026lt;class '_asyncio.Task'\u0026gt;, which is different from a regular coroutine. Running Concurrently:\nAfter creating the task, the program does not wait for the task to finish. The print() statement runs immediately after the task is created. Waiting for the Task:\nThe await sleep_for_three line pauses the main coroutine until the task finishes. Once the task is complete, it returns its result, which is printed. Why Await is Important: If you don’t use await on a task, it might not get enough time to finish. When the asyncio.run function exits, the event loop stops, and any unfinished tasks are “cleaned up” without completing. Using await ensures the task has a chance to finish.\nNote : When we create task using asyncio.create_task it run the task immediately in the background. It does not wait for the task to finish and immediately return a task object such that our program can do other things while waiting for the task to finish.We can use await later on to pause the program until the task is done and get its result.\n2.6 Running multiple tasks concurrently Given that tasks are created instantly and are scheduled to run as soon as possible, this allows us to run many long-running tasks concurrently. We can do this by sequentially starting multiple tasks with our long-running coroutine.\nimport asyncio from util.delay_functions import delay async def main(): # Create two tasks that take 3 seconds to complete sleep_for_three=asyncio.create_task(delay(3)) sleep_again=asyncio.create_task(delay(3)) sleep_once_more=asyncio.create_task(delay(3)) await sleep_for_three await sleep_again await sleep_once_more asyncio.run(main()) In this code, we create three tasks that each sleep for 3 seconds. We then await each task in sequence. This will cause each task to run concurrently, and the total time to complete will be around 3 seconds, not 9 seconds. This is because we are not waiting for each task to finish before starting the next one. Lets breakdown\nStarting Three Tasks:\nThe program begins by creating three tasks, each of which takes 3 seconds to complete. The create_task function starts the tasks immediately but doesn\u0026rsquo;t wait for them to finish—it just sets them up to run in the background. The First Await Statement:\nWhen the code reaches the await sleep_for_three line, it pauses and gives control to the event loop. This pause allows the event loop to check for any tasks waiting to run and starts them “as soon as possible.” Tasks Run Simultaneously:\nAll three tasks begin running their sleep operations at the same time because the event loop handles them concurrently. This concurrency allows the program to complete the work in 3 seconds instead of 9. Concurrency in Action:\nWhile the sleep operations run concurrently, any other code in the tasks (like print statements) runs one at a time, not simultaneously. This means only the parts of the tasks that involve waiting (like sleeping) are parallelized. Time Saved:\nIf the tasks were executed one after another, the program would take 9 seconds (3 seconds × 3 tasks). By running the tasks concurrently, the program finishes in just 3 seconds, saving a lot of time. This is illustrated in figure NOTE This benefit compounds as we add more tasks; if we had launched 10 of these tasks, we would still take roughly 3 seconds, giving us a 10-fold speedup. This is the power of concurrency in asyncio.\nasyncio.gather function Gather function is a quick way to run multiple tasks concurrently and wait for all of them to complete. It takes in an iterable of awaitables and returns a single awaitable that will yield results in the order they were created. This is useful when we want to run multiple tasks concurrently and wait for all of them to finish before proceeding.\nimport asyncio from util.delay_functions import delay async def main(): # Create three tasks that take 3 seconds to complete and handel using asyncio.gather results = await asyncio.gather( delay(3), delay(3), delay(3) ) print(results) asyncio.run(main()) Note : For understanding You can use this logic . There is a task queue and event loop. When we only await coroutine there is only one task in the task queue and event loop .\ncoroutine need to await for running the task i.e keep in the task queue and eventloop if we directly run coroutine it will just give us coroutine object.\nWhen we use asyncio.createtask() there are as much task in the task queue as the number of tasks created and event loop will run all the tasks concurrently also when we await new coroutine it will be added to the task queue and event loop will run it concurrently.\nIt return a task object instantly and run all the task concurrently i.e keep in the task queue and event loop without awaiting but does not wait for the task to finish it need to be awaited to get the proper result.\nWhen we use asyncio.gather() it will run all the tasks concurrently and wait for all of them to finish before proceeding.\nIt need to be awaited to keep all the task in the task queue and event loop and wait for all of them to finish before proceeding.After finishing all the task it will return the result in the order they were created and jump to the next line of code of the main coroutine.\n3. Synchronization Premitives Locks Semaphores 3.1 Locks Locks are a synchronization primitive that allows us to limit access to a shared resource to only one coroutine at a time. This is useful when we have a resource that can only be accessed by one coroutine at a time, like a file or a database connection. Locks are created using the asyncio.Lock class and can be acquired using the acquire method and released using the release method.\n#basic example of lock\nimport asyncio async def locking(lock): print(\u0026#39;Waiting for the lock\u0026#39;) async with lock: print(\u0026#39;Acquired the lock\u0026#39;) await asyncio.sleep(2) print(\u0026#39;Released the lock\u0026#39;) async def main(): lock = asyncio.Lock() await asyncio.gather( locking(lock), locking(lock), locking(lock) ) asyncio.run(main()) Output:\nWaiting for the lock\rAcquired the lock\rWaiting for the lock\rWaiting for the lock\rReleased the lock\rAcquired the lock\rReleased the lock\rAcquired the lock\rReleased the lock In this example, we create a lock using asyncio.Lock and pass it to the locking coroutine. We then use the async with statement to acquire the lock and release it when we are done. When we run the program, we can see that only one coroutine can acquire the lock at a time, and the other coroutines have to wait until the lock is released.\n3.2 Semaphores Semaphores are a synchronization primitive that allows us to limit access to a shared resource to a fixed number of coroutines at a time. This is useful when we have a resource that can be accessed by a limited number of coroutines, like a connection pool or a web API. Semaphores are created using the asyncio.Semaphore class and can be acquired using the acquire method and released using the release method.\n#basic example of semaphore\nimport asyncio async def semaphoring(semaphore): async with semaphore: print(\u0026#39;Acquired the semaphore\u0026#39;) await asyncio.sleep(2) print(\u0026#39;Released the semaphore\u0026#39;) async def main(): semaphore = asyncio.Semaphore(2) await asyncio.gather( semaphoring(semaphore), semaphoring(semaphore), semaphoring(semaphore), semaphoring(semaphore) ) asyncio.run(main()) Output:\nAcquired the semaphore\rAcquired the semaphore\rAcquired the semaphore\rReleased the semaphore\rReleased the semaphore\rReleased the semaphore\rAcquired the semaphore\rReleased the semaphore In this example, we create a semaphore with a limit of 2 using asyncio.Semaphore and pass it to the semaphoring coroutine. We then use the async with statement to acquire the semaphore and release it when we are done. When we run the program, we can see that only two coroutines can acquire the semaphore at a time, and the other coroutines have to wait until the semaphore is released.\nSome popular asyncio libraries aiohttp: An HTTP client and server library for asyncio. fastapi: A modern web framework for building APIs with Python 3.6+ based on standard Python type hints. aiofiles: A file operations library for asyncio. ","permalink":"http://localhost:1313/posts/pages/asyncio/asyncio2/","summary":"how to write programs using this single-threaded concurrency model with asyncio","title":"Async io : Asyncio Basics (Day 2)"},{"content":"36. useRef Hook in React useRef is a hook that is specially designed to work with DOM elements. It allows you to create a reference to a DOM element and access it directly in your components so you can modify it or read its properties as needed.\nAnother important distinction is that useRef holds the same reference across re-renders of the component Similarly, useState also retains its value between renders. However, updating a state value with useState will always trigger a re-render, whereas updating the value of a useRef does not. Its explained in the below example in ## 2. Advanvced Usage\n1. Basic Usage 1. Import useRef import { useRef } from \u0026#39;react\u0026#39;; 2. Create a Reference const myRef = useRef(); 3. Attach to DOM Elements function MyComponent() { const myRef = useRef(); return ( \u0026lt;div ref={myRef}\u0026gt; \u0026lt;h1\u0026gt;useRef Example\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ); } 4. Accessing the Reference // Access the DOM element using .current const element = myRef.current; use myRef.current.value for input elements. use myRef.current.checked for checkbox elements. use myRef.current.focus() to focus on an element. use myRef.current.style to access the style object of an element.\nNote: While you can access DOM elements directly with useRef, it\u0026rsquo;s recommended to avoid manipulating them directly unless necessary.\nPractical Example: Form Input Here\u0026rsquo;s a complete example showing how to use useRef with form inputs:\nimport { useRef, useState } from \u0026#39;react\u0026#39;; function InputExample() { const inputRef = useRef(); const [inputValue, setInputValue] = useState(\u0026#39;\u0026#39;); const handleClick = () =\u0026gt; { setInputValue(inputRef.current.value); inputRef.current.value = \u0026#39;\u0026#39;; // Clear input after reading }; return ( \u0026lt;div\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; ref={inputRef} placeholder=\u0026#34;Type something...\u0026#34; /\u0026gt; \u0026lt;button onClick={handleClick}\u0026gt;Save Input\u0026lt;/button\u0026gt; \u0026lt;p\u0026gt;Saved value: {inputValue}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } Explanation:\nWe create a reference to the input element using useRef. When the button is clicked, we read the input value using inputRef.current.value and update the state. We clear the input field by setting inputRef.current.value to an empty string. 2. Advanced Usage of useRef and useState useRef and useState are both hooks used in React. Both hooks help us store values, but they behave differently: useState: The value is persistent across re-renders, but updating it triggers a re-render. useRef: The value is also persistent across re-renders, but updating it does not trigger a re-render. 2.1. Managing Previous Values in a Stopwatch Here’s an example of how to use useRef and useState to build a simple stopwatch in React:\nimport { useRef, useState } from \u0026#39;react\u0026#39;; function Stopwatch() { const timerRef = useRef(0); // To store the timer ID const [time, setTime] = useState(0); // To store the current time const [isRunning, setIsRunning] = useState(false); // To track if the stopwatch is running // Start the timer when the Start button is clicked const startTimer = () =\u0026gt; { if (!isRunning) { timerRef.current = setInterval(() =\u0026gt; { setTime((time) =\u0026gt; time + 1); // Increment the time every second }, 1000); setIsRunning(true); // Set the timer as running } }; // Stop the timer when the Stop button is clicked const stopTimer = () =\u0026gt; { clearInterval(timerRef.current); // Clear the interval to stop the timer setIsRunning(false); // Set the timer as not running }; // Reset the timer when the Reset button is clicked const resetTimer = () =\u0026gt; { clearInterval(timerRef.current); // Clear the interval to stop the timer setIsRunning(false); // Set the timer as not running setTime(0); // Reset the time to 0 }; return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Stopwatch\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;Time: {time} seconds\u0026lt;/p\u0026gt; \u0026lt;button onClick={startTimer}\u0026gt;Start\u0026lt;/button\u0026gt; \u0026lt;button onClick={stopTimer}\u0026gt;Stop\u0026lt;/button\u0026gt; \u0026lt;button onClick={resetTimer}\u0026gt;Reset\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } Explanation Creating useRef and useState variables:\ntimerRef: This holds the timer ID (returned by setInterval). We use useRef here because we don’t need the component to re-render when the timer ID changes. time: This stores the current time value of the stopwatch, and we use useState for this because we want the component to re-render whenever the time updates. isRunning: This tracks whether the stopwatch is running or not. Starting the timer (Start Button):\nWhen the \u0026ldquo;Start\u0026rdquo; button is clicked, we check if the timer is already running. If it isn’t, we start it by calling setInterval, which increments the time value every second. setInterval returns an interval ID that we store in timerRef.current. This ID will be used to stop the timer later. Stopping the timer (Stop Button):\nWhen the \u0026ldquo;Stop\u0026rdquo; button is clicked, we clear the interval using clearInterval(timerRef.current) to stop the timer. We also set isRunning to false to indicate that the timer is no longer running. Resetting the timer (Reset Button):\nWhen the \u0026ldquo;Reset\u0026rdquo; button is clicked, we clear the interval to stop the timer, set isRunning to false, and reset the time back to 0. Why useRef? Why not just use a regular variable?\nA regular variable inside the component would reset every time the component re-renders. Since the timer is being updated every second, this would cause issues because the value would be reset each time, and the timer wouldn’t function correctly. Why useRef over useState for the timer ID?\nWe use useRef to store the timer ID because updating it with useState would trigger a re-render every time the timer ID changes. Since the timer is running independently, we don’t need a re-render, so useRef is more efficient here. Key Takeaways useRef is useful for storing values that don’t require the component to re-render when they change. useState is used for values that should trigger a re-render when updated, like the time value in our stopwatch. useRef does not cause a re-render when its value changes, making it ideal for holding values like the interval ID that don’t need to affect the UI. Common Use Cases Storing previous values Managing focus, text selection, or media playback Integrating with third-party DOM libraries Accessing underlying DOM elements Isolation in Components: Any variable that is declared inside a component is isolated to that component. It is not shared with other components unless explicitly passed as props. This isolation helps maintain the encapsulation and modularity of components in React.\n37.Forwarding Refs in React Forwarding refs is a technique in React that allows you to pass a ref from a parent component to a child component. This is useful when you want to access the DOM element of a child component from a parent component.\n1. Basic Usage 1.Import useRef import { useRef } from \u0026#39;react\u0026#39;; 2. Create a Ref in the Parent Component const myRef= useRef(); 3. Pass the Ref to the Child Component \u0026lt;MyChildComponent ref={myRef} /\u0026gt; 4.Import forward ref in child component import React, { forwardRef } from \u0026#39;react\u0026#39;; 5. Using forwardRef to Forward the Ref const MyChildComponent = forwardRef((props, ref) =\u0026gt; { return \u0026lt;input ref={ref} /\u0026gt;; }); 6. Accessing the Ref in the Parent Component const element = myRef.current.value; Practical Example: Input Focus to take input from user and focus on the input field of the child component from the parent component.\nimport React, { useRef } from \u0026#39;react\u0026#39;; const InputComponent = forwardRef(({title}, ref) =\u0026gt; { return\u0026lt;\u0026gt; \u0026lt;h1\u0026gt;{title}\u0026lt;/h1\u0026gt; \u0026lt;input ref={ref}/\u0026gt; \u0026lt;/\u0026gt; }); function ParentComponent() { const inputRef = useRef(); const handleClick = () =\u0026gt; { inputRef.current.focus(); console.log(inputRef.current.value); }; return ( \u0026lt;div\u0026gt; \u0026lt;InputComponent ref={inputRef} title=\u0026#34;ENter the Input\u0026#34;/\u0026gt; \u0026lt;button onClick={handleClick}\u0026gt;Focus Input\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 38.useImperativeHandle in React In large-scale applications, we generally avoid using refs directly to access child components. Instead, we use the useImperativeHandle hook to expose specific methods from the child component to the parent component. This approach allows the developer working on the parent component to interact with the child component\u0026rsquo;s methods without needing to understand its internal implementation. Additionally, this separation enables the developer of the child component to modify or update the child component independently, without affecting the parent component. Since only the exposed methods are used by the parent, changes to the internal structure of the child component do not disrupt the parent-child interaction.This is specially used in forwardRef to expose methods of child component to parent component.\nBasic Usage 1.Pass a Ref to the Child Component import {useRef} from \u0026#39;react\u0026#39;; function App() { const childRef = useRef(); return \u0026lt;ChildComponent ref={childRef} /\u0026gt;; } =\u0026gt; Here, we create a ref using useRef and pass it to the ChildComponent using the ref prop.\n2. Use useImperativeHandle in the Child Component with forwardRef to expose methods import { useImperativeHandle, forwardRef } from \u0026#39;react\u0026#39;; const ChildComponent = forwardRef((props, ref) =\u0026gt; { useImperativeHandle(ref, () =\u0026gt; ({ focus: () =\u0026gt; { // Focus on the input element }, reset: () =\u0026gt; { // Reset the input element }, inputValue:\u0026#39;vaule\u0026#39; }),[dependencies]); return \u0026lt;input /\u0026gt;; }); In the ChildComponent, we use the useImperativeHandle hook to expose the focus and reset methods to the parent component. The ref object is passed as the first argument, and the second argument is a function that returns an object containing the methods to be exposed. dependencies is an optional array of values that, when changed, will trigger the re-evaluation of the function that returns the methods. If the dependencies array is not provided, the function will be called on every render and empty array will call only once in entire lifecycle.\n3. Access the Exposed Methods in the Parent Component function App() { const childRef = useRef(); const handleClick = () =\u0026gt; { childRef.current.focus(); }; const resetClick = () =\u0026gt; { childRef.current.reset(); }; return ( \u0026lt;\u0026gt; \u0026lt;ChildComponent ref={childRef} /\u0026gt; \u0026lt;button onClick={handleClick}\u0026gt;Focus Input\u0026lt;/button\u0026gt; \u0026lt;button onClick={resetClick}\u0026gt;Reset Input\u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; ); } In the parent component, we can access the exposed methods using the current property of the ref object. In this example, we call the focus method when the \u0026ldquo;Focus Input\u0026rdquo; button is clicked.\nPractical Example: Use forwardRef and useImperativeHandle to Expose Methods for reset the input field and get the value of the input field. import {useRef} from \u0026#39;react\u0026#39;; function App(){ const childRef = useRef(); const handleClick = () =\u0026gt; { childRef.current.focus(); }; const resetClick = () =\u0026gt; { childRef.current.reset(); }; const getValue = () =\u0026gt; { console.log(childRef.current.value); }; return ( \u0026lt;\u0026gt; \u0026lt;ChildComponent ref={childRef} /\u0026gt; \u0026lt;button onClick={handleClick}\u0026gt;Focus Input\u0026lt;/button\u0026gt; \u0026lt;button onClick={resetClick}\u0026gt;Reset Input\u0026lt;/button\u0026gt; \u0026lt;button onClick={getValue}\u0026gt;Get Value\u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; ); } export default App; import { useImperativeHandle, forwardRef,useRef } from \u0026#39;react\u0026#39;; const ChildComponent = forwardRef((props, ref) =\u0026gt; { const inputRef = useRef(); useImperativeHandle(ref, () =\u0026gt; ({ focus: () =\u0026gt; { inputRef.current.focus(); }, reset: () =\u0026gt; { inputRef.current.value = \u0026#39;\u0026#39;; }, value: inputRef.current.value }),[]); return \u0026lt;input ref={inputRef} /\u0026gt;; }); export default ChildComponent; =\u0026gt; By using useImperativeHandle, we can expose specific methods from the child component to the parent component, allowing for more controlled interactions between the components such as focusing on the input field, resetting the input field, and getting the value of the input field in this example. =\u0026gt; By using this approach, we can maintain a clear separation of concerns between the parent and child components, making it easier to manage and update the components independently.\n37. Portals in React Portals in React provide a way to render children components outside the DOM hierarchy of the parent component. This allows you to render a child component at a different location in the DOM, such as at the root level or inside a specific container, without affecting the parent\u0026rsquo;s layout or styles.\nImporting portal from react-dom import { createPortal } from \u0026#39;react-dom\u0026#39;; using createPortal const MyPortal = ({title}) =\u0026gt; { return createPortal( \u0026lt;\u0026gt; \u0026lt;h1\u0026gt;{title}\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;This is a portal\u0026lt;/p\u0026gt; \u0026lt;\u0026gt;, document.getElementById(\u0026#39;portal-root\u0026#39;)); }; =\u0026gt;When the MyPortal component is rendered, the content will be rendered inside the element with the id \u0026lsquo;portal-root\u0026rsquo;, which can be located anywhere in the DOM.\n","permalink":"http://localhost:1313/posts/pages/react/react7/","summary":"Learn about useRef hook, ref forwarding, useImperativeHandle and Portals in React for DOM manipulation and component interactions.","title":"React : Day 7"},{"content":"1. Some Important Concepts 1.1 Parallism vs Concurrency Parallism: Running multiple tasks at the same time. There are multiple Threads or Processes running at the same time. Concurrency: Switching between multiple tasks. When one task is waiting for I/O, another task can run. There is only one Thread or Process running at a time. 1.2 Synchronous vs Asynchronous Synchronous: Code is executed in sequence. Previous task/line must be completed before the next task/line execution starts. Asynchronous: Code is executed in parallel. Tasks can run concurrently. The next task can start before the previous task is completed. 1.3 Blocking vs Non-Blocking Blocking: The execution of the code is blocked until the task is completed. The next task can\u0026rsquo;t start until the previous task is completed. import time def task1(): print(\u0026#34;Task 1 started\u0026#34;) time.sleep(2) print(\u0026#34;Task 1 completed\u0026#34;) def task2(): print(\u0026#34;Task 2 started\u0026#34;) time.sleep(2) print(\u0026#34;Task 2 completed\u0026#34;) task1() task2() Non-Blocking: The excecution of the code is not blocked. The next task can start before the previous task is completed. import asyncio async def task1(): print(\u0026#34;Task 1 started\u0026#34;) await asyncio.sleep(2) print(\u0026#34;Task 1 completed\u0026#34;) async def task2(): print(\u0026#34;Task 2 started\u0026#34;) await asyncio.sleep(2) print(\u0026#34;Task 2 completed\u0026#34;) async def main(): await asyncio.gather(task1(), task2()) asyncio.run(main()) 1.4 I/O Bound vs CPU Bound I/O Bound: The program is waiting for input/output operations to complete. The program is not using the CPU much. CPU Bound: The program is using the CPU a lot. The program is not waiting for input/output operations to complete. import request response = request.get(\u0026#34;https://www.google.com\u0026#34;) # I/O Bound items = response.headers.items() # CPU Bound headers = [f\u0026#39;{key}: {header}\u0026#39; for key, header in items] # CPU Bound formatted_headers = \u0026#39;\\n\u0026#39;.join(headers) # CPU Bound with open(\u0026#39;headers.txt\u0026#39;, \u0026#39;w\u0026#39;) as file: # I/O Bound file.write(formatted_headers) # I/O Bound 2. How Concurrency is Achieved in Os level To better understand this, we’ll need to dive into how sockets work and, in particular, how non-blocking sockets work.\n2.1 Sockets A socket is a low-level abstraction for sending and receiving data over a network. It is the basis for how data is transferred to and from servers. Sockets support two main operations: sending bytes and receiving bytes. We write bytes to a socket, which will then get sent to a remote address, typically some type of server. Once we’ve sent those bytes, we wait for the server to write its response back to our socket. Once these bytes have been sent back to our socket, we can then read the result.\nIn the case of getting the contents from example.com as we saw earlier, we open a socket that connects to example.com’s server. We then write a request to get the contents to that socket and wait for the server to reply with the result: in this case, the HTML of the web page. We can visualize the flow of bytes to and from the server in figure 1.7\nSockets are blocking by default. Simply put, this means that when we are waiting for a server to reply with data, we halt our application or block it until we get data to read. Thus, our application stops running any other tasks until we get data from the server, an error happens, or there is a timeout. At the operating system level, we don’t need to do this blocking. Sockets can operate in non-blocking mode. In non-blocking mode, when we write bytes to a socket, we can just fire and forget the write or read, and our application can go on to perform other tasks. Later, we can have the operating system tell us that we received bytes and deal with it at that time. This lets the application do any number of things while we wait for bytes to come back to us. Instead of blocking and waiting for data to come to us, we become more reactive, letting the operating system inform us when there is data for us to act on. In the background, this is performed by a few different event notification systems, depending on which operating system we’re running. asyncio is abstracted enough that it switches between the different notification systems, depending on which one our operating system supports. The following are the event notification systems used by specific operating systems:\nkqueue—FreeBSD and MacOS epoll—Linux IOCP (I/O completion port)—Windows These systems keep track of our non-blocking sockets and notify us when they are ready for us to do something with them. This notification system is the basis of how asyncio can achieve concurrency.\nBut how do we keep track of multiple tasks that are waiting for data to come back to them? This is where the event loop comes in.\n2.2 Event Loop The event loop is the core of every asyncio application. In asyncio, the event loop keeps a queue of tasks.\n2.2.1 How the Event Loop Works The event loop works by keeping a queue of tasks instead of messages. Each task is a coroutine. When a task is added to the event loop, it will execute until it encounters an I/O operation (such as a web request). When a task hits an I/O-bound operation, it pauses and allows the event loop to run other tasks that are not waiting for I/O operations to complete. 2.2.2 Understanding Event Loops in Asynchronous Programming When working with event loops in asynchronous programming, the process can be understood as a sequence of steps that efficiently handle tasks without blocking the execution. Here\u0026rsquo;s a breakdown of how it works:\n2.2.2.1 Creating the Event Loop When an event loop is created, an empty queue of tasks is initialized. This queue will hold all the tasks that need to be executed.\n2.2.2.2 Adding Tasks to the Queue We add tasks to the event loop’s queue. These tasks are executed one at a time, based on their order in the queue.\n2.2.2.3 Processing Tasks Iteratively Each iteration of the event loop checks for tasks that need to be executed. It processes tasks sequentially, running them one by one.\n2.2.2.4 Handling I/O Operations If a task encounters an I/O operation (like reading from a file or making a network request), it cannot proceed immediately. In this case, the task is paused and put on hold.\n2.2.2.5 Pausing and Waiting for I/O Completion When a task is paused, the event loop instructs the operating system to monitor any associated sockets or resources for I/O completion. During this time, the event loop continues checking for and executing other tasks.\n2.2.2.6 Waking Up Paused Tasks On each iteration of the event loop, we check if any of the I/O operations have completed. If they have:\nThe paused task is woken up. The task resumes execution and completes its process. 2.2.2.7. Conclusion This cycle of pausing, waiting for I/O, and resuming tasks allows the event loop to run multiple tasks concurrently, making it an efficient way to handle asynchronous operations without blocking the program.\nBy continuously iterating and checking for completed I/O tasks, the event loop ensures that no task is left idle while waiting for I/O operations, enabling a smooth and efficient workflow.\nVisualizing the Event Loop with Asynchronous Tasks We can visualize how the event loop works with asynchronous tasks as shown in Figure 1.9: the main thread submits tasks to the event loop, which then runs them. When a task encounters an I/O operation, it pauses and allows other tasks to run. Once the I/O operation is complete, the paused task is resumed.\nExample: Submitting Multiple Asynchronous Tasks Let\u0026rsquo;s consider three tasks that each make an asynchronous web request. These tasks consist of:\nCPU-bound setup: Some code that prepares data for the web request. I/O-bound web request: The asynchronous part where we send the web request. CPU-bound post-processing: After the web request completes, we do some more CPU-intensive work. Now, let\u0026rsquo;s submit these tasks to the event loop simultaneously. Here’s how we can write this in pseudocode:\ndef make_request(): cpu_bound_setup() io_bound_web_request() cpu_bound_postprocess() task_one = make_request() task_two = make_request() task_three = make_request() First task starts executing code, and the other two are left waiting to run. Once the CPU-bound setup work is finished in Task 1, it hits an I/O-bound operation and will pause itself to say, “I’m waiting for I/O; any other tasks waiting to run can run.” Once this happens, Task 2 can begin executing. Task 2 starts its CPU-bound code and then pauses, waiting for I/O. At this time both Task 1 and Task 2 are waiting concurrently for their network request to complete. Since Tasks 1 and 2 are both paused waiting for I/O, we start running Task 3. Now imagine once Task 3 pauses to wait for its I/O to complete, the web request for Task 1 has finished. We’re now alerted by our operating system’s event notification system that this I/O has finished. We can now resume executing Task 1 while both Task 2 and Task 3 are waiting for their I/O to finish. In figure 1.10, we show the execution flow of the pseudocode we just described. If we look at any vertical slice of this diagram, we can see that only one CPU-bound piece of work is running at any given time; however, we have up to two I/O-bound operations happening concurrently. This overlapping of waiting for I/O per each task is where the real time savings of asyncio comes in.\n","permalink":"http://localhost:1313/posts/pages/asyncio/asyncio1/","summary":"An introduction to asynchronous programming in Python using asyncio.","title":"Async io : Async io Intro (Day 1)"},{"content":"34.Styling in CSS 34.1 Setting Inline Styles =\u0026gt; In react for inline styles we use the style attribute and pass an object with camelCase properties.\nimport React from \u0026#39;react\u0026#39;; const myStyle = { color: \u0026#39;blue\u0026#39;, backgroundColor: \u0026#39;yellow\u0026#39; } const MyComponent = () =\u0026gt; { return ( \u0026lt;div style={myStyle}\u0026gt; \u0026lt;h1\u0026gt;Inline Styles\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ) } or we can use the style attribute directly in the element.\nimport React from \u0026#39;react\u0026#39;; const MyComponent = () =\u0026gt; { return ( \u0026lt;div style={{color: \u0026#39;blue\u0026#39;, backgroundColor: \u0026#39;yellow\u0026#39;}}\u0026gt; \u0026lt;h1\u0026gt;Inline Styles\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ) } 34.2 Setting External Styles =\u0026gt; We can also use external CSS files in react. We can import the CSS file in the component file and use the class name in the\nimport React from \u0026#39;react\u0026#39;; import \u0026#39;./MyComponent.css\u0026#39;; const MyComponent = () =\u0026gt; { return ( \u0026lt;div className=\u0026#34;myStyle\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;External Styles\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ) } 34.3 Setting Inline Dynamic Styles =\u0026gt;You can also set the inline styles dynamically by using the state.\nimport React,{useState} from \u0026#39;react\u0026#39;; const App=()=\u0026gt;{ const [valid,setValid]=useState(true); function changeStyle(){ setValid(!valid); } const myStyle={ color:valid?\u0026#39;blue\u0026#39;:\u0026#39;red\u0026#39;, backgroundColor:valid?\u0026#39;yellow\u0026#39;:\u0026#39;green\u0026#39; } return( \u0026lt;div\u0026gt; \u0026lt;button onClick={changeStyle}\u0026gt;Change Style\u0026lt;/button\u0026gt; \u0026lt;div style={myStyle}\u0026gt; \u0026lt;h1\u0026gt;Inline Dynamic Styles\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) } export default App; or we can use the style attribute directly in the element.\nimport React,{useState} from \u0026#39;react\u0026#39;; const App=()=\u0026gt;{ const [valid,setValid]=useState(true); function changeStyle(){ setValid(!valid); } return( \u0026lt;div\u0026gt; \u0026lt;button onClick={changeStyle}\u0026gt;Change Style\u0026lt;/button\u0026gt; \u0026lt;div style={{color:valid?\u0026#39;blue\u0026#39;:\u0026#39;red\u0026#39;,backgroundColor:valid?\u0026#39;yellow\u0026#39;:\u0026#39;green\u0026#39;}}\u0026gt; \u0026lt;h1\u0026gt;Inline Dynamic Styles\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) } export default App; 34.4 Setting Css Classes Dynamically =\u0026gt; We can also set the CSS classes dynamically by using the state.\nimport React,{useState} from \u0026#39;react\u0026#39;; import \u0026#39;./MyComponent.css\u0026#39;; const App=()=\u0026gt;{ const [valid,setValid]=useState(true); const [active,setActive]=useState(true); function changeStyle(){ setValid(!valid); setActive(!active); } return( \u0026lt;div\u0026gt; \u0026lt;button onClick={changeStyle}\u0026gt;Change Style\u0026lt;/button\u0026gt; \u0026lt;div className={`div-control ${valid?\u0026#39;right\u0026#39;:\u0026#39;wrong\u0026#39;} ${active?\u0026#39;active\u0026#39;:\u0026#39;inactive\u0026#39;}`}\u0026gt; \u0026lt;h1\u0026gt;Setting Css Classes Dynamically\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) } export default App; 34.5 Css modules =\u0026gt; Every time we import Css file in react component they are regarded as global styles i.e One component style can affect another component style =\u0026gt;So, to avoid this we can use CSS modules. CSS modules are local by default. We can use CSS modules by naming the CSS file as filename.module.css. =\u0026gt; The CSS file is imported in the component file and the class name is used as an object.\nProblem1 =\u0026gt; Imagine that you have two components with the same class name. The styles of one component can affect the styles of another component.which is not good for the application to solve this problem we can use CSS modules.\nStructure of the project\nsrc\r|_components\r|_MyComponent\r|_MyComponent.js\r|_MyComponent.module.css Step 1: Create a CSS file with the name MyComponent.module.css\n.myStyle{ color: blue; background-color: yellow; } .right{ text-align: right; } Step 2: Import the CSS file in the component file as shown below.\nimport React from \u0026#39;react\u0026#39;; import styles from \u0026#39;./MyComponent.module.css\u0026#39;; step 3: Use the class name as shown below.\nconst MyComponent = () =\u0026gt; { return ( \u0026lt;div className={styles.myStyle}\u0026gt; \u0026lt;h1\u0026gt;CSS Modules\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ) } Combined code\nimport React from \u0026#39;react\u0026#39;; import styles from \u0026#39;./MyComponent.module.css\u0026#39;; const MyComponent = () =\u0026gt; { return ( \u0026lt;div className={styles.myStyle}\u0026gt; \u0026lt;h1\u0026gt;CSS Modules\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ) } export default MyComponent; 34.5.1 Combining multiple classes import React from \u0026#39;react\u0026#39;; import styles from \u0026#39;./MyComponent.module.css\u0026#39;; const MyComponent = () =\u0026gt; { return ( \u0026lt;div className={`${styles.myStyle} ${styles.right}`}\u0026gt; \u0026lt;h1\u0026gt;CSS Modules\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ) } export default MyComponent; 34.6 Dynamic CSS Modules =\u0026gt; We can also set the CSS classes dynamically by using the state.\nimport React,{useState} from \u0026#39;react\u0026#39;; import styles from \u0026#39;./MyComponent.module.css\u0026#39;; const MyComponent = () =\u0026gt; { const [valid,setValid]=useState(true); const [active,setActive]=useState(true); function changeStyle(){ setValid(!valid); setActive(!active); } return ( \u0026lt;div className={`${styles.myStyle} ${valid?styles.right:styles.wrong} ${active?styles.active:styles.inactive}`}\u0026gt; \u0026lt;h1\u0026gt;CSS Modules\u0026lt;/h1\u0026gt; \u0026lt;button onClick={changeStyle}\u0026gt;Change Style\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } export default MyComponent; ","permalink":"http://localhost:1313/posts/pages/react/react5/","summary":"Learn various methods to style React components including inline styles, external styles, dynamic styles, and CSS modules.","title":"React : Day 5"},{"content":"35. Debugging in react 35.1 Using console.log import React from \u0026#39;react\u0026#39;; const MyComponent = () =\u0026gt; { const name = \u0026#39;John Doe\u0026#39;; console.log(name); return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Debugging in React\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ) } export default MyComponent; 35.2 Strict Mode =\u0026gt; In Strict Mode,React will render components twice. It helps to idenify the issues in the code.\nimport React,{StrictMode} from \u0026#39;react\u0026#39;; const MyComponent = () =\u0026gt; { const name = \u0026#39;John Doe\u0026#39;; console.log(name); return ( \u0026lt;StrictMode\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Debugging in React\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/StrictMode\u0026gt; ) } export default MyComponent; You can wrap any component in StrictMode.Just difference is that it will render the component twice.\n=\u0026gt; We can wrap the entire application in StrictMode in the index.js file.\nimport React,{StrictMode} from \u0026#39;react\u0026#39;; import ReactDOM from \u0026#39;react-dom\u0026#39;; import App from \u0026#39;./App\u0026#39;; ReactDOM.render( \u0026lt;StrictMode\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/StrictMode\u0026gt;, document.getElementById(\u0026#39;root\u0026#39;) ); 35.3 React Developer Tools React Developer Tools is a Chrome extension that allows you to inspect the React component hierarchy in the Chrome Developer Tools. Videos\n","permalink":"http://localhost:1313/posts/pages/react/react6/","summary":"Learn how to debug React applications using console.log, Strict Mode, and React Developer Tools.","title":"React : Day 6"},{"content":"Python Fundamentals: A Beginner\u0026rsquo;s Guide (Part 1) 1. Virtual Environment A virtual environment is a feature in Python that allows you to install the same package with different versions on the same system. This enables you to work on multiple projects using different versions of the same package.\n1.1. Installing venv The venv module is included in the Python standard library, so you don\u0026rsquo;t need to install it separately. However, if you are using an older version of Python (before 3.3), you can install virtualenv using pip:\npip install virtualenv 1.2. Creating a Virtual Environment To create a virtual environment, you can use the venv module, which is included in the Python standard library. Here\u0026rsquo;s how you can create a virtual environment named myenv:\npython -m venv myenv This command creates a new directory named myenv that contains the necessary files for the virtual environment.\n1.3. Activating a Virtual Environment To activate the virtual environment, you may run the following command:\n# For Linux/Mac: source myenv/bin/activate # For Windows: myenv\\Scripts\\activate 2. Python Packages 2.1. List All the Python Packages To list or save all the installed packages in the current environment, you can use the following command using freeze:\npip freeze # To list all the installed packages pip freeze \u0026gt; requirements.txt # To save all the installed packages in a file 2.2. Installing Python Packages To install a Python package, you can use the pip install command followed by the package name. For example, to install the requests package, you can run:\npip install requests 2.3. Uninstalling Python Packages To uninstall a Python package, you can use the pip uninstall command followed by the package name. For example, to uninstall the requests package, you can run:\npip uninstall requests 2.4. Run Python Package/Script To run a python package or script, you can use the following command:\npython -m package_name 3. Python Basics 3.1. Running a Python Script To run a Python script, you can use the following command:\npython script.py 3.2. Python Indentation In Python, the code block (body of the function, loop, etc.) starts with a colon (:) and the line following the colon should be indented.\nif 5 \u0026gt; 2: print(\u0026#34;Five is greater than two!\u0026#34;) # Indented block 3.3. Python Comments There are two types of comments in Python:\n# This is a single line comment \u0026#34;\u0026#34;\u0026#34; This is a multiline comment This is a multiline comment This is a multiline comment This is a multiline comment \u0026#34;\u0026#34;\u0026#34; 3.4. Print Statement The print() function is used to display the output on the console. For example:\nprint(\u0026#34;Hello, World!\u0026#34;) 3.5. Data Types Python has the following data types:\nint float str bool list tuple set dict None a = 10 # int b = 10.5 # float c = \u0026#34;Hello\u0026#34; # str d = True # bool e = [1,2,3] # list f = (1,2,3) # tuple g = {1,2,3} # set h = {\u0026#34;name\u0026#34;:\u0026#34;John\u0026#34;,\u0026#34;age\u0026#34;:30} # dict i = None # None print(type(a)) # \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; Note:Use type() function to check the data type of a variable.As it return the class of the variable.\n3.6. Rules of Variable Declaration A variable name must start with a letter or the underscore character. A variable name cannot start with a number. A variable name can only contain alpha-numeric characters and underscores (A-z, 0-9, and _ ). Variable names are case-sensitive (age, Age, and AGE are three different variables). 3.7. Type Conversion You can convert one data type to another using the following functions:\nint(): To convert to an integer float(): To convert to a float str(): To convert to a string bool(): To convert to a boolean list(): To convert to a list tuple(): To convert to a tuple set(): To convert to a set dict(): To convert to a dictionary a = 10 #a=10 b = float(a) #b=10.0 c = str(a) #c=\u0026#39;10\u0026#39; d = bool(a) #d=True e = list(c) #e=[\u0026#39;1\u0026#39;,\u0026#39;0\u0026#39;] f = tuple(c) #f=(\u0026#39;1\u0026#39;,\u0026#39;0\u0026#39;) g = set(c) #g={\u0026#39;1\u0026#39;,\u0026#39;0\u0026#39;} h = dict(name=\u0026#34;John\u0026#34;,age=30) or dict([(\u0026#34;name\u0026#34;,\u0026#34;John\u0026#34;),(\u0026#34;age\u0026#34;,30)]) #h={\u0026#39;name\u0026#39;:\u0026#39;John\u0026#39;,\u0026#39;age\u0026#39;:30} Note: Python is dynamically typed, which means a variable\u0026rsquo;s data type can be changed.\n4. Operators 4.1. Arithmetic Operators +: Addition -: Subtraction *: Multiplication /: Division %: Modulus **: Power //: Floor Division a = 10 b = 3 print(a + b) # 13 print(a - b) # 7 print(a * b) # 30 print(a / b) # 3.3333333333333335 print(a % b) # 1 print(a ** b) # 1000 print(a // b) # 3 4.2. Assignment Operators =: Assign value +=: Add and assign -=: Subtract and assign *=: Multiply and assign /=: Divide and assign %=: Modulus and assign **=: Power and assign //=: Floor Division and assign a = 10 a += 5 # a = a + 5 a -= 5 # a = a - 5 a *= 5 # a = a * 5 a /= 5 # a = a / 5 a %= 5 # a = a % 5 a **= 5 # a = a ** 5 a //= 5 # a = a // 5 4.3. Comparison Operators ==: Equal to !=: Not equal to \u0026gt;: Greater than \u0026lt;: Less than \u0026gt;=: Greater than or equal to \u0026lt;=: Less than or equal to a = 10 b = 20 print(a == b) # False print(a != b) # True print(a \u0026gt; b) # False print(a \u0026lt; b) # True print(a \u0026gt;= b) # False print(a \u0026lt;= b) # True 4.4. Logical Operators and: Returns True if both statements are true or: Returns True if one of the statements is true not: Reverse the result, returns False if the result is true a = 10 b = 20 c = 30 print(a \u0026lt; b and b \u0026lt; c) # True print(a \u0026lt; b or b \u0026gt; c) # True print(not(a \u0026lt; b and b \u0026lt; c)) # False 4.5. Identity Operators is: Returns True if both variables are the same object is not: Returns True if both variables are not the same object a = [1,2,3] b = [1,2,3] print(a is b) # False print(a is not b) # True 4.6. Membership Operators in: Returns True if a sequence with the specified value is present in the object not in: Returns True if a sequence with the specified value is not present in the object a = [1,2,3] #Can be used in list , tuple , set , dict, string print(1 in a) # True print(4 not in a) # True 4.7. Bitwise Operators \u0026amp;: AND |: OR ^: XOR ~: NOT \u0026lt;\u0026lt;: Left Shift \u0026gt;\u0026gt;: Right Shift a = 10 b = 4 print(a \u0026amp; b) # 0 print(a | b) # 14 print(a ^ b) # 14 print(~a) # -11 print(a \u0026lt;\u0026lt; 2) # 40 print(a \u0026gt;\u0026gt; 2) # 2 Note: is vs ==\nis is used to compare the memory location of two objects. == is used to compare the values of two objects. # For Mutable objects (list, dict, set): a = [1,2,3] b = [1,2,3] print(a == b) # True print(a is b) # False # For immutable objects (int, float, string, tuple, None): a = 10 b = 10 print(a == b) # True print(a is b) # True c = None d = None print(c == d) # True print(c is d) # True 5.Taking User Input In Python, you can take user input using the input() function. Here\u0026rsquo;s an example:\nname = input(\u0026#34;Enter your name: \u0026#34;) print(\u0026#34;Hello, \u0026#34; + name) Note: The input() function always returns a string. If you want to convert it to another data type, you can use type conversion functions like int(), float(), etc.\n","permalink":"http://localhost:1313/posts/pages/python/python_basics/","summary":"A comprehensive guide to Python programming fundamentals covering core concepts for beginners","title":"Python Fundamentals: A Beginner's Guide (Part 1)"},{"content":"30. Sharing State Between React Components: Lifting State Up In React, components are the building blocks of a user interface. Each component can have its own state, but there are situations where multiple components need to share the same state. In such cases, the concept of \u0026ldquo;lifting state up\u0026rdquo; is used to manage the shared state in a common ancestor component.\u0026ldquo;Lifting state up\u0026rdquo; is a common pattern in React used when two or more components need to share data or state. Instead of managing the state in one of the components and creating a dependency between them, the state is \u0026ldquo;lifted up\u0026rdquo; to the closest common ancestor of the components that need the state.\nKey Concept When multiple components need to interact with the same state:\nThe closest common ancestor is identified. The state is moved to this common ancestor. This ancestor manages the state and passes it down to the child components as props. If any child needs to modify the state, the ancestor provides a function (passed as a prop) to handle the state update. Step-by-Step Procedure and Syntax Identify the Closest Common Ancestor:\nDetermine which component is the nearest common parent of all components that need to share the state. Lift the State Up:\nMove the state to the identified ancestor component. Use the useState hook (or class component state) to manage the state. const [state, setState] = useState(initialValue); Pass State Down as Props:\nPass the state to child components that need it via props. \u0026lt;ChildComponent state={state} /\u0026gt; Create State-Modifier Functions:\nDefine functions in the ancestor component to modify the state. const modifyStateHandler = (newData) =\u0026gt; { setState((prev) =\u0026gt; ({ ...prev, newData })); }; Pass Modifier Functions to Children:\nPass these functions to the child components as props so they can trigger state updates. \u0026lt;ChildComponent onModifyState={modifyStateHandler} /\u0026gt; Use Props in Child Components:\nAccess and use the state and modifier functions passed as props in the child components. function ChildComponent({ state, onModifyState }) { return ( \u0026lt;button onClick={() =\u0026gt; onModifyState(\u0026#34;new data\u0026#34;)}\u0026gt;Modify State\u0026lt;/button\u0026gt; ); } Example (Sharing State/Data Between Two Child Component) Parent Component (App.js) The parent component will hold the shared state and provide functions for updating it. It will pass the state and update functions as props to the child components.\nimport React, { useState } from \u0026#34;react\u0026#34;; import ChildOne from \u0026#34;./ChildOne\u0026#34;; import ChildTwo from \u0026#34;./ChildTwo\u0026#34;; const App = () =\u0026gt; { // Shared state const [sharedState, setSharedState] = useState(\u0026#34;Initial State\u0026#34;); // Function to update the state const updateState = (newState) =\u0026gt; { setSharedState(newState); }; return ( \u0026lt;div style={{ padding: \u0026#34;20px\u0026#34;, fontFamily: \u0026#34;Arial\u0026#34; }}\u0026gt; \u0026lt;h1\u0026gt;Parent Component\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;Shared State: {sharedState}\u0026lt;/p\u0026gt; \u0026lt;hr /\u0026gt; \u0026lt;ChildOne sharedState={sharedState} updateState={updateState} /\u0026gt; \u0026lt;hr /\u0026gt; \u0026lt;ChildTwo sharedState={sharedState} updateState={updateState} /\u0026gt; \u0026lt;/div\u0026gt; ); }; export default App; Child Component 1 (ChildOne.js) This component will display the shared state and allow the user to modify it through an input field.\nimport React from \u0026#34;react\u0026#34;; const ChildOne = ({ sharedState, updateState }) =\u0026gt; { const handleChange = (e) =\u0026gt; { updateState(e.target.value); }; return ( \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;Child Component One\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;Shared State: {sharedState}\u0026lt;/p\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; value={sharedState} onChange={handleChange} placeholder=\u0026#34;Update State\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; ); }; export default ChildOne; Child Component 2 (ChildTwo.js) This component will display the shared state and provide a button to reset it.\nimport React from \u0026#34;react\u0026#34;; import React from \u0026#34;react\u0026#34;; const ChildTwo = ({ sharedState, updateState }) =\u0026gt; { const handleReset = () =\u0026gt; { updateState(\u0026#34;Initial State\u0026#34;); }; return ( \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;Child Component Two\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;Shared State: {sharedState}\u0026lt;/p\u0026gt; \u0026lt;button onClick={handleReset}\u0026gt;Reset State\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); }; export default ChildTwo; Folder Structure src/ ├── App.js ├── ChildOne.js ├── ChildTwo.js ├── index.js Explanation:\nThe App component is the parent component that holds the shared state and passes it down to ChildOne and ChildTwo. ChildOne and ChildTwo are child components that receive the shared state and update functions as props. ChildOne allows the user to update the shared state through an input field, while ChildTwo provides a button to reset the state. Note: We cant directly pass data from one child component to another child component. We need to pass the data to the parent component and then pass it to the other child component. This is called lifting state up.\nExample (Sharing State/Data Between Two Sibling Components) Parent Component (App.js) import {usState} from \u0026#39;react\u0026#39;; import Expenses from \u0026#39;./Expenses\u0026#39;; import NewExpense from \u0026#39;./NewExpense\u0026#39;; const App=()=\u0026gt;{ const [expenses,setExpenses]=useState([ {id:1,title:\u0026#39;Car Insurance\u0026#39;,amount:294.67,date:new Date(2021,2,28)}, {id:2,title:\u0026#39;Health Insurance\u0026#39;,amount:394.67,date:new Date(2021,3,28)}, {id:3,title:\u0026#39;Home Insurance\u0026#39;,amount:494.67,date:new Date(2021,4,28)}, ]); const addExpenseHandler=(expense)=\u0026gt;{ setExpenses((prevExpenses)=\u0026gt;{ return [expense,...prevExpenses]; }); }; return ( \u0026lt;div\u0026gt; \u0026lt;NewExpense onAddExpense={addExpenseHandler}/\u0026gt; \u0026lt;Expenses items={expenses}/\u0026gt; \u0026lt;/div\u0026gt; ); }; export default App; NewExpense Component import ExpenseForm from \u0026#39;./ExpenseForm\u0026#39;; const NewExpense=(props)=\u0026gt;{ const saveExpenseDataHandler=(enteredExpenseData)=\u0026gt;{ const expenseData={ ...enteredExpenseData, id:Math.random().toString() }; props.onAddExpense(expenseData); }; return ( \u0026lt;div\u0026gt; \u0026lt;ExpenseForm onSaveExpenseData={saveExpenseDataHandler}/\u0026gt; \u0026lt;/div\u0026gt; ); }; export default NewExpense; Expenses function Expenses({iteam}){ return ( \u0026lt;\u0026gt; {items.map((expense)=\u0026gt;( \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;{expense.title}\u0026lt;/h2\u0026gt; \u0026lt;div\u0026gt;{expense.amount}\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;{expense.date.toISOString()}\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ))} \u0026lt;/div\u0026gt; ) } 31. Dynamically setting object keys In JavaScript, object keys are usually set statically, but there are situations where you may need to set object keys dynamically based on some conditions or variables. This can be achieved using the square bracket notation ([]) to set object keys dynamically.\nfor example:\nconst data=\u0026#34;name\u0026#34;; const person={ [data]:\u0026#39;John\u0026#39; }; console.log(person); // {name:\u0026#39;John\u0026#39;} If we dont use square bracket notation, then the key will be set as \u0026lsquo;data\u0026rsquo; instead of \u0026rsquo;name\u0026rsquo;.\nconst data=\u0026#34;name\u0026#34;; const person={ data:\u0026#39;John\u0026#39; }; console.log(person); // {data:\u0026#39;John\u0026#39;} 32.Using SAme State Variable to store multiple values =\u0026gt; We can use the same state variable to store multiple values by using an object.\nconst [userInput,setUserInput]=useState({ enteredTitle:\u0026#39;\u0026#39;, enteredAmount:\u0026#39;\u0026#39;, enteredDate:\u0026#39;\u0026#39; }); const titleChangeHandler=(event)=\u0026gt;{ setUserInput({ ...userInput, enteredTitle:event.target.value }); }; const amountChangeHandler=(event)=\u0026gt;{ setUserInput({ ...userInput, enteredAmount:event.target.value }); }; const dateChangeHandler=(event)=\u0026gt;{ setUserInput({ ...userInput, enteredDate:event.target.value }); }; return ( \u0026lt;div\u0026gt; Title:\u0026lt;input type=\u0026#34;text\u0026#34; value={userInput.enteredTitle} onChange={titleChangeHandler}/\u0026gt; Amount:\u0026lt;input type=\u0026#34;number\u0026#34; value={userInput.enteredAmount} onChange={amountChangeHandler}/\u0026gt; Date:\u0026lt;input type=\u0026#34;date\u0026#34; value={userInput.enteredDate} onChange={dateChangeHandler}/\u0026gt; The entered title is {userInput.enteredTitle} The entered amount is {userInput.enteredAmount} The entered date is {userInput.enteredDate} \u0026lt;/div\u0026gt; ); =\u0026gt; In the above code, we are using the same state variable userInput to store multiple values. We are using an object to store the values. We are using the spread operator to copy the existing values of the object and then updating the required value.\n33.Handeling page reloads when a form is submitted When a form is submitted, the page reloads by default. This is not what we want in a single page application. We want to stay on the same page and update the content of the page. We can do this by using the preventDefault() method on the event object. The preventDefault() method prevents the default behavior of the event object. In this case, it prevents the page from reloading when the form is submitted. const submitHandler=(event)=\u0026gt;{ event.preventDefault(); // code to handle form submission }; ","permalink":"http://localhost:1313/posts/pages/react/react4/","summary":"Learn how to share state between React components by lifting state up to a common ancestor.","title":"React : Day 4"},{"content":"1. Python Manupulation of Data Types We have already discussed the basic concepts of Python programming in the previous part of this series. In this part, we will dive deeper into operations and manipulations of different data types in Python.\n1.1.Numeric Operations 1.1.1. abs() Function The abs() function returns the absolute value of a number. For example:\nnum = -10 print(abs(num)) # Output: 10 1.1.2. round() Function The round() function rounds a number to the nearest integer. For example:\nnum = 3.14159 print(round(num)) # Output: 3 1.1.3. ord() Function The ord() function returns the Unicode code point of a character. For example:\nchar = \u0026#39;A\u0026#39; print(ord(char)) # Output: 65 1.2. String Operations String is a sequence of characters enclosed within single, double, or triple quotes. In Python, strings are immutable, meaning they cannot be changed once created. Here are some common string operations:\n1.2.1. Declaring a String we can declare a string using single, double, or triple quotes. For example:\nstr1 = \u0026#39;Hello, World!\u0026#39; #for single line string str2 = \u0026#34;Hello, World!\u0026#34; #for single line string str3 = \u0026#39;\u0026#39;\u0026#39;Hello, World! This is a multiline string.\u0026#39;\u0026#39;\u0026#39;#for multiline string 1.2.2. Text Decorators There are many text decorators available in Python to format strings among them we use \\n for a new line, \\t for a tab. For example:\nstr1 = \u0026#39;Hello, \\nWorld!\u0026#39; #for new line str2 = \u0026#34;Hello, \\tWorld!\u0026#34; #for tab 1.2.3. String Indexing The indexing of a string starts from 0 to n-1, where n is the length of the string. For example: for example: a=\u0026ldquo;hello\u0026rdquo;\na = H e l l o 0 1 2 3 4 0 -4 -3 -2 -1 1.2.4. Ascessing Characters in a String We can access characters in a string using the index using []. For example:\nstr = \u0026#34;Hello, World!\u0026#34; print(str[0]) # Output: H print(str[-1]) # Output: ! 1.2.5. String Concatenation We can concatenate two strings using the + operator and * operator . For example:\nstr1 = \u0026#34;Hello\u0026#34; str2 = \u0026#34;World\u0026#34; print(str1 + str2) # Output: HelloWorld print(str1 * 3) # Output: HelloHelloHello 1.2.6. String Slicing We can slice a string using the syntax variable[start:end:step] to get a substring.\nNote: The substring contains characters from index start to end-1, meaning the character at the end index is not included but character at the start index is included . The step refers to the increment or jump of the index\nFor example:\na = \u0026#34;hello\u0026#34; # Slice from index 1 to the end of the string print(a[1:]) # ello (Characters from index 1 to the end) # Slice from the beginning of the string to index 4 (doesn\u0026#39;t contain character at index 4) print(a[:4]) # hell (Characters from index 0 to 3) # Slice from index 1 to index 4 (doesn\u0026#39;t contain character at index 4) print(a[1:4]) # ell (Characters from index 1 to 3) # Full slice of the string with default values print(a[::]) # hello (Default start is 0, end is the string length, step is 1) # Defining a step value in slicing # Slice with a step of 2 print(a[::2]) # hlo (Start from index 0 to the end, select every 2nd character) # Reverse the string using a negative step print(a[::-1]) # olleh (Reverse the string by stepping backward) # Combining start, end, and step print(a[1:4:2]) # el #(Start from index 1 to 4 (doesn\u0026#39;t contain character at index 4), with a step of 2) 1.2.7. String Methods Python provides various built-in methods to manipulate strings. Some of the commonly used string methods are:\nlen() : Returns the length of the string. str = \u0026#34;Hello, World!\u0026#34; print(len(str)) # Output: 13 replace() : Replaces a substring with another substring. str = \u0026#34;Hello, World!\u0026#34; print(str.replace(\u0026#34;World\u0026#34;, \u0026#34;Universe\u0026#34;)) # Output: Hello, Universe! upper() : Converts the string to uppercase. str = \u0026#34;Hello, World!\u0026#34; print(str.upper()) # Output: HELLO, WORLD! lower() : Converts the string to lowercase. str = \u0026#34;Hello, World!\u0026#34; print(str.lower()) # Output: hello, world! split() : Splits the string into a list based on the delimiter. str = \u0026#34;Hello, World!\u0026#34; print(str.split(\u0026#34;,\u0026#34;)) # Output: [\u0026#39;Hello\u0026#39;, \u0026#39; World!\u0026#39;] capitalize() : Converts the first character of the string to uppercase.\nstr = \u0026#34;hello, world!\u0026#34; print(str.capitalize()) # Output: Hello, world! -find() : Returns the index of the first occurrence of a substring.\nstr = \u0026#34;Hello, World!\u0026#34; print(str.find(\u0026#34;World\u0026#34;)) # Output: 7 print(str.find(\u0026#34;e\u0026#34;)) # Output: 1 print(str.find(\u0026#34;Universe\u0026#34;)) # Output: -1 count() : Returns the number of occurrences of a substring. str = \u0026#34;Hello, World!\u0026#34; print(str.count(\u0026#34;l\u0026#34;)) # Output: 3 startswith() : Returns True if the string starts with a specified substring. str = \u0026#34;Hello, World!\u0026#34; print(str.startswith(\u0026#34;Hello\u0026#34;)) # Output: True endswith() : Returns True if the string ends with a specified substring. str = \u0026#34;Hello, World!\u0026#34; print(str.endswith(\u0026#34;World!\u0026#34;)) # Output: True strip() : Removes leading and trailing whitespaces from the string. We can also specify the characters to be removed. str = \u0026#34; Hello, World! \u0026#34; print(str.strip()) # Output: Hello, World! str = \u0026#34;!!!!!!!!Hello, World!!!!!\u0026#34; print(str.strip(\u0026#34;!\u0026#34;)) # Output: Hello, World! lstrip() : Removes leading whitespaces from the string.we can also specify the characters to be removed. str = \u0026#34; Hello, World! \u0026#34; print(str.lstrip()) # Output: Hello, World! str = \u0026#34;!!!!!!!!Hello, World!!!!!\u0026#34; print(str.lstrip(\u0026#34;!\u0026#34;)) # Output: Hello, World!!!!! rstrip() : Removes trailing whitespaces from the string.We can also specify the characters to be removed. str = \u0026#34; Hello, World! \u0026#34; print(str.rstrip()) # Output: Hello, World! str = \u0026#34;!!!!!!!!Hello, World!!!!!\u0026#34; print(str.rstrip(\u0026#34;!\u0026#34;)) # Output: !!!!!!!!Hello, World 1.2.8. f-Strings f-strings are a convenient way to format strings in Python. They allow you to embed expressions inside string literals, using curly braces {}. For example:\nname = \u0026#34;Alice\u0026#34; age = 30 print(f\u0026#34;My name is {name} and I am {age} years old.\u0026#34;) # Output: My name is Alice and I am 30 years old. 1.2.9. Raw Strings Raw strings are used to ignore escape characters in a string. They are prefixed with an r or R. For example:\npath=\u0026#34;C:\\Users\\Alice\\Documents\u0026#34; print(path) # Output: C:UsersAliceDocuments path = r\u0026#34;C:\\Users\\Alice\\Documents\u0026#34; print(path) # Output: C:\\Users\\Alice\\Documents Note:String is immutable in python.\na = \u0026#34;Hello\u0026#34; a[0] = \u0026#34;h\u0026#34; # Error: \u0026#39;str\u0026#39; object does not support item assignment #Instead To change the string value we can use the following method a=\u0026#39;k\u0026#39;+a[1::] # Output: \u0026#39;kello\u0026#39; 1.3. List Operations A list is a collection of items enclosed within square brackets []. Lists are mutable, meaning they can be changed after creation. Here are some common list operations: Key Points:\nList is mutable in python. List support indexing and slicing like string 1.3.1. Declaring a List We can declare a list by enclosing items within square brackets []. For example:\nlist1 = [1, 2, 3, 4, 5] list2 = [\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;] list3 = [1, \u0026#34;apple\u0026#34;, True, 3.14] 1.3.2 List Concatenation We can concatenate two or more lists using the + operator. For example:\nlist1 = [1, 2, 3] list2 = [4, 5, 6] print(list1 + list2) # Output: [1, 2, 3, 4, 5, 6] 1.3.3. Mutable property of List List is mutable in python and its example is shown below:\n#for string a = \u0026#34;Hello\u0026#34; a[0] = \u0026#34;h\u0026#34; # Error: \u0026#39;str\u0026#39; object does not support item assignment #for list list1 = [1, 2, 3] list1[0] = 10 print(list1) # Output: [10, 2, 3] 1.3.4. Built-in List Methods Python provides various built-in methods to manipulate lists. Some of the commonly used list methods are:\nlen() : Returns the length of the list. list1 = [1, 2, 3, 4, 5] print(len(list1)) # Output: 5 append() : Adds an element to the end of the list /Change orginal list does not return anything. list1 = [1, 2, 3] list1.append(4) print(list1) # Output: [1, 2, 3, 4] insert() : Inserts an element at a specified position in the list /Change orginal list does not return anything. list1 = [1, 2, 3] list1.insert(1, 4) print(list1) # Output: [1, 4, 2, 3] pop() : Removes the element at the specified position in the list and returns it. If no index is specified, it removes and returns the last element. list1 = [1, 2, 3] print(list1.pop(1)) # Output: 2 print(list1) # Output: [1, 3] print(list1.pop()) # Output: 3 print(list1) # Output: [1] remove() : Removes the first occurrence of the specified element from the list. list1 = [1, 2, 3, 2] list1.remove(2) print(list1) # Output: [1, 3, 2] -sort() : Sorts the list in ascending order.Does not return anything but change the original list.\nlist1 = [3, 1, 2] list1.sort() print(list1) # Output: [1, 2, 3] -reverse() : Reverses the order of the list. Does not return anything but change the original list.\nlist1 = [1, 2, 3] list1.reverse() print(list1) # Output: [3, 2, 1] -count() : Returns the number of occurrences of a specified element in the list.\nlist1 = [1, 2, 3, 2] print(list1.count(2)) # Output: 2 -index() : Returns the index of the first occurrence of the specified element in the list.\nlist1 = [1, 2, 3, 2] print(list1.index(2)) # Output: 1 1.3.5. List Comprehension List comprehension is a concise way to create lists from existing lists. There are 3 type of syntax.\nNot using if list1=[variable for variable in iterable] Using if only list1 = [variable for variable in iterable if condition] Using if else list1 = [variable if condition else variable for variable in iterable] Traditional way of creating list\nlist1 = [] for i in range(5): list1.append(i) print(list1) # Output: [0, 1, 2, 3, 4] Using list comprehension\nlist1 = [i for i in range(5)] print(list1) # Output: [0, 1, 2, 3, 4] list1 = [i for i in range(5) if i%2==0] print(list1) # Output: [0, 2, 4] list1 = [i if i%2==0 else i**2 for i in range(5)] print(list1) # Output: [0, 1, 2, 9, 4] Note: When you attempt to access an index that is out of range, Python will raise an IndexError so put it in try-except block to handle the error.\nNote: The indexing and slicing of list are similar to string.\n1.4 Dictionary Operations A dictionary is a collection of key-value pairs enclosed within curly braces {}. Dictionaries are mutable and unordered. Here are some common dictionary operations:\n1.4.1. Declaring a Dictionary We can declare a dictionary by specifying key-value pairs within curly braces {}. For example:\ndict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} dict2 = {1: \u0026#34;apple\u0026#34;, 2: \u0026#34;banana\u0026#34;, 3: \u0026#34;cherry\u0026#34;} dict3 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;, \u0026#34;hobbies\u0026#34;: [\u0026#34;reading\u0026#34;, \u0026#34;painting\u0026#34;]} 1.4.2. Accessing Dictionary Elements We can access dictionary elements using keys. For example:\ndict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} print(dict1[\u0026#34;name\u0026#34;]) # Output: Alice 1.4.3 Adding Dictionary Elements We can add new key-value pairs to a dictionary by specifying the key and value. For example:\ndict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30} dict1[\u0026#34;city\u0026#34;] = \u0026#34;New York\u0026#34; print(dict1) # Output: {\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 30, \u0026#39;city\u0026#39;: \u0026#39;New York\u0026#39;} 1.4.4. Updating Dictionary Elements We can update the value of an existing key in a dictionary. For example:\ndict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} dict1[\u0026#34;age\u0026#34;] = 35 print(dict1) # Output: {\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 35, \u0026#39;city\u0026#39;: \u0026#39;New York\u0026#39;} 1.4.5 Dictionary Methods Python provides various built-in methods to manipulate dictionaries. Some of the commonly used dictionary methods are:\nlen() : Returns the number of key-value pairs in the dictionary. dict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} print(len(dict1)) # Output: 3 keys() : Returns a list of all the keys in the dictionary. dict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} print(dict1.keys()) # Output: dict_keys([\u0026#39;name\u0026#39;, \u0026#39;age\u0026#39;, \u0026#39;city\u0026#39;]) values() : Returns a list of all the values in the dictionary. dict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} print(dict1.values()) # Output: dict_values([\u0026#39;Alice\u0026#39;, 30, \u0026#39;New York\u0026#39;]) items() : Returns a list of key-value pairs in the dictionary. dict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} print(dict1.items()) # Output: dict_items([(\u0026#39;name\u0026#39;, \u0026#39;Alice\u0026#39;), (\u0026#39;age\u0026#39;, 30), (\u0026#39;city\u0026#39;, \u0026#39;New York\u0026#39;)]) -pop() : Removes the element with the specified key and returns its value.\ndict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} print(dict1.pop(\u0026#34;age\u0026#34;)) # Output: 30 print(dict1) # Output: {\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;city\u0026#39;: \u0026#39;New York\u0026#39;} -get() : Returns the value of the specified key. If the key does not exist, it returns the specified default value.\ndict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} print(dict1.get(\u0026#34;age\u0026#34;)) # Output: 30 print(dict) # Output: {\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 30, \u0026#39;city\u0026#39;: \u0026#39;New York\u0026#39;} Note: When you attempt to access a key that does not exist in the dictionary, Python will raise a KeyError so put it in try-except block to handle the error or use get() method to avoid the error.\n1.4.6. Nested Dictionaries A dictionary can contain another dictionary as a value. This is known as a nested dictionary. For example:\ndict1 = { \u0026#34;person1\u0026#34;: {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30}, \u0026#34;person2\u0026#34;: {\u0026#34;name\u0026#34;: \u0026#34;Bob\u0026#34;, \u0026#34;age\u0026#34;: 25} } print(dict1[\u0026#34;person1\u0026#34;][\u0026#34;name\u0026#34;]) # Output: Alice 1.4.7. Dictionary Comprehension Dictionary comprehension is a concise way to create dictionaries. For example:\ndict1 = {x: x**2 for x in range(5)} # Output: {0: 0, 1: 1, 2: 4, 3: 9, 4: 16} #using if only dict1 = {x: x**2 for x in range(5) if x%2==0} # Output: {0: 0, 2: 4, 4: 16} #using if else dict1 = {x: x**2 if x%2==0 else x**3 for x in range(5)} # Output: {0: 0, 1: 1, 2: 4, 3: 27, 4: 16} 1.5. Tuple Operations A tuple is a collection of items enclosed within parentheses (). Tuples are immutable, meaning they similar to python as they cant be changed using indexing as a[0]=10 will give an error.\n1.5.1. Declaring a Tuple We can declare a tuple by enclosing items within parentheses (). For example:\ntuple1 = (1, 2, 3) tuple2 = (\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;) tuple3 = (1, \u0026#34;apple\u0026#34;, True, 3.14) 1.5.2. Accessing Tuple Elements We can access tuple elements using indexing . For example:\ntuple1 = (1, 2, 3) print(tuple1[0]) # Output: 1 1.5.3. Slice Tuple We can slice a tuple using the syntax variable[start:end:step] to get a sub-tuple. For example:\ntuple1 = (1, 2, 3, 4, 5) print(tuple1[1:4]) # Output: (2, 3, 4) 1.5.4. Tuple Methods Python provides various built-in methods to manipulate tuples. Some of the commonly used tuple methods are:\ncount() : Returns the number of occurrences of a specified element in the tuple. tuple1 = (1, 2, 3, 2) print(tuple1.count(2)) # Output: 2 index() : Returns the index of the first occurrence of the specified element in the tuple. tuple1 = (1, 2, 3, 2) print(tuple1.index(2)) # Output: 1 len() : Returns the length of the tuple. tuple1 = (1, 2, 3, 2) print(len(tuple1)) # Output: 4 1.5.5 concatenation of tuple We can concatenate two or more tuples using the + operator. For example:\ntuple1 = (1, 2, 3) tuple2 = (4, 5, 6) print(tuple1 + tuple2) # Output: (1, 2, 3, 4, 5, 6) 1.5.6. Tuple Unpacking Tuple unpacking allows us to assign multiple variables at once. For example:\ntuple1 = (1, 2, 3) a, b, c = tuple1 d,*e = tuple1 print(a) # Output: 1 print(b) # Output: 2 print(c) # Output: 3 print(d) # Output: 1 print(e) # Output: [2, 3] tuple1 = (1, 2, 3, 4, 5) a, *b, c = tuple1 print(a) # Output: 1 print(b) # Output: [2, 3, 4] print(c) # Output: 5 Note:Ascessing and slicing of tuple is similar to list and string.\n1.6. Boolean Operations Boolean is a data type that represents one of two values: True or False. Boolean values are used to evaluate conditions in programming. Here are some common boolean operations:\n1.6.1. Condition when variable is True When a variable has a non-zero value, it is considered True. a = 10 if a: print(\u0026#34;The value of a is True\u0026#34;) When a string is not empty, it is considered True. a = \u0026#34;Hello\u0026#34; if a: print(\u0026#34;The value of a is True\u0026#34;) When a list is not empty, it is considered True. a = [1, 2, 3] if a: print(\u0026#34;The value of a is True\u0026#34;) When a dictionary is not empty, it is considered True. a = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30} if a: print(\u0026#34;The value of a is True\u0026#34;) When a tuple is not empty, it is considered True. a = (1, 2, 3) if a: print(\u0026#34;The value of a is True\u0026#34;) When a set is not empty, it is considered True. a = {1, 2, 3} if a: print(\u0026#34;The value of a is True\u0026#34;) When a variable is explicitly set to True, it is considered True. a = True if a: print(\u0026#34;The value of a is True\u0026#34;) 1.6.2. Condition when variable is False Those which are not in the above condition are considered as False.\n1.7. Set Operations A set is a collection of unique items enclosed within curly braces {}. Main Uses of set are:\nTo remove duplicate elements from a list. To perform mathematical set operations like union, intersection, difference, etc. 1.7.1. Declaring a Set We can declare a set by enclosing items within curly braces {} or set(). For example:\nset1 = {1, 2, 3} set2 = {\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;} set3 = {1, \u0026#34;apple\u0026#34;, True, 3.14} #using set() set4 = set([1, 2, 3]) set5=set() 1.7.2. Set Methods Python provides various built-in methods to manipulate sets. Some of the commonly used set methods are:\n-len() : Returns the number of elements in the set.\nset1 = {1, 2, 3} print(len(set1)) # Output: 3 -add() : Adds an element to the set.Doesn\u0026rsquo;t return anything.\nset1 = {1, 2, 3} set1.add(4) print(set1) # Output: {1, 2, 3, 4} -clear() : Removes all elements from the set.Doesn\u0026rsquo;t return anything.\nset1 = {1, 2, 3} set1.clear() print(set1) # Output: set() -remove() : Removes the specified element from the set. If the element is not present, it raises an error.\nset1 = {1, 2, 3} set1.remove(2) print(set1) # Output: {1, 3} discard() : Removes the specified element from the set. If the element is not present, it does not raise an error.\nset1 = {1, 2, 3} set1.discard(2) print(set1) # Output: {1, 3} -union() : Returns a set containing the union of two sets.\nset1 = {1, 2, 3} set2 = {3, 4, 5} print(set1.union(set2)) # Output: {1, 2, 3, 4, 5} -intersection() : Returns a set containing the intersection of two sets.\nset1 = {1, 2, 3} set2 = {3, 4, 5} print(set1.intersection(set2)) # Output: {3} -difference() : Returns a set containing the difference between two sets.\nset1 = {1, 2, 3} set2 = {3, 4, 5} print(set1.difference(set2)) # Output: {1, 2} -symmetric_difference() : Returns a set containing the symmetric difference between two sets.\nset1 = {1, 2, 3} set2 = {3, 4, 5} print(set1.symmetric_difference(set2)) # Output: {1, 2, 4, 5} -issubset() : Returns True if all elements of a set are present in another set.\nset1 = {1, 2, 3} set2 = {1, 2, 3, 4, 5} print(set1.issubset(set2)) # Output: True 1.8 Used in All iterable 1.8.1. in Operator The in operator is used to check if an element is present in an iterable. For example:\n# in string str = \u0026#34;Hello, World!\u0026#34; print(\u0026#34;Hello\u0026#34; in str) # Output: True # in list list1 = [1, 2, 3, 4, 5] print(3 in list1) # Output: True # in tuple tuple1 = (1, 2, 3, 4, 5) print(6 in tuple1) # Output: False # in set set1 = {1, 2, 3, 4, 5} print(5 in set1) # Output: True # in dictionary dict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30} print(\u0026#34;name\u0026#34; in dict1) # Output: True 1.8.2. not in Operator The not in operator is used to check if an element is not present in an iterable. For example:\n# not in string str = \u0026#34;Hello, World!\u0026#34; print(\u0026#34;Alice\u0026#34; not in str) # Output: True # not in list list1 = [1, 2, 3, 4, 5] print(6 not in list1) # Output: True # not in tuple tuple1 = (1, 2, 3, 4, 5) print(5 not in tuple1) # Output: False # not in set set1 = {1, 2, 3, 4, 5} print(5 not in set1) # Output: False # not in dictionary dict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30} print(\u0026#34;name\u0026#34; not in dict1) # Output: False 1.8.3. len() Function The len() function is used to get the length of an iterable. For example:\n# for string str = \u0026#34;Hello, World!\u0026#34; print(len(str)) # Output: 13 # for list list1 = [1, 2, 3, 4, 5] print(len(list1)) # Output: 5 # for tuple tuple1 = (1, 2, 3, 4, 5) print(len(tuple1)) # Output: 5 # for set set1 = {1, 2, 3, 4, 5} print(len(set1)) # Output: 5 # for dictionary dict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30} print(len(dict1)) # Output: 2 1.8.4. max() and min() Functions The max() function is used to get the maximum value from an iterable, and the min() function is used to get the minimum value for list,string,set and tuples only. for dictionary you can use .keys() or .values() and use it. For example:\n# for list list1 = [1, 2, 3, 4, 5] print(max(list1)) # Output: 5 print(min(list1)) # Output: 1 # for tuple tuple1 = (1, 2, 3, 4, 5) print(max(tuple1)) # Output: 5 print(min(tuple1)) # Output: 1 # for string string = \u0026#34;Hello, World!\u0026#34; print(max(string)) # Output: r print(min(string)) # Output: \u0026#39; \u0026#39; # for set set1 = {1, 2, 3, 4, 5} print(max(set1)) # Output: 5 print(min(set1)) # Output: 1 1.8.5. join() Function The join() function is used to concatenate elements of an iterable with a separator. For example:\n# for list list1 = [\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;] print(\u0026#34;, \u0026#34;.join(list1)) # Output: apple, banana, cherry # for tuple tuple1 = (\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;) print(\u0026#34;, \u0026#34;.join(tuple1)) # Output: apple, banana, cherry # for set set1 = {\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;} print(\u0026#34;, \u0026#34;.join(set1)) # Output: apple, banana, cherry # for string string = \u0026#34;Hello, World!\u0026#34; print(\u0026#34;, \u0026#34;.join(string)) # Output: H, e, l, l, o, ,, , W, o, r, l, d, ! ","permalink":"http://localhost:1313/posts/pages/python/python_datatype_operations/","summary":"An in-depth look at Python data types, exploring their usage and importance in programming.","title":"Python Fundamentals: Understanding Data Types (Part 2)"},{"content":"22. Fragments in React Fragments are a way to group multiple elements in React without adding extra nodes to the DOM. Fragments are useful when you want to return multiple elements from a component, but you don\u0026rsquo;t want to add an extra div or span element to the DOM.\nFragments are represented by the \u0026lt;Fragment\u0026gt; tag or the shorthand syntax \u0026lt;\u0026gt;. You can use fragments to return multiple elements from a component without adding extra nodes to the DOM.\nWithout using fragments:\nfunction App() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Hello, World!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;Welcome to React\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } Here, the App component returns two elements, but they are wrapped in a div element. If you don\u0026rsquo;t want to add an extra div element to the DOM, you can use fragments.\nUsing fragments:\nfunction App() { return ( \u0026lt;\u0026gt; or \u0026lt;Fragment\u0026gt; \u0026lt;h1\u0026gt;Hello, World!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;Welcome to React\u0026lt;/p\u0026gt; \u0026lt;/\u0026gt; or \u0026lt;/Fragment\u0026gt; ); } 23. Passing jsx as props In React, you can pass JSX as props to other components. This allows you to create reusable components that can be used in different parts of your application.\nPassing JSX as props: function App() { const heading = \u0026lt;div\u0026gt;\u0026lt;h1\u0026gt;Hello, World!\u0026lt;/h1\u0026gt;\u0026lt;p\u0026gt;My name is nirajan Khatiwada\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;; return \u0026lt;Greeting message={heading} /\u0026gt;; } or function App() { return \u0026lt;Greeting message={\u0026lt;div\u0026gt;\u0026lt;h1\u0026gt;Hello, World!\u0026lt;/h1\u0026gt;\u0026lt;p\u0026gt;My name is nirajan Khatiwada\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;} /\u0026gt;; } Using props in the Greeting component: function Greeting(props) { return \u0026lt;div\u0026gt;{props.message}\u0026lt;/div\u0026gt;; } Passing built-in components as props: function App() { return \u0026lt;Greeting element=\u0026#34;button\u0026#34; /\u0026gt;; } 24. Isolation of Component in React Isolation of components is a key concept in React that allows you to create reusable components that are independent of each other. This means that each component should be self-contained and not rely on external data or state.\nfor example:\nfunction Button(props){ const [showText, setShowText] = useState(false); return ( \u0026lt;button onClick={() =\u0026gt; setShowText(!showText)}\u0026gt; {showText ? \u0026#39;Hide Text\u0026#39; : \u0026#39;Show Text\u0026#39;} \u0026lt;/button\u0026gt; ); } function App(){ return ( \u0026lt;div\u0026gt; \u0026lt;Button /\u0026gt; \u0026lt;Button /\u0026gt; \u0026lt;/div\u0026gt; ); } Here The component Button is isolated means one state of the component does not affect the other component. Each component is self-contained and does not rely on external data or state. for example, the showText state in one Button component does not affect the showText state in the other Button component.\n25. Taking User Input in React Using onChange event: function App() { const [name, setName] = useState(\u0026#39;\u0026#39;); const handleChange = (e) =\u0026gt; { setName(e.target.value); }; return ( \u0026lt;div\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; value={name} onChange={handleChange} /\u0026gt; \u0026lt;p\u0026gt;Hello, {name}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } Whats Happen Here\nHere, we have an input element that takes user input. When the user types in the input field,the onChange event is triggered for ervy keypress. The handleChange function is called with the event object as an argument for every keypress. The setName function is called with value of user input and it rerender the component with the updated value for every keypress. The value of the input field is set to the name state, and the name is displayed below the input field. Note: use onChange event to take user input in React and update the state accordingly to reflect the changes in the UI. If you use value as a prop in the input field, you must also provide an onChange event handler to update the state. Use this method if you want to update in real-time as the user types in the input field.\nOther method will be discussed in upcoming posts. 26.Rendering 2D Arrays in React In React, you can render 2D arrays by using nested map functions to iterate over the rows and columns of the array. This allows you to display tabular data or grid-like structures in your application.\nRendering a 2D array: function App() { const data = [ [\u0026#39;John\u0026#39;, \u0026#39;Doe\u0026#39;, 30], [\u0026#39;Jane\u0026#39;, \u0026#39;Smith\u0026#39;, 25], [\u0026#39;Alice\u0026#39;, \u0026#39;Brown\u0026#39;, 35], ]; return ( \u0026lt;table\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;First Name\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Last Name\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Age\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; {data.map((row, index) =\u0026gt; ( \u0026lt;tr key={index}\u0026gt; {row.map((cell, index) =\u0026gt; ( \u0026lt;td key={index}\u0026gt;{cell}\u0026lt;/td\u0026gt; ))} \u0026lt;/tr\u0026gt; ))} \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; ); } 27. Immutable update patterns in React In react while changing the state we shouldnot change the orginal state directly Instead, we should create a new copy of the state and update the copy with the new values. This is known as immutable update pattern.speciaaly when working with arrays and objects.\nThe Wrong way to update state: function App() { const [items, setItems] = useState([\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;cherry\u0026#39;]); const removeItem = (index) =\u0026gt; { items.splice(index, 1); setItems(items); }; return ( \u0026lt;div\u0026gt; \u0026lt;ul\u0026gt; {items.map((item, index) =\u0026gt; ( \u0026lt;li key={index}\u0026gt; {item} \u0026lt;button onClick={() =\u0026gt; removeItem(index)}\u0026gt;Remove\u0026lt;/button\u0026gt; \u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ); } The Correct way to update state: function App() { const [items, setItems] = useState([\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;cherry\u0026#39;]); const removeItem = (index) =\u0026gt; { const newItems = [...items]; newItems.splice(index, 1); setItems(newItems); }; return ( \u0026lt;div\u0026gt; \u0026lt;ul\u0026gt; {items.map((item, index) =\u0026gt; ( \u0026lt;li key={index}\u0026gt; {item} \u0026lt;button onClick={() =\u0026gt; removeItem(index)}\u0026gt;Remove\u0026lt;/button\u0026gt; \u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt;x x \u0026lt;/div\u0026gt; ); } Note: Always create a new copy of the state when updating arrays or objects in React. This ensures that the state is updated correctly and prevents unexpected behavior in your application. 28. Common Pattern for update,delete and add in React In React, you can use common patterns to update, delete, and add items to an array. These patterns involve creating new copies of the array and updating the state with the new values.\nAdd an item to an array: function App() { const [items, setItems] = useState([\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;cherry\u0026#39;]); const addItem = (item) =\u0026gt; { setItems([...items, item]); // or // const newItems = [...items]; // newItems.push(item); // setItems(newItems); }; return ( \u0026lt;div\u0026gt; \u0026lt;ul\u0026gt; {items.map((item, index) =\u0026gt; ( \u0026lt;li key={index}\u0026gt;{item}\u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;button onClick={() =\u0026gt; addItem(\u0026#39;orange\u0026#39;)}\u0026gt;Add Item\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } Deleting an item from an array: function App() { const [items, setItems] = useState([\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;cherry\u0026#39;]); const removeItem = (index) =\u0026gt; { const newItems = items.filter((item, i) =\u0026gt; i !== index); setItems(newItems); }; return ( \u0026lt;div\u0026gt; \u0026lt;ul\u0026gt; {items.map((item, index) =\u0026gt; ( \u0026lt;li key={index}\u0026gt; {item} \u0026lt;button onClick={() =\u0026gt; removeItem(index)}\u0026gt;Remove\u0026lt;/button\u0026gt; \u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ); } Updating an data of an array using map: function App() { const [items, setItems] = useState([ { id: 1, name: \u0026#39;apple\u0026#39;, price: 1 }, { id: 2, name: \u0026#39;banana\u0026#39;, price: 2 }, { id: 3, name: \u0026#39;cherry\u0026#39;, price: 3 }, ]); const updateItem = (id, price) =\u0026gt; { const newItems = items.map((item) =\u0026gt; item.id === id ? { ...item, price: price } : item ); setItems(newItems); }; return ( \u0026lt;div\u0026gt; \u0026lt;ul\u0026gt; {items.map((item) =\u0026gt; ( \u0026lt;li key={item.id}\u0026gt; {item.name} - ${item.price}{\u0026#39; \u0026#39;} \u0026lt;button onClick={() =\u0026gt; updateItem(item.id, item.price + 1)}\u0026gt; Increase Price \u0026lt;/button\u0026gt; \u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ); } Updating an data of an array using find: function App() { const [items, setItems] = useState([ { id: 1, name: \u0026#39;apple\u0026#39;, price: 1 }, { id: 2, name: \u0026#39;banana\u0026#39;, price: 2 }, { id: 3, name: \u0026#39;cherry\u0026#39;, price: 3 }, ]); const updateItem = (id, price) =\u0026gt; { const newItems= [...items]; const newItem = newItems.find((item) =\u0026gt; item.id === id); if (newItem) { newItem.price = price; setItems(newItems); } }; return ( \u0026lt;div\u0026gt; \u0026lt;ul\u0026gt; {items.map((item) =\u0026gt; ( \u0026lt;li key={item.id}\u0026gt; {item.name} - ${item.price}{\u0026#39; \u0026#39;} \u0026lt;button onClick={() =\u0026gt; updateItem(item.id, item.price + 1)}\u0026gt; Increase Price \u0026lt;/button\u0026gt; \u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ); } Note: Always prefer map over find when updating an array of objects in React. This ensures that the state is updated correctly and prevents unexpected behavior in your application.\n29.Updating object in react In React, you can update an object in state by creating a new copy of the object and updating the copy with the new values. This ensures that the state is updated correctly and prevents unexpected behavior in your application.\nUpdating an object in state: function App() { const [person, setPerson] = useState({ name: \u0026#39;John\u0026#39;, age: 30 }); const updatePerson = () =\u0026gt; { setPerson({ ...person, age: person.age + 1 }); }; return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;Name: {person.name}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Age: {person.age}\u0026lt;/p\u0026gt; \u0026lt;button onClick={updatePerson}\u0026gt;Increase Age\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } use list if you want to show the list of items and use object if you want to show the details of the item to identify which one is clicked or update you can pass the index or id of the item to the function. Or you can hardcode the value to update the object or list.\n","permalink":"http://localhost:1313/posts/pages/react/react3/","summary":"A comprehensive guide covering React\u0026rsquo;s advanced concepts including Fragments, JSX Props, Component Isolation, and proper state management patterns","title":"React : Day 3"},{"content":"Python Control Structures: Mastering Loops and Conditionals In Python programming, control structures are essential for managing the flow of execution in your code. They allow you to make decisions, repeat tasks, and create complex algorithms. In this guide, we will explore two fundamental control structures in Python: loops and conditionals.\n1. Conditional Statements Conditional statements in Python allow you to execute specific blocks of code based on certain conditions. The most common conditional statements are if, elif, and else.\n1.1. The if Statement The if statement is used to check a condition and execute a block of code if the condition is true.\nExample:\nx = 10 if x \u0026gt; 5: print(\u0026#34;x is greater than 5\u0026#34;) Output:\nx is greater than 5 1.2. The elif Statement The elif statement allows you to check multiple conditions after the initial if statement. If the previous conditions are false, the elif block is evaluated.\nExample:\nx = 5 if x \u0026gt; 5: print(\u0026#34;x is greater than 5\u0026#34;) elif x == 5: print(\u0026#34;x is equal to 5\u0026#34;) Output:\nx is equal to 5 1.3. The else Statement The else statement is used to execute a block of code when all the previous conditions are false.\nExample:\nx = 3 if x \u0026gt; 5: print(\u0026#34;x is greater than 5\u0026#34;) elif x == 5: print(\u0026#34;x is equal to 5\u0026#34;) else: print(\u0026#34;x is less than 5\u0026#34;) Output:\nx is less than 5 2. Loops Loops in Python allow you to execute a block of code repeatedly. There are two main types of loops in Python: for loops and while loops.\n2.1. The while Loop The while loop executes a block of code as long as a specified condition is true.\nSyntax:\nwhile condition: # Code block else: # Optional else block Example:\ncount = 0 while count \u0026lt; 5: print(count) count += 1 else: print(\u0026#34;Loop completed\u0026#34;) 2.2. The for Loop The for loop is used to iterate over a sequence (such as a list, tuple, or string) and execute a block of code for each item in the sequence.\nSyntax:\nfor item in sequence: # Code block else: # Optional else block Example:\nfruits = [\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;] for fruit in fruits: print(fruit) else: print(\u0026#34;No more fruits\u0026#34;) 2.3 Using For Loops with different data types 2.3.1. For Loop with Strings Example:\nfor char in \u0026#34;Python\u0026#34;: print(char) Output:\np\ry\rt\rh\ro\rn 2.3.2. For Loop with Lists Example:\nnumbers = [1, 2, 3, 4, 5] for num in numbers: print(num) Output:\n1\r2\r3\r4\r5 2.3.3. For Loop with tuples Example:\nfruits = (\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;) for fruit in fruits: print(fruit) Output:\napple\rbanana\rcherry Tuple unpacking can also be used in for loops to iterate over multiple values in a tuple.\ncoordinates = [(1, 2), (3, 4), (5, 6)] for x, y in coordinates: print(f\u0026#34;X: {x}, Y: {y}\u0026#34;) Output:\nX: 1, Y: 2\rX: 3, Y: 4\rX: 5, Y: 6 2.3.4. For Loop with Sets Example:\ncolors = {\u0026#34;red\u0026#34;, \u0026#34;green\u0026#34;, \u0026#34;blue\u0026#34;} for color in colors: print(color) Output:\nred\rgreen\rblue 2.3.5. For Loop with Dictionaries Example:\nperson = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} for key, value in person.items(): print(f\u0026#34;{key}: {value}\u0026#34;) Output:\nname: Alice\rage: 30\rcity: New York 2.4. break , pass and continue statements in loops 2.4.1. The break Statement The break statement is used to exit a loop prematurely. It terminates the current loop and resumes execution at the next statement after the loop.\nExample:\nfor num in [1, 2, 3, 4, 5]: if num == 3: break print(num) Output:\n1\r2 2.4.2. The continue Statement The continue statement is used to skip the rest of the code inside a loop for the current iteration and jump to the next iteration.\nExample:\nfor num in [1, 2, 3, 4, 5]: if num == 3: continue print(num) Output:\n1\r2\r4\r5 2.4.3. The pass Statement The pass statement is a null operation that does nothing. It is used when a statement is required syntactically but you do not want any code to execute.\nExample:\nfor num in [1, 2, 3, 4, 5]: pass ","permalink":"http://localhost:1313/posts/pages/python/python_control_structure/","summary":"A detailed examination of Python\u0026rsquo;s control structures, focusing on loops and conditionals to enhance your programming skills.","title":"Python Fundamentals: Mastering Control Structures (Part 3)"},{"content":"17. Hooks in React Anythong that start with prefix use is considered as a hook in react\n17.1. Rules of Hooks Only Call Hook inside a component function correct:\nfunction App() { const [val, setVal] = useState(0); } Incorrect:\nconst [val, setVal] = useState(0); function App() { } Only Call Hooks at the Top Level Hook must not be called inside code statement (e.g., inside an if statement, loop, or nested function). correct: function App() { const [val, setVal] = useState(0); } incorrect:\nfunction App() { if (true) { const [val, setVal] = useState(0); } } 3.Hook can be used inside other custom hooks too\n18. useState Hook useState is a React hook that allows you to manage component-specific state. It provides a way to declare state variables in functional components and ensure that changes to these variables cause the component or child component to re-render while the parent component remains unaffected from where the component whose set state is triggered.\nfor example:\nfunction App() { return ( \u0026lt;div\u0026gt; \u0026lt;MemoComp /\u0026gt; \u0026lt;/div\u0026gt; ); } function MemoComp() { const [data, setData] = useState(\u0026#34;No data\u0026#34;); function handle() { setData(\u0026#34;data\u0026#34;); } return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;{data}\u0026lt;/p\u0026gt; \u0026lt;button onClick={handle}\u0026gt;Click me\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } When button is clicked the handle function is called and the setData function is called which updates the data state variable. This cause the MemoComp and its child component to re-render with a new value of data.\n18.1. Syntax const [state, setState] = useState(initialState); 18.2. Managing State State management in React involves handling data and telling React to re-execute a function using the useState hook. This ensures that state updates lead to new state values. Example:\nconst [countes, setcountes] = useState(0); countes is the state variable that holds the current state value. setcountes is the function that updates the state variable. useState(0) is the initial state value. How it works: Initially, the state variable countes is set to 0. When the setcountes function is called, it updates the state variable to a new value. This triggers a re-render of the component, updating the UI with the new state value.\n18.3 Updating State Based on Previous State Suppose the age is 42. The handler calls setAge(age + 1) three times.\nfunction handleClick() { setAge(age + 1); // setAge(42 + 1) setAge(age + 1); // setAge(42 + 1) setAge(age + 1); // setAge(42 + 1) } if the initial age is 42, after calling this function, the age will be 43, not 45.\nTo solve this problem, we use an updater function to pass setAge calls.\nfunction handleClick() { setAge(a =\u0026gt; a + 1); // setAge(42 =\u0026gt; 43) setAge(a =\u0026gt; a + 1); // setAge(43 =\u0026gt; 44) setAge(a =\u0026gt; a + 1); // setAge(44 =\u0026gt; 45) } After this age will be 45 so use updater function when you want to update value based on previous value \u0026amp; it\u0026rsquo;s always recommended to use updater function in.\nIt is mostly used in:\nCounters Toggles Incrementing or decrementing a value 18.4. Pitfalls in useState In React state updates are asynchronous meaning they don\u0026rsquo;t immediately reflect in the current execution cycle. When you call a state setter function like setSelectedValue, React schedules the state update for the next render. This can lead to unexpected behavior if you try to access the updated state immediately after setting it.\nExample: function clickHandler(data) { setSelectedValue(`${data} is being clicked`); console.log(selectedTopic); // logs the old state, not updated one } Why It Happens State updates are asynchronous: React batches state updates and applies them during the next render cycle to optimize performance. Therefore, the state change you request won’t be immediately reflected in the current execution.\nLogging state immediately: Since the update happens after the current execution cycle, logging the state/selected topic immediately after calling setSelectedValue will show the old value (before the update).\nThis can be fixed using useEffect which is read later.\nNote: Always use the state variable when you want to reflect the changes in the UI.\n19. An Example demostrating useState Hook import {useState} from \u0026#39;react\u0026#39;; function App(){ const [count,setCount] = useState(0); return(){ \u0026lt;div\u0026gt; {count} \u0026lt;/div\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;Increment\u0026lt;/button\u0026gt; } } export default App; In the above example, we have a functional component App that uses the useState hook to manage the state of the count variable. The initial value of count is set to 0 using useState(0). The setCount function is used to update the value of count when the button is clicked. The count value is displayed in the UI, and clicking the button increments the count value by 1.\n20.Conditional Rendering in React Conditional rendering is a technique used to render different components or elements based on certain conditions. In React, conditional rendering can be achieved using ternary operators, and logical operators like \u0026amp;\u0026amp; .\n20.1. Ternary Operator The ternary operator is a concise way to write conditional statements in JavaScript. It consists of a condition followed by a question mark ?, an expression to execute if the condition is true, a colon :, and an expression to execute if the condition is false.\nExample:\nfunction App() { const isLoggedIn = true; return ( \u0026lt;div\u0026gt; {isLoggedIn ? \u0026lt;p\u0026gt;Welcome, User!\u0026lt;/p\u0026gt; : \u0026lt;p\u0026gt;Please log in\u0026lt;/p\u0026gt;} \u0026lt;/div\u0026gt; ); } Also We can write jsx code in variable and use it in return statement\nfunction App() { const isLoggedIn = true; const welcomeMessage=\u0026lt;p\u0026gt;Welcome, User!\u0026lt;/p\u0026gt;; const loginMessage=\u0026lt;p\u0026gt;Please log in\u0026lt;/p\u0026gt;; return ( \u0026lt;div\u0026gt; {isLoggedIn ? welcomeMessage : loginMessage} \u0026lt;/div\u0026gt; ); } 20.2. Logical \u0026amp;\u0026amp; Operator The logical \u0026amp;\u0026amp; operator is another way to conditionally render elements in React. The \u0026amp;\u0026amp; operator works by evaluating the expression on the left side of the \u0026amp;\u0026amp; operator. If the expression is true, the expression on the right side of the \u0026amp;\u0026amp; operator is executed. If the expression is false, the right side is not executed.\nExample:\nfunction App() { const isLoggedIn = true; return ( \u0026lt;div\u0026gt; {isLoggedIn \u0026amp;\u0026amp; \u0026lt;p\u0026gt;Welcome, User!\u0026lt;/p\u0026gt;} {isLoggedIn \u0026amp;\u0026amp; \u0026lt;button\u0026gt;Logout\u0026lt;/button\u0026gt;} {!isLoggedIn \u0026amp;\u0026amp; \u0026lt;p\u0026gt;Please log in\u0026lt;/p\u0026gt;} \u0026lt;/div\u0026gt; ); } Also We can write jsx code in variable and use it in return statement\nfunction App() { const isLoggedIn = true; const welcomeMessage=\u0026lt;p\u0026gt;Welcome, User!\u0026lt;/p\u0026gt;; const logoutButton=\u0026lt;button\u0026gt;Logout\u0026lt;/button\u0026gt;; const loginMessage=\u0026lt;p\u0026gt;Please log in\u0026lt;/p\u0026gt;; return ( \u0026lt;div\u0026gt; {isLoggedIn \u0026amp;\u0026amp; welcomeMessage} {isLoggedIn \u0026amp;\u0026amp; logoutButton} {!isLoggedIn \u0026amp;\u0026amp; loginMessage} \u0026lt;/div\u0026gt; ); } 21.Outputting list data dynamically In react we use map function to output list data dynamically as using map.\n21.1. Have a list of data You typically store the list in an array, which might come from a state, props, or external data source like an API\nconst data = [ { id: 1, name: \u0026#34;John\u0026#34; }, { id: 2, name: \u0026#34;Doe\u0026#34; }, { id: 3, name: \u0026#34;Jane\u0026#34; }, ]; 21.2 Using map function to output list data const listItems = data.map((item) =\u0026gt; \u0026lt;li key={item.id}\u0026gt;{item.name}\u0026lt;/li\u0026gt;); Key is used to uniquely identify each element in the list. It helps React identify which items have changed, are added, or are removed.It can be number or string.\n21.3. Rendering the list Use {} to embed the transformed list inside your component’s JSX.\n\u0026lt;ul\u0026gt;{listItems}\u0026lt;/ul\u0026gt;; 21.4. Putting it all together function App() { const data = [ { id: 1, name: \u0026#34;John\u0026#34; }, { id: 2, name: \u0026#34;Doe\u0026#34; }, { id: 3, name: \u0026#34;Jane\u0026#34; }, ]; const listItems = data.map((item) =\u0026gt; \u0026lt;li key={item.id}\u0026gt;{item.name}\u0026lt;/li\u0026gt;); return \u0026lt;ul\u0026gt;{listItems}\u0026lt;/ul\u0026gt;; } 21.5 Another form function App() { const data = [ { id: 1, name: \u0026#34;John\u0026#34; }, { id: 2, name: \u0026#34;Doe\u0026#34; }, { id: 3, name: \u0026#34;Jane\u0026#34; }, ]; return \u0026lt;ul\u0026gt;{data.map((item) =\u0026gt; \u0026lt;li key={item.id}\u0026gt;{item.name}\u0026lt;/li\u0026gt;); }\u0026lt;/ul\u0026gt;; } When will Rerender Occur?\nWhen state varaible or props value changes ","permalink":"http://localhost:1313/posts/pages/react/react1/","summary":"A detailed guide to help you understand and use hooks in React effectively.","title":"React : Day 2"},{"content":"Python Fundamentals: Exploring Advanced Operations (Part 4) In Python programming, advanced operations allow you to perform complex tasks efficiently. These operations include working with ranges, enumerations, zip functions, and more. In this guide, we will explore various advanced operations in Python to enhance your programming skills.\n1. Ranges Ranges in Python are used to generate a sequence of numbers. They are commonly used in loops to iterate over a specific range of values. Ranges can be created using the range() function.\n1.1. Creating a Range To create a range of numbers, you can use the range() function with the desired start, stop, and step values where start number is in inclusive and stop number is exclusive.\nExample:\n# Generate a range of numbers from 0 to 9 for i in range(10): print(i) Output:\n0\r1\r2\r3\r4\r5\r6\r7\r8\r9 Example:\n# Generate a range of numbers from 1 to 10 with a step of 2 for i in range(0, 10,2): print(i) Output:\n0\r2\r4\r6\r8 1.2 Enumerate Function The enumerate() function in Python is used to iterate over a sequence while keeping track of the index and value of each item. It returns a tuple containing the index and the value of the item.\nExample:\n# Enumerate a list of fruits fruits = [\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;cherry\u0026#39;] for index, fruit in enumerate(fruits): print(index, fruit) Output:\n0 apple\r1 banana\r2 cherry Example:\na=\u0026#34;nirajan\u0026#34; for index, char in enumerate(a): print(index, char) Output:\n0 n\r1 i\r2 r\r3 a\r4 j\r5 a\r6 n 1.3. Zip Function The zip() function in Python is used to combine multiple iterables (such as lists) element-wise. It returns an iterator of tuples where the i-th tuple contains the i-th element from each of the input iterables.\nExample:\n# Zip two lists together names = [\u0026#39;Alice\u0026#39;, \u0026#39;Bob\u0026#39;, \u0026#39;Charlie\u0026#39;] ages = [25, 30, 35] for name, age in zip(names, ages): print(name, age) Output:\nAlice 25\rBob 30\rCharlie 35 Example:\na=[1,2,3] b=[4,5,6] c=[7,8,9] print(list(zip(a,b,c))) Output:\n[(1, 4, 7), (2, 5, 8), (3, 6, 9)] 1.5 Sorted Function The sorted() function in Python is used to sort a list of elements. It returns a new sorted list without modifying the original list.The main feature of the sorted() function is that it can take a key argument that specifies a function to be called on each list element prior to making comparisons.\nExample:\n# Sort a list of numbers numbers = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5] sorted_numbers = sorted(numbers) print(sorted_numbers) Output:\n[1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] Example:\n# Sort a list of strings based on the length of the string fruits = [\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;cherry\u0026#39;, \u0026#39;date\u0026#39;] sorted_fruits = sorted(fruits, key=len) print(sorted_fruits) Output:\n[\u0026#39;date\u0026#39;, \u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;cherry\u0026#39;] Example:\n#Sort an dictionary based on the value d = {\u0026#39;apple\u0026#39;: 10, \u0026#39;banana\u0026#39;: 5, \u0026#39;cherry\u0026#39;: 15} sorted_d = sorted(d.items(), key=lambda x: x[1]) print(sorted_d) Output:\n[(\u0026#39;banana\u0026#39;, 5), (\u0026#39;apple\u0026#39;, 10), (\u0026#39;cherry\u0026#39;, 15)] Example:\n#Sort a list of tuples based on the second element t = [(1, 2), (3, 1), (5, 6)] sorted_t = sorted(t, key=lambda x: x[1]) print(sorted_t) Output:\n[(3, 1), (1, 2), (5, 6)] #2. Import in Python In Python, the import statement is used to import modules or packages into your script. It allows you to use functions, classes, and variables defined in other modules in your code.\n2.1. Importing Modules To import a module in Python, you can use the import keyword followed by the module name. You can then access the functions, classes, and variables defined in the module using dot notation.\nExample:\n# Import the math module import math # Calculate the square root of a number x = 16 print(math.sqrt(x)) Output:\n4.0 Example:\n# Import the datetime module import datetime # Get the current date and time now = datetime.datetime.now() print(now) Output:\n2024-11-17 10:30:00 2.2. Importing Specific Functions You can import specific functions or variables from a module using the from keyword. This allows you to use the imported functions directly without using the module name.\nExample:\n# Import the pi constant from the math module from math import pi # Print the value of pi print(pi) Output:\n3.141592653589793 Example:\n# Import the date class from the datetime module from datetime import date # Get the current date today = date.today() print(today) Output:\n2024-11-17 2.3. Aliasing Modules You can alias a module or package by using the as keyword. This allows you to refer to the module by a different name in your code.\nExample:\n# Import the math module and alias it as m import math as m # Calculate the square root of a number x = 25 print(m.sqrt(x)) Output:\n5.0 Example:\n# Import the datetime module using import and from and alias it as dt from datetime import datetime as dt now = dt.now() print(now) Output:\n2024-11-17 10:30:00 2.4. Importing All Functions You can import all functions and variables from a module using the * operator. This imports all the functions and variables defined in the module.\nExample:\n# Import all functions from the math module from math import * # Calculate the square root of a number x = 36 print(sqrt(x)) Output:\n6.0 The General Syntax is\nfrom module_name.submodule_name.submodule_name... import funtion_name or variable_name or filename as alias_name\nrandom module The random module in Python is used to generate random numbers. It provides various functions to generate random integers, floating-point numbers, and sequences.\n1. Generating Random Numbers The random module provides functions to generate random numbers within a specified range which can contain both integers starting and ending number.\nExample:\nfrom random import randint # Generate a random integer between 1 and 10 random_number = randint(1, 10) print(random_number) Output:\n5 2.Shuffling a List The random module provides a function to shuffle the elements of a list randomly. It modifies the original list in place.\nExample:\nfrom random import shuffle # Shuffle a list of numbers numbers = [1, 2, 3, 4, 5] shuffle(numbers) print(numbers) Output:\n[3, 1, 5, 2, 4] ","permalink":"http://localhost:1313/posts/pages/python/python_advanced_operations/","summary":"An in-depth exploration of advanced Python operations to enhance your programming skills.","title":"Python Fundamentals: Exploring Advanced Operations (Part 4)"},{"content":"Python Fundamentals: Understanding Functions In Python programming, functions are essential building blocks that allow you to organize and reuse code effectively. Functions help break down complex problems into smaller, manageable tasks, making your code more readable and maintainable. In this guide, we will explore the fundamentals of Python functions, including their syntax, parameters, return values, and more.\n1. Defining Functions A function in Python is defined using the def keyword followed by the function name and parentheses. You can also specify parameters inside the parentheses if the function requires input values.\nSyntax:\ndef function_name(parameters): # Function body # Statements Example:\ndef greet(): print(\u0026#34;Hello, World!\u0026#34;) 2. Calling Functions To call a function in Python, you simply write the function name followed by parentheses. If the function requires input values, you can pass them inside the parentheses.\nSyntax:\nfunction_name(arguments) Example:\ngreet() 3. return Statement The return statement in Python is used to exit a function and return a value to the caller. You can use the return statement to send a result back to the calling code.\nSyntax:\ndef function_name(parameters): # Function body return value Demostration using all:\ndef add_numbers(a, b): return a + b result = add_numbers(5, 3) print(result) 4. Args , Default Args and Kwargs 4.1. Args Using Args you can pass any number of arguments to a function. The arguments are passed as a tuple.\nSyntax:\ndef function_name(*args): # Function body Example:\ndef display_args(*args): print(args) display_args(1, 2, 3, 4, 5) Output:\n(1, 2, 3, 4, 5) 4.2. Default Args Default arguments are used when you do not pass a value for an argument in the function call. If a value is not provided, the default value is used.\nSyntax:\ndef function_name(arg=value): # Function body Example:\ndef add(a,b,c=0): return a+b+c result = add(5,3) print(result) result = add(5,3,2) print(result) Output:\n8\r10 4.3. Kwargs Using Kwargs you can pass any number of keyword arguments to a function. The arguments are passed as a dictionary.\nSyntax:\ndef function_name(**kwargs): # Function body Example:\ndef display_kwargs(**kwargs): print(kwargs) display_kwargs(name=\u0026#34;Alice\u0026#34;, age=30, city=\u0026#34;New York\u0026#34;) Output:\n{\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 30, \u0026#39;city\u0026#39;: \u0026#39;New York\u0026#39;} 4.4. Combination of Args and Kwargs Example:\ndef display_args_kwargs(*args, **kwargs): print(args) print(kwargs) display_args_kwargs(1, 2, 3, name=\u0026#34;Alice\u0026#34;, age=30) Output:\n(1, 2, 3)\r{\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 30} 4.5. Unpacking Args and Kwargs Example:\ndef display_args_kwargs(*args, **kwargs): print(args) print(kwargs) args = (1, 2, 3) kwargs = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30} display_args_kwargs(*args, **kwargs) Output:\n(1, 2, 3)\r{\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 30} 5. Lambda Functions Lambda functions, also known as anonymous functions, are small, single-expression functions that do not require a name. They are defined using the lambda keyword.\nSyntax:\nlambda arguments: expression Example:\nadd = lambda a, b: a + b result = add(5, 3) print(result) Output:\n8 6.Map and filter functions 6.1. Map Function The map() function in Python applies a given function to each item of an iterable (such as a list, tuple, or set) and returns a new iterable with the results.\nSyntax:\nmap(function, iterable) Example:\nnumbers = [1, 2, 3, 4, 5] squared = map(lambda x: x ** 2, numbers) print(list(squared)) Output:\n[1, 4, 9, 16, 25] 6.2. Filter Function The filter() function in Python filters elements from an iterable based on a given function. It returns an iterator with the elements that satisfy the condition.\nSyntax:\nfilter(function, iterable) Example:\nnumbers = [1, 2, 3, 4, 5] even = filter(lambda x: x % 2 == 0, numbers) print(list(even)) Output:\n[2, 4] 7.Local and Global Variables 7.1. Local Variables Local variables are defined within a function and are only accessible within that function. They are created when the function is called and destroyed when the function exits.\nExample:\ndef display(): message = \u0026#34;Hello, World!\u0026#34; print(message) display() # Trying to access the local variable outside the function will result in an error print(message) # NameError: name \u0026#39;message\u0026#39; is not defined 7.2. Global Variables Global variables are defined outside any function and can be accessed from any part of the code. You can use the global keyword to modify a global variable inside a function.\nExample:\nmessage = \u0026#34;Hello, World!\u0026#34; def display(): print(message) display() # Modifying a global variable inside a function def change_message(): global message message = \u0026#34;Hello, Python!\u0026#34; change_message() print(message) Output:\nHello, World!\rHello, Python! 7.3. Local vs. Global Variables If a local variable has the same name as a global variable, the local variable takes precedence within the function scope.\nExample:\nmessage = \u0026#34;Hello, World!\u0026#34; def display(): message = \u0026#34;Hello, Python!\u0026#34; print(message) display() print(message) Output:\nHello, Python!\rHello, World! ","permalink":"http://localhost:1313/posts/pages/python/python_function/","summary":"An in-depth exploration of Python functions, their usage, and importance in programming.","title":"Python Fundamentals: Understanding Functions (Part 5)"},{"content":"1. Create A React Project To create a React app we use Vite and its command is:\nnpm create vite@latest 2. Component In a React application, one page is broken down into multiple components. Components allow:\nReusability: For example, we can create one component for cards and use it to create multiple cards with different data. Related code lives together: Related items (JS code) are stored together. Separation of logic: Different components handle different data and logic. Diagram 3. Folder Structure my-app/\r├─ node_modules/\r├─ public/\r│ ├─ index.html\r│ ├─ image.png\r│ └─ favicon.ico\r├─ src/\r│ ├─ index.js\r│ ├─ App.js\r│ ├─ App.css\r│ └─ index.css\r├─ package.json\r└─ README.md node_module: Contains all the files of installed packages.\npublic: All static files are kept in this folder. For example, if image.png is in public, we can access it in the browser as 127.0.0.1:8000/image.png.\nindex.html: It is the page that is served to us and its content is managed by React using the DOM.Modify this file if you want to change the title or favicon.\npackage.json: Contains all the configuration of the project, package list, versions, and all related information.\nsrc: This is the folder where all the code is written.\nsrc/index.js React runs this file first.Code of index.js\nThe DOM selects the element of index.html whose id is root because of this code: document.getElementById('root') Then render() renders the \u0026lt;App/\u0026gt; component so that the root element will contain the data of the \u0026lt;App/\u0026gt; component. All changes are done in the index.html root element using the DOM. Remember that we never edit this file (code). src/App.js : This is where we will write all the SPA code. We start coding from App.jsx and link components as required.\nsrc/index.css : This CSS file is used by main.jsx, so it applies to the whole page. You can remove it if needed by removing its import in main.jsx.\n*** src/App.css:*** This CSS file is used by App.jsx, so it applies to all App components.\nRemember: Component functions must follow two rules:\nThe name should start with an uppercase letter (e.g., Head, MyHead). The function must return renderable content. The function must return a value that can be rendered (displayed on screen) by React. In most cases, return JSX. Example of a simple component:\nfunction App() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Hello world\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ); } As we know, App.jsx is provided by default when we create a React app. We can modify it and tailor it to our requirements\n4. Making Custom Components function FunctionName() { return ( \u0026lt;tagname\u0026gt; content \u0026lt;/tagname\u0026gt; ); } Important Note:\nTags that don\u0026rsquo;t have ending tags, such as \u0026lt;br\u0026gt; and \u0026lt;hr\u0026gt;, should be written as \u0026lt;br/\u0026gt; and \u0026lt;hr/\u0026gt;. class is replaced by className. For example, \u0026lt;body class=\u0026quot;data\u0026quot;\u0026gt; is written as \u0026lt;body className=\u0026quot;data\u0026quot;\u0026gt;. During a return in React, we cannot return multiple elements directly. Instead, we need to wrap them inside a single parent element like \u0026lt;div\u0026gt;, \u0026lt;\u0026gt;\u0026lt;/\u0026gt;. For Example :\nWrong Way: function component1() { return ( \u0026lt;div\u0026gt; Hi \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; Hello \u0026lt;/div\u0026gt; ); } right way: function component1() { return ( \u0026lt;div\u0026gt; {/* or \u0026lt;\u0026gt; */} \u0026lt;div\u0026gt; Hi \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; Hello \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; {/* or \u0026lt;/\u0026gt; */} ); } 5.Using One Component Inside Another Component To use one component inside another in React, follow the steps\nCreate a component. function Comp1() { return \u0026lt;div\u0026gt; Component \u0026lt;/div\u0026gt; } Use the component inside another component. function Comp2() { return ( \u0026lt;div\u0026gt; \u0026lt;Comp1 /\u0026gt; or \u0026lt;Comp1\u0026gt; \u0026lt;Comp1 /\u0026gt; content \u0026lt;/div\u0026gt; ) } Here, Comp1 is used inside Comp2.We can use Comp1 multiple times inside Comp2 as needed. Note: For proper management, create a components folder, create one file for each component, and export from there. Then, import and use it in another component.\nExample structure:\nsrc/\r├─ Assets/\r├─ App.jsx\r└─ Components/\r├─ Comp1.jsx\r└─ Comp2.jsx Task: Break Down a Component into Multiple Components\nfunction App() { return ( \u0026lt;\u0026gt; \u0026lt;header\u0026gt; I am header \u0026lt;/header\u0026gt; \u0026lt;main\u0026gt; I am main content \u0026lt;/main\u0026gt; \u0026lt;footer\u0026gt; I am footer \u0026lt;/footer\u0026gt; \u0026lt;/\u0026gt; ); } Solution: components/Header.jsx\nfunction Header() { return ( \u0026lt;header\u0026gt; I am header \u0026lt;/header\u0026gt; ); } export default Header; components/Footer.jsx\nfunction Footer() { return ( \u0026lt;footer\u0026gt; I am footer \u0026lt;/footer\u0026gt; ); } export default Footer; Finally, App.jsx\nimport Header from \u0026#39;./components/Header\u0026#39;; import Footer from \u0026#39;./components/Footer\u0026#39;; function App() { return ( \u0026lt;\u0026gt; \u0026lt;Header /\u0026gt; \u0026lt;main\u0026gt; I am main content \u0026lt;/main\u0026gt; \u0026lt;Footer /\u0026gt; \u0026lt;/\u0026gt; ); } export default App; structure:\nsrc/\r├─ Assets/\r├─ App.jsx\r└─ components/\r├─ Header.jsx\r└─ Footer.jsx Note: You Can Always break down a component as many times as you want. The main goal is to make the code more readable and maintainable.\n6. Some Component Hierarchies Examples THis is the simple example of a component hierarchy. 7. Embedding JavaScript code in JSX In JSX, we can embed JavaScript code using curly braces {}. We can write any JavaScript code inside the curly braces. For example, we can write a variable, function, or any JavaScript expression but of single line.\nfunction componentName() { return ( \u0026lt;div\u0026gt; { JavaScript code } \u0026lt;/div\u0026gt; ); } Example:\nfunction App() { const name = \u0026#39;John Doe\u0026#39;; return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt; Hello, {name} \u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ); } Where To Write Javascript Logic?\nWe can write JavaScript logic inside the component function. We can write JavaScript logic outside the component function and use it inside the component function. 7.1 Using JavaScript Logic Outside Component Function syntax:\n// Multiple lines of JavaScript code function ComponentName() { return ( \u0026lt;div\u0026gt; {/* JSX code */} \u0026lt;/div\u0026gt; ); } 7.2 Using JavaScript Logic Inside Component Function syntax:\nfunction ComponentName() { // Multiple lines of JavaScript code return ( \u0026lt;div\u0026gt; {/* JSX code */} \u0026lt;/div\u0026gt; ); } When to use Inside Component Function Outside Component Function Use Case When the logic is specific to the component and not used anywhere else. When the logic is used in multiple components. Advantages Logic is specific to the component. Logic can be reused in multiple components. Disadvantages Logic cannot be reused in other components. Logic is not specific to the component. Combined Example Task1: Create a component that generate random number between 1 to 10 and display in every page reload\nfunction RandomNumber(){ return \u0026lt;\u0026gt; \u0026lt;h1\u0026gt;Random Number: {Math.floor(Math.random() * 10) + 1}\u0026lt;/h1\u0026gt; } export default RandomNumber; This can be done in another ways which is more readable and maintainable\nfunction RandomNumber(){ const randomNumber = Math.floor(Math.random() * 10) + 1; return \u0026lt;h1\u0026gt;Random Number: {randomNumber}\u0026lt;/h1\u0026gt; } export default RandomNumber; Task2 : Create a component that generate random element from an array and display on each page reload\nconst elements = [\u0026#39;Earth\u0026#39;, \u0026#39;Water\u0026#39;, \u0026#39;Fire\u0026#39;, \u0026#39;Air\u0026#39;]; function generateRandomElement(){ return elements[Math.floor(Math.random() * elements.length)]; } function RandomElement(){ const randomElement = generateRandomElement(); return \u0026lt;h1\u0026gt;Random Element: {randomElement}\u0026lt;/h1\u0026gt; } export default RandomElement; This can be done by putting the logic inside the component function\nconst elements = [\u0026#39;Earth\u0026#39;, \u0026#39;Water\u0026#39;, \u0026#39;Fire\u0026#39;, \u0026#39;Air\u0026#39;]; function generateRandomElement(){ return elements[Math.floor(Math.random() * elements.length)]; } function RandomElement(){ const randomElement = elements[Math.floor(Math.random() * elements.length)]; return \u0026lt;h1\u0026gt;Random Element: {randomElement}\u0026lt;/h1\u0026gt; } export default RandomElement; The most optimal way is using this\nconst elements = [\u0026#39;Earth\u0026#39;, \u0026#39;Water\u0026#39;, \u0026#39;Fire\u0026#39;, \u0026#39;Air\u0026#39;]; function RandomElement(){ const randomElement = elements[Math.floor(Math.random() * elements.length)]; return \u0026lt;h1\u0026gt;Random Element: {randomElement}\u0026lt;/h1\u0026gt; } export default RandomElement; 8.Loading Images in React step 1: put the images in assets folder that need to be loaded step 2: import the image in the component where it is needed as shown below import imageName from Location Note: Location is the path of the image from the current file location and imageName can be set to any name\nstep 3: use the image in the component as shown below \u0026lt;img src={imageName} alt=\u0026#34;description\u0026#34; /\u0026gt; Note: imageName is the location of the image as src/Assets/logo.png\nTask: Load an image in a Header component with the image name logo.png and description logo. structure:\nsrc/\r├─ Assets/\r└─ logo.png\r├─ App.jsx\r└─ components/\r├─ Header.jsx import logo from \u0026#39;../Assets/logo.png\u0026#39;; function Header() { return ( \u0026lt;header\u0026gt; \u0026lt;img src={logo} alt=\u0026#34;logo\u0026#34; /\u0026gt; \u0026lt;/header\u0026gt; ); } 9.Importing CSS in React step 1: create a css file in the src folder step 2: import the css file in the component where it is needed as shown below import cssfileLocation Note: style.css is the name of the css file\nfor example:\nimport \u0026#39;./style.css\u0026#39; function App() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt; Hello world \u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ); } 9.1 Managing CSS in React Create css file in same directory as of your component src/ ├─ App.jsx └─ components/ ├─ Header.jsx └─ Header.css -Import the css file in the component where it is needed as shown below\r```jsx\rimport \u0026#39;./Header.css\u0026#39; 10.Props in React Props are used to pass data from parent component to child component. It is used to reuse the same component with different data. Props are passed as attributes to the component. Prop accept any type of value like string, number, array, object, function,compenent,jsx bool etc. 10.1 Passing Props from Parent to Child Component Parent Component function ParentComponent() { return ( \u0026lt;ChildComponent prop1={value1} prop2={value2} /\u0026gt; ); } 10.2 Receiving Props in Child Component Child Component function ChildComponent(props) { console.log(props); // will print object of props {prop1: value1, prop2:value2} return ( \u0026lt;\u0026gt; {props.prop1} {props.prop2} \u0026lt;/\u0026gt; ); } This approach is not recommended because it is not clear what props are being passed to the component. Instead, we can destructure the props as shown below.\n10.3 Destructuring Props Child Component function ChildComponent({prop1, prop2}) { return ( \u0026lt;\u0026gt; {prop1} {prop2} \u0026lt;/\u0026gt; ); } Task: Create a card cmponent and use multiple cards in the App component to make card section\nfunction Card({title, description, image}) { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;{title}\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;{description}\u0026lt;/p\u0026gt; \u0026lt;img src={image} alt=\u0026#34;description\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; ); } export default Card; import Card from \u0026#39;./components/Card\u0026#39;; function App() { return ( \u0026lt;div\u0026gt; \u0026lt;Card title=\u0026#34;Card 1\u0026#34; description=\u0026#34;This is card 1\u0026#34; image={image1} /\u0026gt; \u0026lt;Card title=\u0026#34;Card 2\u0026#34; description=\u0026#34;This is card 2\u0026#34; image={image2} /\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; 11. Children Props in React Children props are used to pass data between opening and closing tags of a component. 11.1 Passing Children Props Parent Component function ParentComponent() { return ( \u0026lt;ChildComponent\u0026gt; \u0026lt;h1\u0026gt; Hello \u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt; World \u0026lt;/p\u0026gt; \u0026lt;/ChildComponent\u0026gt; ); } 11.2 Receiving Children Props Child Component function ChildComponent({ children }) { return ( \u0026lt;div\u0026gt; {children} \u0026lt;/div\u0026gt; ); } 11.3 Output \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt; Hello \u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt; World \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; 12.Using Props and Children Props Together Task: Create a card component that accepts title, description, and children props. Use the card component in the App component to make a card section.\nfunction Card({ title, description, children }) { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;{title}\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;{description}\u0026lt;/p\u0026gt; {children} \u0026lt;/div\u0026gt; ); } export default Card; import Card from \u0026#39;./components/Card\u0026#39;; function App() { return ( \u0026lt;div\u0026gt; \u0026lt;Card title=\u0026#34;Card 1\u0026#34; description=\u0026#34;This is card 1\u0026#34;\u0026gt; \u0026lt;h1\u0026gt; Hello \u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt; World \u0026lt;/p\u0026gt; \u0026lt;/Card\u0026gt; \u0026lt;Card title=\u0026#34;Card 2\u0026#34; description=\u0026#34;This is card 2\u0026#34;\u0026gt; \u0026lt;h1\u0026gt; Hello \u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt; World \u0026lt;/p\u0026gt; \u0026lt;/Card\u0026gt; \u0026lt;/div\u0026gt; ); } 13. Making a Button Component 13.1 Using Props function App() { return ( \u0026lt;div\u0026gt; \u0026lt;Button text=\u0026#34;Click me\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; ); } function Button({ text}) { return ( \u0026lt;button\u0026gt; {text} \u0026lt;/button\u0026gt; ); } export default Button; 13.2 Using Children Props function App() { return ( \u0026lt;div\u0026gt; \u0026lt;Button\u0026gt;Click me\u0026lt;/Button\u0026gt; \u0026lt;/div\u0026gt; ); } function Button({ children }) { return ( \u0026lt;button\u0026gt; {children} \u0026lt;/button\u0026gt; ); } export default Button; 14. Reacting to Events In React, we can add event listeners like onClick, onMouseOver, onMouseOut, etc to buildin components lie button, div, etc using syntax \u0026lt;InbuiltComponent eventlistener={functionName} /\u0026gt; Note: functionName is the name of the function that will be called when the event is triggered.\nThere are Many eventlisteners that can be used in React like onClick, onMouseOver, onMouseOut etc.\nYou can check the full list of event listeners in the React documentation also note that the event listener will always start with on followed by the event name.\nWe can call the handle function in two ways:\n14.1 The First Way function App() { function handleClick() { console.log(\u0026#39;Button clicked\u0026#39;); } return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={handleClick}\u0026gt;Click me\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 14.2 The Second Way function App() { return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={() =\u0026gt; {console.log(\u0026#39;Button clicked\u0026#39;)}}\u0026gt;Click me\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 15. Event Listeners in Custom Components since by default when we add event listeners to custom component it doesnot work just because it is passed as prop but on simple tweaking we can make it work\nDesign Pattern for applying event listeners in custom components\nfunction App(){ function handleClick(){ console.log(\u0026#39;Button clicked\u0026#39;); } return ( \u0026lt;div\u0026gt; \u0026lt;Button onClick={handleClick} /\u0026gt; \u0026lt;/div\u0026gt; ); } The onclick method is passed as a prop to the button component and then used in the button component as shown below\nfunction Button({onClick}){ return ( \u0026lt;button onClick={onClick}\u0026gt;Click me\u0026lt;/button\u0026gt; ); } 16. Passing Arguments to Event Functions To pass Custom arguments to event functions, we can use the arrow function syntax as shown below \u0026lt;inbuildComponent eventListener={() =\u0026gt; functionName(argument)} /\u0026gt; Example function App() { function handleClick(name) { console.log(\u0026#39;Button clicked by\u0026#39;, name); } return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={() =\u0026gt; handleClick(\u0026#39;John\u0026#39;)}\u0026gt;Click me\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } ","permalink":"http://localhost:1313/posts/pages/react/react/","summary":"A detailed reference guide to help you quickly set up and manage React projects, components, and folder structures.","title":"React : Day 1"},{"content":"Python Fundamentals: Understanding Error Handling In Python programming, error handling is an essential concept that allows you to gracefully manage exceptions and errors that may occur during program execution. By handling errors effectively, you can prevent your program from crashing and provide meaningful feedback to users. In this guide, we will explore the fundamentals of error handling in Python, including exceptions, try-except blocks, and best practices.\n1. Exceptions In Python, exceptions are events that occur during the execution of a program that disrupt the normal flow of code. When an exception occurs, the interpreter raises an exception object that can be caught and handled by the program. Exceptions can be caused by various reasons, such as invalid input, file not found, or division by zero.\n2.What May Cause Exceptions Exceptions can be caused by various reasons, such as:\nDivision by zero Invalid input File not found Syntax errors Out of Index of list, tuple , String Key Error in dictionary 3.Types of Exceptions Commonly used exceptions in Python include:\nZeroDivisionError: Raised when division or modulo by zero occurs. ValueError: Raised when a function receives an argument of the correct type but an inappropriate value. TypeError: Raised when an operation or function is applied to an object of an inappropriate type. IndexError: Raised when a sequence subscript is out of range. KeyError: Raised when a dictionary key is not found. SyntaxError: Raised when the parser encounters a syntax error. Note: All exceptions in Python are subclasses of the Exception class.\n3.Handling Exceptions To handle exceptions in Python, you can use the try-except block, which allows you to catch and handle exceptions gracefully. The try block contains the code that may raise an exception, and the except block handles the exception if it occurs.The program control will transfer the control to the except block if any exception occurs in the try block but if there is not exception then the control will not transfer to the except block.\n4.1. Using try-except Block Here\u0026rsquo;s an example of using the try-except block to handle exceptions in Python:\nsyntax:\ntry: # Code that may raise an exception except ExceptionType as e: # Handle the exception Example:\ntry: x = 10 / 0 except Exception as e: print(\u0026#34;Error: Division by zero\u0026#34;) Output:\nError: Division by zero Note: if you don\u0026rsquo;t know the type of exception you can use Exception to catch all exceptions.\nIf you dont handel exception then it will show error and stop the program.\n4.2. Finally Block The finally block is used to execute code that should always run, regardless of whether an exception occurs or not. The finally block is typically used to release resources or clean up operations that need to be performed after the try block, regardless of the outcome Any how the finally block will run. if yout return from the try block then also the finally block will run.\nsyntax:\ntry: # Code that may raise an exception except ExceptionType as e: # Handle the exception finally: # Code that always runs Example:\ntry: x = 10 / 0 except Exception as e: print(\u0026#34;Error: Division by zero\u0026#34;) finally: print(\u0026#34;Cleanup code\u0026#34;) Output:\nError: Division by zero\rCleanup code 3.5. Raising Exceptions You can raise exceptions in Python using the raise statement. This allows you to create custom exceptions and raise them when needed. You can also raise built-in exceptions to indicate errors or exceptional conditions.\nsyntax:\nraise ExceptionType(\u0026#34;Error message\u0026#34;) Example:\nx = -1 if x \u0026lt; 0: raise ValueError(\u0026#34;Value cannot be negative\u0026#34;) Output:\nValueError: Value cannot be negative 3.6. Multiple except Blocks You can use multiple except blocks to handle different types of exceptions in Python. This allows you to catch and handle specific exceptions based on their type.\nsyntax:\ntry: # Code that may raise an exception except ExceptionType1 as e: # Handle ExceptionType1 except ExceptionType2 as e: # Handle ExceptionType2 Example:\ntry: x = 10 / 0 except ZeroDivisionError as e: print(\u0026#34;Error: Division by zero\u0026#34;) except ValueError as e: print(\u0026#34;Error: Invalid value\u0026#34;) Output:\nError: Division by zero 3.7. Custom Exceptions You can create custom exceptions in Python by defining a new exception class that inherits from the Exception class. Custom exceptions allow you to define specific error conditions for your application and raise them when needed.\nsyntax:\nclass CustomException(Exception): pass Example:\n#Will read about class in oop section class CustomError(Exception): def __init__(self,message,value): self.message=message self.value=value def __str__(self): return f\u0026#34;{self.message}\\nError code:{self.value}\u0026#34; try: x = -1 if x \u0026lt; 0: raise CustomError(\u0026#34;Value cannot be negative\u0026#34;,1001) except CustomError as e: print(e) Note: Custom exceptions should inherit from the Exception class or one of its subclasses. You can simply use:\ntry: #code except: #code try: #code except Exception as e: #code try: #code except Exception: #code try: #code except: #code finally: #code ","permalink":"http://localhost:1313/posts/pages/python/python_error_handeling/","summary":"An in-depth exploration of Python error handling, exceptions, and best practices.","title":"Python Fundamentals: Understanding Error Handling (Part 6)"},{"content":"Python Fundamentals: Packages, Generators, and Decorators In this guide, we will explore advanced Python topics including packages, generators, and decorators. These concepts are essential for writing efficient and maintainable Python code. Let\u0026rsquo;s dive in!\n1. Python Packages Python packages are a way of organizing and structuring your code into reusable modules. Packages allow you to group related modules together, making it easier to manage and maintain your codebase. In this section, we will explore how to create and use Python packages.\n1.1. Creating a Package To create a Python package, you need to organize your code into a directory structure with a special file called __init__.py. This file tells Python that the directory is a package and allows you to import modules from the package.\nExample directory structure:\nmy_package/\r│\r├── __init__.py\r├── module1.py\r└── module2.py 1.2. Using a Package To use a Python package, you can import modules from the package using the import statement. You can import specific modules or the entire package.\nExample:\n# Importing a specific module from my_package import module1 # Using a function from the imported module module1.my_function() # Importing the entire package import my_package # Using a function from a module within the package my_package.module2.another_function() #Importing Function from a module from my_package.module1 import my_function my_function() Note : init.py file can be empty or contain initialization code for the package. It will automatically run when the package is imported.\n1.3 Creating a Subpackage You can create subpackages within a package to further organize your code. Subpackages are simply packages within packages, allowing you to create a hierarchical structure for your codebase.\nExample directory structure:\nmy_package/\r│\r├── __init__.py\r├── module1.py\r└── subpackage/\r├── __init__.py\r├── module3.py\r└── module4.py 1.4. Using a Subpackage To use a subpackage, you can import modules from the subpackage using the dot notation.\nExample:\n# Importing a module from a subpackage from my_package.subpackage import module3 # Using a function from the imported module module3.another_function() # Importing the entire subpackage import my_package.subpackage # Using a function from a module within the subpackage my_package.subpackage.module4.some_function() #Importing Function from a module from my_package.subpackage.module3 import another_function another_function() 1.5. name == \u0026ldquo;main\u0026rdquo; We use the __name__ variable to check if a script is being run as the main program or being imported as a module. When a script is run as the main program, __name__ is set to \u0026quot;__main__\u0026quot;. This allows you to include code that should only run when the script is executed directly.\nFor Example:\nStructure:\nMain Directory/\r├── main.py\r└── package/\r├── __init__.py\r└── module1.py module1.py:\ndef my_function(): print(\u0026#34;Hello from module1\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: my_function() When you run module1.py directly, the my_function() will be executed. However, if you import module1 into another script, the my_function() will not be executed.\nFor Example:\nfrom package import module1 print(\u0026#34;Imported module1\u0026#34;) Output:\nImported module1 When use Dont use if __name__ == \u0026quot;__main__\u0026quot;: in module1.py:\ndef my_function(): print(\u0026#34;Hello from module1\u0026#34;) my_function() also,\nfrom package import module1 print(\u0026#34;Imported module1\u0026#34;) Output:\nHello from module1\rImported module1 2. Python Generators Using generator we can instantly return all the values using the yield keyword without storing them in memory. This is useful when working with large datasets or infinite sequences.\n2.1. Creating a Generator To create a generator in Python, you can use a function with the yield keyword. When a function contains the yield keyword, it becomes a generator function. The yield keyword suspends the function\u0026rsquo;s execution and returns a value to the caller.\nExample:\ndef my_generator(): yield 1 yield 2 yield 3 # Using the generator gen = my_generator() print(next(gen)) # Output: 1 print(next(gen)) # Output: 2 print(next(gen)) # Output: 3 Example:\n#using generator in loop def generate(n): for i in range(n): yield i for i in generate(10): print(i) 3. Python Decorators Decorators are a powerful feature in Python that allows you to modify or extend the behavior of functions or methods. Decorators are functions that take another function as an argument and return a new function that extends the behavior of the original function.\n3.1. Creating a Decorator To create a decorator in Python, you can define a function that takes another function as an argument and returns a new function that extends the behavior of the original function.\nSyntax:\ndef my_decorator(func): def wrapper(): # Code to execute before calling the decorated function func() # Code to execute after return wrapper Example:\ndef my_decorator(func): def wrapper(): print(\u0026#34;Before function call\u0026#34;) func() print(\u0026#34;After function call\u0026#34;) return wrapper @my_decorator def say_hello(): print(\u0026#34;Hello!\u0026#34;) say_hello() #call to my_decorator(say_hello)() just because we use @my_decorator Output:\nBefore function call\rHello!\rAfter function call Example For decorator :\ndef Add_Wrapper(func): def wrapper(a,b,c): print(\u0026#34;Status code is\u0026#34;,c) return func(a,b) return wrapper @Add_Wrapper def add(a,b): return a+b print(add(2,3,200)) Output:\nStatus code is 200\r5 3.2. Decorator with Arguments You can also create decorators that accept arguments by defining a decorator function that takes arguments and returns a decorator function.\nSyntax:\ndef my_decorator_with_args(arg1, arg2): def decorator(func): def wrapper(): # Code to execute before calling the decorated function func() # Code to execute after return wrapper return decorator Example:\ndef my_decorator_with_args(arg1, arg2): def decorator(func): def wrapper(): print(f\u0026#34;Decorator arguments: {arg1}, {arg2}\u0026#34;) func() return wrapper return decorator @my_decorator_with_args(\u0026#34;arg1\u0026#34;, \u0026#34;arg2\u0026#34;) def say_hello(): print(\u0026#34;Hello!\u0026#34;) say_hello() Output:\nDecorator arguments: arg1, arg2\rHello! ","permalink":"http://localhost:1313/posts/pages/python/python_advanced_topics/","summary":"An in-depth exploration of Python packages, generators, and decorators.","title":"Python Fundamentals: Packages, Generators, and Decorators (Part 7)"},{"content":"Python Fundamentals: Understanding request In this guide, we will explore request package in python. This package is used to make HTTP requests in python. Let\u0026rsquo;s dive in!\n1. Python request Python request is a simple and elegant HTTP library for Python. It provides methods for sending HTTP requests and handling the responses. The requests library allows you to send HTTP requests using a simple and intuitive API, and it also provides support for handling cookies, sessions, and authentication.\n1.1. Installing requests To use the requests library in your Python project, you need to install it using pip. You can install the requests library by running the following command in your terminal:\npip install requests 1.2. Types of requests The requests library supports various types of HTTP requests, including GET, POST, PUT, DELETE, and more. You can use these methods to interact with web services and APIs.\nExample:\nimport requests # Send a GET request response = requests.get(\u0026#39;https://api.github.com\u0026#39;) # Send a POST request response = requests.post(\u0026#39;https://httpbin.org/post\u0026#39;) # Send a PUT request response = requests.put(\u0026#39;https://httpbin.org/put\u0026#39;) # Send a DELETE request response = requests.delete(\u0026#39;https://httpbin.org/delete\u0026#39;) 1.3 Parameters for requests The requests library allows you to pass various parameters when making HTTP requests. These parameters include headers, query parameters, request body, and more.\nHeaders: You can pass custom headers in your request using the headers parameter. Example: import requests # Send a GET request with custom headers headers = {\u0026#39;User-Agent\u0026#39;: \u0026#39;Mozilla/5.0\u0026#39;} response = requests.get(\u0026#39;https://api.github.com\u0026#39;, headers=headers) # Send a POST request with custom headers response = requests.post(\u0026#39;https://httpbin.org/post\u0026#39;, headers=headers) #similarly for PUT and DELETE cookie: You can pass cookies in your request using the cookies parameter. Example: import requests # Send a GET request with cookies cookies = {\u0026#39;session_id\u0026#39;: \u0026#39;12345\u0026#39;} response = requests.get(\u0026#39;https://api.github.com\u0026#39;, cookies=cookies) # Send a POST request with cookies response = requests.post(\u0026#39;https://httpbin.org/post\u0026#39;, cookies=cookies) #similarly for PUT and DELETE file: You can upload files in your request using the files parameter. Example: import requests # Upload a file in a POST request files = {\u0026#39;file\u0026#39;: open(\u0026#39;file.txt\u0026#39;, \u0026#39;rb\u0026#39;)} response = requests.post(\u0026#39;https://httpbin.org/post\u0026#39;, files=files) #similarly for PUT and DELETE params: You can pass query parameters in your request using the params parameter. Example: import requests # Send a GET request with query parameters params = {\u0026#39;key1\u0026#39;: \u0026#39;value1\u0026#39;, \u0026#39;key2\u0026#39;: \u0026#39;value2\u0026#39;} response = requests.get(\u0026#39;https://api.github.com\u0026#39;, params=params) # Send a POST request with query parameters response = requests.post(\u0026#39;https://httpbin.org/post\u0026#39;, params=params) #similarly for PUT and DELETE data: You can pass data in your request body using the data parameter. Example: import requests # Send a POST request with data data = {\u0026#39;key1\u0026#39;: \u0026#39;value1\u0026#39;, \u0026#39;key2\u0026#39;: \u0026#39;value2\u0026#39;} response = requests.post(\u0026#39;https://httpbin.org/post\u0026#39;, data=data) #similarly for PUT and DELETE json: You can pass JSON data in your request body using the json parameter. Example: import requests # Send a POST request with JSON data data = {\u0026#39;key1\u0026#39;: \u0026#39;value1\u0026#39;, \u0026#39;key2\u0026#39;: \u0026#39;value2\u0026#39;} response = requests.post(\u0026#39;https://httpbin.org/post\u0026#39;, json=data) #similarly for PUT and DELETE Note: The requests library provides a wide range of parameters and options for making HTTP requests. You can refer to the official documentation for more details.\n** Note ** : While using json it will automatically set the content type to application/json and dump the data to json format but while using data it will set the content type to application/x-www-form-urlencoded and encode the data to urlencoded format.\n1.4. Handling responses The requests library provides methods for handling the responses returned by HTTP requests. You can access the response content, status code, headers, and more.\nResponse content: You can access the response content using the text attribute. Example: import requests # Send a GET request response = requests.get(\u0026#39;https://api.github.com\u0026#39;) # Get the response content content = response.text print(content) Response Content in bytes: You can access the response content in bytes using the content attribute. Example: import requests # Send a GET request response = requests.get(\u0026#39;https://api.github.com\u0026#39;) # Get the response content in bytes content = response.content print(content) json: You can access the response content as JSON using the json method. Example:\nimport requests # Send a GET request response = requests.get(\u0026#39;https://api.github.com\u0026#39;) # Get the response content as JSON data = response.json() print(data) Status code: You can access the response status code using the status_code attribute. Example: import requests # Send a GET request response = requests.get(\u0026#39;https://api.github.com\u0026#39;) # Get the response status code status_code = response.status_code print(status_code) Headers: You can access the response headers using the headers attribute. Example: import requests # Send a GET request response = requests.get(\u0026#39;https://api.github.com\u0026#39;) # Get the response headers headers = response.headers print(headers) Cookies: You can access the response cookies using the cookies attribute. Example: import requests # Send a GET request response = requests.get(\u0026#39;https://api.github.com\u0026#39;) # Get the response cookies cookies = response.cookies print(cookies) ","permalink":"http://localhost:1313/posts/pages/python/python_request/","summary":"An in-depth exploration of Python request.","title":"Python Fundamentals: Understanding request (Part 8)"},{"content":"Python Fundamentals: Understanding File Handeling In Python programming, file handling is an essential operation that allows you to read, write, and manipulate files on your system. Files are used to store data permanently, and Python provides various functions and methods to work with files efficiently. In this guide, we will explore the basics of file handling in Python, including opening, reading, writing, and closing files.\n1.Context Manager Python provides a built-in way to manage resources and ensure that they are properly released when they are no longer needed. This is done using the with statement and is known as a context manager. When working with files, it is recommended to use the with statement to ensure that the file is properly closed after use.\n1.1. Using the with Statement The with statement in Python is used to create a context manager that automatically takes care of resource management. When working with files, the with statement ensures that the file is properly closed after use, even if an error occurs during file operations.\nExample:\nwith open(\u0026#34;example.txt\u0026#34;, \u0026#34;r\u0026#34;) as file: data = file.read() print(data) 2. Opening a File Before you can read or write to a file, you need to open it using the open() function. The open() function takes two arguments: the file path and the mode in which you want to open the file.\n2.1. Modes for Opening Files Python supports various modes for opening files, depending on the operations you want to perform. Some common modes include:\nr: Read mode. Opens the file for reading. The file must exist. w: Write mode. Opens the file for writing. If the file exists, it will be truncated. If the file does not exist, a new file will be created. a: Append mode. Opens the file for writing. If the file exists, the data will be appended to the end. If the file does not exist, a new file will be created. b: Binary mode. Opens the file in binary mode.use for image,video,etc as it will not convert the data to text .You can add b to any mode to open the file in binary mode like rb,wb,ab. t: Text mode. Opens the file in text mode (default). 2.2. Opening a File To open a file, you can use the open() function with the desired file path and mode. You can also specify additional parameters such as encoding, buffering, and newline characters.\nExample:\n# Open a file in read mode with open(\u0026#34;example.txt\u0026#34;, \u0026#34;r\u0026#34;) as file: data = file.read() print(data) 3. Reading from a File Once you have opened a file, you can read its contents using various methods provided by Python. The most common methods for reading from a file is read().\n# Open a file in read mode with open(\u0026#34;example.txt\u0026#34;, \u0026#34;r\u0026#34;) as file: data = file.read() print(data) 4. Writing to a File To write data to a file, you can use the write() method provided by Python. You can write text data to a file using the write() method.\nUsing w mode: # Open a file in write mode with open(\u0026#34;example.txt\u0026#34;, \u0026#34;w\u0026#34;) as file: file.write(\u0026#34;Hello, World!\u0026#34;) Using a mode: # Open a file in append mode with open(\u0026#34;example.txt\u0026#34;, \u0026#34;a\u0026#34;) as file: file.write(\u0026#34;Hello, World!\u0026#34;) 5.Context Manager Reference\nUse of Context Manager: In any programming language, the usage of resources like file operations or database connections is very common. But these resources are limited in supply. Therefore, the main problem lies in making sure to release these resources after usage. If they are not released then it will lead to resource leakage and may cause the system to either slow down or crash. It would be very helpful if users have a mechanism for the automatic setup and teardown of resources. In Python, it can be achieved by the usage of context managers which facilitate the proper handling of resources.\nWhat is happened When the with statement is executed, it will automatically call the __enter__ before entering the code block, and __exit__ after exiting the code block.\nHow to create a context manager To create a context manager, you need to define a class that implements the __enter__ and __exit__ methods. The __enter__ method is called when the with statement is executed, and the __exit__ method is called after the code block is executed.\nSyntax:\nclass MyContextManager: def __init__(self,params): # Code to initialize resources def __enter__(self): # Code to setup resources return self def __exit__(self, exc_type, exc_value, traceback): # Code to release resources Example:\n#implementatio of own file handeling context manager class MeroHandle: def __init__(self,filename,mode): self.filename = filename self.mode = mode def __enter__(self): self.file = open(self.filename,self.mode) return self.file def __exit__(self,exc_type,exc_value,traceback): self.file.close() #using the context manager with MeroHandle(\u0026#34;example.txt\u0026#34;,\u0026#34;r\u0026#34;) as file: data = file.read() print(data) Normal way of file handeling try: file = open(\u0026#34;example.txt\u0026#34;,\u0026#34;r\u0026#34;) data = file.read() print(data) file.close() except: print(\u0026#34;Error Occured\u0026#34;) Advantage of context manager Over normal code When we use normal code shown above then when error occured in try block before file.close() then it will not close the file(i.e file will not be closed) and it will lead to resource leakage . But when we use context manager then it will automatically close the file just because __exit__ method is called after the code block is executed whether error occured or not. but in normal code we can manage this by using finally block but it is not recommended as it is not pythonic way of doing things. try: file = open(\u0026#34;example.txt\u0026#34;,\u0026#34;r\u0026#34;) data = file.read() print(data) except: print(\u0026#34;Error Occured\u0026#34;) finally: file.close() This will work but it is not pythonic way of doing things.Just because we have to write whole try,except,finally block for just opening and closing the file. which make code more complex and lengthy.\n","permalink":"http://localhost:1313/posts/pages/python/python_filehandeling/","summary":"An in-depth look at File Handeling.","title":"Python Fundamentals: Understanding File Handeling (Part 9)"},{"content":"Python Fundamentals: Some Important Package to Know In Python programming, packages are collections of modules that provide additional functionality to your programs. Python has a rich ecosystem of packages that can help you perform a wide range of tasks, from data analysis and visualization to web development and machine learning. In this guide, we will explore some of the most important packages in Python that you should be familiar with.\n1.json The json package in Python provides functions for encoding and decoding JSON data. JSON (JavaScript Object Notation) is a lightweight data interchange format that is easy for humans to read and write and easy for machines to parse and generate. The json package allows you to work with JSON data in Python by converting Python objects to JSON strings and vice versa.\nConversion of Python dictionary to JSON string We can convert a Python dictionary to a JSON string using the json.dumps() function. This function takes a Python object as input and returns a JSON string representation of the object. Example:\nimport json # Create a Python dictionary data = { \u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34; } # Convert the dictionary to a JSON string json_string = json.dumps(data) print(json_string) Conversion of JSON string to Python dictionary We can convert a JSON string to a Python dictionary using the json.loads() function. This function takes a JSON string as input and returns a Python object (usually a dictionary) representing the JSON data. Example:\nimport json # JSON string json_string = \u0026#39;{\u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;}\u0026#39; # Convert the JSON string to a Python dictionary data = json.loads(json_string) print(data) 2.os The os package in Python provides functions for interacting with the operating system.You can get indepth knowladge of os using its own documentation.but the most common methods are:\nos.path.join(\u0026quot;C:\u0026quot;,\u0026quot;users\u0026quot;,\u0026quot;bin\u0026quot;): Join one or more path components intelligently. os.rename(\u0026quot;old\u0026quot;,\u0026quot;new\u0026quot;): Rename a file or directory. 3.time The time package in Python provides functions for working with time-related tasks. You can use the time package to get the current time, sleep for a specified duration, and measure the execution time of your code.\ntime.time(): Returns the current time in seconds since the epoch. time.sleep(seconds): Suspends the execution of the current thread for the given number of seconds. 4.uuid The uuid package in Python provides functions for generating and working with UUIDs (Universally Unique Identifiers). UUIDs are unique identifiers that are used to identify objects in a distributed computing environment. The uuid package allows you to generate UUIDs based on various algorithms and formats.\nGenerating a UUID You can generate a UUID using the uuid.uuid4() function, which generates a random UUID. Example:\nimport uuid # Generate a random UUID uuid_value = uuid.uuid4() print(uuid_value) 5.Datetime The datetime package in Python provides classes for working with dates and times. You can use the datetime package to create, manipulate, and format dates and times in your Python programs.\nCreating a datetime object You can create a datetime object using the datetime.datetime() constructor, which takes the year, month, day, hour, minute, second, and microsecond as input. Example:\nimport datetime # Create a datetime object dt = datetime.datetime(2022, 11, 27, 10, 30, 0) print(dt) Output:\n2022-11-27 10:30:00 get current date and time You can get the current date and time using the datetime.now() method. Example:\nimport datetime # Get the current date and time now = datetime.datetime.now() print(now) Output:\n2022-11-27 10:30:00 Formatting a datetime object some Properties of datetime object:\nyear: The year of the datetime object month: The month of the datetime object (1-12) day: The day of the datetime object (1-31) hour: The hour of the datetime object (0-23) minute: The minute of the datetime object (0-59) second: The second of the datetime object (0-59) import datetime # Create a datetime object dt = datetime.datetime.now() # Format the datetime object print(dt.month()) print(dt.day()) print(dt.year()) print(dt.hour()) print(dt.minute()) print(dt.second()) Output:\n11\r27\r2022\r10\r30\r0 ","permalink":"http://localhost:1313/posts/pages/python/python_extrapackage/","summary":"An in-depth look at frequently used important package.","title":"Python Fundamentals: Some Important Package to Know (Part 10)"},{"content":"Shared References in Python: How Changes Propagate Across Variables In Python, variables are references to objects in memory. When you assign a value to a variable, you are creating a reference to the object that holds that value. In some cases, multiple variables can refer to the same object in memory. This is known as a shared reference.\nMutability and Shared References in Python: How Changes Propagate Across Variables List Lists are mutable, so if two variables reference the same list, changes through one variable will affect the other.\n# Create a list list1 = [1, 2, 3] # Create a reference to the list list2 = list1 # Modify the list through one reference list2.append(4) # Check the original list print(list1) # Output: [1, 2, 3, 4] Dictionary Dictionaries are mutable as well. If two variables point to the same dictionary, any change made through one will reflect in the other.\n# Create a dictionary dict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30} # Create a reference to the dictionary dict2 = dict1 # Modify the dictionary through one reference dict2[\u0026#34;age\u0026#34;] = 31 # Check the original dictionary print(dict1) # Output: {\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 31} Set Sets are mutable, so changes made through one reference will affect the other if two variables point to the same set.\n# Create a set set1 = {1, 2, 3} # Create a reference to the set set2 = set1 # Modify the set through one reference set2.add(4) # Check the original set print(set1) # Output: {1, 2, 3, 4} Custom Objects\nclass Person: def __init__(self, name, age): self.name = name self.age = age # Create an instance of the Person class person1 = Person(\u0026#34;Alice\u0026#34;, 30) # Create a reference to the instance person2 = person1 # Modify the instance through one reference person2.age = 31 # Check the original instance print(person1.age) # Output: 31 Note: Mutable objects like lists, dictionaries, sets, and custom objects allow changes to propagate across variables that reference the same object. Immutable objects like integers, strings, and tuples do not exhibit this behavior.\n","permalink":"http://localhost:1313/posts/pages/python/python_shared_references/","summary":"An in-depth look at shared references in Python.","title":"Python Fundamentals : Shared References in Python (part 11)"},{"content":"Object oriented programming in python Object oriented programming is a programming paradigm that provides a means of structuring programs so that properties and behaviors are bundled into individual objects.\n1. Class and Object Class is a blueprint for creating objects (a particular data structure), providing initial values for state (member variables or attributes), and implementations of behavior (member functions or methods).\nObject is an instance of a class. When class is defined, only the description for the object is defined. Therefore, no memory or storage is allocated.\n1.1 Creating a class We can create a class using the class keyword followed by the class name. The class definition can contain class variables, instance variables, methods, and constructors.\nSyntax:\nclass ClassName: #code block Example:\nclass Person: name=\u0026#34;Nirajan\u0026#34; age=20 classes=\u0026#34;Bachelor\u0026#34; 1.2 Creating an object To create an object of a class, we use the class name followed by parentheses. This calls the constructor method of the class and returns an object.\nSyntax:\nobject_name = ClassName() Example:\nperson1 = Person() 1.3 Accessing class attributes We can access the attributes of a class using the dot operator (.) followed by the attribute name.\nSyntax:\nobject_name.attribute_name Example:\nprint(person1.name) # Output: Nirajan print(person1.age) # Output: 20 print(person1.classes) # Output: Bachelor 1.4 Modifying class attributes We can modify the attributes of a class using the dot operator (.) followed by the attribute name.\nSyntax:\nobject_name.attribute_name = new_value Example:\nperson1.age = 21 print(person1.age) # Output: 21 1.5 Creating a member function We can create a member function (method) inside a class using the def keyword followed by the function name. The first parameter of the method should be self, which refers to the current instance of the class.we will see about self in next part.\nSyntax:\nclass ClassName: def method_name(self, parameters): #code block Example:\nclass Person: name=\u0026#34;Nirajan\u0026#34; age=20 classes=\u0026#34;Bachelor\u0026#34; def display(self): print(f\u0026#34;Name: {self.name}\u0026#34;) print(f\u0026#34;Age: {self.age}\u0026#34;) print(f\u0026#34;Class: {self.classes}\u0026#34;) 1.6 Calling a member function We can call a member function of a class using the dot operator (.) followed by the function name and parentheses.\nSyntax:\nobject_name.method_name(arguments) Example:\nperson1.display() 1.7 Nested member function We can call a member function from another member function of the same class using the self keyword.\nSyntax:\nclass ClassName: def method1(self): #code block self.method2() def method2(self): #code block Example:\nclass Person: name=\u0026#34;Nirajan\u0026#34; age=20 classes=\u0026#34;Bachelor\u0026#34; def display(self): print(f\u0026#34;Name: {self.name}\u0026#34;) print(f\u0026#34;Age: {self.age}\u0026#34;) print(f\u0026#34;Class: {self.classes}\u0026#34;) self.greet() def greet(self): print(\u0026#34;Hello, Welcome to the class\u0026#34;) 1.8 self parameter The self parameter is a reference to the current instance of the class, and is used to access variables and methods of the class. It is the first parameter of any method in a class.\nSyntax:\nclass ClassName: def method_name(self, parameters): #code block Example:\nclass Person: name=\u0026#34;Nirajan\u0026#34; age=20 classes=\u0026#34;Bachelor\u0026#34; def display(self): print(f\u0026#34;Name: {self.name}\u0026#34;) print(f\u0026#34;Age: {self.age}\u0026#34;) print(f\u0026#34;Class: {self.classes}\u0026#34;) self.greet() def greet(self): print(\u0026#34;Hello, Welcome to the class\u0026#34;) 2. Constructor in Python A constructor is a special type of method (function) which is used to initialize the instance members of the class. It is called when an object of the class is created.\n2.1 Creating a constructor In Python, the constructor method is called __init__. It is a special method that is automatically called when an object is created.\nSyntax:\nclass ClassName: def __init__(self, parameters): #code block Example:\nclass Person: def __init__(self, name, age, classes): self.name = name self.age = age self.classes = classes def display(self): print(f\u0026#34;Name: {self.name}\u0026#34;) print(f\u0026#34;Age: {self.age}\u0026#34;) print(f\u0026#34;Class: {self.classes}\u0026#34;) 2.2 Creating an object with constructor When an object is created, the constructor method is automatically called with the arguments passed to the class.\nSyntax:\nobject_name = ClassName(arguments) Example:\nperson1 = Person(\u0026#34;Nirajan\u0026#34;, 20, \u0026#34;Bachelor\u0026#34;) 3. Getters and Setters in Python 3.1. Getters Getters are methods is implementes by using the @property decorator. They are specially used\nto act as an value ie data instead of a method. to access the value of a private attribute without directly accessing it. Syntax:\nclass ClassName: @property def method_name(self): #code block Example:\nclass Person: def __init__(self, name, age): self._name = name self._age = age @property def display(self): return f\u0026#34;Name: {self._name}, Age: {self._age}\u0026#34; person1 = Person(\u0026#34;Nirajan\u0026#34;, 20) print(person1.display) # Output: Name: Nirajan, Age: 20 3.2. Setters Setters are methods is implementes by using the @method_name.setter decorator. They are specially used\nto set the value of a private attribute without directly setting it. to perform validation before setting the value of an attribute. Syntax:\nclass ClassName: @method_name.setter def method_name(self, value): #code block Example:\nclass Person: def __init__(self, name, age): self._name = name self._age = age @property def display(self): return f\u0026#34;Name: {self._name}, Age: {self._age}\u0026#34; @display.setter def display(self, value): self._name, self._age = value.split(\u0026#34;,\u0026#34;) self._age = int(self._age) person1 = Person(\u0026#34;Nirajan\u0026#34;, 20) print(person1.display) # Output: Name: Nirajan, Age: 20 person1.display = \u0026#34;Alice, 30\u0026#34; print(person1.display) # Output: Name: Alice, Age: 30 4. Inheritance in Python Inheritance is a mechanism in which one class acquires the properties and behavior of another class. The class which inherits the properties and behavior is known as the child class, and the class whose properties and behavior are inherited is known as the parent class.\n4.1. Creating a child class To create a child class that inherits from a parent class, we specify the parent class in parentheses after the child class name.\nSyntax:\nclass ChildClassName(ParentClassName): #code block Example:\nclass Employee: def __init__(self,name,age,id): self.name=name self.age=age self.id=id def display(self): print(f\u0026#34;Name: {self.name}\u0026#34;) print(f\u0026#34;Age: {self.age}\u0026#34;) print(f\u0026#34;ID: {self.id}\u0026#34;) class Manager(Employee):# it has all the properties of Employee class so we can access the # properties of Employee class also its method using object of Manager class def task(self): self.display() print(\u0026#34;Assigning tasks to employees\u0026#34;) class Developer(Employee): # it has all the properties of Employee class so we can access # the properties of Employee class also its method using object of Developer class def task(self): self.display() print(\u0026#34;Developing software applications\u0026#34;) manager1 = Manager(\u0026#34;Alice\u0026#34;, 30, 101) manager1.task() developer1 = Developer(\u0026#34;Bob\u0026#34;, 25, 102) developer1.task() Note : Only public and protected members are inherited by the child class. Private members are not inherited by the child class.\n5.Ascess Specifiers in Python 5.1. Public members Public members are accessible from outside the class. They can be accessed using the dot operator (.) from outside the class.\nExample:\nclass Person: name = \u0026#34;Alice\u0026#34; # Public member person1 = Person() print(person1.name) # Output: Alice 5.2. Protected members Protected members are accessible within the class and its subclasses. They are denoted by a single underscore (_) before the member name.\nExample:\nclass Person: _age = 30 # Protected member class Student(Person): def display(self): print(self._age) # Accessing protected member student1 = Student() student1.display() # Output: 30 Example of protected variable and method\nclass Person: _name = \u0026#34;Alice\u0026#34; # Protected variable def _display(self): # Protected method print(f\u0026#34;Name: {self._name}\u0026#34;) class Student(Person): def display(self): self._display() # Accessing protected metho student1 = Student() student1.display() # Output: Name: Alice 5.3. Private members Private members are accessible only within the class. They are denoted by a double underscore (__) before the member name.\nExample:\nclass Person: __city = \u0026#34;New York\u0026#34; # Private member person1 = Person() print(person1.__city) # Error: \u0026#39;Person\u0026#39; object has no attribute \u0026#39;__city\u0026#39; Example of private variable and method\nclass Person: __name = \u0026#34;Alice\u0026#34; # Private variable def __display(self): # Private method print(f\u0026#34;Name: {self.__name}\u0026#34;) person1 = Person() print(person1.__name) # Error: \u0026#39;Person\u0026#39; object has no attribute \u0026#39;__name\u0026#39; person1.__display() # Error: \u0026#39;Person\u0026#39; object has no attribute \u0026#39;__display\u0026#39; Table of Access Specifiers in Python:\nAccess Specifier Accessible from class Accessible from subclass Accessible from outside class Public Yes Yes Yes Protected Yes Yes No Private Yes No No Static Method in Python Static Method is those method that can be called without creating an object of the class. They are defined using the @staticmethod decorator. They can be called using the class name . Syntax: class ClassName: @staticmethod def method_name(parameters): #code block Example:\nclass Calculator: @staticmethod def add(a, b): return a + b result = Calculator.add(5, 3) print(result) # Output: 8 #Can call using object also calculator = Calculator() result = calculator.add(5, 3) print(result) # Output: 8 #this is also valid but it is not recommended Class Method in Python They are defined using the @classmethod decorator.The useage of class method is to access the class variable and change class variable. ie when we change variable using class method it will change for all the object of the class.THey can be called using the class name. Syntax:\nclass ClassName: @classmethod def method_name(cls, parameters): #code block Example:\nclass copany : copany=\u0026#34;Google\u0026#34; @classmethod def change_company(cls,new_company): cls.copany=new_company print(copany.copany) #Output: Google copany.change_company(\u0026#34;Microsoft\u0026#34;) print(copany.copany) #Output: Microsoft c1=copany() print(c1.copany) #Output: Microsoft c1.change_company(\u0026#34;Apple\u0026#34;) c2=copany() print(c2.copany) #Output: Applex Dir and dict method in Python dir() method is used to return a list of attributes and methods of any object. It returns a list of valid attributes and methods of the object. Syntax:\ndir(object) Example:\nclass Person: name = \u0026#34;Alice\u0026#34; age = 30 person1 = Person() print(dir(person1)) # Output: [\u0026#39;__class__\u0026#39;, \u0026#39;__delattr__\u0026#39;, \u0026#39;__dict__\u0026#39;, \u0026#39;__dir__\u0026#39;, \u0026#39;__doc__\u0026#39;, \u0026#39;__eq__\u0026#39;, \u0026#39;__format__\u0026#39;, \u0026#39;__ge__\u0026#39;, \u0026#39;__getattribute__\u0026#39;, \u0026#39;__gt__\u0026#39;, \u0026#39;__hash__\u0026#39;, \u0026#39;__init__\u0026#39;, \u0026#39;__init_subclass__\u0026#39;, \u0026#39;__le__\u0026#39;, \u0026#39;__lt__\u0026#39;, \u0026#39;__module__\u0026#39;, \u0026#39;__ne__\u0026#39;, \u0026#39;__new__\u0026#39;, \u0026#39;__reduce__\u0026#39;, \u0026#39;__reduce_ex__\u0026#39;, \u0026#39;__repr__\u0026#39;, \u0026#39;__setattr__\u0026#39;, \u0026#39;__sizeof__\u0026#39;, \u0026#39;__str__\u0026#39;, \u0026#39;__subclasshook__\u0026#39;, \u0026#39;__weakref__\u0026#39;, \u0026#39;age\u0026#39;, \u0026#39;name\u0026#39;] Example:\nl=[1,2,3] print(dir(l)) # Output: [\u0026#39;__add__\u0026#39;, \u0026#39;__class__\u0026#39;, \u0026#39;__class_getitem__\u0026#39;, \u0026#39;__contains__\u0026#39;, \u0026#39;__delattr__\u0026#39;, \u0026#39;__delitem__\u0026#39;, \u0026#39;__dir__\u0026#39;, \u0026#39;__doc__\u0026#39;, \u0026#39;__eq__\u0026#39;, \u0026#39;__format__\u0026#39;, \u0026#39;__ge__\u0026#39;, \u0026#39;__getattribute__\u0026#39;, \u0026#39;__getitem__\u0026#39;, \u0026#39;__getstate__\u0026#39;, \u0026#39;__gt__\u0026#39;, \u0026#39;__hash__\u0026#39;, \u0026#39;__iadd__\u0026#39;, \u0026#39;__imul__\u0026#39;, \u0026#39;__init__\u0026#39;, \u0026#39;__init_subclass__\u0026#39;, \u0026#39;__iter__\u0026#39;, \u0026#39;__le__\u0026#39;, \u0026#39;__len__\u0026#39;, \u0026#39;__lt__\u0026#39;, \u0026#39;__mul__\u0026#39;, \u0026#39;__ne__\u0026#39;, \u0026#39;__new__\u0026#39;, \u0026#39;__reduce__\u0026#39;, \u0026#39;__reduce_ex__\u0026#39;, \u0026#39;__repr__\u0026#39;, \u0026#39;__reversed__\u0026#39;, \u0026#39;__rmul__\u0026#39;, \u0026#39;__setattr__\u0026#39;, \u0026#39;__setitem__\u0026#39;, \u0026#39;__sizeof__\u0026#39;, \u0026#39;__str__\u0026#39;, \u0026#39;__subclasshook__\u0026#39;, \u0026#39;append\u0026#39;, \u0026#39;clear\u0026#39;, \u0026#39;copy\u0026#39;, \u0026#39;count\u0026#39;, \u0026#39;extend\u0026#39;, \u0026#39;index\u0026#39;, \u0026#39;insert\u0026#39;, \u0026#39;pop\u0026#39;, \u0026#39;remove\u0026#39;, \u0026#39;reverse\u0026#39;, \u0026#39;sort\u0026#39;] __dict__ method is used to return a dictionary containing the attributes of an object. It returns a dictionary containing the attributes of the object.\nSyntax:\nobject.__dict__ Example:\nclass Person: name = \u0026#34;Alice\u0026#34; age = 30 person1 = Person() print(person1.__dict__) # Output: {\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 30} 9.super() method in Python When a parent class and a child class define a method with the same name, and we create an object of the child class, invoking the method on the child class object will execute the method defined in the child class, not the one in the parent class. To explicitly call the parent class\u0026rsquo;s method, we can use the super() function.\nTo explicitly invoke the parent class\u0026rsquo;s version of the method, the super() function is used. This is especially useful when the child class\u0026rsquo;s method needs to build upon or extend the functionality of the parent class\u0026rsquo;s method.\nSyntax:\nsuper().method_name() Example:\nclass Person: def display(self): print(\u0026#34;Person class\u0026#34;) class Student(Person): def display(self): super().display() print(\u0026#34;Student class\u0026#34;) student1 = Student() student1.display() # Output: # Person class # Student class Example:\nclass Person: def __init__(self,name,age): self.name=name self.age=age class Student(Person): def __init__(self,name,age,roll): super().__init__(name,age) self.roll=roll def display(self): print(f\u0026#34;Name: {self.name}\u0026#34;) print(f\u0026#34;Age: {self.age}\u0026#34;) print(f\u0026#34;Roll: {self.roll}\u0026#34;) student1 = Student(\u0026#34;Alice\u0026#34;, 30, 101) student1.display() # Output: # Name: Alice # Age: 30 # Roll: 101 Note: Use super for single inheritance only. For multiple inheritance, use the class name directly.\nMagic/dunder methods in Python Magic methods are special methods that have double underscores at the beginning and end of their names. They are also known as dunder methods (short for \u0026ldquo;double underscore\u0026rdquo;). Magic methods are used to define the behavior of objects. They are automatically called when certain operations are performed on objects. Some of the commonly used magic methods are:\n__init__: Constructor method, called when an object is created. __str__: Called by the str() built-in function to return a string representation of an object. __repr__: Called by the repr() built-in function to return an unambiguous string representation of an object. __add__: Called by the + operator to perform addition. __len__: Called by the len() built-in function to return the length of an object. __call__: Called when an object is called as a function. Note : All magic method can be seen using dir(objectname) method and we can override the magic method in our class.\nexample of all method:\nclass Person: def __init__(self, name, age): self.name = name self.age = age def __str__(self): return f\u0026#34;Name: {self.name}, Age: {self.age}\u0026#34; def __repr__(self): return f\u0026#34;Person(\u0026#39;{self.name}\u0026#39;, {self.age})\u0026#34; def __add__(self, other): return self.age + other.age def __len__(self): return len(self.name) def __call__(self): return f\u0026#34;Name: {self.name}, Age: {self.age}\u0026#34; person1 = Person(\u0026#34;Alice\u0026#34;, 30) person2 = Person(\u0026#34;Bob\u0026#34;, 25) print(person1) # Output: Name: Alice, Age: 30 print(repr(person1)) # Output: Person(\u0026#39;Alice\u0026#39;, 30) print(person1 + person2) # Output: 55 print(len(person1)) # Output: 5 print(person1()) # Output: Name: Alice, Age: 30 Method Overriding Method overriding is a feature of object-oriented programming that allows a subclass to provide a specific implementation of a method that is already provided by its parent class. When a method in a subclass has the same name, same parameters or signature, and same return type as a method in its parent class, then the method in the subclass is said to override the method in the parent class. Example:\nclass Person: def display(self): print(\u0026#34;Person class\u0026#34;) class Student(Person): def display(self): print(\u0026#34;Student class\u0026#34;) student1 = Student() student1.display() # Output: Student class We can also call the parent class\u0026rsquo;s method from the overridden method using the super() function.\nExample:\nclass Person: def display(self): print(\u0026#34;Person class\u0026#34;) class Student(Person): def display(self): super().display() #Or Person.display(self) print(\u0026#34;Student class\u0026#34;) student1 = Student() student1.display() # Output: # Person class # Student class Operator overloading in Python Operator overloading is a feature of object-oriented programming that allows us to define the behavior of operators for user-defined objects. It allows us to define the behavior of operators such as +, -, *, /, ==, !=, etc., for objects of a class. To overload an operator, we need to define a special method in the class that corresponds to the operator. These special methods are called magic methods or dunder methods.\nExample:\nclass Point: def __init__(self, x, y): self.x = x self.y = y def __add__(self, other): x = self.x + other.x y = self.y + other.y return Point(x, y) def __str__(self): return f\u0026#34;({self.x}, {self.y})\u0026#34; point1 = Point(1, 2) point2 = Point(3, 4) point3 = point1 + point2 print(point3) # Output: (4, 6) Types of Inheritance in Python Inheritance is a mechanism in which one class acquires the properties and behavior of another class. There are different types of inheritance in Python: Single Inheritance: In single inheritance, a class inherits from only one parent class. The pictorial representation of single inheritance is:\nA\r|\rB Syntax:\nclass ParentClass: #code block class ChildClass(ParentClass): #code block Example:\nclass Person: def __init__(self, name, age): self.name = name self.age = age def display(self): return f\u0026#34;Name: {self.name}, Age: {self.age}\u0026#34; def __str__(self): return f\u0026#34;Name: {self.name}, Age: {self.age}\u0026#34; def __repr__(self): return f\u0026#34;Person(\u0026#39;{self.name}\u0026#39;, {self.age})\u0026#34; def __call__(self): return f\u0026#34;Name: {self.name}, Age: {self.age}\u0026#34; class Student(Person): def __init__(self,naem,age,id): super().__init__(name,age) #or Person.__init__(self,name,age) self.id=id def display(self): print(f\u0026#34;ID: {self.id}\u0026#34;,super().display()) #or Person.display(self) student1 = Student(\u0026#34;Alice\u0026#34;, 30, 101) student1.display() # Output: # ID: 101 # Name: Alice, Age: 30 Multiple Inheritance: In multiple inheritance, a class inherits from more than one parent class. The pictorial representation of multiple inheritance is:\nA B\r\\ /\rC Syntax:\nclass ParentClass1: #code block class ParentClass2: #code block class ChildClass(ParentClass1, ParentClass2): #code block Example:\nclass Person: def __init__(self, name, age): self.name = name self.age = age def display(self): return f\u0026#34;Name: {self.name}, Age: {self.age}\u0026#34; class Address: def __init__(self,city,state): self.city=city self.state=state def display(self): return f\u0026#34;City: {self.city}, State: {self.state}\u0026#34; class Student(Person,Address): def __init__(self,name,age,id,city,state): Person.__init__(self,name,age) Address.__init__(self,city,state) self.id=id def display(self): print(f\u0026#34;ID: {self.id}\u0026#34;,Person.display(self),Address.display(self)) student1 = Student(\u0026#34;Alice\u0026#34;, 30, 101,\u0026#34;New York\u0026#34;,\u0026#34;New York\u0026#34;) student1.display() # Output: # ID: 101 # Name: Alice, Age: 30 # City: New York, State: New York Multilevel Inheritance: In multilevel inheritance, a class inherits from a parent class, and another class inherits from the child class. The pictorial representation of multilevel inheritance is:\nA\r|\rB\r|\rC Syntax:\nclass ParentClass: #code block class ChildClass(ParentClass): #code block class GrandChildClass(ChildClass): #code block Example:\nclass Person: def __init__(self, name, age): self.name = name self.age = age def display(self): return f\u0026#34;Name: {self.name}, Age: {self.age}\u0026#34; class Student(Person): def __init__(self,name,age,id): super().__init__(name,age) # or Person.__init__(self,name,age) self.id=id def display(self): print(f\u0026#34;ID: {self.id}\u0026#34;,super().display()) # print(f\u0026#34;ID: {self.id}\u0026#34;,Person.display(self)) class CollegeStudent(Student): def __init__(self,name,age,id,classes): super().__init__(name,age,id) #or Student.__init__(self,name,age,id) self.classes=classes def display(self): print(f\u0026#34;Class: {self.classes}\u0026#34;,super().display()) #or print(f\u0026#34;Class: {self.classes}\u0026#34;,Student.display(self)) student1 = CollegeStudent(\u0026#34;Alice\u0026#34;, 30, 101,\u0026#34;Bachelor\u0026#34;) student1.display() # Output: # Class: Bachelor # ID: 101 # Name: Alice, Age: 30 Hierarchical Inheritance: In hierarchical inheritance, more than one class inherits from a single parent class. The pictorial representation of hierarchical inheritance is:\nA\r/ \\\rB C Syntax:\nclass ParentClass: #code block class ChildClass1(ParentClass): #code block class ChildClass2(ParentClass): #code block Example:\nclass Person: def __init__(self, name, age): self.name = name self.age = age def display(self): return f\u0026#34;Name: {self.name}, Age: {self.age}\u0026#34; class Student(Person): def __init__(self,name,age,id): super().__init__(name,age) #or Person.__init__(self,name,age) self.id=id def display(self): print(f\u0026#34;ID: {self.id}\u0026#34;,super().display()) #or print(f\u0026#34;ID: {self.id}\u0026#34;,Person.display(self)) class Employee(Person): def __init__(self,name,age,emp_id): super().__init__(name,age) #or Person.__init__(self,name,age) self.emp_id=emp_id def display(self): print(f\u0026#34;Emp ID: {self.emp_id}\u0026#34;,super().display()) #or print(f\u0026#34;Emp ID: {self.emp_id}\u0026#34;,Person.display(self)) student1 = Student(\u0026#34;Alice\u0026#34;, 30, 101) student1.display() employee1 = Employee(\u0026#34;Bob\u0026#34;, 25, 201) employee1.display() # Output: # ID: 101 # Name: Alice, Age: 30 # Emp ID: 201 # Name: Bob, Age: 25 Note: Hybrid inheritance is a combination of two or more types of inheritance.\n14. MRO (Method Resolution Order) in Python Method Resolution Order (MRO) is the order in which methods are resolved in the inheritance hierarchy. It defines the order in which the base classes are searched when executing a method.\nfor example:\nclass C: f=\u0026#34;dirajan\u0026#34; class A(C): f=\u0026#34;nirajan\u0026#34; class B(C): f=\u0026#34;kirajan\u0026#34; class D(A,B): pass def display(self): print(self.f) d=D() print(D.__mro__) d.display() Output:\n(\u0026lt;class \u0026#39;__main__.D\u0026#39;\u0026gt;, \u0026lt;class \u0026#39;__main__.A\u0026#39;\u0026gt;, \u0026lt;class \u0026#39;__main__.B\u0026#39;\u0026gt;, \u0026lt;class \u0026#39;__main__.C\u0026#39;\u0026gt;, \u0026lt;class \u0026#39;object\u0026#39;\u0026gt;)\rnirajan It means it will search for the method in the order of D-\u0026gt;A-\u0026gt;B-\u0026gt;C-\u0026gt;object if the method is not found in the D it will search in A and so on. but if the method is found in the D it will not search in the A,B,C and object.\n15.Class Inside a Class in Python A class can be defined inside another class. The class inside the class is known as nested class. The nested class can access the attributes and methods of the outer class.\nSyntax:\nclass OuterClass: class InnerClass: #code block Example:\nclass OuterClass: def __init__(self): self.name = \u0026#34;Alice\u0026#34; self.age = 30 class InnerClass: def display(self, outer): print(f\u0026#34;Name: {outer.name}\u0026#34;) print(f\u0026#34;Age: {outer.age}\u0026#34;) outer1 = OuterClass() inner1 = outer1.InnerClass() inner1.display(outer1) # Output: # Name: Alice # Age: 30 16. Nested class in Python A class can be defined inside another class. The class inside the class is known as nested class. The nested class can access the attributes and methods of the outer class.\nSyntax:\nclass OuterClass: class InnerClass: #code block Creating an object of the nested class: Syntax:\nouter_object = OuterClass() inner_object = outer_object.InnerClass() Example:\nclass OuterClass: def __init__(self): self.name = \u0026#34;Alice\u0026#34; self.age = 30 class InnerClass: def display(self, outer): print(f\u0026#34;Name: {outer.name}\u0026#34;) print(f\u0026#34;Age: {outer.age}\u0026#34;) outer1 = OuterClass() inner1 = outer1.InnerClass() inner1.display(outer1) # Output: # Name: Alice # Age: 30 creating an object of the nested class inside the outer class:\nclass OuterClass: def __init__(self): self.name = \u0026#34;Alice\u0026#34; self.age = 30 self.inner = self.InnerClass() class InnerClass: def display(self, outer): print(f\u0026#34;Name: {outer.name}\u0026#34;) print(f\u0026#34;Age: {outer.age}\u0026#34;) outer1 = OuterClass() outer1.inner.display(outer1) # Output: # Name: Alice # Age: 30 ","permalink":"http://localhost:1313/posts/pages/python/python_object_oriented1/","summary":"This is the first part of series of Object Oriented Programming in Python","title":"Python Fundamentals: Exploring OOP (Part 12)"},{"content":"DOM (Document Object Model) Theory The DOM is a programming interface for HTML and XML documents. It represents the document as a tree structure where each node is an object representing a part of the document. This allows programming languages to interact with the document structure, style, and content.\n1. DOM Selection Methods a) document.getElementById() Selects an element by its ID attribute.\n\u0026lt;!-- HTML --\u0026gt; \u0026lt;div id=\u0026#34;myDiv\u0026#34;\u0026gt;Hello\u0026lt;/div\u0026gt; // JavaScript const element = document.getElementById(\u0026#39;myDiv\u0026#39;); console.log(element.innerText); // Output: // \u0026#34;Hello\u0026#34; b) document.getElementsByClassName() Returns a collection of elements with the specified class name.\n\u0026lt;!-- HTML --\u0026gt; \u0026lt;div class=\u0026#34;myClass\u0026#34;\u0026gt;Item 1\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;myClass\u0026#34;\u0026gt;Item 2\u0026lt;/div\u0026gt; // JavaScript const elements = document.getElementsByClassName(\u0026#39;myClass\u0026#39;); for (let i = 0; i \u0026lt; elements.length; i++) { console.log(elements[i].innerText); } // Output: // \u0026#34;Item 1\u0026#34; // \u0026#34;Item 2\u0026#34; c) document.getElementsByTagName() Returns a collection of elements with the specified tag name.\n\u0026lt;!-- HTML --\u0026gt; \u0026lt;p\u0026gt;Paragraph 1\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Paragraph 2\u0026lt;/p\u0026gt; // JavaScript const paragraphs = document.getElementsByTagName(\u0026#39;p\u0026#39;); for (let i = 0; i \u0026lt; paragraphs.length; i++) { console.log(paragraphs[i].innerText); // Output: // \u0026#34;Paragraph 1\u0026#34; // \u0026#34;Paragraph 2\u0026#34; d) document.querySelector() Returns the first element that matches the CSS selector.\n\u0026lt;!-- HTML --\u0026gt; \u0026lt;div class=\u0026#34;myClass\u0026#34;\u0026gt;First Element\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;myClass\u0026#34;\u0026gt;Second Element\u0026lt;/div\u0026gt; // JavaScript const firstElement = document.querySelector(\u0026#39;.myClass\u0026#39;); console.log(firstElement.innerText); // Output: // \u0026#34;First Element\u0026#34; e) document.querySelectorAll() Returns all elements that match the CSS selector.\n\u0026lt;!-- HTML --\u0026gt; \u0026lt;div class=\u0026#34;myClass\u0026#34;\u0026gt;First Element\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;myClass\u0026#34;\u0026gt;Second Element\u0026lt;/div\u0026gt; // JavaScript const allElements = document.querySelectorAll(\u0026#39;.myClass\u0026#39;); allElements.forEach(el =\u0026gt; console.log(el.innerText)); // Output: // \u0026#34;First Element\u0026#34; // \u0026#34;Second Element\u0026#34; 2. DOM Properties a) innerText Gets or sets the text content of an element.\n\u0026lt;!-- HTML --\u0026gt; \u0026lt;div id=\u0026#34;textElement\u0026#34;\u0026gt;Original Text\u0026lt;/div\u0026gt; // JavaScript const element = document.getElementById(\u0026#39;textElement\u0026#39;); element.innerText = \u0026#39;Hello World\u0026#39;; console.log(element.innerText); // Output: // \u0026#34;Hello World\u0026#34; b) innerHTML Gets or sets the HTML content of an element.\n\u0026lt;!-- HTML --\u0026gt; \u0026lt;div id=\u0026#34;htmlElement\u0026#34;\u0026gt;Original Content\u0026lt;/div\u0026gt; // JavaScript const element = document.getElementById(\u0026#39;htmlElement\u0026#39;); element.innerHTML = \u0026#39;\u0026lt;span\u0026gt;Hello World\u0026lt;/span\u0026gt;\u0026#39;; console.log(element.innerHTML); // Output: // \u0026#34;\u0026lt;span\u0026gt;Hello World\u0026lt;/span\u0026gt;\u0026#34; c) textContent Gets or sets the text content of a node and its descendants.\n\u0026lt;!-- HTML --\u0026gt; \u0026lt;div id=\u0026#34;contentElement\u0026#34;\u0026gt;Original Content\u0026lt;/div\u0026gt; // JavaScript const element = document.getElementById(\u0026#39;contentElement\u0026#39;); element.textContent = \u0026#39;Hello World\u0026#39;; console.log(element.textContent); // Output: // \u0026#34;Hello World\u0026#34; d) style Gets or sets inline styles of an element.\n\u0026lt;!-- HTML --\u0026gt; \u0026lt;div id=\u0026#34;styledElement\u0026#34;\u0026gt;Style Me\u0026lt;/div\u0026gt; // JavaScript const element = document.getElementById(\u0026#39;styledElement\u0026#39;); element.style.backgroundColor = \u0026#39;red\u0026#39;; element.style.fontSize = \u0026#39;16px\u0026#39;; // Result: Element with red background and font size of 16px 3. Events in JavaScript Events are actions that occur in a web page that can be detected by JavaScript.\nClick Event Example \u0026lt;!-- HTML --\u0026gt; \u0026lt;button id=\u0026#34;clickButton\u0026#34;\u0026gt;Click Me\u0026lt;/button\u0026gt; // JavaScript const button = document.getElementById(\u0026#39;clickButton\u0026#39;); button.addEventListener(\u0026#39;click\u0026#39;, function(e) { console.log(\u0026#39;Clicked!\u0026#39;); }); // Output when clicked: // \u0026#34;Clicked!\u0026#34; Mouse Over Event Example \u0026lt;!-- HTML --\u0026gt; \u0026lt;div id=\u0026#34;hoverElement\u0026#34;\u0026gt;Hover Over Me\u0026lt;/div\u0026gt; // JavaScript const element = document.getElementById(\u0026#39;hoverElement\u0026#39;); element.addEventListener(\u0026#39;mouseover\u0026#39;, function(e) { console.log(\u0026#39;Mouse over!\u0026#39;); }); // Output when hovered: // \u0026#34;Mouse over!\u0026#34; ","permalink":"http://localhost:1313/posts/pages/js/domevents/","summary":"A complete reference guide for DOM manipulation and Events","title":"Javascript : Dom and Events"},{"content":"Asynchronous Programming in JavaScript Asynchronous programming allows a program to perform multiple tasks simultaneously. It enables non-blocking operations, making it possible to execute long-running tasks without freezing the main program.\nFor example:\nconsole.log(\u0026#39;Start\u0026#39;); setTimeout(() =\u0026gt; { console.log(\u0026#39;This message is delayed by 2 seconds\u0026#39;); }, 2000); console.log(\u0026#39;End\u0026#39;); When you run this code, the output will be:\nStart\rEnd\rThis message is delayed by 2 seconds Explanation:\nconsole.log('Start'); is executed, and \u0026ldquo;Start\u0026rdquo; is printed. setTimeout() sets up a callback function to run after 2000 milliseconds (2 seconds) but does not block the next line. console.log('End'); is executed immediately after, and \u0026ldquo;End\u0026rdquo; is printed. After 2 seconds, the callback function in setTimeout() is executed, and \u0026ldquo;This message is delayed by 2 seconds\u0026rdquo; is printed. This demonstrates how asynchronous functions like setTimeout() work without blocking the execution of subsequent code.\nPromises Promises are a way to handle asynchronous operations in JavaScript. They represent a value that may be available now, in the future, or never. Promises can be in one of three states: pending, fulfilled, or rejected. They allow us to run code when the promise is fulfilled or rejected using the .then() and .catch() methods.\nSyntax to create a new Promise:\nconst promise = new Promise((resolve, reject) =\u0026gt; { // Perform an asynchronous operation // If successful, call resolve(value) // If an error occurs, call reject(error) }); Why We Use Promises Consider the following code:\nfunction main() { setTimeout(() =\u0026gt; { console.log(\u0026#34;Hello\u0026#34;); }, 1000); } main(); main(); main(); This code waits for 1 second and then logs \u0026ldquo;Hello\u0026rdquo; three times instantly. But what if we want to wait for the first to be completed before the second?\nThis can be solved using promises:\nfunction promise() { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { console.log(\u0026#34;Hello\u0026#34;); resolve(\u0026#34;Done\u0026#34;); }, 2000); }); } let data = promise(); When a promise is called, it returns a promise object instantly in a pending state. When the asynchronous operation completes, the promise is either fulfilled or rejected.\nHandling Promises To do a task when the promise is fulfilled (resolved):\ndata.then((data) =\u0026gt; { console.log(data); }); To do a task when the promise is rejected:\ndata.catch((err) =\u0026gt; { console.log(\u0026#34;Promise rejected\u0026#34;, err); }); Handling Multiple Promises function promise1() { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { console.log(\u0026#34;Promise 1 resolved\u0026#34;); resolve(\u0026#34;Done 1\u0026#34;); }, 2000); }); } function promise2() { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { console.log(\u0026#34;Promise 2 resolved\u0026#34;); resolve(\u0026#34;Done 2\u0026#34;); }, 2000); }); } function promise3() { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { console.log(\u0026#34;Promise 3 resolved\u0026#34;); resolve(\u0026#34;Done 3\u0026#34;); }, 2000); }); } let data1 = promise1(); let data2 = promise2(); let data3 = promise3(); How Promises Work:\npromise1 is called. promise2 is called immediately. promise3 is called immediately, regardless of whether the previous promises are resolved. To execute promises one by one:\nlet data1 = promise1(); data1.then((data) =\u0026gt; { console.log(data); return promise2(); }).then((data) =\u0026gt; { console.log(data); return promise3(); }).then((data) =\u0026gt; { console.log(data); }).catch((err) =\u0026gt; { console.log(\u0026#34;Error\u0026#34;, err); }); Here, the first promise will run, then the second, then the third, and so on, one by one.\nAsync and Await Async functions always return a promise. await is used to wait for a promise to be resolved, such that the code below it will not run until the promise is resolved.\nTo use await, we need to use an async function:\nasync function main() { console.log(\u0026#34;Hello\u0026#34;); } main(); Example with await:\nlet promise = new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { resolve(\u0026#34;Done\u0026#34;); }, 2000); }); async function main() { console.log(\u0026#34;Hello\u0026#34;); await promise; console.log(\u0026#34;Hello again\u0026#34;); } main(); console.log(\u0026#34;Hi\u0026#34;); What happens here is the main function is called, it prints \u0026ldquo;Hello\u0026rdquo;, then waits for 2 seconds to resolve. During that time, it prints \u0026ldquo;Hi\u0026rdquo;. When the promise is resolved, it prints \u0026ldquo;Hello again\u0026rdquo;.\nWhen await is called, the function pauses its execution until the promise is resolved. Then it continues the execution of the function, such that code below await will not run until the promise is resolved, but the code outside the function will run.\nasync function main() { console.log(\u0026#34;Hello\u0026#34;); await promise; await promise; await promise; console.log(\u0026#34;Hello again\u0026#34;); } Here, the first promise is resolved, then the second is resolved, and so on.\n","permalink":"http://localhost:1313/posts/pages/js/asyncronous/","summary":"A complete guide to asynchronous programming in JavaScript, covering promises and async/await.","title":"Asynchronous Programming in JavaScript"},{"content":"Basics of Vim Vim is a powerful text editor, often used in the command line, that is known for its efficiency and speed once mastered. Here are the basic commands and modes that you need to get started.\nOpening a File To open a file in Vim, use the following command:\nvim filename Replace filename with the name of the file you wish to open.\nBasic Modes in Vim Vim operates in different modes, and understanding these modes is crucial for using Vim effectively:\nNormal Mode: This is the default mode when you open a file. In this mode, you can navigate, delete, copy, and paste text. To return to Normal Mode from other modes, press Esc.\nInsert Mode: This mode allows you to insert text into the file. To enter Insert Mode, press i. After you\u0026rsquo;re done typing, press Esc to go back to Normal Mode.\nCommon Commands Here are some essential commands for working with files in Vim:\nSave the current file:\n:w This writes (saves) changes to the file.\nQuit Vim:\n:q To quit Vim. If there are unsaved changes, Vim will warn you. You can force quit without saving using:\n:q! Save changes and quit:\n:wq or\n:x These commands save changes and then exit Vim.\nTips for Beginners Press Esc frequently to return to Normal Mode, as it helps you avoid unintended actions while in other modes. Practice using both Normal and Insert modes to become comfortable with the flow of editing and saving files in Vim. Vim can be intimidating at first, but with practice, it becomes an extremely efficient tool for editing text files, especially in programming and development environments. ","permalink":"http://localhost:1313/posts/pages/linux/vim_basics_guide/","summary":"Learn the basics of using Vim, including navigation, saving, and quitting.","title":"Basics of Vim"},{"content":"Docker Cheat Sheet: Commands and Concepts This guide covers essential Docker commands, from creating containers, managing images, building Dockerfiles, to working with volumes.\n🚀 Creating and Running Containers 1. Run a Container from an Image To create and run a container from an image:\ndocker run image 2. Run a Container in Interactive Mode To run a container and open its terminal:\ndocker run -it image After the container starts, you can interact with it directly in the terminal. 3. Name a Container To give a container a specific name:\ndocker run --name container_name image 4. Port Mapping To map a port from your computer to the container:\ndocker run -p computer_port:container_port image Incoming traffic to computer_port will be forwarded to container_port in the container. 5. Run a Container in the Background (Detached Mode) To run the container in the background:\ndocker run -d image 6. Passing Environment Variables to a Container To pass environment variables to a container:\ndocker run -e key=value image 🛠️ Managing Containers 7. Start a Container To start an existing container:\ndocker start container_id 8. Stop a Container To stop a running container:\ndocker stop container_id 9. Remove a Container To remove a container:\ndocker rm container_id Note: The container must be stopped before removal. 10. Execute a Command in a Running Container To start a terminal session inside a running container:\ndocker exec -it container_id bash 11. View Running Containers To list all currently running containers:\ndocker ps 12. View All Containers (Running and Stopped) To see all containers, including those that are stopped:\ndocker ps -a 🧱 Building Docker Images 13. Creating a Dockerfile A Dockerfile is a script used to build Docker images. Here’s an example of common Dockerfile commands:\n# Set the base image for your container FROM base_image # Run commands during the image build process RUN command # Copy files from your local machine to the container COPY source /path/in/container # Set environment variables ENV key=value # Expose a port for the container EXPOSE 8080 # Define the command to run when the container starts CMD [\u0026#34;executable\u0026#34;] # Optionally, run commands automatically when the container starts ENTRYPOINT [\u0026#34;/path/to/script\u0026#34;] # Set the working directory in the container WORKDIR /app # Copy all files from the local directory to the container, excluding files listed in .dockerignore COPY . . 14. Building a Docker Image To build a Docker image from a Dockerfile:\ndocker build -t image_name /path/to/Dockerfile 📂 Managing Docker Files 15. Using the .dockerignore File The .dockerignore file helps exclude unnecessary files from being copied into the Docker image, improving build speed and reducing image size:\nnode_modules/ .git/ 16. COPY Command in Dockerfile The COPY command copies files from your local system to the container:\nCopy all files from the current directory to the container: COPY . /path/in/container Copy a specific file: COPY ./filename.extension /path/in/container Copy an entire folder: COPY ./foldername /path/in/container Copy contents of a folder (not the folder itself): COPY ./foldername/ /path/in/container 📦 Working with Volumes 17. Mounting Volumes Volumes allow data to persist even if the container is deleted. To mount a folder from your host to the container:\ndocker run -it -v /path/on/host:/path/in/container image Example: docker run -it -v /home/user/backup:/app/data ubuntu This will map /home/user/backup on your host to /app/data inside the container. Use Cases for Volumes: Data Persistence: Preserve data even after the container is removed. Backups: Easily back up container data to the host. Shared Data: Share data between multiple containers or between host and container. 💾 Publishing Docker Images 18. Pushing an Image to Docker Hub To publish an image to Docker Hub:\nTag the image with your Docker Hub username: docker tag image_name username/image_name Log in to Docker Hub: docker login Push the image to your repository: docker push username/image_name This guide gives you the essentials for working with Docker. With these commands, you\u0026rsquo;ll be able to manage containers, build images, use volumes, and more effectively.\n","permalink":"http://localhost:1313/posts/pages/docker/docker_basics/","summary":"A guide to understanding Docker commands and concepts.","title":"Docker Basic: Commands and Concepts"},{"content":"Docker Compose Documentation Introduction Docker Compose is a tool for defining and running multi-container Docker applications. With Docker Compose, you can use a YAML file to configure your application\u0026rsquo;s services and create and start all the services from your configuration with a single command.\nBasic docker-compose.yml Structure The docker-compose.yml file is where you define the services that make up your app. A typical file might look like this:\nversion: \u0026#39;3.8\u0026#39; services: service_name: image: image_name:tag ports: - \u0026#34;host_port:container_port\u0026#34; environment: - ENV_VAR=value volumes: - \u0026#34;host_path:container_path\u0026#34; depends_on: - dependency_service Example Configurations Example 1: Basic Setup with PostgreSQL and Redis version: \u0026#39;3.8\u0026#39; services: postgres: image: postgres ports: - \u0026#34;5432:5432\u0026#34; environment: POSTGRES_USER: postgres POSTGRES_DB: review POSTGRES_PASSWORD: password redis: image: redis ports: - \u0026#34;80:80\u0026#34; Example 2: Real-World Application version: \u0026#39;3\u0026#39; services: pythonapp: image: your-python-image:tag ports: - \u0026#34;8000:8000\u0026#34; volumes: - /Users/data:/src/bin/data depends_on: - db - redis db: image: postgres environment: POSTGRES_DB: mydatabase POSTGRES_USER: myuser POSTGRES_PASSWORD: mypassword redis: image: redis volumes: - /path/to/local/directory:/data Example 3: Building from Dockerfile version: \u0026#39;3\u0026#39; services: pythonapp: build: context: . dockerfile: Dockerfile ports: - \u0026#34;8000:8000\u0026#34; volumes: - /Users/desktop:/src/bin/desktop depends_on: - db - redis db: image: postgres environment: POSTGRES_DB: mydatabase POSTGRES_USER: myuser POSTGRES_PASSWORD: mypassword redis: image: redis volumes: - /path/to/local/directory:/data Example 4: Django Application with PostgreSQL and Redis version: \u0026#39;3.8\u0026#39; services: django-app: container_name: django-app image: django-app:latest # Replace with your actual Django image name/tag ports: - \u0026#34;8000:8000\u0026#34; # Expose Django app on port 8000 environment: - DEBUG=1 # Set Django debug mode to 1 for development - POSTGRES_HOST=postgres # PostgreSQL host - POSTGRES_DB_NAME=nirajan # PostgreSQL database name - POSTGRES_DB_PASSWORD=nirajan@9845 # PostgreSQL database password - REDIS_URL=redis://redis:6379/0 # Redis URL depends_on: - postgres - redis volumes: - static_volume:/code/static # Volume for Django static files - media_volume:/code/media # Volume for Django media files postgres: container_name: postgres image: postgres:latest environment: POSTGRES_DB: nirajan # Database name POSTGRES_USER: nirajan # Database username POSTGRES_PASSWORD: nirajan@9845 # Database password volumes: - postgres_data:/var/lib/postgresql/data redis: container_name: redis image: redis:latest ports: - \u0026#34;6379:6379\u0026#34; Service Names as Hostnames In Docker Compose, the names of the services defined in the docker-compose.yml file are used as hostnames for inter-service communication.\nService Names as Hostnames Each service name in the docker-compose.yml file acts as a hostname for that service. For example, in the configuration above:\nThe django-app service can connect to the postgres service using POSTGRES_HOST=postgres. The django-app service can connect to the redis service using REDIS_URL=redis://redis:6379/0. Example In the django-app service:\nPostgreSQL Host: POSTGRES_HOST=postgres — The Django app connects to the PostgreSQL service using the hostname postgres, which matches the name of the PostgreSQL service defined in Docker Compose. Redis Host: REDIS_URL=redis://redis:6379/0 — The Django app connects to the Redis service using the hostname redis, which matches the name of the Redis service defined in Docker Compose. Note: In Docker, services within a Docker Compose setup are typically connected to the same network by default. This allows containers to communicate with each other using service names as hostnames.\nDocker Compose Commands To start the containers defined in docker-compose.yml:\nsudo docker compose up To stop and remove all containers, networks, and volumes created by docker-compose up:\nsudo docker compose down To run the containers in the background (detached mode):\nsudo docker compose up -d Tips Use depends_on to specify dependencies between services. This ensures that the dependent services start in the correct order. Use volumes to persist data outside of your containers, which is especially useful for databases. Use environment variables to configure your services and avoid hardcoding sensitive information. Conclusion Docker Compose simplifies the process of managing multi-container Docker applications. By defining your services in a docker-compose.yml file, you can easily spin up your entire application stack with a single command. This guide provides a solid starting point for using Docker Compose to manage multi-container applications effectively.\n","permalink":"http://localhost:1313/posts/pages/docker/docker_compose/","summary":"Learn how to define and manage services in Docker Compose.","title":"Docker Compose Documentation"},{"content":"Docker CPU and Memory Limits When you want to control the CPU and memory usage of Docker containers, you can use specific options in both Docker CLI commands and Docker Compose files. Here\u0026rsquo;s a detailed guide on how to use these options:\nDocker CLI Commands Setting CPU Limits:\nOption: --cpus Usage: Specifies the number of CPUs that the container can use. Example: docker run --cpus=\u0026#34;1.5\u0026#34; my-image The --cpus option limits the container to 1.5 CPU cores. Setting Memory Limits:\nOption: --memory or -m\nUsage: Sets the maximum amount of memory the container can use.\nExample:\ndocker run --memory=\u0026#34;500m\u0026#34; my-image This command limits the container to 500MB of RAM. If the limit is exceeded, the container will be throttled or terminated.\nNote: The options take a positive integer followed by suffixes such as b, k, m, or g to indicate bytes, kilobytes, megabytes, or gigabytes.\nSoft Memory Limits:\nOption: --memory-reservation Example: docker run --memory=\u0026#34;1g\u0026#34; --memory-reservation=\u0026#34;512m\u0026#34; nginx This reserves 512MB of memory while setting a hard limit of 1GB. Docker Compose Configuration In Docker Compose, you can define resource limits under the deploy section for version 3.x or directly under the services section for version 2.x.\nSetting CPU and Memory Limits in Docker Compose (Version 2.x):\nversion: \u0026#39;2\u0026#39; services: my-service: image: my-image deploy: resources: limits: cpus: \u0026#39;1.5\u0026#39; memory: 500M This limits the service to 1.5 CPUs and 500MB of memory.\nSetting CPU and Memory Limits in Docker Compose (Version 3.x and above):\nversion: \u0026#39;3.8\u0026#39; services: my-service: image: my-image deploy: resources: limits: cpus: \u0026#39;1.5\u0026#39; memory: \u0026#39;500M\u0026#39; This limits the service to 1.5 CPUs and 500MB of memory.\nNotes: Swap Memory: You can enable swap memory using the --memory-swap option in CLI. For example:\ndocker run --memory=\u0026#34;512m\u0026#34; --memory-swap=\u0026#34;1g\u0026#34; nginx CPU Shares: Set CPU priorities between containers using --cpu-shares, with 1024 being the default.\nBy using these options, you can ensure that your Docker containers use resources efficiently, preventing them from overwhelming the host machine.\n","permalink":"http://localhost:1313/posts/pages/docker/docker_cpu_memory_limits_guide/","summary":"Control the CPU and memory usage of Docker containers with CLI and Docker Compose configurations.","title":"Docker CPU and Memory Limits"},{"content":"Docker Networking and Port Access In Docker, containers are isolated by default, meaning:\nContainers cannot access the host machine\u0026rsquo;s ports directly. Containers cannot access the ports of other containers directly. Container ports are not accessible from outside the host machine unless configured. 🛠️ Accessing Container Ports from Outside To access a container\u0026rsquo;s port from outside (e.g., from the host or another machine), you can use port mapping:\n1. Port Mapping docker run -p host_port:container_port imagename This command maps a container\u0026rsquo;s port to a port on the host machine. 2. Host Network To share the host\u0026rsquo;s network namespace with the container:\ndocker run --network host imagename 🌐 Accessing Container Ports from Another Container To allow inter-container communication, you need to create and use a custom Docker network.\nSteps: 1. Create a Docker Network docker network create my_network 2. Run Containers in the Same Network docker run --network my_network --name container1 imagename docker run --network my_network --name container2 imagename 3. Access One Container from Another Use the container name and port to access one container from another:\ncontainer1:port Example Scenario Create a Network docker network create my_network Run First Container docker run --network my_network --name webserver -d nginx Run Second Container docker run --network my_network --name client -it alpine /bin/sh Access Web Server from Client Inside the client container, use the following commands to access the web server: wget -qO- http://webserver or\ncurl http://webserver 📝 Important Notes Container-to-Container Access: Containers in the same custom network can communicate using their names as hostnames. Host Machine Access: Containers cannot directly access the host machine\u0026rsquo;s ports. External Access: Use port mapping or host networking to access container ports from outside the host machine. List Docker Networks To list all available Docker networks and verify the existence of custom networks:\ndocker network ls ","permalink":"http://localhost:1313/posts/pages/docker/docker_networking_guide/","summary":"Understanding Docker networking and inter-container communication.","title":"Docker Networking and Port Access"},{"content":" 1. Configure Git To set up your Git username and email globally on your machine:\ngit config --global user.name \u0026#34;username\u0026#34; # Set your Git username git config --global user.email \u0026#34;email\u0026#34; # Set your Git email git config --list # Display the current Git configuration (username and email) 2. Git Status and Git Clone Clone a remote repository to your local machine:\ngit clone \u0026lt;url\u0026gt; # Copy repository to the local machine Check the status of your local repository:\ngit status # Show the current status of the repository Git Status Breakdown: untracked: A new file that has not been added or committed. unstaged: A file that has been added but not committed. unchanged: No changes have been made. changed: Changes have been made but not yet added or committed. 3. Git Add and Commit Add specific files or all changes and commit them:\ngit add \u0026lt;filename\u0026gt; # Add a specific file to the staging area git add . # Add all changes (modified and untracked files) git commit -m \u0026#34;Your commit message\u0026#34; # Commit the changes with a message 4. Push Local Repo to Remote To upload your local repository changes to the remote repository:\ngit push [alias] [branch] # Push changes to a specific alias and branch git remote add \u0026lt;alias\u0026gt; \u0026lt;url\u0026gt; # Add a remote alias (e.g., \u0026#39;origin\u0026#39;) git push -u [alias] [branch] # Save the alias and branch for future pushes 5. Git Initialization Initialize a new Git repository:\ngit init # Initialize a new Git repository 6. Git Branches Manage Git branches with the following commands:\ngit branch # List all local branches git branch -m \u0026lt;oldbranch\u0026gt; \u0026lt;newbranch\u0026gt; # Rename a branch git checkout \u0026lt;branchname\u0026gt; # Switch to another branch git checkout -b \u0026lt;branchname\u0026gt; # Create and switch to a new branch git branch -d \u0026lt;branchname\u0026gt; # Delete a branch (ensure you\u0026#39;re not on it) git diff \u0026lt;branchname\u0026gt; # Compare the current branch with another 7. Git Merge Merge changes from one branch into another:\ngit merge \u0026lt;branchname\u0026gt; # Merge changes from \u0026lt;branchname\u0026gt; into the current branch 8. Pull Request and Syncing Changes To pull updates from the remote repository to your local one:\ngit pull # Pull the latest changes from the remote repository git pull [alias] [branch] # Pull changes from a specific alias and branch 9. Undoing Changes If You Have Only Added Changes: git reset \u0026lt;filename\u0026gt; # Unstage a file from the staging area git reset # Unstage all files that have been added If You Have Committed Changes: git reset HEAD~1 # Undo the last commit (one step back) git reset \u0026lt;commit_hash\u0026gt; # Reset to a specific commit hash git reset --hard \u0026lt;commit_hash\u0026gt; # Hard reset to a commit and reflect changes in your editor git log # View all commit hashes and logs 10. Forking Repositories When contributing to open-source projects, you can fork a repository, which creates a copy of the repo under your GitHub account. Afterward, you can make changes and submit a pull request:\n# Fork a repository on GitHub and clone it locally git clone \u0026lt;forked_repo_url\u0026gt; # Clone your forked repository Make changes, commit them, and push to your fork. Finally, create a pull request on GitHub to merge your changes into the original repository.\nIF ANY CONCEPT IS LAGGING THEN: Watch this helpful video\n","permalink":"http://localhost:1313/posts/pages/git/git-cheetsheet/","summary":"A brief tutorial on github recipe and git command","title":"Git Commands and Configuration Guide"},{"content":"How to Create Content for Hugo Using Markdown Hugo, a static site generator, uses Markdown (.md) files to generate content. In this guide, we will explain how you can create content for Hugo using Markdown.\n1. Front Matter Every Markdown file in Hugo requires front matter, which is metadata placed at the top of the file. It helps Hugo understand how to process the file.\nExample:\n--- title: \u0026#34;My First Hugo Post\u0026#34; date: 2024-10-18 tags: [\u0026#34;Hugo\u0026#34;, \u0026#34;Markdown\u0026#34;] summary: \u0026#34;A brief summary of the post.\u0026#34; --- 2. Headers Headers are used to organize content. Use one # for an H1 header, two ## for H2, and so on.\nExample:\n# H1 Header ## H2 Header ### H3 Header Output:\nH3 Header 3. Text Formatting Markdown supports several text formatting options:\nExample:\n**Bold Text** *Italic Text* ~~Strikethrough~~ Output: Bold Text\nItalic Text\nStrikethrough\n4. Spacing and Line Breaks In Markdown, you can create paragraphs by leaving a blank line between lines of text.\nExample:\nThis is the first paragraph. This is the second paragraph. Output: This is the first paragraph.\nThis is the second paragraph.\n5. Horizontal Rules You can create horizontal lines (dividers) using three or more dashes (---), asterisks (***), or underscores (___).\nExample:\n--- Output:\n6. Lists Create unordered lists with - or *, and ordered lists with numbers followed by periods.\nExample:\n- Item 1 - Item 2 1. First item 2. Second item Output:\nItem 1 Item 2 First item Second item 7. Links and Images Add links and images with square brackets [] and parentheses ().\nExample:\n[Hugo Documentation](https://gohugo.io) ![Hugo Logo](/images/hugo.webp) Output: Hugo Documentation\n8. Code Blocks For inline code, use backticks. For block code, use triple backticks.\nExample:\nInline code: `print(\u0026#34;Hello World\u0026#34;)` Output: Inline code: print(\u0026quot;Hello World\u0026quot;)\nExample:\nBlock Code: def hello(): print(\u0026#34;Hello, Hugo!\u0026#34;) def hello(): print(\u0026#34;Hello, Hugo!\u0026#34;) 9. Blockquotes Use the greater than symbol (\u0026gt;) to create blockquotes.\nExample:\n\u0026gt; This is a blockquote in Hugo. Output:\nThis is a blockquote in Hugo.\n10. Tables You can create tables using pipes | and dashes -.\nExample:\n| Column 1 | Column 2 | |----------|----------| | Row 1 | Data 1 | | Row 2 | Data 2 | Output:\nColumn 1 Column 2 Row 1 Data 1 Row 2 Data 2 11. Task Lists Create task lists by using square brackets []. An x in the brackets [x] marks a task as completed.\nExample:\n- [ ] Task 1 - [x] Task 2 (Completed) Output:\nTask 1 Task 2 (Completed) 12. Syntax Highlighting Hugo supports syntax highlighting for various programming languages. You can specify the language after the triple backticks(```).\nExample: Output:\ndef greet(): print(\u0026#34;Hello, Hugo!\u0026#34;) 12. Task Lists Create task lists by using square brackets []. An x in the brackets [x] marks a task as completed.\nExample:\n- [ ] Task 1 - [ ] Sub-task 1 - [x] Sub-task 2 (Completed) - [x] Task 2 (Completed) Output:\nTask 1 Sub-task 1 Sub-task 2 (Completed) Task 2 (Completed) 13. Escaping Special Characters To use special characters like #, escape them using a backslash \\.\nExample:\n\\# This is not a header Output: # This is not a header\n14. Backtick To display backtick use four space before it as\n``` 15. Consistency It\u0026rsquo;s important to maintain consistent formatting throughout your Markdown files to ensure a clean and readable structure.\nBy following these steps, you can effectively create well-formatted content for your Hugo site using Markdown.\n","permalink":"http://localhost:1313/posts/pages/hugo/markdown_hugo_content_guide/","summary":"A tutorial on creating content with Markdown in Hugo.","title":"How to Create Content for Hugo"},{"content":"JavaScript Reference Behavior: Objects and Arrays Introduction In JavaScript, both objects and arrays are considered reference types. This means that when you assign an object or an array to another variable, you’re not creating a new copy of that object or array. Instead, the new variable holds a reference to the original object or array in memory. Understanding this concept is crucial because it directly affects how data is manipulated and shared within your code.\nObject Reference Behavior 1. Overview When you work with objects in JavaScript, it\u0026rsquo;s essential to recognize that assigning an object to a new variable does not create a new object. Instead, it creates a reference to the original object. This means that any changes made through the new reference will affect the original object.\n2. Example const person = { name: \u0026#34;Alice\u0026#34;, address: { city: \u0026#34;Wonderland\u0026#34; } }; const newPerson = person.address; // newPerson now references the same object as person.address newPerson.city = \u0026#34;New Wonderland\u0026#34;; // modifying newPerson affects the original object console.log(person); // Output: { name: \u0026#39;Alice\u0026#39;, address: { city: \u0026#39;New Wonderland\u0026#39; } } ## JavaScript Reference Behavior: Objects and Arrays ### Introduction In JavaScript, both objects and arrays are considered reference types. This means that when you assign an object or an array to another variable, you’re not creating a new copy of that object or array. Instead, the new variable holds a reference to the original object or array in memory. Understanding this concept is crucial because it directly affects how data is manipulated and shared within your code. ### Object Reference Behavior #### 1. Overview When you work with objects in JavaScript, it\u0026#39;s essential to recognize that assigning an object to a new variable does not create a new object. Instead, it creates a reference to the original object. This means that any changes made through the new reference will affect the original object. #### 2. Example ```javascript const person = { name: \u0026#34;Alice\u0026#34;, address: { city: \u0026#34;Wonderland\u0026#34; } }; const newPerson = person.address; // newPerson now references the same object as person.address newPerson.city = \u0026#34;New Wonderland\u0026#34;; // modifying newPerson affects the original object console.log(person); // Output: { name: \u0026#39;Alice\u0026#39;, address: { city: \u0026#39;New Wonderland\u0026#39; } } 3. Explanation Object Reference: When you create const newPerson = person.address;, you\u0026rsquo;re not making a copy of the address object. Instead, newPerson references the same address object that person.address references. Thus, when you update newPerson.city = \u0026quot;New Wonderland\u0026quot;;, it directly modifies the person.address object because both newPerson and person.address are pointing to the same location in memory. Output: The console logs the person object, which now reflects the change: { name: 'Alice', address: { city: 'New Wonderland' } }. Array Reference Behavior 1. Overview Arrays in JavaScript behave similarly to objects in terms of reference handling. When you assign an array to another variable, you create a reference to the original array. As a result, any modifications through this reference will affect the original array.\n2. Example const numbers = [1, 2, 3]; const moreNumbers = numbers; // moreNumbers now references the same array as numbers moreNumbers[0] = 99; // modifying moreNumbers affects the original array console.log(numbers); // Output: [99, 2, 3] 3. Explanation Array Reference: When you create const moreNumbers = numbers;, you\u0026rsquo;re not creating a new array. Instead, moreNumbers becomes a reference to the same array that numbers references. Any changes to moreNumbers, such as moreNumbers[0] = 99, directly modify the numbers array because both variables point to the same array in memory. Output: The console logs the numbers array, which now reflects the change: [99, 2, 3]. Key Takeaways Reference Types: Both objects and arrays are reference types in JavaScript, meaning that variables assigned to them hold references to the same data in memory. Shared Modifications: Changes made to an object or array through one reference will affect all other references to that same object or array. Memory Efficiency: This reference behavior allows for memory-efficient data management but requires careful handling to avoid unintended side effects. JavaScript References with filter() and find() In JavaScript, the way references work with methods like filter() and find() is different, leading to distinct behaviors. Understanding these differences is crucial for working effectively with arrays and avoiding unintended side effects.\nfilter(): Creating a New Array 1. Overview The filter() method in JavaScript creates a new array that contains only the elements that satisfy the provided condition. This means that a new array is returned, and it does not affect the original array. However, if the elements in the array are objects, the references to these objects are retained, meaning any modifications to the objects in the new array will also affect the original array.\n2. Example const originalArray = [ { id: 1, name: \u0026#34;Alice\u0026#34; }, { id: 2, name: \u0026#34;Bob\u0026#34; }, { id: 3, name: \u0026#34;Charlie\u0026#34; } ]; const filteredArray = originalArray.filter(item =\u0026gt; item.id !== 2); // Modify an object in the filtered array filteredArray[0].name = \u0026#34;Alicia\u0026#34;; console.log(originalArray); // Output: [{ id: 1, name: \u0026#39;Alicia\u0026#39; }, { id: 2, name: \u0026#39;Bob\u0026#39; }, { id: 3, name: \u0026#39;Charlie\u0026#39; }] console.log(filteredArray); // Output: [{ id: 1, name: \u0026#39;Alicia\u0026#39; }, { id: 3, name: \u0026#39;Charlie\u0026#39; }] 3. Explanation New Array Creation: The filter() method creates a new array (filteredArray) that includes all elements from originalArray except the one with id 2. However, the objects within the new array are still references to the original objects in originalArray. Shared References: When you modify the name property of the first object in filteredArray (filteredArray[0].name = \u0026quot;Alicia\u0026quot;;), it also changes in originalArray because both arrays reference the same object in memory. Output: The original array shows that the name of the first object has been changed to \u0026ldquo;Alicia\u0026rdquo;, indicating that the object references are shared. find(): Returning a Single Element Reference 1. Overview The find() method returns the first element in the array that satisfies the provided condition. This element is not a copy but a reference to the original element in the array. As a result, any modification to this element directly affects the original array.\n2. Example const originalArray = [ { id: 1, name: \u0026#34;Alice\u0026#34; }, { id: 2, name: \u0026#34;Bob\u0026#34; }, { id: 3, name: \u0026#34;Charlie\u0026#34; } ]; const foundItem = originalArray.find(item =\u0026gt; item.id === 2); // Modify the found item foundItem.name = \u0026#34;Robert\u0026#34;; console.log(originalArray); // Output: [{ id: 1, name: \u0026#39;Alice\u0026#39; }, { id: 2, name: \u0026#39;Robert\u0026#39; }, { id: 3, name: \u0026#39;Charlie\u0026#39; }] console.log(foundItem); // Output: { id: 2, name: \u0026#39;Robert\u0026#39; } 3. Explanation Element Reference: The find() method returns a reference to the first element that meets the condition (item.id === 2). In this case, foundItem references the same object in memory as the element in originalArray with id: 2. Direct Modification: When you modify the name property of foundItem (foundItem.name = \u0026quot;Robert\u0026quot;;), it directly alters the corresponding object in originalArray because they are the same object in memory. Output: The original array now shows that the name of the object with id: 2 has been changed to \u0026ldquo;Robert\u0026rdquo;, demonstrating that the reference was modified. Key Differences Between filter() and find() New Array vs. Single Element: filter(): Returns a new array containing references to elements that meet the condition. find(): Returns a reference to the first element that meets the condition. Impact on Original Array: filter(): The original array remains unchanged, but the objects within the new array are still references to the original objects. find(): The original array can be directly modified through the returned element. Use Cases: Use filter() when you need a subset of the original array without altering it directly. Use find() when you need to retrieve and possibly modify a specific element from the array. Conclusion Understanding how references work with methods like filter() and find() is crucial in JavaScript. While filter() returns a new array that retains references to the original objects, find() returns a direct reference to a single element. Being aware of these behaviors helps prevent unintended modifications to your data.\n","permalink":"http://localhost:1313/posts/pages/js/referencebehavious/","summary":"Learn about reference types in JavaScript, including objects and arrays, and how methods like filter() and find() handle references.","title":"JavaScript Reference Behavior: Objects and Arrays"},{"content":"JavaScript Reference Guide 1. Console.log() Method Purpose: Prints output to the console, useful for debugging. Syntax: console.log(value); Example: const name = \u0026#39;John\u0026#39;; console.log(name); // Output: John 2. Variables: let, const let: Block-scoped variable that can be updated but not accessed before declaration.\nlet x = 10; if (true) { let x = 20; // Block-scoped console.log(x); // 20 } console.log(x); // 10 const: Block-scoped variable that cannot be reassigned and must be initialized when declared.\nconst pi = 3.14; // pi = 3.1415; // Error: Cannot reassign 3. JavaScript Data Types String\nExplanation: Represents a sequence of characters. Can be enclosed in single quotes, double quotes, or backticks (for template literals). Syntax: const str = 'Hello, World!'; Example: const greeting = \u0026#34;Hello, \u0026#34; + \u0026#34;World!\u0026#34;; // Output: Hello, World! Number\nExplanation: Represents both integer and floating-point numbers. JavaScript numbers range from -(2^53 - 1) to 2^53 - 1. Syntax: const num = 123; Example: const amount = 25; // Output: 25 BigInt\nExplanation: Represents integers with arbitrary precision. Denoted by appending an n to the end of the number. Syntax: const bigNum = 1234567890123456789012345678901234567890n; Example: const bigNumber = 1234567890123456789012345678901234567890n; Boolean\nExplanation: Represents a value that is either true or false. Syntax: const isTrue = true; Example: const isActive = Boolean(1); // Output: true Null\nExplanation: Represents the intentional absence of any value. Syntax: const emptyValue = null; Example: const noValue = null; Undefined\nExplanation: Represents a variable that has been declared but not assigned a value. Syntax: let uninitialized; Example: let value; console.log(value); // Output: undefined For Checking Data Type We Use: typeof variableName; 4. Explicit Type Conversion To String: String(value) or value.toString()\nlet str = String(123); // \u0026#39;123\u0026#39; To Number: Number(value), parseInt(value), or parseFloat(value)\nlet num = Number(\u0026#39;456\u0026#39;); // 456 To Boolean: Boolean(value)\nlet bool = Boolean(\u0026#39;hello\u0026#39;); // true 5. JavaScript Operators i) Comparison Operators Greater than: a \u0026gt; b Less than: a \u0026lt; b Greater than or equal to: a \u0026gt;= b Less than or equal to: a \u0026lt;= b Not equal to: a != b Equal to: a == b Strictly equal to: a === b Examples:\nconsole.log(\u0026#34;2\u0026#34; == 2); // true console.log(\u0026#34;2\u0026#34; === 2); // false ii) Logical Operators AND: operand1 \u0026amp;\u0026amp; operand2 OR: operand1 || operand2 NOT: !operand Examples:\nconsole.log(true \u0026amp;\u0026amp; false); // false console.log(true || false); // true console.log(!true); // false iii) Arithmetic Operators Addition: operand1 + operand2 Subtraction: operand1 - operand2 Multiplication: operand1 * operand2 Division: operand1 / operand2 Modulo: operand1 % operand2 Increment: operand++ Decrement: operand-- Examples:\nconsole.log(5 + 3); // 8 console.log(5 - 3); // 2 console.log(5 * 3); // 15 console.log(6 / 3); // 2 console.log(5 % 3); // 2 6. String Methods and Operations 1. Concatenation Explanation: Combines two or more strings into one. Syntax: string1 + string2 Returns: A new string combining the original strings. Example: let a = \u0026#39; My name is nirajan \u0026#39;; let b = \u0026#34;nirajan\u0026#34;; console.log(a + b + \u0026#34;Khatiwada\u0026#34;); // Output: \u0026#39; My name is nirajan nirajanKhatiwada\u0026#39; 2. Simple Form (String Boilerplate) Explanation: Uses template literals to embed expressions within a string. Syntax: ${expression} Returns: A new string with evaluated expressions. Example: let a = \u0026#39; My name is nirajan \u0026#39;; let b = \u0026#34;nirajan\u0026#34;; console.log(`${a}${b}khatiwada`); // Output: \u0026#39; My name is nirajan nirajankhatiwada\u0026#39; 3. Accessing Element of String Explanation: Retrieves the character at a specified index. Syntax: string[index] Returns: The character at the given index (or undefined if out of range). Example: let a = \u0026#39; My name is nirajan \u0026#39;; console.log(a[0]); // Output: \u0026#39; \u0026#39; 4. Finding Length of String Explanation: Gets the number of characters in the string. Syntax: string.length Returns: The length of the string as a number. Example: let a = \u0026#39; My name is nirajan \u0026#39;; console.log(a.length); // Output: 21 5. To Uppercase Explanation: Converts all characters in the string to uppercase. Syntax: string.toUpperCase() Returns: A new string with all characters in uppercase. Example: let a = \u0026#39; My name is nirajan \u0026#39;; console.log(a.toUpperCase()); // Output: \u0026#39; MY NAME IS NIRAJAN \u0026#39; 6. To Lowercase Explanation: Converts all characters in the string to lowercase. Syntax: string.toLowerCase() Returns: A new string with all characters in lowercase. Example: let a = \u0026#39; My name is nirajan \u0026#39;; console.log(a.toLowerCase()); // Output: \u0026#39; my name is nirajan \u0026#39; 8. String Slicing Explanation: Extracts a section of the string based on start and end indices. Syntax: string.slice(start, end) Returns: A new string containing the extracted section. Example: let a = \u0026#39; My name is nirajan \u0026#39;; console.log(a.slice(0, 4)); // Output: \u0026#39; My\u0026#39; 9. Trim Explanation: Removes whitespace from both ends of the string. Syntax: string.trim() Returns: A new string with whitespace removed from both ends. Example: let a = \u0026#39; My name is nirajan \u0026#39;; console.log(a.trim()); // Output: \u0026#39;My name is nirajan\u0026#39; 10. Replace Explanation: Replaces the first occurrence of a specified substring or pattern with a new substring. Syntax: string.replace(search, replacement) Returns: A new string with the specified substring replaced. Example: let a = \u0026#39; My name is nirajan \u0026#39;; console.log(a.replace(\u0026#34;nirajan\u0026#34;, \u0026#34;kirajan\u0026#34;)); // Output: \u0026#39; My name is kirajan \u0026#39; 11. Split Explanation: Splits the string into an array of substrings based on a separator. Syntax: string.split(separator, limit) Returns: An array of substrings. Example: let a = \u0026#39; My name is nirajan \u0026#39;; console.log(a.split(\u0026#34; \u0026#34;)); // Output: [\u0026#39; My\u0026#39;, \u0026#39;name\u0026#39;, \u0026#39;is\u0026#39;, \u0026#39;nirajan\u0026#39;] 7. Number Methods 1. toFixed() Explanation: Formats a number using fixed-point notation with a specified number of decimal places. Syntax: number.toFixed(digits); Returns: A string representing the number with the specified number of decimal places. Example: let c = 10.001; console.log(c.toFixed(10)); // Output: \u0026#39;10.0010000000\u0026#39; 2. Math.ceil() Explanation: Rounds a number up to the nearest integer. Syntax: Math.ceil(number); Returns: The smallest integer greater than or equal to the given number. Example: let a = 1.1000; console.log(Math.ceil(a)); // Output: 2 3. Math.floor() Explanation: Rounds a number down to the nearest integer. Syntax: Math.floor(number); Returns: The largest integer less than or equal to the given number. Example: console.log(Math.floor(a)); // Output: 1 4. Math.round() Explanation: Rounds a number to the nearest integer. Syntax: Math.round(number); Returns: The value of the number rounded to the nearest integer. Example: console.log(Math.round(a)); // Output: 1 5. Math.random() Explanation: Returns a pseudo-random floating-point number between 0 (inclusive) and 1 (exclusive). Syntax: Math.random(); Returns: A floating-point number between 0 (inclusive) and 1 (exclusive). Example: console.log(Math.random()); // Output: A random number between 0 and 1 8. Non-Primitive Data Types in JavaScript 1. Object Explanation: Objects are collections of key-value pairs. Keys are usually strings (or symbols) and values can be any data type. Syntax: let objectName = { key1: value1, key2: value2, // more key-value pairs }; Example: let data = { \u0026#34;name\u0026#34;: \u0026#34;nirajan\u0026#34;, \u0026#34;age\u0026#34;: 20 }; 2. Array Explanation: Arrays are ordered collections of values. Values can be of any data type and are accessed by their index. Syntax: let arrayName = [value1, value2, value3, ...]; Example: let a = [\u0026#34;nirajan\u0026#34;, \u0026#34;kirajan\u0026#34;, \u0026#34;birajan\u0026#34;]; 3. Function Explanation: Functions are blocks of code designed to perform a particular task. They can be invoked (called) to execute their code. Syntax: function functionName(parameters) { // code to be executed } Example: function outer() { console.log(\u0026#34;hi\u0026#34;); } outer(); // Output: hi 9. Array Methods 1. Indexing in Array Accessing Elements: Description: Arrays are zero-indexed, so the first element is at index 0. Returns: Value of the element at the specified index. Example: console.log(a[0]); // Output: 1 console.log(a[3]); // Output: 4 2. Slicing in Array Slicing: Description: Extracts a section of the array and returns it as a new array. Syntax: array.slice(startIndex, endIndex) Returns: A new array containing the elements from startIndex up to, but not including, endIndex. Example: console.log(a.slice(0, 2)); // Output: [1, 2] 3. Length of Array Description: Returns the number of elements in the array. Returns: Integer (length of the array). Example: console.log(a.length); // Output: 4 4. Push Description: Adds one or more elements to the end of the array. Returns: The new length of the array. Example: a.push(5); console.log(a); // Output: [1, 2, 3, 4, 5] 5. Pop Description: Removes the last element from the array. Returns: The removed element. Example: a.pop(); console.log(a); // Output: [1, 2, 3, 4] 6. Shift Description: Removes the first element from the array. Returns: The removed element. Example: a.shift(); console.log(a); // Output: [2, 3, 4] 7. Unshift Description: Adds one or more elements to the beginning of the array. Returns: The new length of the array. Example: a.unshift(0); console.log(a); // Output: [0, 1, 2, 3, 4] 8. Join Description: Joins all elements of an array into a string, separated by a specified separator. Returns: A string representing the array elements joined by the specified separator. Example: let data = a.join(\u0026#34; \u0026#34;); console.log(data); // Output: \u0026#34;1 2 3 4\u0026#34; 9. Concatenation of Two Arrays Description: Merges two or more arrays into one. Returns: A new array containing the elements of the original arrays. Example: let a2 = [5, 4, 1, 3, 4]; console.log(a.concat(a2)); // Output: [1, 2, 3, 4, 5, 4, 1, 3, 4] 10. Sort Description: Sorts the elements of an array in place. Returns: The sorted array. Example: a2.sort(); console.log(a2); // Output: [1, 3, 4, 4, 5] 11. Reverse Description: Reverses the order of the elements in the array. Returns: The reversed array. Example: a2.reverse(); console.log(a2); // Output: [5, 4, 4, 3, 1] 12. Removing Elements from a Specific Position Description: Changes the contents of an array by removing or replacing existing elements. Syntax: array.splice(index, numberOfElementsToRemove) Returns: An array containing the removed elements. Example: let newData = [1, 2, 3, 4]; newData.splice(1, 2); // Removes 2 elements starting at index 1 console.log(newData); // Output: [1, 4] 13. Inserting Elements at a Specific Position Description: Inserts elements into the array. Syntax: array.splice(index, 0, element1, element2, ...) Returns: An array containing the removed elements (empty if no elements were removed). Example: let lasrData = [1, 4]; lasrData.splice(1, 0, 2, 3); // Inserts elements 2 and 3 at index 1 console.log(lasrData); // Output: [1, 2, 3, 4] 14. Spread Operator (\u0026hellip;) Description: Spreads out elements of an array into another array or function arguments. Returns: A new array containing the elements spread from the original arrays. Example: let finalData = [...newData, ...lasrData]; console.log(finalData); // Output: [1, 4, 1, 2, 3, 4] 15. Array Destructuring Description: Allows unpacking values from arrays into distinct variables in a concise and readable way. Basic Syntax: const [var1, var2, var3] = array; Example: const numbers = [1, 2, 3]; const [first, second, third] = numbers; console.log(first); // Output: 1 console.log(second); // Output: 2 console.log(third); // Output: 3 10. Object in Js i. Defining an Object An object in JavaScript is a collection of key-value pairs. Each key (also known as a property) is a unique identifier, and the value can be anything: a string, number, array, function, or even another object. Example:\nconst myObject = { name: \u0026#34;Nirajan\u0026#34;, // String property class: \u0026#34;Bachelor\u0026#34;, // String property is_topper: \u0026#34;No\u0026#34;, // Boolean property (as a string) greet: function (from) { // Method (function inside an object) console.log(`Welcome ${this.name}. From ${from}`); } }; ii. Accessing There are two common ways to access properties in an object:\nDot Notation: console.log(myObject.name); // Output: nirajan This is the most common and preferred method when you know the property name in advance. Bracket Notation: console.log(myObject[\u0026#39;name\u0026#39;]); // Output: nirajan Bracket notation is useful when the property name is stored in a variable or when it contains special characters or spaces. iii. Modifying Object Properties You can modify an object\u0026rsquo;s properties using dot or bracket notation:\nDot Notation: Use when you know the property name.\nmyObject.name = \u0026#34;Kirajan\u0026#34;; // Modifies the \u0026#39;name\u0026#39; property Bracket Notation: Use when the property name is dynamic or contains special characters.\nmyObject[\u0026#39;class\u0026#39;] = \u0026#34;Master\u0026#39;s\u0026#34;; // Modifies the \u0026#39;class\u0026#39; property iv. Adding New Properties You can dynamically add new key-value pairs to an object.\nmyObject.lol = \u0026#34;lol\u0026#34;; console.log(myObject.lol); // Output: lol v. Using the this Keyword The this keyword inside an object’s method refers to the object itself, allowing you to access its properties. Example:\nconst person = { name: \u0026#34;Kirajan\u0026#34;, greet: function() { console.log(`Hello, my name is ${this.name}`); } }; person.greet(); // Output: Hello, my name is Kirajan vi. Objects Inside Objects Objects can contain other objects, allowing you to create complex data structures. Example:\nconst a = { details: { name: \u0026#34;Nirajan\u0026#34;, age: 20 } }; console.log(a.details.name); // Output: Nirajan vii. Spread Operator (\u0026hellip;) The spread operator lets you copy, merge, or combine objects efficiently.\nCopying Properties: const original = { name: \u0026#34;Kirajan\u0026#34;, class: \u0026#34;Bachelor\u0026#34; }; const copy = { ...original }; console.log(copy); // Output: { name: \u0026#34;Kirajan\u0026#34;, class: \u0026#34;Bachelor\u0026#34; } Merging Objects: const info1 = { name: \u0026#34;Kirajan\u0026#34;, class: \u0026#34;Bachelor\u0026#34; }; const info2 = { age: 21, is_topper: true }; const combined = { ...info1, ...info2 }; console.log(combined); // Output: { name: \u0026#34;Kirajan\u0026#34;, class: \u0026#34;Bachelor\u0026#34;, age: 21, is_topper: true } viii. Object Destructuring Destructuring allows you to extract properties from an object and assign them to variables. Example:\nconst lol = { name: \u0026#34;Nirajan\u0026#34;, class: 12, rollno: \u0026#34;11\u0026#34; }; const { name, rollno } = lol; console.log(name); // Output: Nirajan console.log(rollno); // Output: 11 Also, Renaming in Destructuring: const lol = { name: \u0026#34;Nirajan\u0026#34;, class: 12, rollno: \u0026#34;11\u0026#34; }; const { name: studentName, rollno: studentRollNo } = lol; console.log(studentName); // Output: Nirajan console.log(studentRollNo); // Output: 11 ix. Object Methods Objects can have methods—functions that are properties of the object. These methods can perform actions using the object’s data. Example:\nconst calculator = { add: function(a, b) { return a + b; }, subtract: function(a, b) { return a - b; } }; console.log(calculator.add(5, 3)); // Output: 8 console.log(calculator.subtract(5, 3)); // Output: 2 11. JavaScript Functions Function Definitions: Function Expression: const add1 = function(a, b) { return a + b; }; Creates a function and assigns it to a variable. You call the function using the variable name. Arrow Function: const add2 = (a, b) =\u0026gt; { return a + b; }; Provides a shorter syntax and does not have its own this context. Function Declaration: function add3(a, b) { return a + b; } Defines a function with a name. It is hoisted, so it can be called before its declaration. Comparison: add3 has its own this context, while add1 and add2 do not. Using the Spread Operator: function add(...data) { let sum = 0; for (let i = 0; i \u0026lt; data.length; i++) { sum += data[i]; } return sum; } console.log(add(1, 2, 3)); // Output: 6 The ...data syntax lets the function accept any number of arguments as an array.\nImmediately Invoked Function Expression (IIFE): ( function add(a, b) { console.log(a + b); } )(2, 3); // Output: 5 An IIFE is a function that runs immediately after its definition, creating a local scope to avoid affecting the global scope.\n12. Control Flow in JavaScript Conditional Statements: if-else Statement: Executes code blocks based on a condition. let a = 2; if (a === 1) { console.log(1); } else if (a === 2) { console.log(2); } else { console.log(\u0026#34;None\u0026#34;); } Truthy and Falsy Values: Falsy Values: Values that evaluate to false in a boolean context. console.log(Boolean(false)); // false console.log(Boolean(0)); // false console.log(Boolean(-0)); // false console.log(Boolean(0n)); // false console.log(Boolean(\u0026#34;\u0026#34;)); // false console.log(Boolean(null)); // false console.log(Boolean(undefined)); // false console.log(Boolean(NaN)); // false Truthy Values: Any value that is not falsy. console.log(Boolean(true)); // true console.log(Boolean(1)); // true console.log(Boolean(-1)); // true console.log(Boolean(\u0026#34;hello\u0026#34;)); // true console.log(Boolean(\u0026#34; \u0026#34;)); // true console.log(Boolean({})); // true console.log(Boolean([])); // true console.log(Boolean(function() {})); // true console.log(Boolean(Symbol())); // true console.log(Boolean(1n)); // true Nullish Coalescing Operator (??): Provides a default value when dealing with null or undefined. let val1 = null; let val2 = val1 ?? 10; console.log(val2); // Output: 10 Ternary Operator (?:): A shorthand for the if-else statement. let c = 10; let b = 10; let largest = (c \u0026gt; b) ? c : b; console.log(largest); // Output: 10 13. Loops in JavaScript For Loop // Syntax: for(initialization; condition; increment/decrement) { ... } for (let i = 0; i \u0026lt; 10; i++) { console.log(i); } While Loop // Syntax: while(condition) { ... } let i = 0; while (i \u0026lt; 10) { console.log(i); i++; } Do-While Loop // Syntax: do { ... } while(condition); let i = 0; do { console.log(i); i++; } while (i \u0026lt; 10); For-Of Loop Usage: Iterates over arrays and strings const array = [1, 2, 3]; for (const x of array) { console.log(x); } For-In Loop Usage: Iterates over the properties of an object, indices of an array, or characters of a string const obj = { \u0026#34;name\u0026#34;: \u0026#34;nirajan\u0026#34;, \u0026#34;lol\u0026#34;: \u0026#34;lol\u0026#34; }; const arr = [\u0026#34;nirajan\u0026#34;, \u0026#34;lol\u0026#34;]; const str = \u0026#34;mynameisnirajan\u0026#34;; for (const key in obj) { console.log(key); // Prints the keys of the object } for (const index in arr) { console.log(arr[index]); // Prints the values of the array } for (const index in str) { console.log(str[index]); // Prints the characters of the string } For-Each Loop Usage: Iterates over array elements const array = [1, 2, 3]; array.forEach((data) =\u0026gt; { console.log(data); }); Break and Continue Statements break: Exits the loop continue: Skips the current iteration and continues with the next iteration 14. Map, Filter, and Reduce in JavaScript i. filter() Purpose: Creates a new array with elements that pass a test. Example: To get all odd numbers from an array: const a = [1, 2, 3, 4, 5, 6]; const filtered = a.filter(num =\u0026gt; num % 2); // [1, 3, 5] ii. map() Method Purpose: map() creates a new array populated with the results of calling a provided function on every element in the calling array. It’s used to transform each element in the array. Example: Create an array of squares from an existing array. const a = [1, 2, 3, 4, 5, 6]; const squares = a.map((num) =\u0026gt; num * num); console.log(squares); // Output: [1, 4, 9, 16, 25, 36] Here, the function num * num is applied to each element, resulting in a new array of squared numbers. iii. reduce() Method Purpose: reduce() executes a reducer function on each element of the array, resulting in a single output value. It’s used to accumulate or combine values from the array into a single result. Example: Sum up all the numbers in the array. const a = [1, 2, 3, 4, 5, 6]; const sum = a.reduce((accumulator, currentValue) =\u0026gt; accumulator + currentValue, 0); console.log(sum); // Output: 21 Here, accumulator starts at 0 and currentValue iterates over each element, summing them up. iv. Method Chaining Purpose: You can chain filter(), map(), and other array methods together to perform multiple operations in a single, readable statement. Example: Filter out odd numbers and then square them. const a = [1, 2, 3, 4, 5, 6]; const result = a.filter((num) =\u0026gt; num % 2) .map((num) =\u0026gt; num * num); console.log(result); // Output: [1, 9, 25] Here, filter() first selects the odd numbers, and then map() squares those numbers, producing a new array with the squared values of the odd numbers. Summary filter(): Selects elements that meet a specific condition. map(): Transforms elements based on a function. reduce(): Reduces the array to a single value based on a function. Method Chaining: Combines multiple array operations in a concise and readable manner. These methods are powerful tools for processing and transforming arrays in JavaScript. 15. Importing and Exporting in JavaScript Default Export Only one default export is allowed per module. Use for the primary function, class, or object in a module. // utils.js export default function primaryFunction() { console.log(\u0026#34;This is the primary function\u0026#34;); } // main.js import primaryFunction from \u0026#39;./utils.js\u0026#39;; primaryFunction(); // Output: This is the primary function Named Export Allows multiple exports per module. Use to export multiple functions, variables, or objects. // utils.js function function1() { console.log(\u0026#34;This is function1\u0026#34;); } function function2() { console.log(\u0026#34;This is function2\u0026#34;); } export { function1, function2 }; // main.js import { function1, function2 } from \u0026#39;./utils.js\u0026#39;; function1(); // Output: This is function1 function2(); // Output: This is function2 Summary Default Export: One per module, no curly braces during import. Named Export: Multiple per module, use curly braces during import. 16. Error Handling Try-catch blocks are used to handle errors gracefully.\ntry { // Code that might throw an error let result = nonExistentFunction(); } catch (error) { // Code to handle the error console.log(\u0026#39;An error occurred:\u0026#39;, error.message); } finally { // Code that always executes console.log(\u0026#39;This always executes\u0026#39;); } // Output: // \u0026#34;An error occurred: nonExistentFunction is not defined\u0026#34; // \u0026#34;This always executes\u0026#34; 16.1. Custom Error Throwing You can throw custom errors using the throw statement.\nfunction divide(a, b) { if (b === 0) { throw new Error(\u0026#39;Division by zero is not allowed\u0026#39;); } return a / b; } try { console.log(divide(4, 2)); console.log(divide(4, 0)); } catch (error) { console.log(\u0026#39;Error:\u0026#39;, error.message); } // Output: // 2 // \u0026#34;Error: Division by zero is not allowed\u0026#34; 17. Timers setTimeout Schedules a function to be executed after a specified delay (in milliseconds).\nconst timeoutId = setTimeout(() =\u0026gt; { console.log(\u0026#39;Executed after 1 second\u0026#39;); }, 1000); setInterval Repeatedly executes a function at specified intervals (in milliseconds).\nconst intervalId = setInterval((a, b) =\u0026gt; { console.log(a); // Output: hi console.log(b); // Output: oi }, 20, \u0026#34;hi\u0026#34;, \u0026#34;oi\u0026#34;); clearInterval Stops a function from being executed repeatedly by clearing the interval.\nclearInterval(intervalId); clearTimeout Cancels a timeout previously established by setTimeout.\nclearTimeout(timeoutId); 18. Local Storage Local storage is a way to store data in the browser that persists even after the browser is closed.\nStoring Data localStorage.setItem(\u0026#39;name\u0026#39;, \u0026#39;Nirajan\u0026#39;); Retrieving Data const name = localStorage.getItem(\u0026#39;name\u0026#39;); console.log(name); // Output: Nirajan 19. JSON JSON (JavaScript Object Notation) is a lightweight data interchange format that is easy for humans to read and write and easy for machines to parse and generate.\nConverting Objects to JSON const person = { name: \u0026#39;Nirajan\u0026#39;, age: 20 }; const json = JSON.stringify(person); console.log(json); // Output: {\u0026#34;name\u0026#34;:\u0026#34;Nirajan\u0026#34;,\u0026#34;age\u0026#34;:20} Converting JSON to Objects const json = \u0026#39;{\u0026#34;name\u0026#34;:\u0026#34;Nirajan\u0026#34;,\u0026#34;age\u0026#34;:20}\u0026#39;; const person = JSON.parse(json); console.log(person.name); // Output: Nirajan 20. Fetch API Fetch is used to make HTTP requests and returns a promise that resolves to the response of the request.\nBasic Usage fetch(\u0026#39;https://api.example.com/data\u0026#39;) .then(response =\u0026gt; response.json()) .then(data =\u0026gt; console.log(data)) .catch(error =\u0026gt; console.error(\u0026#39;Error:\u0026#39;, error)); ","permalink":"http://localhost:1313/posts/pages/js/javascript/","summary":"A complete reference guide for JavaScript including data types, functions, DOM manipulation, and modern ES6+ features","title":"JavaScript Reference Guide"},{"content":" Linux Commands and Directories Guide Important Directories Default Web Server Root Directory\nLocation: /var/www/html\nThis is the standard location for serving web content on Apache.\nDownloads Folder\nLocation: /home/username/Downloads\nThis is where files downloaded from the internet are usually saved by default.\nDocuments Folder\nLocation: /home/username/Documents\nA common directory for storing personal documents and files.\nDesktop Folder\nLocation: /home/username/Desktop\nThis is the location for files and shortcuts displayed on your desktop screen.\nCommon Commands cd Change the current directory to another one.\nUsage: cd [directory]\nExample: cd /var/www/html changes to the web server root directory.\nls List files and directories in the current location or specified path.\nUsage: ls [options] [path]\nExample: ls -l lists files in a detailed format.\npwd Print the path of the current working directory.\nUsage: pwd\nThis command shows where you are in the filesystem.\nsudo su Switch to the superuser (root) account, allowing you to perform administrative tasks.\nUsage: sudo su\nAfter entering your password, you\u0026rsquo;ll have root access.\nsudo Execute a command with elevated privileges.\nUsage: sudo [command]\nExample: sudo apt update runs the update command as an administrator.\nmkdir Create a new directory.\nUsage: mkdir [directory name]\nExample: mkdir new_folder creates a directory named \u0026ldquo;new_folder\u0026rdquo;.\ndir List files and directories, similar to ls.\nUsage: dir [options] [path]\nThis command can be used interchangeably with ls.\nmv Move or rename files and directories.\nUsage: mv [source] [destination]\nExample: mv /home/username/Downloads/file.txt /home/username/Documents/ moves the file to a different directory.\ncp Copy files or directories.\nUsage: cp [source] [destination]\nExample: cp /home/username/Downloads/file.txt /home/username/Documents/ copies the file.\nrm Remove files or directories.\nUsage: rm [options] [file/directory]\nExample: To remove a directory and its contents, use rm -r [directory].\ntouch Create an empty file or update the timestamp of an existing file.\nUsage: touch [filename]\nExample: touch newfile.txt creates an empty file named \u0026ldquo;newfile.txt\u0026rdquo;.\ncat Display the contents of a file in the terminal.\nUsage: cat [filename]\nExample: cat file.txt shows the content of \u0026ldquo;file.txt\u0026rdquo;.\ngedit Open the Gedit text editor to edit files.\nUsage: gedit [filename]\nExample: gedit notes.txt opens \u0026ldquo;notes.txt\u0026rdquo; for editing.\nkill Terminate a process using its process ID (PID).\nUsage: kill [PID]\nExample: kill 1234 stops the process with the ID 1234.\ntop Display real-time information about system processes and resource usage.\nUsage: top\nThis command helps monitor system performance.\napt-get update Update the package lists for upgrades and new package installations.\nUsage: apt-get update\nThis command fetches the latest package information.\napt install path_of_.deb_file Install a .deb file package.\nUsage: apt install ./filename.deb\nExample: apt install ./main.deb installs the specified Debian package.\napt-get upgrade Upgrade all installed packages to their latest versions.\nUsage: apt-get upgrade\nThis command updates your installed software.\napt-get install package Install a specific software package.\nUsage: apt-get install [package]\nExample: apt-get install vim installs the Vim text editor.\nman Display the manual page for a command, providing detailed information.\nUsage: man [command]\nExample: man ls shows the manual for the ls command.\nwhoami Show the currently logged-in user\u0026rsquo;s username.\nUsage: whoami\nThis command is useful for confirming your user identity.\nzip Compress a directory and its contents into a zip file.\nUsage: zip -r [filename.zip] [foldername]\nExample: zip -r archive.zip myfolder creates a zip file of \u0026ldquo;myfolder\u0026rdquo;.\nunzip Extract files from a zip archive.\nUsage: unzip [filename]\nExample: unzip archive.zip extracts files from \u0026ldquo;archive.zip\u0026rdquo;.\napt install apache2 Install the Apache web server.\nUsage: apt install apache2\nThis command sets up Apache on your system.\nservice apache2 start Start the Apache web server.\nUsage: service apache2 start\nUse this to begin serving web content.\nservice apache2 restart Restart the Apache web server.\nUsage: service apache2 restart\nThis is useful for applying configuration changes.\nservice apache2 stop Stop the Apache web server.\nUsage: service apache2 stop\nUse this command to halt the server.\napt install redis Install the Redis database server.\nUsage: apt install redis\nThis sets up Redis for use.\nservice redis start Start the Redis server.\nUsage: service redis start\nThis command activates the Redis service.\nservice redis restart Restart the Redis server.\nUsage: service redis restart\nUse this to refresh the Redis service.\nservice redis stop Stop the Redis server.\nUsage: service redis stop\nThis halts the Redis service.\napt install mysql-server Install the MySQL server.\nUsage: apt install mysql-server\nThis command installs the MySQL database management system.\nchmod Change file or directory permissions.\nUsage: chmod [permissions] [file/folder]\nExample: chmod +rwx file.txt grants read, write, and execute permissions.\nTo remove permissions, use chmod -r file.txt.\nImportant Notes Folder Names with Spaces:\nIf a folder name contains spaces, enclose it in double quotes.\nmkdir \u0026quot;New Folder\u0026quot; creates a single folder named \u0026ldquo;New Folder\u0026rdquo;. mkdir New Folder creates two separate folders named \u0026ldquo;New\u0026rdquo; and \u0026ldquo;Folder\u0026rdquo;. Using Wildcards for Operations:\nTo perform operations on:\nAll files/folders: use *. Files with a specific extension (e.g., .exe): use *.exe. Files/folders starting with \u0026ldquo;hello\u0026rdquo;: use hello*. Use Relative Paths:\nPrefer using relative paths whenever possible to simplify navigation.\nExample: mv /home/username/Downloads/index.html /var/www/html/index.html moves a file to the web server directory. ","permalink":"http://localhost:1313/posts/pages/linux/linux_cheatsheet/","summary":"A practical guide to navigating and managing files in Linux.","title":"Linux Commands and Directories Guide"},{"content":"Learning Journey Topics I Have Learned So Far Docker Linux Celery Django Channels Git Celery Python Django JavaScript React Basics HTML CSS Tailwind Css What I Plan to Learn In third Semester Django Rest Framework (DRF) Django ORM Deep Dive React Advanced Git Advanced Docker Advanced WebSOcket Deep Dive in Django Celery Deep Dive Plan to learn in future WebSocket Deep Dive in Django Celery Deep Dive Redis for Cache Kafka Basics + Advanced Docker Advanced + Kubernetes Message Brokers Django Rest Framework (DRF) Django ORM Deep Dive React Advanced Git Advanced Django Docs+Advance Like class based views Additional Topics for Future Learning Real-time WebSocket usage in Django. Kafka streaming for handling large data volumes. Implementing Kubernetes for containerized applications. ","permalink":"http://localhost:1313/posts/pages/readinglist/my_reading/","summary":"A detailed overview of my learning journey and future plans.","title":"Learning Journey"},{"content":"46.Sending request to the server In react we can send request to the server using fetch api.\nExample:\nimport React, { useState } from \u0026#39;react\u0026#39;; const App = () =\u0026gt; { const [data, setData] = useState([]); const fetchData = async () =\u0026gt; { const response = await fetch(\u0026#39;https://jsonplaceholder.typicode.com/posts\u0026#39;); const data = await response.json(); setData(data); } return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={fetchData}\u0026gt;Fetch Data\u0026lt;/button\u0026gt; \u0026lt;ul\u0026gt; {data.map((item) =\u0026gt; ( \u0026lt;li key={item.id}\u0026gt;{item.title}\u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ) ","permalink":"http://localhost:1313/posts/pages/react/react11/","summary":"\u003ch2 id=\"46sending-request-to-the-server\"\u003e46.Sending request to the server\u003c/h2\u003e\n\u003cp\u003eIn react we can send request to the server using fetch api.\u003c/p\u003e\n\u003cp\u003eExample:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-jsx\" data-lang=\"jsx\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eimport\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eReact\u003c/span\u003e, { \u003cspan style=\"color:#a6e22e\"\u003euseState\u003c/span\u003e } \u003cspan style=\"color:#a6e22e\"\u003efrom\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;react\u0026#39;\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eApp\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e () =\u0026gt; {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e [\u003cspan style=\"color:#a6e22e\"\u003edata\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003esetData\u003c/span\u003e] \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003euseState\u003c/span\u003e([]);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003efetchData\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003easync\u003c/span\u003e () =\u0026gt; {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eresponse\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eawait\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003efetch\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;https://jsonplaceholder.typicode.com/posts\u0026#39;\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003edata\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eawait\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eresponse\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ejson\u003c/span\u003e();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003esetData\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003edata\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e (\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u0026lt;\u003cspan style=\"color:#f92672\"\u003ediv\u003c/span\u003e\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u0026lt;\u003cspan style=\"color:#f92672\"\u003ebutton\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eonClick\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e{\u003cspan style=\"color:#a6e22e\"\u003efetchData\u003c/span\u003e}\u0026gt;\u003cspan style=\"color:#a6e22e\"\u003eFetch\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eData\u003c/span\u003e\u0026lt;/\u003cspan style=\"color:#f92672\"\u003ebutton\u003c/span\u003e\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u0026lt;\u003cspan style=\"color:#f92672\"\u003eul\u003c/span\u003e\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                {\u003cspan style=\"color:#a6e22e\"\u003edata\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003emap\u003c/span\u003e((\u003cspan style=\"color:#a6e22e\"\u003eitem\u003c/span\u003e) =\u0026gt; (\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    \u0026lt;\u003cspan style=\"color:#f92672\"\u003eli\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ekey\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e{\u003cspan style=\"color:#a6e22e\"\u003eitem\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eid\u003c/span\u003e}\u0026gt;{\u003cspan style=\"color:#a6e22e\"\u003eitem\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003etitle\u003c/span\u003e}\u0026lt;/\u003cspan style=\"color:#f92672\"\u003eli\u003c/span\u003e\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                ))}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u0026lt;/\u003cspan style=\"color:#f92672\"\u003eul\u003c/span\u003e\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u0026lt;/\u003cspan style=\"color:#f92672\"\u003ediv\u003c/span\u003e\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    )\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":""},{"content":"44. Optimizing Performance 44.1. memo memo is a higher-order function in React that optimizes functional components by preventing unnecessary re-renders. It returns a new component that behaves the same as the original one but only re-renders if its props change or internal state changes not every time the parent component re-renders.\nWhy Use memo? When a parent component re-renders, all its child components also re-render by default—even if their props remain unchanged. This behavior can lead to performance bottlenecks. Using memo, we can avoid these unnecessary re-renders for child components.\nExample:\nimport { memo } from \u0026#39;react\u0026#39;; const MyComponent = memo((props) =\u0026gt; { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;{props.title}\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ); }); export default MyComponent; In the above example, the MyComponent functional component is wrapped with the memo function. This ensures that the component will only re-render if its props have changed or if its satate has been change not every time the parent component re-renders.\nUse Case:\nBefore using memo: In this example, the Custom component re-renders unnecessarily whenever the parent component re-renders, even if its props haven\u0026rsquo;t changed or internal state hasn\u0026rsquo;t changed. Custom.js import { useState } from \u0026#39;react\u0026#39;; const Custom = ({ title }) =\u0026gt; { const [count, setCount] = useState(0); return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;{title}\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;{count}\u0026lt;/p\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;Increment\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); }; export default Custom; App.js\nimport { useState } from \u0026#39;react\u0026#39;; import Custom from \u0026#39;./Custom\u0026#39;; function App() { const [count, setCount] = useState(0); return ( \u0026lt;div\u0026gt; \u0026lt;Custom title=\u0026#34;Counter\u0026#34; /\u0026gt; \u0026lt;p\u0026gt;{count}\u0026lt;/p\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;Increment Parent Count\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; Problem: The Custom component re-renders whenever the count state in the App component changes, even though the title prop remains the same. This can cause unnecessary rendering and reduce performance.i.e child component re-renders even if the props are not changed when the parent component re-renders.\nAfter using memo: Using memo, we can optimize the Custom component to only re-render when its props change. Custom.jsx import { useState, memo } from \u0026#39;react\u0026#39;; const Custom = memo(({ title }) =\u0026gt; { const [count, setCount] = useState(0); return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;{title}\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;{count}\u0026lt;/p\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;Increment\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); }); export default Custom; App.js\nimport { useState } from \u0026#39;react\u0026#39;; import Custom from \u0026#39;./Custom\u0026#39;; function App() { const [count, setCount] = useState(0); return ( \u0026lt;div\u0026gt; \u0026lt;Custom title=\u0026#34;Counter\u0026#34; /\u0026gt; \u0026lt;p\u0026gt;{count}\u0026lt;/p\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;Increment Parent Count\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; After using memo the Custom component will only re-render when its props change or state change i.e when the title prop changes or the count state of the Custom component changes . It will not re-render when the count state of the App component changes, which optimizes performance in this scenario as that change does not affect the Custom component.\n44.2. useCallback In every rerender of a component, the functions defined inside the component are recreated. This can lead to performance issues, especially when passing functions as props to child components. useCallback is a hook in React that memoizes functions to prevent unnecessary re-creations.\nSyntax:\nuseCallback(fn, dependencies) fn: The function value that you want to cache. It can take any arguments and return any values. React will return (not call!) your function back to you during the initial render. On next renders, React will give you the same function again if the dependencies have not changed since the last render. Otherwise, it will give you the function that you have passed during the current render, and store it in case it can be reused later. React will not call your function. The function is returned to you so you can decide when and whether to call it. dependencies: An array of values that, when changed, will cause the function to be re-created. If the dependencies array is empty, the function will only be created once, and will not be re-created on subsequent renders. Whats the use of dependencies array in useCallback? just because dependency array the function is recreated with the new values of the dependencies.\nBefore using useCallback:\nimport { useState,memo } from \u0026#39;react\u0026#39;; const Child = memo(({ handleClick }) =\u0026gt; { return ( \u0026lt;button onClick={handleClick}\u0026gt;Click Me\u0026lt;/button\u0026gt; ); }); const Parent = () =\u0026gt; { const [count, setCount] = useState(0); const handleClick = () =\u0026gt; { setCount(count + 1); }; return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;{count}\u0026lt;/p\u0026gt; \u0026lt;Child handleClick={handleClick} /\u0026gt; \u0026lt;/div\u0026gt; ); }; In the above example, the handleClick function is re-created on every re-render of the Parent component. As a result, the reference to the handleClick function passed as a prop to the Child component changes on every re-render of the Parent component. This causes the Child component to re-render unnecessarily, even though the handleClick function remains logically the same After using useCallback:\nimport { useState, useCallback, memo } from \u0026#39;react\u0026#39;; const Child = memo(({ handleClick }) =\u0026gt; { return ( \u0026lt;button onClick={handleClick}\u0026gt;Click Me\u0026lt;/button\u0026gt; ); }); const Parent = () =\u0026gt; { const [count, setCount] = useState(0); const handleClick = useCallback(() =\u0026gt; { setCount(count + 1); }, [count]); return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;{count}\u0026lt;/p\u0026gt; \u0026lt;Child handleClick={handleClick} /\u0026gt; \u0026lt;/div\u0026gt; ); }; By using useCallback, the handleClick function is memoized and will only be re-created when the count state changes. The reference to the handleClick function remains the same across re-renders of the Parent component unless the dependencies specified in the dependency array (in this case, [count]) change. This ensures that the Child component only re-renders when the count state changes, and not when the handleClick function reference changes, thus improving performance.\n44.3. useMemo useMemo is a hook in React that memoizes the result of a function. It is similar to useCallback, but instead of memoizing a function, it memoizes the result of a function.\nSyntax:\nconst cachedValue = useMemo(calculateValue, dependencies) calculateValue: The function calculating the value that you want to cache. It should be pure, should take no arguments, and should return a value of any type. React will call your function during the initial render. On next renders, React will return the same value again if the dependencies have not changed since the last render. Otherwise, it will call calculateValue, return its result, and store it so it can be reused later. dependencies: An array of values that, when changed, will cause the function to be re-executed.\nreturn On the initial render, useMemo returns the result of calling calculateValue with no arguments.During next renders, it will either return an already stored value from the last render (if the dependencies haven’t changed), or call calculateValue again, and return the result that calculateValue has returned.\nBefore using useMemo:\nimport { useState, memo } from \u0026#39;react\u0026#39;; const fibonacci = (n) =\u0026gt; { if (n \u0026lt;= 1) { return n; } return fibonacci(n - 1) + fibonacci(n - 2); }; const Fib = ()=\u0026gt;{ const [count, setCount] = useState(1); const result = fibonacci(100000000000); return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;{result} and count is {count}\u0026lt;/p\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;Increase Count\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } In the above example, the fibonacci function is called on every re-render of the Fib component. This can lead to performance issues, especially when the function is computationally expensive. In this case, the fibonacci function is called with a large number, which can cause the component to freeze or crash.\nAfter using useMemo:\nimport { useState, useMemo } from \u0026#39;react\u0026#39;; const fibonacci = (n) =\u0026gt; { if (n \u0026lt;= 1) { return n; } return fibonacci(n - 1) + fibonacci(n - 2); }; const Fib = ()=\u0026gt;{ const [count, setCount] = useState(1); const result = useMemo(() =\u0026gt; fibonacci(100000000000), []); return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;{result} and count is {count}\u0026lt;/p\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;Increase Count\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } By using useMemo, the result of the fibonacci function is memoized and will only be re-calculated when the dependencies specified in the dependency array change. In this case, the fibonacci function is only called once during the initial render of the Fib component, and the result is stored and reused on subsequent renders. This optimizes performance by preventing unnecessary re-calculation of the fibonacci function on every re-render of the component.\n45.Key conside a scenarion where your base component state variable need to be initialized with the value of the props passed to the component. since the state variable is initialized with the props value, the state variable will not be updated when the props value changes as it is initialized only. to handle we can either use useEffect or we can use key prop.\nUsing useEffect:\nimport { useEffect, useState } from \u0026#39;react\u0026#39;; const Parent = () =\u0026gt; { const [value, setValue] = useState(0); return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={() =\u0026gt; setValue(value + 1)}\u0026gt;Increment\u0026lt;/button\u0026gt; \u0026lt;Child value={value} /\u0026gt; \u0026lt;/div\u0026gt; ); }; const Child = ({ value }) =\u0026gt; { const [stateValue, setStateValue] = useState(value); useEffect(() =\u0026gt; { setStateValue(value); }, [value]); return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;State Value: {stateValue}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Props Value: {value}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); }; stateValue is initialized with the value prop and const [stateValue, setStateValue] = useState(value); runs only once during initial render so useEffect is used to update the stateValue when the value prop changes.\nUsing key prop:\nimport { useState } from \u0026#39;react\u0026#39;; const Parent = () =\u0026gt; { const [value, setValue] = useState(0); return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={() =\u0026gt; setValue(value + 1)}\u0026gt;Increment\u0026lt;/button\u0026gt; \u0026lt;Child key={value} value={value} /\u0026gt; \u0026lt;/div\u0026gt; ); }; const Child = ({ value }) =\u0026gt; { const [stateValue, setStateValue] = useState(value); return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;State Value: {stateValue}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Props Value: {value}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); }; IN the above example,When a key changes between renders, React will create a new instance of the component. By using the key prop with the value prop, we ensure that a new instance of the Child component is created whenever the value prop changes. This allows the stateValue to be initialized with the new value prop on every render, without the need for useEffect.\nNote:The useState() hook us run only one time during the initial render of the component. If the state variable is initialized with a prop value, it will not be updated when the prop value changes. To handle this scenario, we can use the useEffect() hook to update the state variable when the prop value changes. Alternatively, we can use the key prop to create a new instance of the component whenever the prop value changes, allowing the state variable to be initialized with the new prop value on every render. Similar goes for useReducer() and useRef() hooks as well.\n","permalink":"http://localhost:1313/posts/pages/react/react10/","summary":"Learn how to optimize React applications using memo for component memoization, useCallback for function memoization, and useMemo for value memoization.","title":"React : 10"},{"content":"40. useEffect useEffect is a React hook that lets you perform side effects in functional components. Common use cases include:\nEstablishing a database connection when the DOM content loads. Updating the page title when the content changes. Note: The useEffect hook runs after the component has rendered.\n41. What to Put in useEffect Use useEffect for:\nNetwork requests Operations that take time to complete (e.g., fetching data, setting timers, etc.) 42. useEffect Syntax 42.1. Importing useEffect import React, { useEffect } from \u0026#39;react\u0026#39;; 42.2. useEffect Syntax useEffect(() =\u0026gt; { // code here return () =\u0026gt; { // cleanup code here }; }, [dependencies]); The first argument is a function containing the code to execute. The second argument is an array of dependencies. If any dependency changes, the function runs again. The return statement is optional and is used for cleanup tasks, such as removing event listeners or canceling subscriptions. This cleanup function is executed: Just before the the useEffect function runs again cause due to dependency change, with variables from the previous render. After the component unmounts (i.e., when removed from the DOM). Note: When your component is added to the DOM, React runs the setup function. After each re-render with changed dependencies, React first executes the cleanup function (if provided) with old values, then runs the setup function with new values.\nExample: useEffect(() =\u0026gt; { const id = setTimeout(() =\u0026gt; { console.log(count); }, 1000); return () =\u0026gt; { clearTimeout(id); }; }, [count]); In this example, the useEffect hook runs whenever the count variable changes. It sets a timeout to log the count value after 1 second, and the cleanup function clears the previous timeout before the next execution. Cleanup Function:\nUsed for tasks like removing event listeners or clearing timeouts. Ensures stale operations are cleared before new ones are executed. Executes when dependencies change or when the component unmounts. 43. Variations of useEffect 43.1. useEffect Without Dependencies Array useEffect(() =\u0026gt; { // code here }); The useEffect function runs after every re-render. 43.2. useEffect With Empty Dependencies Array useEffect(() =\u0026gt; { // code here }, []); The useEffect function runs only once after the initial render, making it ideal for tasks like loading local storage data. 43.3. useEffect With Multiple Dependencies useEffect(() =\u0026gt; { // code here }, [count, name]); The useEffect function runs when either count or name changes. Note: In all of the variation, useEffect always runs after the first render no matter what is passed in the dependencies array.\nExample: Loading Local Storage Data Correct Usage:\nimport React, { useState, useEffect } from \u0026#39;react\u0026#39;; const App = () =\u0026gt; { const [data, setData] = useState([]); useEffect(() =\u0026gt; { const data = localStorage.getItem(\u0026#39;data\u0026#39;); if (data) { setData(JSON.parse(data)); } }, []); return ( \u0026lt;div\u0026gt; {data.map((item, index) =\u0026gt; ( \u0026lt;p key={index}\u0026gt;{item}\u0026lt;/p\u0026gt; ))} \u0026lt;/div\u0026gt; ); }; Incorrect Usage:\nimport React, { useState } from \u0026#39;react\u0026#39;; const App = () =\u0026gt; { const [data, setData] = useState([]); const loadData = () =\u0026gt; { const data = localStorage.getItem(\u0026#39;data\u0026#39;); if (data) { setData(JSON.parse(data)); } }; loadData(); return ( \u0026lt;div\u0026gt; {data.map((item, index) =\u0026gt; ( \u0026lt;p key={index}\u0026gt;{item}\u0026lt;/p\u0026gt; ))} \u0026lt;/div\u0026gt; ); }; Problem: Calling loadData directly causes an infinite loop because it triggers a re-render, which calls loadData again. Solution: Use useEffect with an empty dependency array to ensure the function runs only once after the initial render. ","permalink":"http://localhost:1313/posts/pages/react/react9/","summary":"Learn how to use the useEffect hook in React for performing side effects in functional components.","title":"React : 9"},{"content":"38. Understanding the Concept of Prop Drilling Prop drilling refers to the process of passing data from a parent component to a deeply nested child component through all the intermediate components, even if those intermediate components don’t need the data themselves. Let’s break this down with an example.\nComponent Tree Imagine the following component hierarchy: Now, suppose we want to transfer some data from the Product component to the Cart component. Since Product and Cart are in separate branches of the component tree, they don’t have a direct connection.\nHow Prop Drilling Works To make this work, we need to store the shared state in a common ancestor, which is the App component in this case. Then, we have to pass the state down through all the intermediate components, even if those components don’t actually use the data.\nHere’s a visual representation of this:\nData flows from Product → Shop → App (common ancestor). The data then flows from App → Header → CardModel → Cart. This creates a lot of unnecessary overhead because the intermediate components (Shop, Header, and CardModel) don’t need the data but still have to handle it.\nProp drilling can quickly become cumbersome in large applications with deeply nested components. To solve this, we can use state management tools like Redux, Context API, or React Query, which allow us to manage and share state more effectively without passing it through every component.\n39. Introduction to React Context API Context API is a feature in React that allows you to share data between components without having to pass props down manually at every level. It provides a way to pass data through the component tree without having to pass props down manually at every level as shown in the image below.\nHow to use context API Create a context using the createContext function. import { createContext } from \u0026#39;react\u0026#39;; const CartContext = createContext(); export default CartContext; Wrap the parent component with the Provider component. Which Component to wrap? Wrap to the common ancestor of the components that need the context data. In the example below, we wrap the App component with the Provider component. For Example:\nimport CartContext from \u0026#39;./store/CartContext\u0026#39;; function App() { return ( \u0026lt;CartContext.Provider value={data}\u0026gt; \u0026lt;Header /\u0026gt; \u0026lt;Shop /\u0026gt; \u0026lt;/CartContext.Provider\u0026gt; ); } Explaination:Since we want to share the product Component data with the Cart Component SO in order to do that we wrap the first common ancestor of the Product and Cart Component i.e App Component with the Provider Component and pass the data to the value prop of the Provider Component.\nAccess the context data in the child component using the useContext hook. for example:\nimport { useContext } from \u0026#39;react\u0026#39;; import CartContext from \u0026#39;../store/CartContext\u0026#39;; function Cart() { const cartCtx = useContext(CartContext); return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Cart\u0026lt;/h1\u0026gt; {cartCtx.products.map(product =\u0026gt; ( \u0026lt;p key={product.id}\u0026gt;{product.name}\u0026lt;/p\u0026gt; ))} \u0026lt;/div\u0026gt; ); } What Whappen when the data is updated? When the data is updated in the Provider component, all the child components that are using the context data will be re-rendered automatically. Task: Design a simple application that has a component called App. App has two child components: Header and Shop. Header has one child, CartModel, and Shop has one child, Product. Pass the data from the Product component to the CartModel component using the Context API.\nStructure of the project\nsrc\r|_components\r|_App\r|_App.js\r|_Header\r|_Header.js\r|_CartModel.js\r|_Shop\r|_Shop.js\r|_Product.js\r|_store\r|_CartContext.js CartContext.js\nimport { createContext } from \u0026#39;react\u0026#39;; const CartContext = createContext(); export default CartContext; App.js\nimport CartContext from \u0026#39;../store/CartContext\u0026#39;; import Header from \u0026#39;../Header/Header\u0026#39;; import Shop from \u0026#39;../Shop/Shop\u0026#39;; import { useState } from \u0026#39;react\u0026#39;; function App() { const [cartProducts, setCartProducts] = useState([]); const addProductToCart = (product) =\u0026gt; { setCartProducts((prevProducts) =\u0026gt; [...prevProducts, product]); }; return ( \u0026lt;CartContext.Provider value={ { products: cartProducts, addProduct: addProductToCart } }\u0026gt; \u0026lt;Header /\u0026gt; \u0026lt;Shop /\u0026gt; \u0026lt;/CartContext.Provider\u0026gt; ); } export default App; Header.js\nimport CartModel from \u0026#39;./CartModel\u0026#39;; function Header() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Header\u0026lt;/h1\u0026gt; \u0026lt;CartModel /\u0026gt; \u0026lt;/div\u0026gt; ); } export default Header; CartModel.js\nimport { useContext } from \u0026#39;react\u0026#39;; import CartContext from \u0026#39;../../store/CartContext\u0026#39;; function CartModel() { const cartCtx = useContext(CartContext); return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;CartModel\u0026lt;/h1\u0026gt; {cartCtx.products.map(product =\u0026gt; ( \u0026lt;p key={product.id}\u0026gt;{product.name}\u0026lt;/p\u0026gt; ))} \u0026lt;/div\u0026gt; ); } export default CartModel; Shop.js\nimport Product from \u0026#39;./Product\u0026#39;; function Shop() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Shop\u0026lt;/h1\u0026gt; \u0026lt;Product /\u0026gt; \u0026lt;/div\u0026gt; ); } export default Shop; Product.js\nimport { useContext } from \u0026#39;react\u0026#39;; import CartContext from \u0026#39;../../store/CartContext\u0026#39;; function Product() { const cartCtx = useContext(CartContext); const product = { id: 1, name: \u0026#39;Laptop\u0026#39; }; return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Product\u0026lt;/h1\u0026gt; \u0026lt;button onClick={() =\u0026gt; cartCtx.addProduct(product)}\u0026gt;Add to Cart\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } export default Product; Outsoursing the Context Provider Since all the logic related to the context is in the App Component so we can outsource the context provider and its logic to a separate component in order to make the App Component more clean and readable.\nCartContext.js\nimport { createContext, useState } from \u0026#39;react\u0026#39;; const CartContext = createContext(); export const CartContextProvider = (props) =\u0026gt; { const [cartProducts, setCartProducts] = useState([]); const addProductToCart = (product) =\u0026gt; { setCartProducts((prevProducts) =\u0026gt; [...prevProducts, product]); }; const context = { products: cartProducts, addProduct: addProductToCart }; return ( \u0026lt;CartContext.Provider value={context}\u0026gt; {props.children} \u0026lt;/CartContext.Provider\u0026gt; ); }; App.js\nimport Header from \u0026#39;../Header/Header\u0026#39;; import Shop from \u0026#39;../Shop/Shop\u0026#39;; import { CartContextProvider } from \u0026#39;../store/CartContext\u0026#39;; function App() { return ( \u0026lt;CartContextProvider\u0026gt; \u0026lt;Header /\u0026gt; \u0026lt;Shop /\u0026gt; \u0026lt;/CartContextProvider\u0026gt; ); } export default App; Other Components remain the same.\n39.UseReducer Hook in React USe reducer is a hook that is used for state management in React. It is an alternative to useState. It is usually preferable when you have complex state logic that involves multiple sub-values or when the next state depends on the previous one.\nHow to use useReducer Hook Create a reducer function. A reducer function is a function that takes the current state and an action as arguments and returns a new state based on the action type.action . action:It contains the object that is sent by the dispatch function. For Example:\nconst counterReducer = (state, action) =\u0026gt; { if (action.type === \u0026#39;INCREMENT\u0026#39;) { return { counter: state.counter + 1 }; } if (action.type === \u0026#39;DECREMENT\u0026#39;) { return { counter: state.counter - 1 }; } return state; }; Here, the reducer function takes two arguments: state and action. It checks the action type and returns a new state based on the action type.\nUse the useReducer hook in the component. The useReducer hook takes two arguments: the reducer function and the initial state and returns the current state and a dispatch function as an array which is shown below. For Example: import { useReducer } from \u0026#39;react\u0026#39;; const [counterState, dispatchCounter] = useReducer(counterReducer, { counter: 0 }); Here, counterState is the current state and dispatchCounter is the dispatch function that is used to dispatch an action to the reducer function and { counter: 0 } is the initial state such that the counter is initialized to 0.\nDispatch an action to the reducer function. To dispatch an action to the reducer function, you need to call the dispatch function with an object that contains the action type and any additional data that is required by the reducer function. For Example: dispatchCounter({ type: \u0026#39;INCREMENT\u0026#39; }); To change the state, you need to call the dispatch function with an object that contains the action type.Here, the action type is \u0026lsquo;INCREMENT\u0026rsquo; which increments the counter by 1.\nTask: Design a simple counter application that has a component called Counter. The Counter component has two buttons: Increment and Decrement. Use the useReducer hook to manage the state of the counter.\nStructure of the project\nsrc\r|_components\r|_Counter\r|_Counter.js Counter.js\nimport { useReducer } from \u0026#39;react\u0026#39;; const counterReducer = (state, action) =\u0026gt; { if (action.type === \u0026#39;INCREMENT\u0026#39;) { return { counter: state.counter + 1 }; } if (action.type === \u0026#39;DECREMENT\u0026#39;) { return { counter: state.counter - 1 }; } return state; }; function Counter() { const [counterState, dispatchCounter] = useReducer(counterReducer, { counter: 0 }); const handleIncrement = () =\u0026gt; { dispatchCounter({ type: \u0026#39;INCREMENT\u0026#39; }); }; const handleDecrement = () =\u0026gt; { dispatchCounter({ type: \u0026#39;DECREMENT\u0026#39; }); }; return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Counter\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;{counterState.counter}\u0026lt;/p\u0026gt; \u0026lt;button onClick={handleIncrement}\u0026gt;Increment\u0026lt;/button\u0026gt; \u0026lt;button onClick={handleDecrement}\u0026gt;Decrement\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } If we use useState hook then the code will be like this:\nimport { useState } from \u0026#39;react\u0026#39;; function Counter() { const [counter, setCounter] = useState(0); const handleIncrement = () =\u0026gt; { setCounter(counter=\u0026gt;counter + 1); }; const handleDecrement = () =\u0026gt; { setCounter(counter=\u0026gt;counter - 1); }; return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Counter\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;{counter}\u0026lt;/p\u0026gt; \u0026lt;button onClick={handleIncrement}\u0026gt;Increment\u0026lt;/button\u0026gt; \u0026lt;button onClick={handleDecrement}\u0026gt;Decrement\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } What is the difference between useState and useReducer?\nuseState is a simple and straightforward way to manage state in React. It is suitable for managing simple state logic. useReducer is more powerful and flexible than useState. It is suitable for managing complex state logic that involves multiple sub-values or when the next state depends on the previous one. Looking the example case Scenario: Here using reducer we write all the logic in a single function and then we dispatch the action to the reducer function and then the reducer function returns the new state based on the action type. This makes the code more readable and maintainable.\nbut in the case of useState, we have to write the logic for each state change separately which makes the code more complex and difficult to maintain.\nNote: Always change in state variable will cause the re-rendering of the component.\n","permalink":"http://localhost:1313/posts/pages/react/react8/","summary":"Learn about prop drilling and how to use the Context API in React to manage and share state effectively.","title":"React : 8"},{"content":"1.1 When to use asyncio? Asyncio is a library to write concurrent code using the async/await syntax. It is a single-threaded, single-process design that is ideal for I/O-bound and high-level structured network code. It is not suitable for CPU-bound code, which is better handled by the multiprocessing module.It is used for :\n2.1 Coroutine Think of a coroutine like a regular Python function but with the superpower that it can pause its execution when it encounters an operation that could take a while to complete. When that long-running operation is complete, we can “wake up” our paused coroutine and finish executing any other code in that coroutine. While a paused coroutine is waiting for the operation it paused for to finish, we can run other code. This running of other code while waiting is what gives our application concur rency. We can also run several time-consuming operations concurrently, which can give our applications big performance improvements. To both create and pause a coroutine, we’ll need to learn to use Python’s async and await keywords. The async keyword will let us define a coroutine; the await key word will let us pause our coroutine when we have a long-running operation.\n2.2 Creating a coroutine with async creating a coroutine is straightforward and not much different from creating a nor mal Python function. The only difference is that, instead of using the def keyword, we use async def. The async keyword marks a function as a coroutine instead of a nor mal Python function.\nimport asyncio async def mero_coroutine(): print(\u0026#34;Hello From Asyncio\u0026#34;) The coroutine in the preceding listing does nothing yet other than print “Hello world!” It’s also worth noting that this coroutine does not perform any long-running operations; it just prints our message and returns. This means that, when we put the coroutine on the event loop, it will execute immediately because we don’t have any blocking I/O, and nothing is pausing execution yet. This syntax is simple, but we’re creating something very different from a plain Python function. To illustrate this, let’s create a function that adds one to an integer as well as a coroutine that does the same and compare the results of calling each. We’ll also use the type convenience function to look at the type returned by calling a corou tine as compared to calling our normal function.\ndef add_function(a,b): return a+b async def add_coroutine(a,b): return a+b function=add_function(1,2) coroutine=add_coroutine(1,2) print(type(function)) print(type(coroutine)) When we run this code, we’ll see output like the following\nMethod result is 3 and the type is \u0026lt;class \u0026#39;int\u0026#39;\u0026gt;\rCoroutine result is \u0026lt;coroutine object coroutine_add_one at 0x1071d6040\u0026gt; and the type is \u0026lt;class \u0026#39;coroutine\u0026#39;\u0026gt; Notice how when we call our normal add_one function it executes immediately and returns what we would expect, another integer. However, when we call coroutine_ add_one we don’t get our code in the coroutine executed at all. We get a coroutine object instead. This is an important point, as coroutines aren’t executed when we call them directly. Instead, we create a coroutine object that can be run later. To run a corou tine, we need to explicitly run it on an event loop. So how can we create an event loop and run our coroutine?\nIn versions of Python older than 3.7, we had to create an event loop if one did not already exist. However, the asyncio library has added several functions that abstract the event loop management. There is a convenience function, asyncio.run, we can use to run our coroutine. This is illustrated in the following listing.\nimport asyncio async def add_coroutine(a,b): return a+b res=asyncio.run(add_coroutine(1,2)) print(res) When we run this code, we’ll see output like the following:\n3 We’ve properly put our coroutine on the event loop, and we have executed it! asyncio.run is doing a few important things in this scenario. First, it creates a brand-new event. Once it successfully does so, it takes whichever coroutine we pass into it and runs it until it completes, returning the result. This function will also do some cleanup of anything that might be left running after the main coroutine fin ishes. Once everything has finished, it shuts down and closes the event loop. Possibly the most important thing about asyncio.run is that it is intended to be the main entry point into the asyncio application we have created. It only executes one coroutine, and that coroutine should launch all other aspects of our application. As we progress further, we will use this function as the entry point into nearly all our applications. The coroutine that asyncio.run executes will create and run other coroutines that will allow us to utilize the concurrent nature of asyncio.\n2.3 Pausing execution with the await keyword The example we saw in block 2.2 did not need to be a coroutine, as it executed only non-blocking Python code. The real benefit of asyncio is being able to pause execu tion to let the event loop run other tasks during a long-running operation. To pause execution, we use the await keyword. The await keyword is usually followed by a call to a coroutine (more specifically, an object known as an awaitable, which is not always a coroutine; we’ll learn more about awaitables later in the chapter). Using the await keyword will cause the coroutine following it to be run, unlike calling a coroutine directly, which produces a coroutine object. The await expression will also pause the coroutine where it is contained in until the coroutine we awaited finishes and returns a result. When the coroutine we awaited finishes, we’ll have access to the result it returned, and the containing coroutine will “wake up” to handle the result. We can use the await keyword by putting it in front of a coroutine call. Expanding on our earlier program, we can write a program where we call the add_coroutine function inside of a “main” async function and get the result\nimport asyncio async def add_one(number: int) -\u0026gt; int: return number + 1 async def main() -\u0026gt; None: one_plus_one = await add_one(1) # Pause, and wait for the result of add_one(1). two_plus_one = await add_one(2) # Pause, and wait for the result of add_one(2). print(one_plus_one) print(two_plus_one) asyncio.run(main()) Note: Coroutine will only run when we use await keyword. If we call the coroutine directly it will return a coroutine object.\nIn above code we pause execution twice. We first await the call to add_one(1). Once we have the result, the main function will be “unpaused,” and we will assign the return value from add_one(1) to the variable one_plus_one, which in this case will be two. We then do the same for add_one(2) and then print the results.We can visualize the execution flow of our application, as shown in figure\nAs it stands now, this code does not operate differently from normal, sequential code. We are, in effect, mimicking a normal call stack. Next, let’s look at a simple example of how to run other code by introducing a dummy sleep operation while we’re waiting.\n2.4 Introducing long-running coroutines with sleep Our previous examples did not use any slow operations and were used to help us learn the basic syntax of coroutines. To fully see the benefits and show how we can run mul tiple events simultaneously, we’ll need to introduce some long-running operations. Instead of making web API or database queries right away, which are nondeterministic as to how much time they will take, we’ll simulate long-running operations by specify ing how long we want to wait. We’ll do this with the asyncio.sleep function. We can use asyncio.sleep to make a coroutine “sleep” for a given number of sec onds. This will pause our coroutine for the time we give it, simulating what would hap pen if we had a long-running call to a database or web API. asyncio.sleep is itself a coroutine, so we must use it with the await keyword. If we call it just by itself, we’ll get a coroutine object. Since asyncio.sleep is a coroutine, this means that when a coroutine awaits it, other code will be able to run. Let’s examine a simple example, shown in the following listing, that sleeps for 1 sec ond and then prints a \u0026lsquo;Hello World!\u0026rsquo; message.\nimport asyncio async def hello_world_message(): await asyncio.sleep(1) print(\u0026#34;Hello World\u0026#34;) asyncio.run(hello_world_message()) When we run this application, our program will wait 1 second before printing our \u0026lsquo;Hello World!\u0026rsquo; message. Since hello_world_message is a coroutine and we pause it for 1 second with asyncio.sleep, we now have 1 second where we could be running other code concurrently.\nWe’ll be using sleep a lot in the next few examples, so let’s invest the time to cre ate a reusable coroutine that sleeps for us and prints out some useful information. We’ll call this coroutine delay. This is shown in the following listing\nimport asyncio async def delay(delaysecond): print(f\u0026#39;Sleeping for delay seconds : {delaysecond}\u0026#39;) await asyncio.sleep(delaysecond) print(f\u0026#39;finished sleeping for {delay_seconds} second(s)\u0026#39;) return delay_seconds delay will take in an integer of the duration in seconds that we’d like the function to sleep and will return that integer to the caller once it has finished sleeping. We’ll also print when sleep begins and ends. This will help us see what other code, if any, is run ning concurrently while our coroutines are paused.\nTo make referencing this utility function easier in future code listings, we’ll create a module that we’ll import in the remainder of this book when needed. We’ll also add to this module as we create additional reusable functions. We’ll call this module util, and we’ll put our delay function in a file called delay_functions.py. We’ll also add an init.py file with the following line, so we can nicely import the timer\nfrom util.delay_functions import delay From now on in this book, we’ll use from util import delay whenever we need to use the delay function. Now that we have a reusable delay coroutine, let’s combine it with the earlier coroutine add_one to see if we can get our simple addition to run concur rently while hello_world_message is paused.\nimport asyncio from util.delay_functions import delay async def add_one(number): return number + 1 async def hello_world_message(): await delay(1) print(\u0026#34;Hello World\u0026#34;) async def main() -\u0026gt; None: message = await hello_world_message() #pause until hello_world_message is finished one_plus_one = await add_one(1) #pause until add_one is finished print(one_plus_one) print(message) asyncio.run(main()) When we run this, 1 second passes before the results of both function calls are printed. What we really want is the value of add_one(1) to be printed immediately while hello_world_message()runs concurrently. So why isn’t this happening with this code? The answer is that await pauses our current coroutine and won’t execute any other code inside that coroutine until the await expression gives us a value. Since it will take 1 second for our hello_world_message function to give us a value, the main coroutine will be paused for 1 second. Our code behaves as if it were sequential in this case. This behavior is illustrated in figure\nWe can see that the main coroutine is paused for 1 second while hello_world_\nBoth main and hello_world paused while we wait for delay(1) to finish. After it has finished, main resumes and can execute add_one. We’d like to move away from this sequential model and run add_one concurrently with hello_world. To achieve this, we’ll need to introduce a concept called tasks.\n2.5 Running concurrently with task In Python\u0026rsquo;s asyncio, you can create tasks to run code concurrently. This is done using the asyncio.create_task function. When you create a task, it starts running in the background immediately, allowing your program to do other things while waiting for the task to finish.\nKey Points: Creating a Task:\nUse asyncio.create_task() with a coroutine function as its input. It returns a task object instantly. Awaiting a Task:\nYou can use await with the task object to pause your program until the task is done and get its result. Why Use Tasks?\nTasks allow other parts of your program to run without waiting for one operation to finish. Code Example: Creating and Using a Task import asyncio from util import delay # A custom function that simulates a delay async def main(): # Create a task that takes 3 seconds to complete sleep_for_three = asyncio.create_task(delay(3)) # Immediately print the type of the task object print(f\u0026#34;Task type: {type(sleep_for_three)}\u0026#34;) # Wait for the task to finish and get the result result = await sleep_for_three print(f\u0026#34;Task result: {result}\u0026#34;) # Run the main coroutine asyncio.run(main()) What’s Happening in the Code: Task Creation:\nasyncio.create_task(delay(3)) creates a task to run the delay(3) coroutine in the background. The task is of type \u0026lt;class '_asyncio.Task'\u0026gt;, which is different from a regular coroutine. Running Concurrently:\nAfter creating the task, the program does not wait for the task to finish. The print() statement runs immediately after the task is created. Waiting for the Task:\nThe await sleep_for_three line pauses the main coroutine until the task finishes. Once the task is complete, it returns its result, which is printed. Why Await is Important: If you don’t use await on a task, it might not get enough time to finish. When the asyncio.run function exits, the event loop stops, and any unfinished tasks are “cleaned up” without completing. Using await ensures the task has a chance to finish.\nNote : When we create task using asyncio.create_task it run the task immediately in the background. It does not wait for the task to finish and immediately return a task object such that our program can do other things while waiting for the task to finish.We can use await later on to pause the program until the task is done and get its result.\n2.6 Running multiple tasks concurrently Given that tasks are created instantly and are scheduled to run as soon as possible, this allows us to run many long-running tasks concurrently. We can do this by sequentially starting multiple tasks with our long-running coroutine.\nimport asyncio from util.delay_functions import delay async def main(): # Create two tasks that take 3 seconds to complete sleep_for_three=asyncio.create_task(delay(3)) sleep_again=asyncio.create_task(delay(3)) sleep_once_more=asyncio.create_task(delay(3)) await sleep_for_three await sleep_again await sleep_once_more asyncio.run(main()) In this code, we create three tasks that each sleep for 3 seconds. We then await each task in sequence. This will cause each task to run concurrently, and the total time to complete will be around 3 seconds, not 9 seconds. This is because we are not waiting for each task to finish before starting the next one. Lets breakdown\nStarting Three Tasks:\nThe program begins by creating three tasks, each of which takes 3 seconds to complete. The create_task function starts the tasks immediately but doesn\u0026rsquo;t wait for them to finish—it just sets them up to run in the background. The First Await Statement:\nWhen the code reaches the await sleep_for_three line, it pauses and gives control to the event loop. This pause allows the event loop to check for any tasks waiting to run and starts them “as soon as possible.” Tasks Run Simultaneously:\nAll three tasks begin running their sleep operations at the same time because the event loop handles them concurrently. This concurrency allows the program to complete the work in 3 seconds instead of 9. Concurrency in Action:\nWhile the sleep operations run concurrently, any other code in the tasks (like print statements) runs one at a time, not simultaneously. This means only the parts of the tasks that involve waiting (like sleeping) are parallelized. Time Saved:\nIf the tasks were executed one after another, the program would take 9 seconds (3 seconds × 3 tasks). By running the tasks concurrently, the program finishes in just 3 seconds, saving a lot of time. This is illustrated in figure NOTE This benefit compounds as we add more tasks; if we had launched 10 of these tasks, we would still take roughly 3 seconds, giving us a 10-fold speedup. This is the power of concurrency in asyncio.\nasyncio.gather function Gather function is a quick way to run multiple tasks concurrently and wait for all of them to complete. It takes in an iterable of awaitables and returns a single awaitable that will yield results in the order they were created. This is useful when we want to run multiple tasks concurrently and wait for all of them to finish before proceeding.\nimport asyncio from util.delay_functions import delay async def main(): # Create three tasks that take 3 seconds to complete and handel using asyncio.gather results = await asyncio.gather( delay(3), delay(3), delay(3) ) print(results) asyncio.run(main()) Note : For understanding You can use this logic . There is a task queue and event loop. When we only await coroutine there is only one task in the task queue and event loop .\ncoroutine need to await for running the task i.e keep in the task queue and eventloop if we directly run coroutine it will just give us coroutine object.\nWhen we use asyncio.createtask() there are as much task in the task queue as the number of tasks created and event loop will run all the tasks concurrently also when we await new coroutine it will be added to the task queue and event loop will run it concurrently.\nIt return a task object instantly and run all the task concurrently i.e keep in the task queue and event loop without awaiting but does not wait for the task to finish it need to be awaited to get the proper result.\nWhen we use asyncio.gather() it will run all the tasks concurrently and wait for all of them to finish before proceeding.\nIt need to be awaited to keep all the task in the task queue and event loop and wait for all of them to finish before proceeding.After finishing all the task it will return the result in the order they were created and jump to the next line of code of the main coroutine.\n3. Synchronization Premitives Locks Semaphores 3.1 Locks Locks are a synchronization primitive that allows us to limit access to a shared resource to only one coroutine at a time. This is useful when we have a resource that can only be accessed by one coroutine at a time, like a file or a database connection. Locks are created using the asyncio.Lock class and can be acquired using the acquire method and released using the release method.\n#basic example of lock\nimport asyncio async def locking(lock): print(\u0026#39;Waiting for the lock\u0026#39;) async with lock: print(\u0026#39;Acquired the lock\u0026#39;) await asyncio.sleep(2) print(\u0026#39;Released the lock\u0026#39;) async def main(): lock = asyncio.Lock() await asyncio.gather( locking(lock), locking(lock), locking(lock) ) asyncio.run(main()) Output:\nWaiting for the lock\rAcquired the lock\rWaiting for the lock\rWaiting for the lock\rReleased the lock\rAcquired the lock\rReleased the lock\rAcquired the lock\rReleased the lock In this example, we create a lock using asyncio.Lock and pass it to the locking coroutine. We then use the async with statement to acquire the lock and release it when we are done. When we run the program, we can see that only one coroutine can acquire the lock at a time, and the other coroutines have to wait until the lock is released.\n3.2 Semaphores Semaphores are a synchronization primitive that allows us to limit access to a shared resource to a fixed number of coroutines at a time. This is useful when we have a resource that can be accessed by a limited number of coroutines, like a connection pool or a web API. Semaphores are created using the asyncio.Semaphore class and can be acquired using the acquire method and released using the release method.\n#basic example of semaphore\nimport asyncio async def semaphoring(semaphore): async with semaphore: print(\u0026#39;Acquired the semaphore\u0026#39;) await asyncio.sleep(2) print(\u0026#39;Released the semaphore\u0026#39;) async def main(): semaphore = asyncio.Semaphore(2) await asyncio.gather( semaphoring(semaphore), semaphoring(semaphore), semaphoring(semaphore), semaphoring(semaphore) ) asyncio.run(main()) Output:\nAcquired the semaphore\rAcquired the semaphore\rAcquired the semaphore\rReleased the semaphore\rReleased the semaphore\rReleased the semaphore\rAcquired the semaphore\rReleased the semaphore In this example, we create a semaphore with a limit of 2 using asyncio.Semaphore and pass it to the semaphoring coroutine. We then use the async with statement to acquire the semaphore and release it when we are done. When we run the program, we can see that only two coroutines can acquire the semaphore at a time, and the other coroutines have to wait until the semaphore is released.\nSome popular asyncio libraries aiohttp: An HTTP client and server library for asyncio. fastapi: A modern web framework for building APIs with Python 3.6+ based on standard Python type hints. aiofiles: A file operations library for asyncio. ","permalink":"http://localhost:1313/posts/pages/asyncio/asyncio2/","summary":"how to write programs using this single-threaded concurrency model with asyncio","title":"Async io : Asyncio Basics (Day 2)"},{"content":"36. useRef Hook in React useRef is a hook that is specially designed to work with DOM elements. It allows you to create a reference to a DOM element and access it directly in your components so you can modify it or read its properties as needed.\nAnother important distinction is that useRef holds the same reference across re-renders of the component Similarly, useState also retains its value between renders. However, updating a state value with useState will always trigger a re-render, whereas updating the value of a useRef does not. Its explained in the below example in ## 2. Advanvced Usage\n1. Basic Usage 1. Import useRef import { useRef } from \u0026#39;react\u0026#39;; 2. Create a Reference const myRef = useRef(); 3. Attach to DOM Elements function MyComponent() { const myRef = useRef(); return ( \u0026lt;div ref={myRef}\u0026gt; \u0026lt;h1\u0026gt;useRef Example\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ); } 4. Accessing the Reference // Access the DOM element using .current const element = myRef.current; use myRef.current.value for input elements. use myRef.current.checked for checkbox elements. use myRef.current.focus() to focus on an element. use myRef.current.style to access the style object of an element.\nNote: While you can access DOM elements directly with useRef, it\u0026rsquo;s recommended to avoid manipulating them directly unless necessary.\nPractical Example: Form Input Here\u0026rsquo;s a complete example showing how to use useRef with form inputs:\nimport { useRef, useState } from \u0026#39;react\u0026#39;; function InputExample() { const inputRef = useRef(); const [inputValue, setInputValue] = useState(\u0026#39;\u0026#39;); const handleClick = () =\u0026gt; { setInputValue(inputRef.current.value); inputRef.current.value = \u0026#39;\u0026#39;; // Clear input after reading }; return ( \u0026lt;div\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; ref={inputRef} placeholder=\u0026#34;Type something...\u0026#34; /\u0026gt; \u0026lt;button onClick={handleClick}\u0026gt;Save Input\u0026lt;/button\u0026gt; \u0026lt;p\u0026gt;Saved value: {inputValue}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } Explanation:\nWe create a reference to the input element using useRef. When the button is clicked, we read the input value using inputRef.current.value and update the state. We clear the input field by setting inputRef.current.value to an empty string. 2. Advanced Usage of useRef and useState useRef and useState are both hooks used in React. Both hooks help us store values, but they behave differently: useState: The value is persistent across re-renders, but updating it triggers a re-render. useRef: The value is also persistent across re-renders, but updating it does not trigger a re-render. 2.1. Managing Previous Values in a Stopwatch Here’s an example of how to use useRef and useState to build a simple stopwatch in React:\nimport { useRef, useState } from \u0026#39;react\u0026#39;; function Stopwatch() { const timerRef = useRef(0); // To store the timer ID const [time, setTime] = useState(0); // To store the current time const [isRunning, setIsRunning] = useState(false); // To track if the stopwatch is running // Start the timer when the Start button is clicked const startTimer = () =\u0026gt; { if (!isRunning) { timerRef.current = setInterval(() =\u0026gt; { setTime((time) =\u0026gt; time + 1); // Increment the time every second }, 1000); setIsRunning(true); // Set the timer as running } }; // Stop the timer when the Stop button is clicked const stopTimer = () =\u0026gt; { clearInterval(timerRef.current); // Clear the interval to stop the timer setIsRunning(false); // Set the timer as not running }; // Reset the timer when the Reset button is clicked const resetTimer = () =\u0026gt; { clearInterval(timerRef.current); // Clear the interval to stop the timer setIsRunning(false); // Set the timer as not running setTime(0); // Reset the time to 0 }; return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Stopwatch\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;Time: {time} seconds\u0026lt;/p\u0026gt; \u0026lt;button onClick={startTimer}\u0026gt;Start\u0026lt;/button\u0026gt; \u0026lt;button onClick={stopTimer}\u0026gt;Stop\u0026lt;/button\u0026gt; \u0026lt;button onClick={resetTimer}\u0026gt;Reset\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } Explanation Creating useRef and useState variables:\ntimerRef: This holds the timer ID (returned by setInterval). We use useRef here because we don’t need the component to re-render when the timer ID changes. time: This stores the current time value of the stopwatch, and we use useState for this because we want the component to re-render whenever the time updates. isRunning: This tracks whether the stopwatch is running or not. Starting the timer (Start Button):\nWhen the \u0026ldquo;Start\u0026rdquo; button is clicked, we check if the timer is already running. If it isn’t, we start it by calling setInterval, which increments the time value every second. setInterval returns an interval ID that we store in timerRef.current. This ID will be used to stop the timer later. Stopping the timer (Stop Button):\nWhen the \u0026ldquo;Stop\u0026rdquo; button is clicked, we clear the interval using clearInterval(timerRef.current) to stop the timer. We also set isRunning to false to indicate that the timer is no longer running. Resetting the timer (Reset Button):\nWhen the \u0026ldquo;Reset\u0026rdquo; button is clicked, we clear the interval to stop the timer, set isRunning to false, and reset the time back to 0. Why useRef? Why not just use a regular variable?\nA regular variable inside the component would reset every time the component re-renders. Since the timer is being updated every second, this would cause issues because the value would be reset each time, and the timer wouldn’t function correctly. Why useRef over useState for the timer ID?\nWe use useRef to store the timer ID because updating it with useState would trigger a re-render every time the timer ID changes. Since the timer is running independently, we don’t need a re-render, so useRef is more efficient here. Key Takeaways useRef is useful for storing values that don’t require the component to re-render when they change. useState is used for values that should trigger a re-render when updated, like the time value in our stopwatch. useRef does not cause a re-render when its value changes, making it ideal for holding values like the interval ID that don’t need to affect the UI. Common Use Cases Storing previous values Managing focus, text selection, or media playback Integrating with third-party DOM libraries Accessing underlying DOM elements Isolation in Components: Any variable that is declared inside a component is isolated to that component. It is not shared with other components unless explicitly passed as props. This isolation helps maintain the encapsulation and modularity of components in React.\n37.Forwarding Refs in React Forwarding refs is a technique in React that allows you to pass a ref from a parent component to a child component. This is useful when you want to access the DOM element of a child component from a parent component.\n1. Basic Usage 1.Import useRef import { useRef } from \u0026#39;react\u0026#39;; 2. Create a Ref in the Parent Component const myRef= useRef(); 3. Pass the Ref to the Child Component \u0026lt;MyChildComponent ref={myRef} /\u0026gt; 4.Import forward ref in child component import React, { forwardRef } from \u0026#39;react\u0026#39;; 5. Using forwardRef to Forward the Ref const MyChildComponent = forwardRef((props, ref) =\u0026gt; { return \u0026lt;input ref={ref} /\u0026gt;; }); 6. Accessing the Ref in the Parent Component const element = myRef.current.value; Practical Example: Input Focus to take input from user and focus on the input field of the child component from the parent component.\nimport React, { useRef } from \u0026#39;react\u0026#39;; const InputComponent = forwardRef(({title}, ref) =\u0026gt; { return\u0026lt;\u0026gt; \u0026lt;h1\u0026gt;{title}\u0026lt;/h1\u0026gt; \u0026lt;input ref={ref}/\u0026gt; \u0026lt;/\u0026gt; }); function ParentComponent() { const inputRef = useRef(); const handleClick = () =\u0026gt; { inputRef.current.focus(); console.log(inputRef.current.value); }; return ( \u0026lt;div\u0026gt; \u0026lt;InputComponent ref={inputRef} title=\u0026#34;ENter the Input\u0026#34;/\u0026gt; \u0026lt;button onClick={handleClick}\u0026gt;Focus Input\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 38.useImperativeHandle in React In large-scale applications, we generally avoid using refs directly to access child components. Instead, we use the useImperativeHandle hook to expose specific methods from the child component to the parent component. This approach allows the developer working on the parent component to interact with the child component\u0026rsquo;s methods without needing to understand its internal implementation. Additionally, this separation enables the developer of the child component to modify or update the child component independently, without affecting the parent component. Since only the exposed methods are used by the parent, changes to the internal structure of the child component do not disrupt the parent-child interaction.This is specially used in forwardRef to expose methods of child component to parent component.\nBasic Usage 1.Pass a Ref to the Child Component import {useRef} from \u0026#39;react\u0026#39;; function App() { const childRef = useRef(); return \u0026lt;ChildComponent ref={childRef} /\u0026gt;; } =\u0026gt; Here, we create a ref using useRef and pass it to the ChildComponent using the ref prop.\n2. Use useImperativeHandle in the Child Component with forwardRef to expose methods import { useImperativeHandle, forwardRef } from \u0026#39;react\u0026#39;; const ChildComponent = forwardRef((props, ref) =\u0026gt; { useImperativeHandle(ref, () =\u0026gt; ({ focus: () =\u0026gt; { // Focus on the input element }, reset: () =\u0026gt; { // Reset the input element }, inputValue:\u0026#39;vaule\u0026#39; }),[dependencies]); return \u0026lt;input /\u0026gt;; }); In the ChildComponent, we use the useImperativeHandle hook to expose the focus and reset methods to the parent component. The ref object is passed as the first argument, and the second argument is a function that returns an object containing the methods to be exposed. dependencies is an optional array of values that, when changed, will trigger the re-evaluation of the function that returns the methods. If the dependencies array is not provided, the function will be called on every render and empty array will call only once in entire lifecycle.\n3. Access the Exposed Methods in the Parent Component function App() { const childRef = useRef(); const handleClick = () =\u0026gt; { childRef.current.focus(); }; const resetClick = () =\u0026gt; { childRef.current.reset(); }; return ( \u0026lt;\u0026gt; \u0026lt;ChildComponent ref={childRef} /\u0026gt; \u0026lt;button onClick={handleClick}\u0026gt;Focus Input\u0026lt;/button\u0026gt; \u0026lt;button onClick={resetClick}\u0026gt;Reset Input\u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; ); } In the parent component, we can access the exposed methods using the current property of the ref object. In this example, we call the focus method when the \u0026ldquo;Focus Input\u0026rdquo; button is clicked.\nPractical Example: Use forwardRef and useImperativeHandle to Expose Methods for reset the input field and get the value of the input field. import {useRef} from \u0026#39;react\u0026#39;; function App(){ const childRef = useRef(); const handleClick = () =\u0026gt; { childRef.current.focus(); }; const resetClick = () =\u0026gt; { childRef.current.reset(); }; const getValue = () =\u0026gt; { console.log(childRef.current.value); }; return ( \u0026lt;\u0026gt; \u0026lt;ChildComponent ref={childRef} /\u0026gt; \u0026lt;button onClick={handleClick}\u0026gt;Focus Input\u0026lt;/button\u0026gt; \u0026lt;button onClick={resetClick}\u0026gt;Reset Input\u0026lt;/button\u0026gt; \u0026lt;button onClick={getValue}\u0026gt;Get Value\u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; ); } export default App; import { useImperativeHandle, forwardRef,useRef } from \u0026#39;react\u0026#39;; const ChildComponent = forwardRef((props, ref) =\u0026gt; { const inputRef = useRef(); useImperativeHandle(ref, () =\u0026gt; ({ focus: () =\u0026gt; { inputRef.current.focus(); }, reset: () =\u0026gt; { inputRef.current.value = \u0026#39;\u0026#39;; }, value: inputRef.current.value }),[]); return \u0026lt;input ref={inputRef} /\u0026gt;; }); export default ChildComponent; =\u0026gt; By using useImperativeHandle, we can expose specific methods from the child component to the parent component, allowing for more controlled interactions between the components such as focusing on the input field, resetting the input field, and getting the value of the input field in this example. =\u0026gt; By using this approach, we can maintain a clear separation of concerns between the parent and child components, making it easier to manage and update the components independently.\n37. Portals in React Portals in React provide a way to render children components outside the DOM hierarchy of the parent component. This allows you to render a child component at a different location in the DOM, such as at the root level or inside a specific container, without affecting the parent\u0026rsquo;s layout or styles.\nImporting portal from react-dom import { createPortal } from \u0026#39;react-dom\u0026#39;; using createPortal const MyPortal = ({title}) =\u0026gt; { return createPortal( \u0026lt;\u0026gt; \u0026lt;h1\u0026gt;{title}\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;This is a portal\u0026lt;/p\u0026gt; \u0026lt;\u0026gt;, document.getElementById(\u0026#39;portal-root\u0026#39;)); }; =\u0026gt;When the MyPortal component is rendered, the content will be rendered inside the element with the id \u0026lsquo;portal-root\u0026rsquo;, which can be located anywhere in the DOM.\n","permalink":"http://localhost:1313/posts/pages/react/react7/","summary":"Learn about useRef hook, ref forwarding, useImperativeHandle and Portals in React for DOM manipulation and component interactions.","title":"React : Day 7"},{"content":"1. Some Important Concepts 1.1 Parallism vs Concurrency Parallism: Running multiple tasks at the same time. There are multiple Threads or Processes running at the same time. Concurrency: Switching between multiple tasks. When one task is waiting for I/O, another task can run. There is only one Thread or Process running at a time. 1.2 Synchronous vs Asynchronous Synchronous: Code is executed in sequence. Previous task/line must be completed before the next task/line execution starts. Asynchronous: Code is executed in parallel. Tasks can run concurrently. The next task can start before the previous task is completed. 1.3 Blocking vs Non-Blocking Blocking: The execution of the code is blocked until the task is completed. The next task can\u0026rsquo;t start until the previous task is completed. import time def task1(): print(\u0026#34;Task 1 started\u0026#34;) time.sleep(2) print(\u0026#34;Task 1 completed\u0026#34;) def task2(): print(\u0026#34;Task 2 started\u0026#34;) time.sleep(2) print(\u0026#34;Task 2 completed\u0026#34;) task1() task2() Non-Blocking: The excecution of the code is not blocked. The next task can start before the previous task is completed. import asyncio async def task1(): print(\u0026#34;Task 1 started\u0026#34;) await asyncio.sleep(2) print(\u0026#34;Task 1 completed\u0026#34;) async def task2(): print(\u0026#34;Task 2 started\u0026#34;) await asyncio.sleep(2) print(\u0026#34;Task 2 completed\u0026#34;) async def main(): await asyncio.gather(task1(), task2()) asyncio.run(main()) 1.4 I/O Bound vs CPU Bound I/O Bound: The program is waiting for input/output operations to complete. The program is not using the CPU much. CPU Bound: The program is using the CPU a lot. The program is not waiting for input/output operations to complete. import request response = request.get(\u0026#34;https://www.google.com\u0026#34;) # I/O Bound items = response.headers.items() # CPU Bound headers = [f\u0026#39;{key}: {header}\u0026#39; for key, header in items] # CPU Bound formatted_headers = \u0026#39;\\n\u0026#39;.join(headers) # CPU Bound with open(\u0026#39;headers.txt\u0026#39;, \u0026#39;w\u0026#39;) as file: # I/O Bound file.write(formatted_headers) # I/O Bound 2. How Concurrency is Achieved in Os level To better understand this, we’ll need to dive into how sockets work and, in particular, how non-blocking sockets work.\n2.1 Sockets A socket is a low-level abstraction for sending and receiving data over a network. It is the basis for how data is transferred to and from servers. Sockets support two main operations: sending bytes and receiving bytes. We write bytes to a socket, which will then get sent to a remote address, typically some type of server. Once we’ve sent those bytes, we wait for the server to write its response back to our socket. Once these bytes have been sent back to our socket, we can then read the result.\nIn the case of getting the contents from example.com as we saw earlier, we open a socket that connects to example.com’s server. We then write a request to get the contents to that socket and wait for the server to reply with the result: in this case, the HTML of the web page. We can visualize the flow of bytes to and from the server in figure 1.7\nSockets are blocking by default. Simply put, this means that when we are waiting for a server to reply with data, we halt our application or block it until we get data to read. Thus, our application stops running any other tasks until we get data from the server, an error happens, or there is a timeout. At the operating system level, we don’t need to do this blocking. Sockets can operate in non-blocking mode. In non-blocking mode, when we write bytes to a socket, we can just fire and forget the write or read, and our application can go on to perform other tasks. Later, we can have the operating system tell us that we received bytes and deal with it at that time. This lets the application do any number of things while we wait for bytes to come back to us. Instead of blocking and waiting for data to come to us, we become more reactive, letting the operating system inform us when there is data for us to act on. In the background, this is performed by a few different event notification systems, depending on which operating system we’re running. asyncio is abstracted enough that it switches between the different notification systems, depending on which one our operating system supports. The following are the event notification systems used by specific operating systems:\nkqueue—FreeBSD and MacOS epoll—Linux IOCP (I/O completion port)—Windows These systems keep track of our non-blocking sockets and notify us when they are ready for us to do something with them. This notification system is the basis of how asyncio can achieve concurrency.\nBut how do we keep track of multiple tasks that are waiting for data to come back to them? This is where the event loop comes in.\n2.2 Event Loop The event loop is the core of every asyncio application. In asyncio, the event loop keeps a queue of tasks.\n2.2.1 How the Event Loop Works The event loop works by keeping a queue of tasks instead of messages. Each task is a coroutine. When a task is added to the event loop, it will execute until it encounters an I/O operation (such as a web request). When a task hits an I/O-bound operation, it pauses and allows the event loop to run other tasks that are not waiting for I/O operations to complete. 2.2.2 Understanding Event Loops in Asynchronous Programming When working with event loops in asynchronous programming, the process can be understood as a sequence of steps that efficiently handle tasks without blocking the execution. Here\u0026rsquo;s a breakdown of how it works:\n2.2.2.1 Creating the Event Loop When an event loop is created, an empty queue of tasks is initialized. This queue will hold all the tasks that need to be executed.\n2.2.2.2 Adding Tasks to the Queue We add tasks to the event loop’s queue. These tasks are executed one at a time, based on their order in the queue.\n2.2.2.3 Processing Tasks Iteratively Each iteration of the event loop checks for tasks that need to be executed. It processes tasks sequentially, running them one by one.\n2.2.2.4 Handling I/O Operations If a task encounters an I/O operation (like reading from a file or making a network request), it cannot proceed immediately. In this case, the task is paused and put on hold.\n2.2.2.5 Pausing and Waiting for I/O Completion When a task is paused, the event loop instructs the operating system to monitor any associated sockets or resources for I/O completion. During this time, the event loop continues checking for and executing other tasks.\n2.2.2.6 Waking Up Paused Tasks On each iteration of the event loop, we check if any of the I/O operations have completed. If they have:\nThe paused task is woken up. The task resumes execution and completes its process. 2.2.2.7. Conclusion This cycle of pausing, waiting for I/O, and resuming tasks allows the event loop to run multiple tasks concurrently, making it an efficient way to handle asynchronous operations without blocking the program.\nBy continuously iterating and checking for completed I/O tasks, the event loop ensures that no task is left idle while waiting for I/O operations, enabling a smooth and efficient workflow.\nVisualizing the Event Loop with Asynchronous Tasks We can visualize how the event loop works with asynchronous tasks as shown in Figure 1.9: the main thread submits tasks to the event loop, which then runs them. When a task encounters an I/O operation, it pauses and allows other tasks to run. Once the I/O operation is complete, the paused task is resumed.\nExample: Submitting Multiple Asynchronous Tasks Let\u0026rsquo;s consider three tasks that each make an asynchronous web request. These tasks consist of:\nCPU-bound setup: Some code that prepares data for the web request. I/O-bound web request: The asynchronous part where we send the web request. CPU-bound post-processing: After the web request completes, we do some more CPU-intensive work. Now, let\u0026rsquo;s submit these tasks to the event loop simultaneously. Here’s how we can write this in pseudocode:\ndef make_request(): cpu_bound_setup() io_bound_web_request() cpu_bound_postprocess() task_one = make_request() task_two = make_request() task_three = make_request() First task starts executing code, and the other two are left waiting to run. Once the CPU-bound setup work is finished in Task 1, it hits an I/O-bound operation and will pause itself to say, “I’m waiting for I/O; any other tasks waiting to run can run.” Once this happens, Task 2 can begin executing. Task 2 starts its CPU-bound code and then pauses, waiting for I/O. At this time both Task 1 and Task 2 are waiting concurrently for their network request to complete. Since Tasks 1 and 2 are both paused waiting for I/O, we start running Task 3. Now imagine once Task 3 pauses to wait for its I/O to complete, the web request for Task 1 has finished. We’re now alerted by our operating system’s event notification system that this I/O has finished. We can now resume executing Task 1 while both Task 2 and Task 3 are waiting for their I/O to finish. In figure 1.10, we show the execution flow of the pseudocode we just described. If we look at any vertical slice of this diagram, we can see that only one CPU-bound piece of work is running at any given time; however, we have up to two I/O-bound operations happening concurrently. This overlapping of waiting for I/O per each task is where the real time savings of asyncio comes in.\n","permalink":"http://localhost:1313/posts/pages/asyncio/asyncio1/","summary":"An introduction to asynchronous programming in Python using asyncio.","title":"Async io : Async io Intro (Day 1)"},{"content":"34.Styling in CSS 34.1 Setting Inline Styles =\u0026gt; In react for inline styles we use the style attribute and pass an object with camelCase properties.\nimport React from \u0026#39;react\u0026#39;; const myStyle = { color: \u0026#39;blue\u0026#39;, backgroundColor: \u0026#39;yellow\u0026#39; } const MyComponent = () =\u0026gt; { return ( \u0026lt;div style={myStyle}\u0026gt; \u0026lt;h1\u0026gt;Inline Styles\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ) } or we can use the style attribute directly in the element.\nimport React from \u0026#39;react\u0026#39;; const MyComponent = () =\u0026gt; { return ( \u0026lt;div style={{color: \u0026#39;blue\u0026#39;, backgroundColor: \u0026#39;yellow\u0026#39;}}\u0026gt; \u0026lt;h1\u0026gt;Inline Styles\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ) } 34.2 Setting External Styles =\u0026gt; We can also use external CSS files in react. We can import the CSS file in the component file and use the class name in the\nimport React from \u0026#39;react\u0026#39;; import \u0026#39;./MyComponent.css\u0026#39;; const MyComponent = () =\u0026gt; { return ( \u0026lt;div className=\u0026#34;myStyle\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;External Styles\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ) } 34.3 Setting Inline Dynamic Styles =\u0026gt;You can also set the inline styles dynamically by using the state.\nimport React,{useState} from \u0026#39;react\u0026#39;; const App=()=\u0026gt;{ const [valid,setValid]=useState(true); function changeStyle(){ setValid(!valid); } const myStyle={ color:valid?\u0026#39;blue\u0026#39;:\u0026#39;red\u0026#39;, backgroundColor:valid?\u0026#39;yellow\u0026#39;:\u0026#39;green\u0026#39; } return( \u0026lt;div\u0026gt; \u0026lt;button onClick={changeStyle}\u0026gt;Change Style\u0026lt;/button\u0026gt; \u0026lt;div style={myStyle}\u0026gt; \u0026lt;h1\u0026gt;Inline Dynamic Styles\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) } export default App; or we can use the style attribute directly in the element.\nimport React,{useState} from \u0026#39;react\u0026#39;; const App=()=\u0026gt;{ const [valid,setValid]=useState(true); function changeStyle(){ setValid(!valid); } return( \u0026lt;div\u0026gt; \u0026lt;button onClick={changeStyle}\u0026gt;Change Style\u0026lt;/button\u0026gt; \u0026lt;div style={{color:valid?\u0026#39;blue\u0026#39;:\u0026#39;red\u0026#39;,backgroundColor:valid?\u0026#39;yellow\u0026#39;:\u0026#39;green\u0026#39;}}\u0026gt; \u0026lt;h1\u0026gt;Inline Dynamic Styles\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) } export default App; 34.4 Setting Css Classes Dynamically =\u0026gt; We can also set the CSS classes dynamically by using the state.\nimport React,{useState} from \u0026#39;react\u0026#39;; import \u0026#39;./MyComponent.css\u0026#39;; const App=()=\u0026gt;{ const [valid,setValid]=useState(true); const [active,setActive]=useState(true); function changeStyle(){ setValid(!valid); setActive(!active); } return( \u0026lt;div\u0026gt; \u0026lt;button onClick={changeStyle}\u0026gt;Change Style\u0026lt;/button\u0026gt; \u0026lt;div className={`div-control ${valid?\u0026#39;right\u0026#39;:\u0026#39;wrong\u0026#39;} ${active?\u0026#39;active\u0026#39;:\u0026#39;inactive\u0026#39;}`}\u0026gt; \u0026lt;h1\u0026gt;Setting Css Classes Dynamically\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) } export default App; 34.5 Css modules =\u0026gt; Every time we import Css file in react component they are regarded as global styles i.e One component style can affect another component style =\u0026gt;So, to avoid this we can use CSS modules. CSS modules are local by default. We can use CSS modules by naming the CSS file as filename.module.css. =\u0026gt; The CSS file is imported in the component file and the class name is used as an object.\nProblem1 =\u0026gt; Imagine that you have two components with the same class name. The styles of one component can affect the styles of another component.which is not good for the application to solve this problem we can use CSS modules.\nStructure of the project\nsrc\r|_components\r|_MyComponent\r|_MyComponent.js\r|_MyComponent.module.css Step 1: Create a CSS file with the name MyComponent.module.css\n.myStyle{ color: blue; background-color: yellow; } .right{ text-align: right; } Step 2: Import the CSS file in the component file as shown below.\nimport React from \u0026#39;react\u0026#39;; import styles from \u0026#39;./MyComponent.module.css\u0026#39;; step 3: Use the class name as shown below.\nconst MyComponent = () =\u0026gt; { return ( \u0026lt;div className={styles.myStyle}\u0026gt; \u0026lt;h1\u0026gt;CSS Modules\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ) } Combined code\nimport React from \u0026#39;react\u0026#39;; import styles from \u0026#39;./MyComponent.module.css\u0026#39;; const MyComponent = () =\u0026gt; { return ( \u0026lt;div className={styles.myStyle}\u0026gt; \u0026lt;h1\u0026gt;CSS Modules\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ) } export default MyComponent; 34.5.1 Combining multiple classes import React from \u0026#39;react\u0026#39;; import styles from \u0026#39;./MyComponent.module.css\u0026#39;; const MyComponent = () =\u0026gt; { return ( \u0026lt;div className={`${styles.myStyle} ${styles.right}`}\u0026gt; \u0026lt;h1\u0026gt;CSS Modules\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ) } export default MyComponent; 34.6 Dynamic CSS Modules =\u0026gt; We can also set the CSS classes dynamically by using the state.\nimport React,{useState} from \u0026#39;react\u0026#39;; import styles from \u0026#39;./MyComponent.module.css\u0026#39;; const MyComponent = () =\u0026gt; { const [valid,setValid]=useState(true); const [active,setActive]=useState(true); function changeStyle(){ setValid(!valid); setActive(!active); } return ( \u0026lt;div className={`${styles.myStyle} ${valid?styles.right:styles.wrong} ${active?styles.active:styles.inactive}`}\u0026gt; \u0026lt;h1\u0026gt;CSS Modules\u0026lt;/h1\u0026gt; \u0026lt;button onClick={changeStyle}\u0026gt;Change Style\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } export default MyComponent; ","permalink":"http://localhost:1313/posts/pages/react/react5/","summary":"Learn various methods to style React components including inline styles, external styles, dynamic styles, and CSS modules.","title":"React : Day 5"},{"content":"35. Debugging in react 35.1 Using console.log import React from \u0026#39;react\u0026#39;; const MyComponent = () =\u0026gt; { const name = \u0026#39;John Doe\u0026#39;; console.log(name); return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Debugging in React\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ) } export default MyComponent; 35.2 Strict Mode =\u0026gt; In Strict Mode,React will render components twice. It helps to idenify the issues in the code.\nimport React,{StrictMode} from \u0026#39;react\u0026#39;; const MyComponent = () =\u0026gt; { const name = \u0026#39;John Doe\u0026#39;; console.log(name); return ( \u0026lt;StrictMode\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Debugging in React\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/StrictMode\u0026gt; ) } export default MyComponent; You can wrap any component in StrictMode.Just difference is that it will render the component twice.\n=\u0026gt; We can wrap the entire application in StrictMode in the index.js file.\nimport React,{StrictMode} from \u0026#39;react\u0026#39;; import ReactDOM from \u0026#39;react-dom\u0026#39;; import App from \u0026#39;./App\u0026#39;; ReactDOM.render( \u0026lt;StrictMode\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/StrictMode\u0026gt;, document.getElementById(\u0026#39;root\u0026#39;) ); 35.3 React Developer Tools React Developer Tools is a Chrome extension that allows you to inspect the React component hierarchy in the Chrome Developer Tools. Videos\n","permalink":"http://localhost:1313/posts/pages/react/react6/","summary":"Learn how to debug React applications using console.log, Strict Mode, and React Developer Tools.","title":"React : Day 6"},{"content":"Python Fundamentals: A Beginner\u0026rsquo;s Guide (Part 1) 1. Virtual Environment A virtual environment is a feature in Python that allows you to install the same package with different versions on the same system. This enables you to work on multiple projects using different versions of the same package.\n1.1. Installing venv The venv module is included in the Python standard library, so you don\u0026rsquo;t need to install it separately. However, if you are using an older version of Python (before 3.3), you can install virtualenv using pip:\npip install virtualenv 1.2. Creating a Virtual Environment To create a virtual environment, you can use the venv module, which is included in the Python standard library. Here\u0026rsquo;s how you can create a virtual environment named myenv:\npython -m venv myenv This command creates a new directory named myenv that contains the necessary files for the virtual environment.\n1.3. Activating a Virtual Environment To activate the virtual environment, you may run the following command:\n# For Linux/Mac: source myenv/bin/activate # For Windows: myenv\\Scripts\\activate 2. Python Packages 2.1. List All the Python Packages To list or save all the installed packages in the current environment, you can use the following command using freeze:\npip freeze # To list all the installed packages pip freeze \u0026gt; requirements.txt # To save all the installed packages in a file 2.2. Installing Python Packages To install a Python package, you can use the pip install command followed by the package name. For example, to install the requests package, you can run:\npip install requests 2.3. Uninstalling Python Packages To uninstall a Python package, you can use the pip uninstall command followed by the package name. For example, to uninstall the requests package, you can run:\npip uninstall requests 2.4. Run Python Package/Script To run a python package or script, you can use the following command:\npython -m package_name 3. Python Basics 3.1. Running a Python Script To run a Python script, you can use the following command:\npython script.py 3.2. Python Indentation In Python, the code block (body of the function, loop, etc.) starts with a colon (:) and the line following the colon should be indented.\nif 5 \u0026gt; 2: print(\u0026#34;Five is greater than two!\u0026#34;) # Indented block 3.3. Python Comments There are two types of comments in Python:\n# This is a single line comment \u0026#34;\u0026#34;\u0026#34; This is a multiline comment This is a multiline comment This is a multiline comment This is a multiline comment \u0026#34;\u0026#34;\u0026#34; 3.4. Print Statement The print() function is used to display the output on the console. For example:\nprint(\u0026#34;Hello, World!\u0026#34;) 3.5. Data Types Python has the following data types:\nint float str bool list tuple set dict None a = 10 # int b = 10.5 # float c = \u0026#34;Hello\u0026#34; # str d = True # bool e = [1,2,3] # list f = (1,2,3) # tuple g = {1,2,3} # set h = {\u0026#34;name\u0026#34;:\u0026#34;John\u0026#34;,\u0026#34;age\u0026#34;:30} # dict i = None # None print(type(a)) # \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; Note:Use type() function to check the data type of a variable.As it return the class of the variable.\n3.6. Rules of Variable Declaration A variable name must start with a letter or the underscore character. A variable name cannot start with a number. A variable name can only contain alpha-numeric characters and underscores (A-z, 0-9, and _ ). Variable names are case-sensitive (age, Age, and AGE are three different variables). 3.7. Type Conversion You can convert one data type to another using the following functions:\nint(): To convert to an integer float(): To convert to a float str(): To convert to a string bool(): To convert to a boolean list(): To convert to a list tuple(): To convert to a tuple set(): To convert to a set dict(): To convert to a dictionary a = 10 #a=10 b = float(a) #b=10.0 c = str(a) #c=\u0026#39;10\u0026#39; d = bool(a) #d=True e = list(c) #e=[\u0026#39;1\u0026#39;,\u0026#39;0\u0026#39;] f = tuple(c) #f=(\u0026#39;1\u0026#39;,\u0026#39;0\u0026#39;) g = set(c) #g={\u0026#39;1\u0026#39;,\u0026#39;0\u0026#39;} h = dict(name=\u0026#34;John\u0026#34;,age=30) or dict([(\u0026#34;name\u0026#34;,\u0026#34;John\u0026#34;),(\u0026#34;age\u0026#34;,30)]) #h={\u0026#39;name\u0026#39;:\u0026#39;John\u0026#39;,\u0026#39;age\u0026#39;:30} Note: Python is dynamically typed, which means a variable\u0026rsquo;s data type can be changed.\n4. Operators 4.1. Arithmetic Operators +: Addition -: Subtraction *: Multiplication /: Division %: Modulus **: Power //: Floor Division a = 10 b = 3 print(a + b) # 13 print(a - b) # 7 print(a * b) # 30 print(a / b) # 3.3333333333333335 print(a % b) # 1 print(a ** b) # 1000 print(a // b) # 3 4.2. Assignment Operators =: Assign value +=: Add and assign -=: Subtract and assign *=: Multiply and assign /=: Divide and assign %=: Modulus and assign **=: Power and assign //=: Floor Division and assign a = 10 a += 5 # a = a + 5 a -= 5 # a = a - 5 a *= 5 # a = a * 5 a /= 5 # a = a / 5 a %= 5 # a = a % 5 a **= 5 # a = a ** 5 a //= 5 # a = a // 5 4.3. Comparison Operators ==: Equal to !=: Not equal to \u0026gt;: Greater than \u0026lt;: Less than \u0026gt;=: Greater than or equal to \u0026lt;=: Less than or equal to a = 10 b = 20 print(a == b) # False print(a != b) # True print(a \u0026gt; b) # False print(a \u0026lt; b) # True print(a \u0026gt;= b) # False print(a \u0026lt;= b) # True 4.4. Logical Operators and: Returns True if both statements are true or: Returns True if one of the statements is true not: Reverse the result, returns False if the result is true a = 10 b = 20 c = 30 print(a \u0026lt; b and b \u0026lt; c) # True print(a \u0026lt; b or b \u0026gt; c) # True print(not(a \u0026lt; b and b \u0026lt; c)) # False 4.5. Identity Operators is: Returns True if both variables are the same object is not: Returns True if both variables are not the same object a = [1,2,3] b = [1,2,3] print(a is b) # False print(a is not b) # True 4.6. Membership Operators in: Returns True if a sequence with the specified value is present in the object not in: Returns True if a sequence with the specified value is not present in the object a = [1,2,3] #Can be used in list , tuple , set , dict, string print(1 in a) # True print(4 not in a) # True 4.7. Bitwise Operators \u0026amp;: AND |: OR ^: XOR ~: NOT \u0026lt;\u0026lt;: Left Shift \u0026gt;\u0026gt;: Right Shift a = 10 b = 4 print(a \u0026amp; b) # 0 print(a | b) # 14 print(a ^ b) # 14 print(~a) # -11 print(a \u0026lt;\u0026lt; 2) # 40 print(a \u0026gt;\u0026gt; 2) # 2 Note: is vs ==\nis is used to compare the memory location of two objects. == is used to compare the values of two objects. # For Mutable objects (list, dict, set): a = [1,2,3] b = [1,2,3] print(a == b) # True print(a is b) # False # For immutable objects (int, float, string, tuple, None): a = 10 b = 10 print(a == b) # True print(a is b) # True c = None d = None print(c == d) # True print(c is d) # True 5.Taking User Input In Python, you can take user input using the input() function. Here\u0026rsquo;s an example:\nname = input(\u0026#34;Enter your name: \u0026#34;) print(\u0026#34;Hello, \u0026#34; + name) Note: The input() function always returns a string. If you want to convert it to another data type, you can use type conversion functions like int(), float(), etc.\n","permalink":"http://localhost:1313/posts/pages/python/python_basics/","summary":"A comprehensive guide to Python programming fundamentals covering core concepts for beginners","title":"Python Fundamentals: A Beginner's Guide (Part 1)"},{"content":"30. Sharing State Between React Components: Lifting State Up In React, components are the building blocks of a user interface. Each component can have its own state, but there are situations where multiple components need to share the same state. In such cases, the concept of \u0026ldquo;lifting state up\u0026rdquo; is used to manage the shared state in a common ancestor component.\u0026ldquo;Lifting state up\u0026rdquo; is a common pattern in React used when two or more components need to share data or state. Instead of managing the state in one of the components and creating a dependency between them, the state is \u0026ldquo;lifted up\u0026rdquo; to the closest common ancestor of the components that need the state.\nKey Concept When multiple components need to interact with the same state:\nThe closest common ancestor is identified. The state is moved to this common ancestor. This ancestor manages the state and passes it down to the child components as props. If any child needs to modify the state, the ancestor provides a function (passed as a prop) to handle the state update. Step-by-Step Procedure and Syntax Identify the Closest Common Ancestor:\nDetermine which component is the nearest common parent of all components that need to share the state. Lift the State Up:\nMove the state to the identified ancestor component. Use the useState hook (or class component state) to manage the state. const [state, setState] = useState(initialValue); Pass State Down as Props:\nPass the state to child components that need it via props. \u0026lt;ChildComponent state={state} /\u0026gt; Create State-Modifier Functions:\nDefine functions in the ancestor component to modify the state. const modifyStateHandler = (newData) =\u0026gt; { setState((prev) =\u0026gt; ({ ...prev, newData })); }; Pass Modifier Functions to Children:\nPass these functions to the child components as props so they can trigger state updates. \u0026lt;ChildComponent onModifyState={modifyStateHandler} /\u0026gt; Use Props in Child Components:\nAccess and use the state and modifier functions passed as props in the child components. function ChildComponent({ state, onModifyState }) { return ( \u0026lt;button onClick={() =\u0026gt; onModifyState(\u0026#34;new data\u0026#34;)}\u0026gt;Modify State\u0026lt;/button\u0026gt; ); } Example (Sharing State/Data Between Two Child Component) Parent Component (App.js) The parent component will hold the shared state and provide functions for updating it. It will pass the state and update functions as props to the child components.\nimport React, { useState } from \u0026#34;react\u0026#34;; import ChildOne from \u0026#34;./ChildOne\u0026#34;; import ChildTwo from \u0026#34;./ChildTwo\u0026#34;; const App = () =\u0026gt; { // Shared state const [sharedState, setSharedState] = useState(\u0026#34;Initial State\u0026#34;); // Function to update the state const updateState = (newState) =\u0026gt; { setSharedState(newState); }; return ( \u0026lt;div style={{ padding: \u0026#34;20px\u0026#34;, fontFamily: \u0026#34;Arial\u0026#34; }}\u0026gt; \u0026lt;h1\u0026gt;Parent Component\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;Shared State: {sharedState}\u0026lt;/p\u0026gt; \u0026lt;hr /\u0026gt; \u0026lt;ChildOne sharedState={sharedState} updateState={updateState} /\u0026gt; \u0026lt;hr /\u0026gt; \u0026lt;ChildTwo sharedState={sharedState} updateState={updateState} /\u0026gt; \u0026lt;/div\u0026gt; ); }; export default App; Child Component 1 (ChildOne.js) This component will display the shared state and allow the user to modify it through an input field.\nimport React from \u0026#34;react\u0026#34;; const ChildOne = ({ sharedState, updateState }) =\u0026gt; { const handleChange = (e) =\u0026gt; { updateState(e.target.value); }; return ( \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;Child Component One\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;Shared State: {sharedState}\u0026lt;/p\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; value={sharedState} onChange={handleChange} placeholder=\u0026#34;Update State\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; ); }; export default ChildOne; Child Component 2 (ChildTwo.js) This component will display the shared state and provide a button to reset it.\nimport React from \u0026#34;react\u0026#34;; import React from \u0026#34;react\u0026#34;; const ChildTwo = ({ sharedState, updateState }) =\u0026gt; { const handleReset = () =\u0026gt; { updateState(\u0026#34;Initial State\u0026#34;); }; return ( \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;Child Component Two\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;Shared State: {sharedState}\u0026lt;/p\u0026gt; \u0026lt;button onClick={handleReset}\u0026gt;Reset State\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); }; export default ChildTwo; Folder Structure src/ ├── App.js ├── ChildOne.js ├── ChildTwo.js ├── index.js Explanation:\nThe App component is the parent component that holds the shared state and passes it down to ChildOne and ChildTwo. ChildOne and ChildTwo are child components that receive the shared state and update functions as props. ChildOne allows the user to update the shared state through an input field, while ChildTwo provides a button to reset the state. Note: We cant directly pass data from one child component to another child component. We need to pass the data to the parent component and then pass it to the other child component. This is called lifting state up.\nExample (Sharing State/Data Between Two Sibling Components) Parent Component (App.js) import {usState} from \u0026#39;react\u0026#39;; import Expenses from \u0026#39;./Expenses\u0026#39;; import NewExpense from \u0026#39;./NewExpense\u0026#39;; const App=()=\u0026gt;{ const [expenses,setExpenses]=useState([ {id:1,title:\u0026#39;Car Insurance\u0026#39;,amount:294.67,date:new Date(2021,2,28)}, {id:2,title:\u0026#39;Health Insurance\u0026#39;,amount:394.67,date:new Date(2021,3,28)}, {id:3,title:\u0026#39;Home Insurance\u0026#39;,amount:494.67,date:new Date(2021,4,28)}, ]); const addExpenseHandler=(expense)=\u0026gt;{ setExpenses((prevExpenses)=\u0026gt;{ return [expense,...prevExpenses]; }); }; return ( \u0026lt;div\u0026gt; \u0026lt;NewExpense onAddExpense={addExpenseHandler}/\u0026gt; \u0026lt;Expenses items={expenses}/\u0026gt; \u0026lt;/div\u0026gt; ); }; export default App; NewExpense Component import ExpenseForm from \u0026#39;./ExpenseForm\u0026#39;; const NewExpense=(props)=\u0026gt;{ const saveExpenseDataHandler=(enteredExpenseData)=\u0026gt;{ const expenseData={ ...enteredExpenseData, id:Math.random().toString() }; props.onAddExpense(expenseData); }; return ( \u0026lt;div\u0026gt; \u0026lt;ExpenseForm onSaveExpenseData={saveExpenseDataHandler}/\u0026gt; \u0026lt;/div\u0026gt; ); }; export default NewExpense; Expenses function Expenses({iteam}){ return ( \u0026lt;\u0026gt; {items.map((expense)=\u0026gt;( \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;{expense.title}\u0026lt;/h2\u0026gt; \u0026lt;div\u0026gt;{expense.amount}\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;{expense.date.toISOString()}\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ))} \u0026lt;/div\u0026gt; ) } 31. Dynamically setting object keys In JavaScript, object keys are usually set statically, but there are situations where you may need to set object keys dynamically based on some conditions or variables. This can be achieved using the square bracket notation ([]) to set object keys dynamically.\nfor example:\nconst data=\u0026#34;name\u0026#34;; const person={ [data]:\u0026#39;John\u0026#39; }; console.log(person); // {name:\u0026#39;John\u0026#39;} If we dont use square bracket notation, then the key will be set as \u0026lsquo;data\u0026rsquo; instead of \u0026rsquo;name\u0026rsquo;.\nconst data=\u0026#34;name\u0026#34;; const person={ data:\u0026#39;John\u0026#39; }; console.log(person); // {data:\u0026#39;John\u0026#39;} 32.Using SAme State Variable to store multiple values =\u0026gt; We can use the same state variable to store multiple values by using an object.\nconst [userInput,setUserInput]=useState({ enteredTitle:\u0026#39;\u0026#39;, enteredAmount:\u0026#39;\u0026#39;, enteredDate:\u0026#39;\u0026#39; }); const titleChangeHandler=(event)=\u0026gt;{ setUserInput({ ...userInput, enteredTitle:event.target.value }); }; const amountChangeHandler=(event)=\u0026gt;{ setUserInput({ ...userInput, enteredAmount:event.target.value }); }; const dateChangeHandler=(event)=\u0026gt;{ setUserInput({ ...userInput, enteredDate:event.target.value }); }; return ( \u0026lt;div\u0026gt; Title:\u0026lt;input type=\u0026#34;text\u0026#34; value={userInput.enteredTitle} onChange={titleChangeHandler}/\u0026gt; Amount:\u0026lt;input type=\u0026#34;number\u0026#34; value={userInput.enteredAmount} onChange={amountChangeHandler}/\u0026gt; Date:\u0026lt;input type=\u0026#34;date\u0026#34; value={userInput.enteredDate} onChange={dateChangeHandler}/\u0026gt; The entered title is {userInput.enteredTitle} The entered amount is {userInput.enteredAmount} The entered date is {userInput.enteredDate} \u0026lt;/div\u0026gt; ); =\u0026gt; In the above code, we are using the same state variable userInput to store multiple values. We are using an object to store the values. We are using the spread operator to copy the existing values of the object and then updating the required value.\n33.Handeling page reloads when a form is submitted When a form is submitted, the page reloads by default. This is not what we want in a single page application. We want to stay on the same page and update the content of the page. We can do this by using the preventDefault() method on the event object. The preventDefault() method prevents the default behavior of the event object. In this case, it prevents the page from reloading when the form is submitted. const submitHandler=(event)=\u0026gt;{ event.preventDefault(); // code to handle form submission }; ","permalink":"http://localhost:1313/posts/pages/react/react4/","summary":"Learn how to share state between React components by lifting state up to a common ancestor.","title":"React : Day 4"},{"content":"1. Python Manupulation of Data Types We have already discussed the basic concepts of Python programming in the previous part of this series. In this part, we will dive deeper into operations and manipulations of different data types in Python.\n1.1.Numeric Operations 1.1.1. abs() Function The abs() function returns the absolute value of a number. For example:\nnum = -10 print(abs(num)) # Output: 10 1.1.2. round() Function The round() function rounds a number to the nearest integer. For example:\nnum = 3.14159 print(round(num)) # Output: 3 1.1.3. ord() Function The ord() function returns the Unicode code point of a character. For example:\nchar = \u0026#39;A\u0026#39; print(ord(char)) # Output: 65 1.2. String Operations String is a sequence of characters enclosed within single, double, or triple quotes. In Python, strings are immutable, meaning they cannot be changed once created. Here are some common string operations:\n1.2.1. Declaring a String we can declare a string using single, double, or triple quotes. For example:\nstr1 = \u0026#39;Hello, World!\u0026#39; #for single line string str2 = \u0026#34;Hello, World!\u0026#34; #for single line string str3 = \u0026#39;\u0026#39;\u0026#39;Hello, World! This is a multiline string.\u0026#39;\u0026#39;\u0026#39;#for multiline string 1.2.2. Text Decorators There are many text decorators available in Python to format strings among them we use \\n for a new line, \\t for a tab. For example:\nstr1 = \u0026#39;Hello, \\nWorld!\u0026#39; #for new line str2 = \u0026#34;Hello, \\tWorld!\u0026#34; #for tab 1.2.3. String Indexing The indexing of a string starts from 0 to n-1, where n is the length of the string. For example: for example: a=\u0026ldquo;hello\u0026rdquo;\na = H e l l o 0 1 2 3 4 0 -4 -3 -2 -1 1.2.4. Ascessing Characters in a String We can access characters in a string using the index using []. For example:\nstr = \u0026#34;Hello, World!\u0026#34; print(str[0]) # Output: H print(str[-1]) # Output: ! 1.2.5. String Concatenation We can concatenate two strings using the + operator and * operator . For example:\nstr1 = \u0026#34;Hello\u0026#34; str2 = \u0026#34;World\u0026#34; print(str1 + str2) # Output: HelloWorld print(str1 * 3) # Output: HelloHelloHello 1.2.6. String Slicing We can slice a string using the syntax variable[start:end:step] to get a substring.\nNote: The substring contains characters from index start to end-1, meaning the character at the end index is not included but character at the start index is included . The step refers to the increment or jump of the index\nFor example:\na = \u0026#34;hello\u0026#34; # Slice from index 1 to the end of the string print(a[1:]) # ello (Characters from index 1 to the end) # Slice from the beginning of the string to index 4 (doesn\u0026#39;t contain character at index 4) print(a[:4]) # hell (Characters from index 0 to 3) # Slice from index 1 to index 4 (doesn\u0026#39;t contain character at index 4) print(a[1:4]) # ell (Characters from index 1 to 3) # Full slice of the string with default values print(a[::]) # hello (Default start is 0, end is the string length, step is 1) # Defining a step value in slicing # Slice with a step of 2 print(a[::2]) # hlo (Start from index 0 to the end, select every 2nd character) # Reverse the string using a negative step print(a[::-1]) # olleh (Reverse the string by stepping backward) # Combining start, end, and step print(a[1:4:2]) # el #(Start from index 1 to 4 (doesn\u0026#39;t contain character at index 4), with a step of 2) 1.2.7. String Methods Python provides various built-in methods to manipulate strings. Some of the commonly used string methods are:\nlen() : Returns the length of the string. str = \u0026#34;Hello, World!\u0026#34; print(len(str)) # Output: 13 replace() : Replaces a substring with another substring. str = \u0026#34;Hello, World!\u0026#34; print(str.replace(\u0026#34;World\u0026#34;, \u0026#34;Universe\u0026#34;)) # Output: Hello, Universe! upper() : Converts the string to uppercase. str = \u0026#34;Hello, World!\u0026#34; print(str.upper()) # Output: HELLO, WORLD! lower() : Converts the string to lowercase. str = \u0026#34;Hello, World!\u0026#34; print(str.lower()) # Output: hello, world! split() : Splits the string into a list based on the delimiter. str = \u0026#34;Hello, World!\u0026#34; print(str.split(\u0026#34;,\u0026#34;)) # Output: [\u0026#39;Hello\u0026#39;, \u0026#39; World!\u0026#39;] capitalize() : Converts the first character of the string to uppercase.\nstr = \u0026#34;hello, world!\u0026#34; print(str.capitalize()) # Output: Hello, world! -find() : Returns the index of the first occurrence of a substring.\nstr = \u0026#34;Hello, World!\u0026#34; print(str.find(\u0026#34;World\u0026#34;)) # Output: 7 print(str.find(\u0026#34;e\u0026#34;)) # Output: 1 print(str.find(\u0026#34;Universe\u0026#34;)) # Output: -1 count() : Returns the number of occurrences of a substring. str = \u0026#34;Hello, World!\u0026#34; print(str.count(\u0026#34;l\u0026#34;)) # Output: 3 startswith() : Returns True if the string starts with a specified substring. str = \u0026#34;Hello, World!\u0026#34; print(str.startswith(\u0026#34;Hello\u0026#34;)) # Output: True endswith() : Returns True if the string ends with a specified substring. str = \u0026#34;Hello, World!\u0026#34; print(str.endswith(\u0026#34;World!\u0026#34;)) # Output: True strip() : Removes leading and trailing whitespaces from the string. We can also specify the characters to be removed. str = \u0026#34; Hello, World! \u0026#34; print(str.strip()) # Output: Hello, World! str = \u0026#34;!!!!!!!!Hello, World!!!!!\u0026#34; print(str.strip(\u0026#34;!\u0026#34;)) # Output: Hello, World! lstrip() : Removes leading whitespaces from the string.we can also specify the characters to be removed. str = \u0026#34; Hello, World! \u0026#34; print(str.lstrip()) # Output: Hello, World! str = \u0026#34;!!!!!!!!Hello, World!!!!!\u0026#34; print(str.lstrip(\u0026#34;!\u0026#34;)) # Output: Hello, World!!!!! rstrip() : Removes trailing whitespaces from the string.We can also specify the characters to be removed. str = \u0026#34; Hello, World! \u0026#34; print(str.rstrip()) # Output: Hello, World! str = \u0026#34;!!!!!!!!Hello, World!!!!!\u0026#34; print(str.rstrip(\u0026#34;!\u0026#34;)) # Output: !!!!!!!!Hello, World 1.2.8. f-Strings f-strings are a convenient way to format strings in Python. They allow you to embed expressions inside string literals, using curly braces {}. For example:\nname = \u0026#34;Alice\u0026#34; age = 30 print(f\u0026#34;My name is {name} and I am {age} years old.\u0026#34;) # Output: My name is Alice and I am 30 years old. 1.2.9. Raw Strings Raw strings are used to ignore escape characters in a string. They are prefixed with an r or R. For example:\npath=\u0026#34;C:\\Users\\Alice\\Documents\u0026#34; print(path) # Output: C:UsersAliceDocuments path = r\u0026#34;C:\\Users\\Alice\\Documents\u0026#34; print(path) # Output: C:\\Users\\Alice\\Documents Note:String is immutable in python.\na = \u0026#34;Hello\u0026#34; a[0] = \u0026#34;h\u0026#34; # Error: \u0026#39;str\u0026#39; object does not support item assignment #Instead To change the string value we can use the following method a=\u0026#39;k\u0026#39;+a[1::] # Output: \u0026#39;kello\u0026#39; 1.3. List Operations A list is a collection of items enclosed within square brackets []. Lists are mutable, meaning they can be changed after creation. Here are some common list operations: Key Points:\nList is mutable in python. List support indexing and slicing like string 1.3.1. Declaring a List We can declare a list by enclosing items within square brackets []. For example:\nlist1 = [1, 2, 3, 4, 5] list2 = [\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;] list3 = [1, \u0026#34;apple\u0026#34;, True, 3.14] 1.3.2 List Concatenation We can concatenate two or more lists using the + operator. For example:\nlist1 = [1, 2, 3] list2 = [4, 5, 6] print(list1 + list2) # Output: [1, 2, 3, 4, 5, 6] 1.3.3. Mutable property of List List is mutable in python and its example is shown below:\n#for string a = \u0026#34;Hello\u0026#34; a[0] = \u0026#34;h\u0026#34; # Error: \u0026#39;str\u0026#39; object does not support item assignment #for list list1 = [1, 2, 3] list1[0] = 10 print(list1) # Output: [10, 2, 3] 1.3.4. Built-in List Methods Python provides various built-in methods to manipulate lists. Some of the commonly used list methods are:\nlen() : Returns the length of the list. list1 = [1, 2, 3, 4, 5] print(len(list1)) # Output: 5 append() : Adds an element to the end of the list /Change orginal list does not return anything. list1 = [1, 2, 3] list1.append(4) print(list1) # Output: [1, 2, 3, 4] insert() : Inserts an element at a specified position in the list /Change orginal list does not return anything. list1 = [1, 2, 3] list1.insert(1, 4) print(list1) # Output: [1, 4, 2, 3] pop() : Removes the element at the specified position in the list and returns it. If no index is specified, it removes and returns the last element. list1 = [1, 2, 3] print(list1.pop(1)) # Output: 2 print(list1) # Output: [1, 3] print(list1.pop()) # Output: 3 print(list1) # Output: [1] remove() : Removes the first occurrence of the specified element from the list. list1 = [1, 2, 3, 2] list1.remove(2) print(list1) # Output: [1, 3, 2] -sort() : Sorts the list in ascending order.Does not return anything but change the original list.\nlist1 = [3, 1, 2] list1.sort() print(list1) # Output: [1, 2, 3] -reverse() : Reverses the order of the list. Does not return anything but change the original list.\nlist1 = [1, 2, 3] list1.reverse() print(list1) # Output: [3, 2, 1] -count() : Returns the number of occurrences of a specified element in the list.\nlist1 = [1, 2, 3, 2] print(list1.count(2)) # Output: 2 -index() : Returns the index of the first occurrence of the specified element in the list.\nlist1 = [1, 2, 3, 2] print(list1.index(2)) # Output: 1 1.3.5. List Comprehension List comprehension is a concise way to create lists from existing lists. There are 3 type of syntax.\nNot using if list1=[variable for variable in iterable] Using if only list1 = [variable for variable in iterable if condition] Using if else list1 = [variable if condition else variable for variable in iterable] Traditional way of creating list\nlist1 = [] for i in range(5): list1.append(i) print(list1) # Output: [0, 1, 2, 3, 4] Using list comprehension\nlist1 = [i for i in range(5)] print(list1) # Output: [0, 1, 2, 3, 4] list1 = [i for i in range(5) if i%2==0] print(list1) # Output: [0, 2, 4] list1 = [i if i%2==0 else i**2 for i in range(5)] print(list1) # Output: [0, 1, 2, 9, 4] Note: When you attempt to access an index that is out of range, Python will raise an IndexError so put it in try-except block to handle the error.\nNote: The indexing and slicing of list are similar to string.\n1.4 Dictionary Operations A dictionary is a collection of key-value pairs enclosed within curly braces {}. Dictionaries are mutable and unordered. Here are some common dictionary operations:\n1.4.1. Declaring a Dictionary We can declare a dictionary by specifying key-value pairs within curly braces {}. For example:\ndict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} dict2 = {1: \u0026#34;apple\u0026#34;, 2: \u0026#34;banana\u0026#34;, 3: \u0026#34;cherry\u0026#34;} dict3 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;, \u0026#34;hobbies\u0026#34;: [\u0026#34;reading\u0026#34;, \u0026#34;painting\u0026#34;]} 1.4.2. Accessing Dictionary Elements We can access dictionary elements using keys. For example:\ndict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} print(dict1[\u0026#34;name\u0026#34;]) # Output: Alice 1.4.3 Adding Dictionary Elements We can add new key-value pairs to a dictionary by specifying the key and value. For example:\ndict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30} dict1[\u0026#34;city\u0026#34;] = \u0026#34;New York\u0026#34; print(dict1) # Output: {\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 30, \u0026#39;city\u0026#39;: \u0026#39;New York\u0026#39;} 1.4.4. Updating Dictionary Elements We can update the value of an existing key in a dictionary. For example:\ndict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} dict1[\u0026#34;age\u0026#34;] = 35 print(dict1) # Output: {\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 35, \u0026#39;city\u0026#39;: \u0026#39;New York\u0026#39;} 1.4.5 Dictionary Methods Python provides various built-in methods to manipulate dictionaries. Some of the commonly used dictionary methods are:\nlen() : Returns the number of key-value pairs in the dictionary. dict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} print(len(dict1)) # Output: 3 keys() : Returns a list of all the keys in the dictionary. dict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} print(dict1.keys()) # Output: dict_keys([\u0026#39;name\u0026#39;, \u0026#39;age\u0026#39;, \u0026#39;city\u0026#39;]) values() : Returns a list of all the values in the dictionary. dict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} print(dict1.values()) # Output: dict_values([\u0026#39;Alice\u0026#39;, 30, \u0026#39;New York\u0026#39;]) items() : Returns a list of key-value pairs in the dictionary. dict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} print(dict1.items()) # Output: dict_items([(\u0026#39;name\u0026#39;, \u0026#39;Alice\u0026#39;), (\u0026#39;age\u0026#39;, 30), (\u0026#39;city\u0026#39;, \u0026#39;New York\u0026#39;)]) -pop() : Removes the element with the specified key and returns its value.\ndict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} print(dict1.pop(\u0026#34;age\u0026#34;)) # Output: 30 print(dict1) # Output: {\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;city\u0026#39;: \u0026#39;New York\u0026#39;} -get() : Returns the value of the specified key. If the key does not exist, it returns the specified default value.\ndict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} print(dict1.get(\u0026#34;age\u0026#34;)) # Output: 30 print(dict) # Output: {\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 30, \u0026#39;city\u0026#39;: \u0026#39;New York\u0026#39;} Note: When you attempt to access a key that does not exist in the dictionary, Python will raise a KeyError so put it in try-except block to handle the error or use get() method to avoid the error.\n1.4.6. Nested Dictionaries A dictionary can contain another dictionary as a value. This is known as a nested dictionary. For example:\ndict1 = { \u0026#34;person1\u0026#34;: {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30}, \u0026#34;person2\u0026#34;: {\u0026#34;name\u0026#34;: \u0026#34;Bob\u0026#34;, \u0026#34;age\u0026#34;: 25} } print(dict1[\u0026#34;person1\u0026#34;][\u0026#34;name\u0026#34;]) # Output: Alice 1.4.7. Dictionary Comprehension Dictionary comprehension is a concise way to create dictionaries. For example:\ndict1 = {x: x**2 for x in range(5)} # Output: {0: 0, 1: 1, 2: 4, 3: 9, 4: 16} #using if only dict1 = {x: x**2 for x in range(5) if x%2==0} # Output: {0: 0, 2: 4, 4: 16} #using if else dict1 = {x: x**2 if x%2==0 else x**3 for x in range(5)} # Output: {0: 0, 1: 1, 2: 4, 3: 27, 4: 16} 1.5. Tuple Operations A tuple is a collection of items enclosed within parentheses (). Tuples are immutable, meaning they similar to python as they cant be changed using indexing as a[0]=10 will give an error.\n1.5.1. Declaring a Tuple We can declare a tuple by enclosing items within parentheses (). For example:\ntuple1 = (1, 2, 3) tuple2 = (\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;) tuple3 = (1, \u0026#34;apple\u0026#34;, True, 3.14) 1.5.2. Accessing Tuple Elements We can access tuple elements using indexing . For example:\ntuple1 = (1, 2, 3) print(tuple1[0]) # Output: 1 1.5.3. Slice Tuple We can slice a tuple using the syntax variable[start:end:step] to get a sub-tuple. For example:\ntuple1 = (1, 2, 3, 4, 5) print(tuple1[1:4]) # Output: (2, 3, 4) 1.5.4. Tuple Methods Python provides various built-in methods to manipulate tuples. Some of the commonly used tuple methods are:\ncount() : Returns the number of occurrences of a specified element in the tuple. tuple1 = (1, 2, 3, 2) print(tuple1.count(2)) # Output: 2 index() : Returns the index of the first occurrence of the specified element in the tuple. tuple1 = (1, 2, 3, 2) print(tuple1.index(2)) # Output: 1 len() : Returns the length of the tuple. tuple1 = (1, 2, 3, 2) print(len(tuple1)) # Output: 4 1.5.5 concatenation of tuple We can concatenate two or more tuples using the + operator. For example:\ntuple1 = (1, 2, 3) tuple2 = (4, 5, 6) print(tuple1 + tuple2) # Output: (1, 2, 3, 4, 5, 6) 1.5.6. Tuple Unpacking Tuple unpacking allows us to assign multiple variables at once. For example:\ntuple1 = (1, 2, 3) a, b, c = tuple1 d,*e = tuple1 print(a) # Output: 1 print(b) # Output: 2 print(c) # Output: 3 print(d) # Output: 1 print(e) # Output: [2, 3] tuple1 = (1, 2, 3, 4, 5) a, *b, c = tuple1 print(a) # Output: 1 print(b) # Output: [2, 3, 4] print(c) # Output: 5 Note:Ascessing and slicing of tuple is similar to list and string.\n1.6. Boolean Operations Boolean is a data type that represents one of two values: True or False. Boolean values are used to evaluate conditions in programming. Here are some common boolean operations:\n1.6.1. Condition when variable is True When a variable has a non-zero value, it is considered True. a = 10 if a: print(\u0026#34;The value of a is True\u0026#34;) When a string is not empty, it is considered True. a = \u0026#34;Hello\u0026#34; if a: print(\u0026#34;The value of a is True\u0026#34;) When a list is not empty, it is considered True. a = [1, 2, 3] if a: print(\u0026#34;The value of a is True\u0026#34;) When a dictionary is not empty, it is considered True. a = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30} if a: print(\u0026#34;The value of a is True\u0026#34;) When a tuple is not empty, it is considered True. a = (1, 2, 3) if a: print(\u0026#34;The value of a is True\u0026#34;) When a set is not empty, it is considered True. a = {1, 2, 3} if a: print(\u0026#34;The value of a is True\u0026#34;) When a variable is explicitly set to True, it is considered True. a = True if a: print(\u0026#34;The value of a is True\u0026#34;) 1.6.2. Condition when variable is False Those which are not in the above condition are considered as False.\n1.7. Set Operations A set is a collection of unique items enclosed within curly braces {}. Main Uses of set are:\nTo remove duplicate elements from a list. To perform mathematical set operations like union, intersection, difference, etc. 1.7.1. Declaring a Set We can declare a set by enclosing items within curly braces {} or set(). For example:\nset1 = {1, 2, 3} set2 = {\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;} set3 = {1, \u0026#34;apple\u0026#34;, True, 3.14} #using set() set4 = set([1, 2, 3]) set5=set() 1.7.2. Set Methods Python provides various built-in methods to manipulate sets. Some of the commonly used set methods are:\n-len() : Returns the number of elements in the set.\nset1 = {1, 2, 3} print(len(set1)) # Output: 3 -add() : Adds an element to the set.Doesn\u0026rsquo;t return anything.\nset1 = {1, 2, 3} set1.add(4) print(set1) # Output: {1, 2, 3, 4} -clear() : Removes all elements from the set.Doesn\u0026rsquo;t return anything.\nset1 = {1, 2, 3} set1.clear() print(set1) # Output: set() -remove() : Removes the specified element from the set. If the element is not present, it raises an error.\nset1 = {1, 2, 3} set1.remove(2) print(set1) # Output: {1, 3} discard() : Removes the specified element from the set. If the element is not present, it does not raise an error.\nset1 = {1, 2, 3} set1.discard(2) print(set1) # Output: {1, 3} -union() : Returns a set containing the union of two sets.\nset1 = {1, 2, 3} set2 = {3, 4, 5} print(set1.union(set2)) # Output: {1, 2, 3, 4, 5} -intersection() : Returns a set containing the intersection of two sets.\nset1 = {1, 2, 3} set2 = {3, 4, 5} print(set1.intersection(set2)) # Output: {3} -difference() : Returns a set containing the difference between two sets.\nset1 = {1, 2, 3} set2 = {3, 4, 5} print(set1.difference(set2)) # Output: {1, 2} -symmetric_difference() : Returns a set containing the symmetric difference between two sets.\nset1 = {1, 2, 3} set2 = {3, 4, 5} print(set1.symmetric_difference(set2)) # Output: {1, 2, 4, 5} -issubset() : Returns True if all elements of a set are present in another set.\nset1 = {1, 2, 3} set2 = {1, 2, 3, 4, 5} print(set1.issubset(set2)) # Output: True 1.8 Used in All iterable 1.8.1. in Operator The in operator is used to check if an element is present in an iterable. For example:\n# in string str = \u0026#34;Hello, World!\u0026#34; print(\u0026#34;Hello\u0026#34; in str) # Output: True # in list list1 = [1, 2, 3, 4, 5] print(3 in list1) # Output: True # in tuple tuple1 = (1, 2, 3, 4, 5) print(6 in tuple1) # Output: False # in set set1 = {1, 2, 3, 4, 5} print(5 in set1) # Output: True # in dictionary dict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30} print(\u0026#34;name\u0026#34; in dict1) # Output: True 1.8.2. not in Operator The not in operator is used to check if an element is not present in an iterable. For example:\n# not in string str = \u0026#34;Hello, World!\u0026#34; print(\u0026#34;Alice\u0026#34; not in str) # Output: True # not in list list1 = [1, 2, 3, 4, 5] print(6 not in list1) # Output: True # not in tuple tuple1 = (1, 2, 3, 4, 5) print(5 not in tuple1) # Output: False # not in set set1 = {1, 2, 3, 4, 5} print(5 not in set1) # Output: False # not in dictionary dict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30} print(\u0026#34;name\u0026#34; not in dict1) # Output: False 1.8.3. len() Function The len() function is used to get the length of an iterable. For example:\n# for string str = \u0026#34;Hello, World!\u0026#34; print(len(str)) # Output: 13 # for list list1 = [1, 2, 3, 4, 5] print(len(list1)) # Output: 5 # for tuple tuple1 = (1, 2, 3, 4, 5) print(len(tuple1)) # Output: 5 # for set set1 = {1, 2, 3, 4, 5} print(len(set1)) # Output: 5 # for dictionary dict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30} print(len(dict1)) # Output: 2 1.8.4. max() and min() Functions The max() function is used to get the maximum value from an iterable, and the min() function is used to get the minimum value for list,string,set and tuples only. for dictionary you can use .keys() or .values() and use it. For example:\n# for list list1 = [1, 2, 3, 4, 5] print(max(list1)) # Output: 5 print(min(list1)) # Output: 1 # for tuple tuple1 = (1, 2, 3, 4, 5) print(max(tuple1)) # Output: 5 print(min(tuple1)) # Output: 1 # for string string = \u0026#34;Hello, World!\u0026#34; print(max(string)) # Output: r print(min(string)) # Output: \u0026#39; \u0026#39; # for set set1 = {1, 2, 3, 4, 5} print(max(set1)) # Output: 5 print(min(set1)) # Output: 1 1.8.5. join() Function The join() function is used to concatenate elements of an iterable with a separator. For example:\n# for list list1 = [\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;] print(\u0026#34;, \u0026#34;.join(list1)) # Output: apple, banana, cherry # for tuple tuple1 = (\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;) print(\u0026#34;, \u0026#34;.join(tuple1)) # Output: apple, banana, cherry # for set set1 = {\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;} print(\u0026#34;, \u0026#34;.join(set1)) # Output: apple, banana, cherry # for string string = \u0026#34;Hello, World!\u0026#34; print(\u0026#34;, \u0026#34;.join(string)) # Output: H, e, l, l, o, ,, , W, o, r, l, d, ! ","permalink":"http://localhost:1313/posts/pages/python/python_datatype_operations/","summary":"An in-depth look at Python data types, exploring their usage and importance in programming.","title":"Python Fundamentals: Understanding Data Types (Part 2)"},{"content":"22. Fragments in React Fragments are a way to group multiple elements in React without adding extra nodes to the DOM. Fragments are useful when you want to return multiple elements from a component, but you don\u0026rsquo;t want to add an extra div or span element to the DOM.\nFragments are represented by the \u0026lt;Fragment\u0026gt; tag or the shorthand syntax \u0026lt;\u0026gt;. You can use fragments to return multiple elements from a component without adding extra nodes to the DOM.\nWithout using fragments:\nfunction App() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Hello, World!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;Welcome to React\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } Here, the App component returns two elements, but they are wrapped in a div element. If you don\u0026rsquo;t want to add an extra div element to the DOM, you can use fragments.\nUsing fragments:\nfunction App() { return ( \u0026lt;\u0026gt; or \u0026lt;Fragment\u0026gt; \u0026lt;h1\u0026gt;Hello, World!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;Welcome to React\u0026lt;/p\u0026gt; \u0026lt;/\u0026gt; or \u0026lt;/Fragment\u0026gt; ); } 23. Passing jsx as props In React, you can pass JSX as props to other components. This allows you to create reusable components that can be used in different parts of your application.\nPassing JSX as props: function App() { const heading = \u0026lt;div\u0026gt;\u0026lt;h1\u0026gt;Hello, World!\u0026lt;/h1\u0026gt;\u0026lt;p\u0026gt;My name is nirajan Khatiwada\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;; return \u0026lt;Greeting message={heading} /\u0026gt;; } or function App() { return \u0026lt;Greeting message={\u0026lt;div\u0026gt;\u0026lt;h1\u0026gt;Hello, World!\u0026lt;/h1\u0026gt;\u0026lt;p\u0026gt;My name is nirajan Khatiwada\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;} /\u0026gt;; } Using props in the Greeting component: function Greeting(props) { return \u0026lt;div\u0026gt;{props.message}\u0026lt;/div\u0026gt;; } Passing built-in components as props: function App() { return \u0026lt;Greeting element=\u0026#34;button\u0026#34; /\u0026gt;; } 24. Isolation of Component in React Isolation of components is a key concept in React that allows you to create reusable components that are independent of each other. This means that each component should be self-contained and not rely on external data or state.\nfor example:\nfunction Button(props){ const [showText, setShowText] = useState(false); return ( \u0026lt;button onClick={() =\u0026gt; setShowText(!showText)}\u0026gt; {showText ? \u0026#39;Hide Text\u0026#39; : \u0026#39;Show Text\u0026#39;} \u0026lt;/button\u0026gt; ); } function App(){ return ( \u0026lt;div\u0026gt; \u0026lt;Button /\u0026gt; \u0026lt;Button /\u0026gt; \u0026lt;/div\u0026gt; ); } Here The component Button is isolated means one state of the component does not affect the other component. Each component is self-contained and does not rely on external data or state. for example, the showText state in one Button component does not affect the showText state in the other Button component.\n25. Taking User Input in React Using onChange event: function App() { const [name, setName] = useState(\u0026#39;\u0026#39;); const handleChange = (e) =\u0026gt; { setName(e.target.value); }; return ( \u0026lt;div\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; value={name} onChange={handleChange} /\u0026gt; \u0026lt;p\u0026gt;Hello, {name}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } Whats Happen Here\nHere, we have an input element that takes user input. When the user types in the input field,the onChange event is triggered for ervy keypress. The handleChange function is called with the event object as an argument for every keypress. The setName function is called with value of user input and it rerender the component with the updated value for every keypress. The value of the input field is set to the name state, and the name is displayed below the input field. Note: use onChange event to take user input in React and update the state accordingly to reflect the changes in the UI. If you use value as a prop in the input field, you must also provide an onChange event handler to update the state. Use this method if you want to update in real-time as the user types in the input field.\nOther method will be discussed in upcoming posts. 26.Rendering 2D Arrays in React In React, you can render 2D arrays by using nested map functions to iterate over the rows and columns of the array. This allows you to display tabular data or grid-like structures in your application.\nRendering a 2D array: function App() { const data = [ [\u0026#39;John\u0026#39;, \u0026#39;Doe\u0026#39;, 30], [\u0026#39;Jane\u0026#39;, \u0026#39;Smith\u0026#39;, 25], [\u0026#39;Alice\u0026#39;, \u0026#39;Brown\u0026#39;, 35], ]; return ( \u0026lt;table\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;First Name\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Last Name\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Age\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; {data.map((row, index) =\u0026gt; ( \u0026lt;tr key={index}\u0026gt; {row.map((cell, index) =\u0026gt; ( \u0026lt;td key={index}\u0026gt;{cell}\u0026lt;/td\u0026gt; ))} \u0026lt;/tr\u0026gt; ))} \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; ); } 27. Immutable update patterns in React In react while changing the state we shouldnot change the orginal state directly Instead, we should create a new copy of the state and update the copy with the new values. This is known as immutable update pattern.speciaaly when working with arrays and objects.\nThe Wrong way to update state: function App() { const [items, setItems] = useState([\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;cherry\u0026#39;]); const removeItem = (index) =\u0026gt; { items.splice(index, 1); setItems(items); }; return ( \u0026lt;div\u0026gt; \u0026lt;ul\u0026gt; {items.map((item, index) =\u0026gt; ( \u0026lt;li key={index}\u0026gt; {item} \u0026lt;button onClick={() =\u0026gt; removeItem(index)}\u0026gt;Remove\u0026lt;/button\u0026gt; \u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ); } The Correct way to update state: function App() { const [items, setItems] = useState([\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;cherry\u0026#39;]); const removeItem = (index) =\u0026gt; { const newItems = [...items]; newItems.splice(index, 1); setItems(newItems); }; return ( \u0026lt;div\u0026gt; \u0026lt;ul\u0026gt; {items.map((item, index) =\u0026gt; ( \u0026lt;li key={index}\u0026gt; {item} \u0026lt;button onClick={() =\u0026gt; removeItem(index)}\u0026gt;Remove\u0026lt;/button\u0026gt; \u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt;x x \u0026lt;/div\u0026gt; ); } Note: Always create a new copy of the state when updating arrays or objects in React. This ensures that the state is updated correctly and prevents unexpected behavior in your application. 28. Common Pattern for update,delete and add in React In React, you can use common patterns to update, delete, and add items to an array. These patterns involve creating new copies of the array and updating the state with the new values.\nAdd an item to an array: function App() { const [items, setItems] = useState([\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;cherry\u0026#39;]); const addItem = (item) =\u0026gt; { setItems([...items, item]); // or // const newItems = [...items]; // newItems.push(item); // setItems(newItems); }; return ( \u0026lt;div\u0026gt; \u0026lt;ul\u0026gt; {items.map((item, index) =\u0026gt; ( \u0026lt;li key={index}\u0026gt;{item}\u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;button onClick={() =\u0026gt; addItem(\u0026#39;orange\u0026#39;)}\u0026gt;Add Item\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } Deleting an item from an array: function App() { const [items, setItems] = useState([\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;cherry\u0026#39;]); const removeItem = (index) =\u0026gt; { const newItems = items.filter((item, i) =\u0026gt; i !== index); setItems(newItems); }; return ( \u0026lt;div\u0026gt; \u0026lt;ul\u0026gt; {items.map((item, index) =\u0026gt; ( \u0026lt;li key={index}\u0026gt; {item} \u0026lt;button onClick={() =\u0026gt; removeItem(index)}\u0026gt;Remove\u0026lt;/button\u0026gt; \u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ); } Updating an data of an array using map: function App() { const [items, setItems] = useState([ { id: 1, name: \u0026#39;apple\u0026#39;, price: 1 }, { id: 2, name: \u0026#39;banana\u0026#39;, price: 2 }, { id: 3, name: \u0026#39;cherry\u0026#39;, price: 3 }, ]); const updateItem = (id, price) =\u0026gt; { const newItems = items.map((item) =\u0026gt; item.id === id ? { ...item, price: price } : item ); setItems(newItems); }; return ( \u0026lt;div\u0026gt; \u0026lt;ul\u0026gt; {items.map((item) =\u0026gt; ( \u0026lt;li key={item.id}\u0026gt; {item.name} - ${item.price}{\u0026#39; \u0026#39;} \u0026lt;button onClick={() =\u0026gt; updateItem(item.id, item.price + 1)}\u0026gt; Increase Price \u0026lt;/button\u0026gt; \u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ); } Updating an data of an array using find: function App() { const [items, setItems] = useState([ { id: 1, name: \u0026#39;apple\u0026#39;, price: 1 }, { id: 2, name: \u0026#39;banana\u0026#39;, price: 2 }, { id: 3, name: \u0026#39;cherry\u0026#39;, price: 3 }, ]); const updateItem = (id, price) =\u0026gt; { const newItems= [...items]; const newItem = newItems.find((item) =\u0026gt; item.id === id); if (newItem) { newItem.price = price; setItems(newItems); } }; return ( \u0026lt;div\u0026gt; \u0026lt;ul\u0026gt; {items.map((item) =\u0026gt; ( \u0026lt;li key={item.id}\u0026gt; {item.name} - ${item.price}{\u0026#39; \u0026#39;} \u0026lt;button onClick={() =\u0026gt; updateItem(item.id, item.price + 1)}\u0026gt; Increase Price \u0026lt;/button\u0026gt; \u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ); } Note: Always prefer map over find when updating an array of objects in React. This ensures that the state is updated correctly and prevents unexpected behavior in your application.\n29.Updating object in react In React, you can update an object in state by creating a new copy of the object and updating the copy with the new values. This ensures that the state is updated correctly and prevents unexpected behavior in your application.\nUpdating an object in state: function App() { const [person, setPerson] = useState({ name: \u0026#39;John\u0026#39;, age: 30 }); const updatePerson = () =\u0026gt; { setPerson({ ...person, age: person.age + 1 }); }; return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;Name: {person.name}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Age: {person.age}\u0026lt;/p\u0026gt; \u0026lt;button onClick={updatePerson}\u0026gt;Increase Age\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } use list if you want to show the list of items and use object if you want to show the details of the item to identify which one is clicked or update you can pass the index or id of the item to the function. Or you can hardcode the value to update the object or list.\n","permalink":"http://localhost:1313/posts/pages/react/react3/","summary":"A comprehensive guide covering React\u0026rsquo;s advanced concepts including Fragments, JSX Props, Component Isolation, and proper state management patterns","title":"React : Day 3"},{"content":"Python Control Structures: Mastering Loops and Conditionals In Python programming, control structures are essential for managing the flow of execution in your code. They allow you to make decisions, repeat tasks, and create complex algorithms. In this guide, we will explore two fundamental control structures in Python: loops and conditionals.\n1. Conditional Statements Conditional statements in Python allow you to execute specific blocks of code based on certain conditions. The most common conditional statements are if, elif, and else.\n1.1. The if Statement The if statement is used to check a condition and execute a block of code if the condition is true.\nExample:\nx = 10 if x \u0026gt; 5: print(\u0026#34;x is greater than 5\u0026#34;) Output:\nx is greater than 5 1.2. The elif Statement The elif statement allows you to check multiple conditions after the initial if statement. If the previous conditions are false, the elif block is evaluated.\nExample:\nx = 5 if x \u0026gt; 5: print(\u0026#34;x is greater than 5\u0026#34;) elif x == 5: print(\u0026#34;x is equal to 5\u0026#34;) Output:\nx is equal to 5 1.3. The else Statement The else statement is used to execute a block of code when all the previous conditions are false.\nExample:\nx = 3 if x \u0026gt; 5: print(\u0026#34;x is greater than 5\u0026#34;) elif x == 5: print(\u0026#34;x is equal to 5\u0026#34;) else: print(\u0026#34;x is less than 5\u0026#34;) Output:\nx is less than 5 2. Loops Loops in Python allow you to execute a block of code repeatedly. There are two main types of loops in Python: for loops and while loops.\n2.1. The while Loop The while loop executes a block of code as long as a specified condition is true.\nSyntax:\nwhile condition: # Code block else: # Optional else block Example:\ncount = 0 while count \u0026lt; 5: print(count) count += 1 else: print(\u0026#34;Loop completed\u0026#34;) 2.2. The for Loop The for loop is used to iterate over a sequence (such as a list, tuple, or string) and execute a block of code for each item in the sequence.\nSyntax:\nfor item in sequence: # Code block else: # Optional else block Example:\nfruits = [\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;] for fruit in fruits: print(fruit) else: print(\u0026#34;No more fruits\u0026#34;) 2.3 Using For Loops with different data types 2.3.1. For Loop with Strings Example:\nfor char in \u0026#34;Python\u0026#34;: print(char) Output:\np\ry\rt\rh\ro\rn 2.3.2. For Loop with Lists Example:\nnumbers = [1, 2, 3, 4, 5] for num in numbers: print(num) Output:\n1\r2\r3\r4\r5 2.3.3. For Loop with tuples Example:\nfruits = (\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;) for fruit in fruits: print(fruit) Output:\napple\rbanana\rcherry Tuple unpacking can also be used in for loops to iterate over multiple values in a tuple.\ncoordinates = [(1, 2), (3, 4), (5, 6)] for x, y in coordinates: print(f\u0026#34;X: {x}, Y: {y}\u0026#34;) Output:\nX: 1, Y: 2\rX: 3, Y: 4\rX: 5, Y: 6 2.3.4. For Loop with Sets Example:\ncolors = {\u0026#34;red\u0026#34;, \u0026#34;green\u0026#34;, \u0026#34;blue\u0026#34;} for color in colors: print(color) Output:\nred\rgreen\rblue 2.3.5. For Loop with Dictionaries Example:\nperson = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} for key, value in person.items(): print(f\u0026#34;{key}: {value}\u0026#34;) Output:\nname: Alice\rage: 30\rcity: New York 2.4. break , pass and continue statements in loops 2.4.1. The break Statement The break statement is used to exit a loop prematurely. It terminates the current loop and resumes execution at the next statement after the loop.\nExample:\nfor num in [1, 2, 3, 4, 5]: if num == 3: break print(num) Output:\n1\r2 2.4.2. The continue Statement The continue statement is used to skip the rest of the code inside a loop for the current iteration and jump to the next iteration.\nExample:\nfor num in [1, 2, 3, 4, 5]: if num == 3: continue print(num) Output:\n1\r2\r4\r5 2.4.3. The pass Statement The pass statement is a null operation that does nothing. It is used when a statement is required syntactically but you do not want any code to execute.\nExample:\nfor num in [1, 2, 3, 4, 5]: pass ","permalink":"http://localhost:1313/posts/pages/python/python_control_structure/","summary":"A detailed examination of Python\u0026rsquo;s control structures, focusing on loops and conditionals to enhance your programming skills.","title":"Python Fundamentals: Mastering Control Structures (Part 3)"},{"content":"17. Hooks in React Anythong that start with prefix use is considered as a hook in react\n17.1. Rules of Hooks Only Call Hook inside a component function correct:\nfunction App() { const [val, setVal] = useState(0); } Incorrect:\nconst [val, setVal] = useState(0); function App() { } Only Call Hooks at the Top Level Hook must not be called inside code statement (e.g., inside an if statement, loop, or nested function). correct: function App() { const [val, setVal] = useState(0); } incorrect:\nfunction App() { if (true) { const [val, setVal] = useState(0); } } 3.Hook can be used inside other custom hooks too\n18. useState Hook useState is a React hook that allows you to manage component-specific state. It provides a way to declare state variables in functional components and ensure that changes to these variables cause the component or child component to re-render while the parent component remains unaffected from where the component whose set state is triggered.\nfor example:\nfunction App() { return ( \u0026lt;div\u0026gt; \u0026lt;MemoComp /\u0026gt; \u0026lt;/div\u0026gt; ); } function MemoComp() { const [data, setData] = useState(\u0026#34;No data\u0026#34;); function handle() { setData(\u0026#34;data\u0026#34;); } return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;{data}\u0026lt;/p\u0026gt; \u0026lt;button onClick={handle}\u0026gt;Click me\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } When button is clicked the handle function is called and the setData function is called which updates the data state variable. This cause the MemoComp and its child component to re-render with a new value of data.\n18.1. Syntax const [state, setState] = useState(initialState); 18.2. Managing State State management in React involves handling data and telling React to re-execute a function using the useState hook. This ensures that state updates lead to new state values. Example:\nconst [countes, setcountes] = useState(0); countes is the state variable that holds the current state value. setcountes is the function that updates the state variable. useState(0) is the initial state value. How it works: Initially, the state variable countes is set to 0. When the setcountes function is called, it updates the state variable to a new value. This triggers a re-render of the component, updating the UI with the new state value.\n18.3 Updating State Based on Previous State Suppose the age is 42. The handler calls setAge(age + 1) three times.\nfunction handleClick() { setAge(age + 1); // setAge(42 + 1) setAge(age + 1); // setAge(42 + 1) setAge(age + 1); // setAge(42 + 1) } if the initial age is 42, after calling this function, the age will be 43, not 45.\nTo solve this problem, we use an updater function to pass setAge calls.\nfunction handleClick() { setAge(a =\u0026gt; a + 1); // setAge(42 =\u0026gt; 43) setAge(a =\u0026gt; a + 1); // setAge(43 =\u0026gt; 44) setAge(a =\u0026gt; a + 1); // setAge(44 =\u0026gt; 45) } After this age will be 45 so use updater function when you want to update value based on previous value \u0026amp; it\u0026rsquo;s always recommended to use updater function in.\nIt is mostly used in:\nCounters Toggles Incrementing or decrementing a value 18.4. Pitfalls in useState In React state updates are asynchronous meaning they don\u0026rsquo;t immediately reflect in the current execution cycle. When you call a state setter function like setSelectedValue, React schedules the state update for the next render. This can lead to unexpected behavior if you try to access the updated state immediately after setting it.\nExample: function clickHandler(data) { setSelectedValue(`${data} is being clicked`); console.log(selectedTopic); // logs the old state, not updated one } Why It Happens State updates are asynchronous: React batches state updates and applies them during the next render cycle to optimize performance. Therefore, the state change you request won’t be immediately reflected in the current execution.\nLogging state immediately: Since the update happens after the current execution cycle, logging the state/selected topic immediately after calling setSelectedValue will show the old value (before the update).\nThis can be fixed using useEffect which is read later.\nNote: Always use the state variable when you want to reflect the changes in the UI.\n19. An Example demostrating useState Hook import {useState} from \u0026#39;react\u0026#39;; function App(){ const [count,setCount] = useState(0); return(){ \u0026lt;div\u0026gt; {count} \u0026lt;/div\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;Increment\u0026lt;/button\u0026gt; } } export default App; In the above example, we have a functional component App that uses the useState hook to manage the state of the count variable. The initial value of count is set to 0 using useState(0). The setCount function is used to update the value of count when the button is clicked. The count value is displayed in the UI, and clicking the button increments the count value by 1.\n20.Conditional Rendering in React Conditional rendering is a technique used to render different components or elements based on certain conditions. In React, conditional rendering can be achieved using ternary operators, and logical operators like \u0026amp;\u0026amp; .\n20.1. Ternary Operator The ternary operator is a concise way to write conditional statements in JavaScript. It consists of a condition followed by a question mark ?, an expression to execute if the condition is true, a colon :, and an expression to execute if the condition is false.\nExample:\nfunction App() { const isLoggedIn = true; return ( \u0026lt;div\u0026gt; {isLoggedIn ? \u0026lt;p\u0026gt;Welcome, User!\u0026lt;/p\u0026gt; : \u0026lt;p\u0026gt;Please log in\u0026lt;/p\u0026gt;} \u0026lt;/div\u0026gt; ); } Also We can write jsx code in variable and use it in return statement\nfunction App() { const isLoggedIn = true; const welcomeMessage=\u0026lt;p\u0026gt;Welcome, User!\u0026lt;/p\u0026gt;; const loginMessage=\u0026lt;p\u0026gt;Please log in\u0026lt;/p\u0026gt;; return ( \u0026lt;div\u0026gt; {isLoggedIn ? welcomeMessage : loginMessage} \u0026lt;/div\u0026gt; ); } 20.2. Logical \u0026amp;\u0026amp; Operator The logical \u0026amp;\u0026amp; operator is another way to conditionally render elements in React. The \u0026amp;\u0026amp; operator works by evaluating the expression on the left side of the \u0026amp;\u0026amp; operator. If the expression is true, the expression on the right side of the \u0026amp;\u0026amp; operator is executed. If the expression is false, the right side is not executed.\nExample:\nfunction App() { const isLoggedIn = true; return ( \u0026lt;div\u0026gt; {isLoggedIn \u0026amp;\u0026amp; \u0026lt;p\u0026gt;Welcome, User!\u0026lt;/p\u0026gt;} {isLoggedIn \u0026amp;\u0026amp; \u0026lt;button\u0026gt;Logout\u0026lt;/button\u0026gt;} {!isLoggedIn \u0026amp;\u0026amp; \u0026lt;p\u0026gt;Please log in\u0026lt;/p\u0026gt;} \u0026lt;/div\u0026gt; ); } Also We can write jsx code in variable and use it in return statement\nfunction App() { const isLoggedIn = true; const welcomeMessage=\u0026lt;p\u0026gt;Welcome, User!\u0026lt;/p\u0026gt;; const logoutButton=\u0026lt;button\u0026gt;Logout\u0026lt;/button\u0026gt;; const loginMessage=\u0026lt;p\u0026gt;Please log in\u0026lt;/p\u0026gt;; return ( \u0026lt;div\u0026gt; {isLoggedIn \u0026amp;\u0026amp; welcomeMessage} {isLoggedIn \u0026amp;\u0026amp; logoutButton} {!isLoggedIn \u0026amp;\u0026amp; loginMessage} \u0026lt;/div\u0026gt; ); } 21.Outputting list data dynamically In react we use map function to output list data dynamically as using map.\n21.1. Have a list of data You typically store the list in an array, which might come from a state, props, or external data source like an API\nconst data = [ { id: 1, name: \u0026#34;John\u0026#34; }, { id: 2, name: \u0026#34;Doe\u0026#34; }, { id: 3, name: \u0026#34;Jane\u0026#34; }, ]; 21.2 Using map function to output list data const listItems = data.map((item) =\u0026gt; \u0026lt;li key={item.id}\u0026gt;{item.name}\u0026lt;/li\u0026gt;); Key is used to uniquely identify each element in the list. It helps React identify which items have changed, are added, or are removed.It can be number or string.\n21.3. Rendering the list Use {} to embed the transformed list inside your component’s JSX.\n\u0026lt;ul\u0026gt;{listItems}\u0026lt;/ul\u0026gt;; 21.4. Putting it all together function App() { const data = [ { id: 1, name: \u0026#34;John\u0026#34; }, { id: 2, name: \u0026#34;Doe\u0026#34; }, { id: 3, name: \u0026#34;Jane\u0026#34; }, ]; const listItems = data.map((item) =\u0026gt; \u0026lt;li key={item.id}\u0026gt;{item.name}\u0026lt;/li\u0026gt;); return \u0026lt;ul\u0026gt;{listItems}\u0026lt;/ul\u0026gt;; } 21.5 Another form function App() { const data = [ { id: 1, name: \u0026#34;John\u0026#34; }, { id: 2, name: \u0026#34;Doe\u0026#34; }, { id: 3, name: \u0026#34;Jane\u0026#34; }, ]; return \u0026lt;ul\u0026gt;{data.map((item) =\u0026gt; \u0026lt;li key={item.id}\u0026gt;{item.name}\u0026lt;/li\u0026gt;); }\u0026lt;/ul\u0026gt;; } When will Rerender Occur?\nWhen state varaible or props value changes ","permalink":"http://localhost:1313/posts/pages/react/react1/","summary":"A detailed guide to help you understand and use hooks in React effectively.","title":"React : Day 2"},{"content":"Python Fundamentals: Exploring Advanced Operations (Part 4) In Python programming, advanced operations allow you to perform complex tasks efficiently. These operations include working with ranges, enumerations, zip functions, and more. In this guide, we will explore various advanced operations in Python to enhance your programming skills.\n1. Ranges Ranges in Python are used to generate a sequence of numbers. They are commonly used in loops to iterate over a specific range of values. Ranges can be created using the range() function.\n1.1. Creating a Range To create a range of numbers, you can use the range() function with the desired start, stop, and step values where start number is in inclusive and stop number is exclusive.\nExample:\n# Generate a range of numbers from 0 to 9 for i in range(10): print(i) Output:\n0\r1\r2\r3\r4\r5\r6\r7\r8\r9 Example:\n# Generate a range of numbers from 1 to 10 with a step of 2 for i in range(0, 10,2): print(i) Output:\n0\r2\r4\r6\r8 1.2 Enumerate Function The enumerate() function in Python is used to iterate over a sequence while keeping track of the index and value of each item. It returns a tuple containing the index and the value of the item.\nExample:\n# Enumerate a list of fruits fruits = [\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;cherry\u0026#39;] for index, fruit in enumerate(fruits): print(index, fruit) Output:\n0 apple\r1 banana\r2 cherry Example:\na=\u0026#34;nirajan\u0026#34; for index, char in enumerate(a): print(index, char) Output:\n0 n\r1 i\r2 r\r3 a\r4 j\r5 a\r6 n 1.3. Zip Function The zip() function in Python is used to combine multiple iterables (such as lists) element-wise. It returns an iterator of tuples where the i-th tuple contains the i-th element from each of the input iterables.\nExample:\n# Zip two lists together names = [\u0026#39;Alice\u0026#39;, \u0026#39;Bob\u0026#39;, \u0026#39;Charlie\u0026#39;] ages = [25, 30, 35] for name, age in zip(names, ages): print(name, age) Output:\nAlice 25\rBob 30\rCharlie 35 Example:\na=[1,2,3] b=[4,5,6] c=[7,8,9] print(list(zip(a,b,c))) Output:\n[(1, 4, 7), (2, 5, 8), (3, 6, 9)] 1.5 Sorted Function The sorted() function in Python is used to sort a list of elements. It returns a new sorted list without modifying the original list.The main feature of the sorted() function is that it can take a key argument that specifies a function to be called on each list element prior to making comparisons.\nExample:\n# Sort a list of numbers numbers = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5] sorted_numbers = sorted(numbers) print(sorted_numbers) Output:\n[1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] Example:\n# Sort a list of strings based on the length of the string fruits = [\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;cherry\u0026#39;, \u0026#39;date\u0026#39;] sorted_fruits = sorted(fruits, key=len) print(sorted_fruits) Output:\n[\u0026#39;date\u0026#39;, \u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;cherry\u0026#39;] Example:\n#Sort an dictionary based on the value d = {\u0026#39;apple\u0026#39;: 10, \u0026#39;banana\u0026#39;: 5, \u0026#39;cherry\u0026#39;: 15} sorted_d = sorted(d.items(), key=lambda x: x[1]) print(sorted_d) Output:\n[(\u0026#39;banana\u0026#39;, 5), (\u0026#39;apple\u0026#39;, 10), (\u0026#39;cherry\u0026#39;, 15)] Example:\n#Sort a list of tuples based on the second element t = [(1, 2), (3, 1), (5, 6)] sorted_t = sorted(t, key=lambda x: x[1]) print(sorted_t) Output:\n[(3, 1), (1, 2), (5, 6)] #2. Import in Python In Python, the import statement is used to import modules or packages into your script. It allows you to use functions, classes, and variables defined in other modules in your code.\n2.1. Importing Modules To import a module in Python, you can use the import keyword followed by the module name. You can then access the functions, classes, and variables defined in the module using dot notation.\nExample:\n# Import the math module import math # Calculate the square root of a number x = 16 print(math.sqrt(x)) Output:\n4.0 Example:\n# Import the datetime module import datetime # Get the current date and time now = datetime.datetime.now() print(now) Output:\n2024-11-17 10:30:00 2.2. Importing Specific Functions You can import specific functions or variables from a module using the from keyword. This allows you to use the imported functions directly without using the module name.\nExample:\n# Import the pi constant from the math module from math import pi # Print the value of pi print(pi) Output:\n3.141592653589793 Example:\n# Import the date class from the datetime module from datetime import date # Get the current date today = date.today() print(today) Output:\n2024-11-17 2.3. Aliasing Modules You can alias a module or package by using the as keyword. This allows you to refer to the module by a different name in your code.\nExample:\n# Import the math module and alias it as m import math as m # Calculate the square root of a number x = 25 print(m.sqrt(x)) Output:\n5.0 Example:\n# Import the datetime module using import and from and alias it as dt from datetime import datetime as dt now = dt.now() print(now) Output:\n2024-11-17 10:30:00 2.4. Importing All Functions You can import all functions and variables from a module using the * operator. This imports all the functions and variables defined in the module.\nExample:\n# Import all functions from the math module from math import * # Calculate the square root of a number x = 36 print(sqrt(x)) Output:\n6.0 The General Syntax is\nfrom module_name.submodule_name.submodule_name... import funtion_name or variable_name or filename as alias_name\nrandom module The random module in Python is used to generate random numbers. It provides various functions to generate random integers, floating-point numbers, and sequences.\n1. Generating Random Numbers The random module provides functions to generate random numbers within a specified range which can contain both integers starting and ending number.\nExample:\nfrom random import randint # Generate a random integer between 1 and 10 random_number = randint(1, 10) print(random_number) Output:\n5 2.Shuffling a List The random module provides a function to shuffle the elements of a list randomly. It modifies the original list in place.\nExample:\nfrom random import shuffle # Shuffle a list of numbers numbers = [1, 2, 3, 4, 5] shuffle(numbers) print(numbers) Output:\n[3, 1, 5, 2, 4] ","permalink":"http://localhost:1313/posts/pages/python/python_advanced_operations/","summary":"An in-depth exploration of advanced Python operations to enhance your programming skills.","title":"Python Fundamentals: Exploring Advanced Operations (Part 4)"},{"content":"Python Fundamentals: Understanding Functions In Python programming, functions are essential building blocks that allow you to organize and reuse code effectively. Functions help break down complex problems into smaller, manageable tasks, making your code more readable and maintainable. In this guide, we will explore the fundamentals of Python functions, including their syntax, parameters, return values, and more.\n1. Defining Functions A function in Python is defined using the def keyword followed by the function name and parentheses. You can also specify parameters inside the parentheses if the function requires input values.\nSyntax:\ndef function_name(parameters): # Function body # Statements Example:\ndef greet(): print(\u0026#34;Hello, World!\u0026#34;) 2. Calling Functions To call a function in Python, you simply write the function name followed by parentheses. If the function requires input values, you can pass them inside the parentheses.\nSyntax:\nfunction_name(arguments) Example:\ngreet() 3. return Statement The return statement in Python is used to exit a function and return a value to the caller. You can use the return statement to send a result back to the calling code.\nSyntax:\ndef function_name(parameters): # Function body return value Demostration using all:\ndef add_numbers(a, b): return a + b result = add_numbers(5, 3) print(result) 4. Args , Default Args and Kwargs 4.1. Args Using Args you can pass any number of arguments to a function. The arguments are passed as a tuple.\nSyntax:\ndef function_name(*args): # Function body Example:\ndef display_args(*args): print(args) display_args(1, 2, 3, 4, 5) Output:\n(1, 2, 3, 4, 5) 4.2. Default Args Default arguments are used when you do not pass a value for an argument in the function call. If a value is not provided, the default value is used.\nSyntax:\ndef function_name(arg=value): # Function body Example:\ndef add(a,b,c=0): return a+b+c result = add(5,3) print(result) result = add(5,3,2) print(result) Output:\n8\r10 4.3. Kwargs Using Kwargs you can pass any number of keyword arguments to a function. The arguments are passed as a dictionary.\nSyntax:\ndef function_name(**kwargs): # Function body Example:\ndef display_kwargs(**kwargs): print(kwargs) display_kwargs(name=\u0026#34;Alice\u0026#34;, age=30, city=\u0026#34;New York\u0026#34;) Output:\n{\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 30, \u0026#39;city\u0026#39;: \u0026#39;New York\u0026#39;} 4.4. Combination of Args and Kwargs Example:\ndef display_args_kwargs(*args, **kwargs): print(args) print(kwargs) display_args_kwargs(1, 2, 3, name=\u0026#34;Alice\u0026#34;, age=30) Output:\n(1, 2, 3)\r{\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 30} 4.5. Unpacking Args and Kwargs Example:\ndef display_args_kwargs(*args, **kwargs): print(args) print(kwargs) args = (1, 2, 3) kwargs = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30} display_args_kwargs(*args, **kwargs) Output:\n(1, 2, 3)\r{\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 30} 5. Lambda Functions Lambda functions, also known as anonymous functions, are small, single-expression functions that do not require a name. They are defined using the lambda keyword.\nSyntax:\nlambda arguments: expression Example:\nadd = lambda a, b: a + b result = add(5, 3) print(result) Output:\n8 6.Map and filter functions 6.1. Map Function The map() function in Python applies a given function to each item of an iterable (such as a list, tuple, or set) and returns a new iterable with the results.\nSyntax:\nmap(function, iterable) Example:\nnumbers = [1, 2, 3, 4, 5] squared = map(lambda x: x ** 2, numbers) print(list(squared)) Output:\n[1, 4, 9, 16, 25] 6.2. Filter Function The filter() function in Python filters elements from an iterable based on a given function. It returns an iterator with the elements that satisfy the condition.\nSyntax:\nfilter(function, iterable) Example:\nnumbers = [1, 2, 3, 4, 5] even = filter(lambda x: x % 2 == 0, numbers) print(list(even)) Output:\n[2, 4] 7.Local and Global Variables 7.1. Local Variables Local variables are defined within a function and are only accessible within that function. They are created when the function is called and destroyed when the function exits.\nExample:\ndef display(): message = \u0026#34;Hello, World!\u0026#34; print(message) display() # Trying to access the local variable outside the function will result in an error print(message) # NameError: name \u0026#39;message\u0026#39; is not defined 7.2. Global Variables Global variables are defined outside any function and can be accessed from any part of the code. You can use the global keyword to modify a global variable inside a function.\nExample:\nmessage = \u0026#34;Hello, World!\u0026#34; def display(): print(message) display() # Modifying a global variable inside a function def change_message(): global message message = \u0026#34;Hello, Python!\u0026#34; change_message() print(message) Output:\nHello, World!\rHello, Python! 7.3. Local vs. Global Variables If a local variable has the same name as a global variable, the local variable takes precedence within the function scope.\nExample:\nmessage = \u0026#34;Hello, World!\u0026#34; def display(): message = \u0026#34;Hello, Python!\u0026#34; print(message) display() print(message) Output:\nHello, Python!\rHello, World! ","permalink":"http://localhost:1313/posts/pages/python/python_function/","summary":"An in-depth exploration of Python functions, their usage, and importance in programming.","title":"Python Fundamentals: Understanding Functions (Part 5)"},{"content":"1. Create A React Project To create a React app we use Vite and its command is:\nnpm create vite@latest 2. Component In a React application, one page is broken down into multiple components. Components allow:\nReusability: For example, we can create one component for cards and use it to create multiple cards with different data. Related code lives together: Related items (JS code) are stored together. Separation of logic: Different components handle different data and logic. Diagram 3. Folder Structure my-app/\r├─ node_modules/\r├─ public/\r│ ├─ index.html\r│ ├─ image.png\r│ └─ favicon.ico\r├─ src/\r│ ├─ index.js\r│ ├─ App.js\r│ ├─ App.css\r│ └─ index.css\r├─ package.json\r└─ README.md node_module: Contains all the files of installed packages.\npublic: All static files are kept in this folder. For example, if image.png is in public, we can access it in the browser as 127.0.0.1:8000/image.png.\nindex.html: It is the page that is served to us and its content is managed by React using the DOM.Modify this file if you want to change the title or favicon.\npackage.json: Contains all the configuration of the project, package list, versions, and all related information.\nsrc: This is the folder where all the code is written.\nsrc/index.js React runs this file first.Code of index.js\nThe DOM selects the element of index.html whose id is root because of this code: document.getElementById('root') Then render() renders the \u0026lt;App/\u0026gt; component so that the root element will contain the data of the \u0026lt;App/\u0026gt; component. All changes are done in the index.html root element using the DOM. Remember that we never edit this file (code). src/App.js : This is where we will write all the SPA code. We start coding from App.jsx and link components as required.\nsrc/index.css : This CSS file is used by main.jsx, so it applies to the whole page. You can remove it if needed by removing its import in main.jsx.\n*** src/App.css:*** This CSS file is used by App.jsx, so it applies to all App components.\nRemember: Component functions must follow two rules:\nThe name should start with an uppercase letter (e.g., Head, MyHead). The function must return renderable content. The function must return a value that can be rendered (displayed on screen) by React. In most cases, return JSX. Example of a simple component:\nfunction App() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Hello world\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ); } As we know, App.jsx is provided by default when we create a React app. We can modify it and tailor it to our requirements\n4. Making Custom Components function FunctionName() { return ( \u0026lt;tagname\u0026gt; content \u0026lt;/tagname\u0026gt; ); } Important Note:\nTags that don\u0026rsquo;t have ending tags, such as \u0026lt;br\u0026gt; and \u0026lt;hr\u0026gt;, should be written as \u0026lt;br/\u0026gt; and \u0026lt;hr/\u0026gt;. class is replaced by className. For example, \u0026lt;body class=\u0026quot;data\u0026quot;\u0026gt; is written as \u0026lt;body className=\u0026quot;data\u0026quot;\u0026gt;. During a return in React, we cannot return multiple elements directly. Instead, we need to wrap them inside a single parent element like \u0026lt;div\u0026gt;, \u0026lt;\u0026gt;\u0026lt;/\u0026gt;. For Example :\nWrong Way: function component1() { return ( \u0026lt;div\u0026gt; Hi \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; Hello \u0026lt;/div\u0026gt; ); } right way: function component1() { return ( \u0026lt;div\u0026gt; {/* or \u0026lt;\u0026gt; */} \u0026lt;div\u0026gt; Hi \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; Hello \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; {/* or \u0026lt;/\u0026gt; */} ); } 5.Using One Component Inside Another Component To use one component inside another in React, follow the steps\nCreate a component. function Comp1() { return \u0026lt;div\u0026gt; Component \u0026lt;/div\u0026gt; } Use the component inside another component. function Comp2() { return ( \u0026lt;div\u0026gt; \u0026lt;Comp1 /\u0026gt; or \u0026lt;Comp1\u0026gt; \u0026lt;Comp1 /\u0026gt; content \u0026lt;/div\u0026gt; ) } Here, Comp1 is used inside Comp2.We can use Comp1 multiple times inside Comp2 as needed. Note: For proper management, create a components folder, create one file for each component, and export from there. Then, import and use it in another component.\nExample structure:\nsrc/\r├─ Assets/\r├─ App.jsx\r└─ Components/\r├─ Comp1.jsx\r└─ Comp2.jsx Task: Break Down a Component into Multiple Components\nfunction App() { return ( \u0026lt;\u0026gt; \u0026lt;header\u0026gt; I am header \u0026lt;/header\u0026gt; \u0026lt;main\u0026gt; I am main content \u0026lt;/main\u0026gt; \u0026lt;footer\u0026gt; I am footer \u0026lt;/footer\u0026gt; \u0026lt;/\u0026gt; ); } Solution: components/Header.jsx\nfunction Header() { return ( \u0026lt;header\u0026gt; I am header \u0026lt;/header\u0026gt; ); } export default Header; components/Footer.jsx\nfunction Footer() { return ( \u0026lt;footer\u0026gt; I am footer \u0026lt;/footer\u0026gt; ); } export default Footer; Finally, App.jsx\nimport Header from \u0026#39;./components/Header\u0026#39;; import Footer from \u0026#39;./components/Footer\u0026#39;; function App() { return ( \u0026lt;\u0026gt; \u0026lt;Header /\u0026gt; \u0026lt;main\u0026gt; I am main content \u0026lt;/main\u0026gt; \u0026lt;Footer /\u0026gt; \u0026lt;/\u0026gt; ); } export default App; structure:\nsrc/\r├─ Assets/\r├─ App.jsx\r└─ components/\r├─ Header.jsx\r└─ Footer.jsx Note: You Can Always break down a component as many times as you want. The main goal is to make the code more readable and maintainable.\n6. Some Component Hierarchies Examples THis is the simple example of a component hierarchy. 7. Embedding JavaScript code in JSX In JSX, we can embed JavaScript code using curly braces {}. We can write any JavaScript code inside the curly braces. For example, we can write a variable, function, or any JavaScript expression but of single line.\nfunction componentName() { return ( \u0026lt;div\u0026gt; { JavaScript code } \u0026lt;/div\u0026gt; ); } Example:\nfunction App() { const name = \u0026#39;John Doe\u0026#39;; return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt; Hello, {name} \u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ); } Where To Write Javascript Logic?\nWe can write JavaScript logic inside the component function. We can write JavaScript logic outside the component function and use it inside the component function. 7.1 Using JavaScript Logic Outside Component Function syntax:\n// Multiple lines of JavaScript code function ComponentName() { return ( \u0026lt;div\u0026gt; {/* JSX code */} \u0026lt;/div\u0026gt; ); } 7.2 Using JavaScript Logic Inside Component Function syntax:\nfunction ComponentName() { // Multiple lines of JavaScript code return ( \u0026lt;div\u0026gt; {/* JSX code */} \u0026lt;/div\u0026gt; ); } When to use Inside Component Function Outside Component Function Use Case When the logic is specific to the component and not used anywhere else. When the logic is used in multiple components. Advantages Logic is specific to the component. Logic can be reused in multiple components. Disadvantages Logic cannot be reused in other components. Logic is not specific to the component. Combined Example Task1: Create a component that generate random number between 1 to 10 and display in every page reload\nfunction RandomNumber(){ return \u0026lt;\u0026gt; \u0026lt;h1\u0026gt;Random Number: {Math.floor(Math.random() * 10) + 1}\u0026lt;/h1\u0026gt; } export default RandomNumber; This can be done in another ways which is more readable and maintainable\nfunction RandomNumber(){ const randomNumber = Math.floor(Math.random() * 10) + 1; return \u0026lt;h1\u0026gt;Random Number: {randomNumber}\u0026lt;/h1\u0026gt; } export default RandomNumber; Task2 : Create a component that generate random element from an array and display on each page reload\nconst elements = [\u0026#39;Earth\u0026#39;, \u0026#39;Water\u0026#39;, \u0026#39;Fire\u0026#39;, \u0026#39;Air\u0026#39;]; function generateRandomElement(){ return elements[Math.floor(Math.random() * elements.length)]; } function RandomElement(){ const randomElement = generateRandomElement(); return \u0026lt;h1\u0026gt;Random Element: {randomElement}\u0026lt;/h1\u0026gt; } export default RandomElement; This can be done by putting the logic inside the component function\nconst elements = [\u0026#39;Earth\u0026#39;, \u0026#39;Water\u0026#39;, \u0026#39;Fire\u0026#39;, \u0026#39;Air\u0026#39;]; function generateRandomElement(){ return elements[Math.floor(Math.random() * elements.length)]; } function RandomElement(){ const randomElement = elements[Math.floor(Math.random() * elements.length)]; return \u0026lt;h1\u0026gt;Random Element: {randomElement}\u0026lt;/h1\u0026gt; } export default RandomElement; The most optimal way is using this\nconst elements = [\u0026#39;Earth\u0026#39;, \u0026#39;Water\u0026#39;, \u0026#39;Fire\u0026#39;, \u0026#39;Air\u0026#39;]; function RandomElement(){ const randomElement = elements[Math.floor(Math.random() * elements.length)]; return \u0026lt;h1\u0026gt;Random Element: {randomElement}\u0026lt;/h1\u0026gt; } export default RandomElement; 8.Loading Images in React step 1: put the images in assets folder that need to be loaded step 2: import the image in the component where it is needed as shown below import imageName from Location Note: Location is the path of the image from the current file location and imageName can be set to any name\nstep 3: use the image in the component as shown below \u0026lt;img src={imageName} alt=\u0026#34;description\u0026#34; /\u0026gt; Note: imageName is the location of the image as src/Assets/logo.png\nTask: Load an image in a Header component with the image name logo.png and description logo. structure:\nsrc/\r├─ Assets/\r└─ logo.png\r├─ App.jsx\r└─ components/\r├─ Header.jsx import logo from \u0026#39;../Assets/logo.png\u0026#39;; function Header() { return ( \u0026lt;header\u0026gt; \u0026lt;img src={logo} alt=\u0026#34;logo\u0026#34; /\u0026gt; \u0026lt;/header\u0026gt; ); } 9.Importing CSS in React step 1: create a css file in the src folder step 2: import the css file in the component where it is needed as shown below import cssfileLocation Note: style.css is the name of the css file\nfor example:\nimport \u0026#39;./style.css\u0026#39; function App() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt; Hello world \u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ); } 9.1 Managing CSS in React Create css file in same directory as of your component src/ ├─ App.jsx └─ components/ ├─ Header.jsx └─ Header.css -Import the css file in the component where it is needed as shown below\r```jsx\rimport \u0026#39;./Header.css\u0026#39; 10.Props in React Props are used to pass data from parent component to child component. It is used to reuse the same component with different data. Props are passed as attributes to the component. Prop accept any type of value like string, number, array, object, function,compenent,jsx bool etc. 10.1 Passing Props from Parent to Child Component Parent Component function ParentComponent() { return ( \u0026lt;ChildComponent prop1={value1} prop2={value2} /\u0026gt; ); } 10.2 Receiving Props in Child Component Child Component function ChildComponent(props) { console.log(props); // will print object of props {prop1: value1, prop2:value2} return ( \u0026lt;\u0026gt; {props.prop1} {props.prop2} \u0026lt;/\u0026gt; ); } This approach is not recommended because it is not clear what props are being passed to the component. Instead, we can destructure the props as shown below.\n10.3 Destructuring Props Child Component function ChildComponent({prop1, prop2}) { return ( \u0026lt;\u0026gt; {prop1} {prop2} \u0026lt;/\u0026gt; ); } Task: Create a card cmponent and use multiple cards in the App component to make card section\nfunction Card({title, description, image}) { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;{title}\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;{description}\u0026lt;/p\u0026gt; \u0026lt;img src={image} alt=\u0026#34;description\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; ); } export default Card; import Card from \u0026#39;./components/Card\u0026#39;; function App() { return ( \u0026lt;div\u0026gt; \u0026lt;Card title=\u0026#34;Card 1\u0026#34; description=\u0026#34;This is card 1\u0026#34; image={image1} /\u0026gt; \u0026lt;Card title=\u0026#34;Card 2\u0026#34; description=\u0026#34;This is card 2\u0026#34; image={image2} /\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; 11. Children Props in React Children props are used to pass data between opening and closing tags of a component. 11.1 Passing Children Props Parent Component function ParentComponent() { return ( \u0026lt;ChildComponent\u0026gt; \u0026lt;h1\u0026gt; Hello \u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt; World \u0026lt;/p\u0026gt; \u0026lt;/ChildComponent\u0026gt; ); } 11.2 Receiving Children Props Child Component function ChildComponent({ children }) { return ( \u0026lt;div\u0026gt; {children} \u0026lt;/div\u0026gt; ); } 11.3 Output \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt; Hello \u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt; World \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; 12.Using Props and Children Props Together Task: Create a card component that accepts title, description, and children props. Use the card component in the App component to make a card section.\nfunction Card({ title, description, children }) { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;{title}\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;{description}\u0026lt;/p\u0026gt; {children} \u0026lt;/div\u0026gt; ); } export default Card; import Card from \u0026#39;./components/Card\u0026#39;; function App() { return ( \u0026lt;div\u0026gt; \u0026lt;Card title=\u0026#34;Card 1\u0026#34; description=\u0026#34;This is card 1\u0026#34;\u0026gt; \u0026lt;h1\u0026gt; Hello \u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt; World \u0026lt;/p\u0026gt; \u0026lt;/Card\u0026gt; \u0026lt;Card title=\u0026#34;Card 2\u0026#34; description=\u0026#34;This is card 2\u0026#34;\u0026gt; \u0026lt;h1\u0026gt; Hello \u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt; World \u0026lt;/p\u0026gt; \u0026lt;/Card\u0026gt; \u0026lt;/div\u0026gt; ); } 13. Making a Button Component 13.1 Using Props function App() { return ( \u0026lt;div\u0026gt; \u0026lt;Button text=\u0026#34;Click me\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; ); } function Button({ text}) { return ( \u0026lt;button\u0026gt; {text} \u0026lt;/button\u0026gt; ); } export default Button; 13.2 Using Children Props function App() { return ( \u0026lt;div\u0026gt; \u0026lt;Button\u0026gt;Click me\u0026lt;/Button\u0026gt; \u0026lt;/div\u0026gt; ); } function Button({ children }) { return ( \u0026lt;button\u0026gt; {children} \u0026lt;/button\u0026gt; ); } export default Button; 14. Reacting to Events In React, we can add event listeners like onClick, onMouseOver, onMouseOut, etc to buildin components lie button, div, etc using syntax \u0026lt;InbuiltComponent eventlistener={functionName} /\u0026gt; Note: functionName is the name of the function that will be called when the event is triggered.\nThere are Many eventlisteners that can be used in React like onClick, onMouseOver, onMouseOut etc.\nYou can check the full list of event listeners in the React documentation also note that the event listener will always start with on followed by the event name.\nWe can call the handle function in two ways:\n14.1 The First Way function App() { function handleClick() { console.log(\u0026#39;Button clicked\u0026#39;); } return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={handleClick}\u0026gt;Click me\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 14.2 The Second Way function App() { return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={() =\u0026gt; {console.log(\u0026#39;Button clicked\u0026#39;)}}\u0026gt;Click me\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 15. Event Listeners in Custom Components since by default when we add event listeners to custom component it doesnot work just because it is passed as prop but on simple tweaking we can make it work\nDesign Pattern for applying event listeners in custom components\nfunction App(){ function handleClick(){ console.log(\u0026#39;Button clicked\u0026#39;); } return ( \u0026lt;div\u0026gt; \u0026lt;Button onClick={handleClick} /\u0026gt; \u0026lt;/div\u0026gt; ); } The onclick method is passed as a prop to the button component and then used in the button component as shown below\nfunction Button({onClick}){ return ( \u0026lt;button onClick={onClick}\u0026gt;Click me\u0026lt;/button\u0026gt; ); } 16. Passing Arguments to Event Functions To pass Custom arguments to event functions, we can use the arrow function syntax as shown below \u0026lt;inbuildComponent eventListener={() =\u0026gt; functionName(argument)} /\u0026gt; Example function App() { function handleClick(name) { console.log(\u0026#39;Button clicked by\u0026#39;, name); } return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={() =\u0026gt; handleClick(\u0026#39;John\u0026#39;)}\u0026gt;Click me\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } ","permalink":"http://localhost:1313/posts/pages/react/react/","summary":"A detailed reference guide to help you quickly set up and manage React projects, components, and folder structures.","title":"React : Day 1"},{"content":"Python Fundamentals: Understanding Error Handling In Python programming, error handling is an essential concept that allows you to gracefully manage exceptions and errors that may occur during program execution. By handling errors effectively, you can prevent your program from crashing and provide meaningful feedback to users. In this guide, we will explore the fundamentals of error handling in Python, including exceptions, try-except blocks, and best practices.\n1. Exceptions In Python, exceptions are events that occur during the execution of a program that disrupt the normal flow of code. When an exception occurs, the interpreter raises an exception object that can be caught and handled by the program. Exceptions can be caused by various reasons, such as invalid input, file not found, or division by zero.\n2.What May Cause Exceptions Exceptions can be caused by various reasons, such as:\nDivision by zero Invalid input File not found Syntax errors Out of Index of list, tuple , String Key Error in dictionary 3.Types of Exceptions Commonly used exceptions in Python include:\nZeroDivisionError: Raised when division or modulo by zero occurs. ValueError: Raised when a function receives an argument of the correct type but an inappropriate value. TypeError: Raised when an operation or function is applied to an object of an inappropriate type. IndexError: Raised when a sequence subscript is out of range. KeyError: Raised when a dictionary key is not found. SyntaxError: Raised when the parser encounters a syntax error. Note: All exceptions in Python are subclasses of the Exception class.\n3.Handling Exceptions To handle exceptions in Python, you can use the try-except block, which allows you to catch and handle exceptions gracefully. The try block contains the code that may raise an exception, and the except block handles the exception if it occurs.The program control will transfer the control to the except block if any exception occurs in the try block but if there is not exception then the control will not transfer to the except block.\n4.1. Using try-except Block Here\u0026rsquo;s an example of using the try-except block to handle exceptions in Python:\nsyntax:\ntry: # Code that may raise an exception except ExceptionType as e: # Handle the exception Example:\ntry: x = 10 / 0 except Exception as e: print(\u0026#34;Error: Division by zero\u0026#34;) Output:\nError: Division by zero Note: if you don\u0026rsquo;t know the type of exception you can use Exception to catch all exceptions.\nIf you dont handel exception then it will show error and stop the program.\n4.2. Finally Block The finally block is used to execute code that should always run, regardless of whether an exception occurs or not. The finally block is typically used to release resources or clean up operations that need to be performed after the try block, regardless of the outcome Any how the finally block will run. if yout return from the try block then also the finally block will run.\nsyntax:\ntry: # Code that may raise an exception except ExceptionType as e: # Handle the exception finally: # Code that always runs Example:\ntry: x = 10 / 0 except Exception as e: print(\u0026#34;Error: Division by zero\u0026#34;) finally: print(\u0026#34;Cleanup code\u0026#34;) Output:\nError: Division by zero\rCleanup code 3.5. Raising Exceptions You can raise exceptions in Python using the raise statement. This allows you to create custom exceptions and raise them when needed. You can also raise built-in exceptions to indicate errors or exceptional conditions.\nsyntax:\nraise ExceptionType(\u0026#34;Error message\u0026#34;) Example:\nx = -1 if x \u0026lt; 0: raise ValueError(\u0026#34;Value cannot be negative\u0026#34;) Output:\nValueError: Value cannot be negative 3.6. Multiple except Blocks You can use multiple except blocks to handle different types of exceptions in Python. This allows you to catch and handle specific exceptions based on their type.\nsyntax:\ntry: # Code that may raise an exception except ExceptionType1 as e: # Handle ExceptionType1 except ExceptionType2 as e: # Handle ExceptionType2 Example:\ntry: x = 10 / 0 except ZeroDivisionError as e: print(\u0026#34;Error: Division by zero\u0026#34;) except ValueError as e: print(\u0026#34;Error: Invalid value\u0026#34;) Output:\nError: Division by zero 3.7. Custom Exceptions You can create custom exceptions in Python by defining a new exception class that inherits from the Exception class. Custom exceptions allow you to define specific error conditions for your application and raise them when needed.\nsyntax:\nclass CustomException(Exception): pass Example:\n#Will read about class in oop section class CustomError(Exception): def __init__(self,message,value): self.message=message self.value=value def __str__(self): return f\u0026#34;{self.message}\\nError code:{self.value}\u0026#34; try: x = -1 if x \u0026lt; 0: raise CustomError(\u0026#34;Value cannot be negative\u0026#34;,1001) except CustomError as e: print(e) Note: Custom exceptions should inherit from the Exception class or one of its subclasses. You can simply use:\ntry: #code except: #code try: #code except Exception as e: #code try: #code except Exception: #code try: #code except: #code finally: #code ","permalink":"http://localhost:1313/posts/pages/python/python_error_handeling/","summary":"An in-depth exploration of Python error handling, exceptions, and best practices.","title":"Python Fundamentals: Understanding Error Handling (Part 6)"},{"content":"Python Fundamentals: Packages, Generators, and Decorators In this guide, we will explore advanced Python topics including packages, generators, and decorators. These concepts are essential for writing efficient and maintainable Python code. Let\u0026rsquo;s dive in!\n1. Python Packages Python packages are a way of organizing and structuring your code into reusable modules. Packages allow you to group related modules together, making it easier to manage and maintain your codebase. In this section, we will explore how to create and use Python packages.\n1.1. Creating a Package To create a Python package, you need to organize your code into a directory structure with a special file called __init__.py. This file tells Python that the directory is a package and allows you to import modules from the package.\nExample directory structure:\nmy_package/\r│\r├── __init__.py\r├── module1.py\r└── module2.py 1.2. Using a Package To use a Python package, you can import modules from the package using the import statement. You can import specific modules or the entire package.\nExample:\n# Importing a specific module from my_package import module1 # Using a function from the imported module module1.my_function() # Importing the entire package import my_package # Using a function from a module within the package my_package.module2.another_function() #Importing Function from a module from my_package.module1 import my_function my_function() Note : init.py file can be empty or contain initialization code for the package. It will automatically run when the package is imported.\n1.3 Creating a Subpackage You can create subpackages within a package to further organize your code. Subpackages are simply packages within packages, allowing you to create a hierarchical structure for your codebase.\nExample directory structure:\nmy_package/\r│\r├── __init__.py\r├── module1.py\r└── subpackage/\r├── __init__.py\r├── module3.py\r└── module4.py 1.4. Using a Subpackage To use a subpackage, you can import modules from the subpackage using the dot notation.\nExample:\n# Importing a module from a subpackage from my_package.subpackage import module3 # Using a function from the imported module module3.another_function() # Importing the entire subpackage import my_package.subpackage # Using a function from a module within the subpackage my_package.subpackage.module4.some_function() #Importing Function from a module from my_package.subpackage.module3 import another_function another_function() 1.5. name == \u0026ldquo;main\u0026rdquo; We use the __name__ variable to check if a script is being run as the main program or being imported as a module. When a script is run as the main program, __name__ is set to \u0026quot;__main__\u0026quot;. This allows you to include code that should only run when the script is executed directly.\nFor Example:\nStructure:\nMain Directory/\r├── main.py\r└── package/\r├── __init__.py\r└── module1.py module1.py:\ndef my_function(): print(\u0026#34;Hello from module1\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: my_function() When you run module1.py directly, the my_function() will be executed. However, if you import module1 into another script, the my_function() will not be executed.\nFor Example:\nfrom package import module1 print(\u0026#34;Imported module1\u0026#34;) Output:\nImported module1 When use Dont use if __name__ == \u0026quot;__main__\u0026quot;: in module1.py:\ndef my_function(): print(\u0026#34;Hello from module1\u0026#34;) my_function() also,\nfrom package import module1 print(\u0026#34;Imported module1\u0026#34;) Output:\nHello from module1\rImported module1 2. Python Generators Using generator we can instantly return all the values using the yield keyword without storing them in memory. This is useful when working with large datasets or infinite sequences.\n2.1. Creating a Generator To create a generator in Python, you can use a function with the yield keyword. When a function contains the yield keyword, it becomes a generator function. The yield keyword suspends the function\u0026rsquo;s execution and returns a value to the caller.\nExample:\ndef my_generator(): yield 1 yield 2 yield 3 # Using the generator gen = my_generator() print(next(gen)) # Output: 1 print(next(gen)) # Output: 2 print(next(gen)) # Output: 3 Example:\n#using generator in loop def generate(n): for i in range(n): yield i for i in generate(10): print(i) 3. Python Decorators Decorators are a powerful feature in Python that allows you to modify or extend the behavior of functions or methods. Decorators are functions that take another function as an argument and return a new function that extends the behavior of the original function.\n3.1. Creating a Decorator To create a decorator in Python, you can define a function that takes another function as an argument and returns a new function that extends the behavior of the original function.\nSyntax:\ndef my_decorator(func): def wrapper(): # Code to execute before calling the decorated function func() # Code to execute after return wrapper Example:\ndef my_decorator(func): def wrapper(): print(\u0026#34;Before function call\u0026#34;) func() print(\u0026#34;After function call\u0026#34;) return wrapper @my_decorator def say_hello(): print(\u0026#34;Hello!\u0026#34;) say_hello() #call to my_decorator(say_hello)() just because we use @my_decorator Output:\nBefore function call\rHello!\rAfter function call Example For decorator :\ndef Add_Wrapper(func): def wrapper(a,b,c): print(\u0026#34;Status code is\u0026#34;,c) return func(a,b) return wrapper @Add_Wrapper def add(a,b): return a+b print(add(2,3,200)) Output:\nStatus code is 200\r5 3.2. Decorator with Arguments You can also create decorators that accept arguments by defining a decorator function that takes arguments and returns a decorator function.\nSyntax:\ndef my_decorator_with_args(arg1, arg2): def decorator(func): def wrapper(): # Code to execute before calling the decorated function func() # Code to execute after return wrapper return decorator Example:\ndef my_decorator_with_args(arg1, arg2): def decorator(func): def wrapper(): print(f\u0026#34;Decorator arguments: {arg1}, {arg2}\u0026#34;) func() return wrapper return decorator @my_decorator_with_args(\u0026#34;arg1\u0026#34;, \u0026#34;arg2\u0026#34;) def say_hello(): print(\u0026#34;Hello!\u0026#34;) say_hello() Output:\nDecorator arguments: arg1, arg2\rHello! ","permalink":"http://localhost:1313/posts/pages/python/python_advanced_topics/","summary":"An in-depth exploration of Python packages, generators, and decorators.","title":"Python Fundamentals: Packages, Generators, and Decorators (Part 7)"},{"content":"Python Fundamentals: Understanding request In this guide, we will explore request package in python. This package is used to make HTTP requests in python. Let\u0026rsquo;s dive in!\n1. Python request Python request is a simple and elegant HTTP library for Python. It provides methods for sending HTTP requests and handling the responses. The requests library allows you to send HTTP requests using a simple and intuitive API, and it also provides support for handling cookies, sessions, and authentication.\n1.1. Installing requests To use the requests library in your Python project, you need to install it using pip. You can install the requests library by running the following command in your terminal:\npip install requests 1.2. Types of requests The requests library supports various types of HTTP requests, including GET, POST, PUT, DELETE, and more. You can use these methods to interact with web services and APIs.\nExample:\nimport requests # Send a GET request response = requests.get(\u0026#39;https://api.github.com\u0026#39;) # Send a POST request response = requests.post(\u0026#39;https://httpbin.org/post\u0026#39;) # Send a PUT request response = requests.put(\u0026#39;https://httpbin.org/put\u0026#39;) # Send a DELETE request response = requests.delete(\u0026#39;https://httpbin.org/delete\u0026#39;) 1.3 Parameters for requests The requests library allows you to pass various parameters when making HTTP requests. These parameters include headers, query parameters, request body, and more.\nHeaders: You can pass custom headers in your request using the headers parameter. Example: import requests # Send a GET request with custom headers headers = {\u0026#39;User-Agent\u0026#39;: \u0026#39;Mozilla/5.0\u0026#39;} response = requests.get(\u0026#39;https://api.github.com\u0026#39;, headers=headers) # Send a POST request with custom headers response = requests.post(\u0026#39;https://httpbin.org/post\u0026#39;, headers=headers) #similarly for PUT and DELETE cookie: You can pass cookies in your request using the cookies parameter. Example: import requests # Send a GET request with cookies cookies = {\u0026#39;session_id\u0026#39;: \u0026#39;12345\u0026#39;} response = requests.get(\u0026#39;https://api.github.com\u0026#39;, cookies=cookies) # Send a POST request with cookies response = requests.post(\u0026#39;https://httpbin.org/post\u0026#39;, cookies=cookies) #similarly for PUT and DELETE file: You can upload files in your request using the files parameter. Example: import requests # Upload a file in a POST request files = {\u0026#39;file\u0026#39;: open(\u0026#39;file.txt\u0026#39;, \u0026#39;rb\u0026#39;)} response = requests.post(\u0026#39;https://httpbin.org/post\u0026#39;, files=files) #similarly for PUT and DELETE params: You can pass query parameters in your request using the params parameter. Example: import requests # Send a GET request with query parameters params = {\u0026#39;key1\u0026#39;: \u0026#39;value1\u0026#39;, \u0026#39;key2\u0026#39;: \u0026#39;value2\u0026#39;} response = requests.get(\u0026#39;https://api.github.com\u0026#39;, params=params) # Send a POST request with query parameters response = requests.post(\u0026#39;https://httpbin.org/post\u0026#39;, params=params) #similarly for PUT and DELETE data: You can pass data in your request body using the data parameter. Example: import requests # Send a POST request with data data = {\u0026#39;key1\u0026#39;: \u0026#39;value1\u0026#39;, \u0026#39;key2\u0026#39;: \u0026#39;value2\u0026#39;} response = requests.post(\u0026#39;https://httpbin.org/post\u0026#39;, data=data) #similarly for PUT and DELETE json: You can pass JSON data in your request body using the json parameter. Example: import requests # Send a POST request with JSON data data = {\u0026#39;key1\u0026#39;: \u0026#39;value1\u0026#39;, \u0026#39;key2\u0026#39;: \u0026#39;value2\u0026#39;} response = requests.post(\u0026#39;https://httpbin.org/post\u0026#39;, json=data) #similarly for PUT and DELETE Note: The requests library provides a wide range of parameters and options for making HTTP requests. You can refer to the official documentation for more details.\n** Note ** : While using json it will automatically set the content type to application/json and dump the data to json format but while using data it will set the content type to application/x-www-form-urlencoded and encode the data to urlencoded format.\n1.4. Handling responses The requests library provides methods for handling the responses returned by HTTP requests. You can access the response content, status code, headers, and more.\nResponse content: You can access the response content using the text attribute. Example: import requests # Send a GET request response = requests.get(\u0026#39;https://api.github.com\u0026#39;) # Get the response content content = response.text print(content) Response Content in bytes: You can access the response content in bytes using the content attribute. Example: import requests # Send a GET request response = requests.get(\u0026#39;https://api.github.com\u0026#39;) # Get the response content in bytes content = response.content print(content) json: You can access the response content as JSON using the json method. Example:\nimport requests # Send a GET request response = requests.get(\u0026#39;https://api.github.com\u0026#39;) # Get the response content as JSON data = response.json() print(data) Status code: You can access the response status code using the status_code attribute. Example: import requests # Send a GET request response = requests.get(\u0026#39;https://api.github.com\u0026#39;) # Get the response status code status_code = response.status_code print(status_code) Headers: You can access the response headers using the headers attribute. Example: import requests # Send a GET request response = requests.get(\u0026#39;https://api.github.com\u0026#39;) # Get the response headers headers = response.headers print(headers) Cookies: You can access the response cookies using the cookies attribute. Example: import requests # Send a GET request response = requests.get(\u0026#39;https://api.github.com\u0026#39;) # Get the response cookies cookies = response.cookies print(cookies) ","permalink":"http://localhost:1313/posts/pages/python/python_request/","summary":"An in-depth exploration of Python request.","title":"Python Fundamentals: Understanding request (Part 8)"},{"content":"Python Fundamentals: Understanding File Handeling In Python programming, file handling is an essential operation that allows you to read, write, and manipulate files on your system. Files are used to store data permanently, and Python provides various functions and methods to work with files efficiently. In this guide, we will explore the basics of file handling in Python, including opening, reading, writing, and closing files.\n1.Context Manager Python provides a built-in way to manage resources and ensure that they are properly released when they are no longer needed. This is done using the with statement and is known as a context manager. When working with files, it is recommended to use the with statement to ensure that the file is properly closed after use.\n1.1. Using the with Statement The with statement in Python is used to create a context manager that automatically takes care of resource management. When working with files, the with statement ensures that the file is properly closed after use, even if an error occurs during file operations.\nExample:\nwith open(\u0026#34;example.txt\u0026#34;, \u0026#34;r\u0026#34;) as file: data = file.read() print(data) 2. Opening a File Before you can read or write to a file, you need to open it using the open() function. The open() function takes two arguments: the file path and the mode in which you want to open the file.\n2.1. Modes for Opening Files Python supports various modes for opening files, depending on the operations you want to perform. Some common modes include:\nr: Read mode. Opens the file for reading. The file must exist. w: Write mode. Opens the file for writing. If the file exists, it will be truncated. If the file does not exist, a new file will be created. a: Append mode. Opens the file for writing. If the file exists, the data will be appended to the end. If the file does not exist, a new file will be created. b: Binary mode. Opens the file in binary mode.use for image,video,etc as it will not convert the data to text .You can add b to any mode to open the file in binary mode like rb,wb,ab. t: Text mode. Opens the file in text mode (default). 2.2. Opening a File To open a file, you can use the open() function with the desired file path and mode. You can also specify additional parameters such as encoding, buffering, and newline characters.\nExample:\n# Open a file in read mode with open(\u0026#34;example.txt\u0026#34;, \u0026#34;r\u0026#34;) as file: data = file.read() print(data) 3. Reading from a File Once you have opened a file, you can read its contents using various methods provided by Python. The most common methods for reading from a file is read().\n# Open a file in read mode with open(\u0026#34;example.txt\u0026#34;, \u0026#34;r\u0026#34;) as file: data = file.read() print(data) 4. Writing to a File To write data to a file, you can use the write() method provided by Python. You can write text data to a file using the write() method.\nUsing w mode: # Open a file in write mode with open(\u0026#34;example.txt\u0026#34;, \u0026#34;w\u0026#34;) as file: file.write(\u0026#34;Hello, World!\u0026#34;) Using a mode: # Open a file in append mode with open(\u0026#34;example.txt\u0026#34;, \u0026#34;a\u0026#34;) as file: file.write(\u0026#34;Hello, World!\u0026#34;) 5.Context Manager Reference\nUse of Context Manager: In any programming language, the usage of resources like file operations or database connections is very common. But these resources are limited in supply. Therefore, the main problem lies in making sure to release these resources after usage. If they are not released then it will lead to resource leakage and may cause the system to either slow down or crash. It would be very helpful if users have a mechanism for the automatic setup and teardown of resources. In Python, it can be achieved by the usage of context managers which facilitate the proper handling of resources.\nWhat is happened When the with statement is executed, it will automatically call the __enter__ before entering the code block, and __exit__ after exiting the code block.\nHow to create a context manager To create a context manager, you need to define a class that implements the __enter__ and __exit__ methods. The __enter__ method is called when the with statement is executed, and the __exit__ method is called after the code block is executed.\nSyntax:\nclass MyContextManager: def __init__(self,params): # Code to initialize resources def __enter__(self): # Code to setup resources return self def __exit__(self, exc_type, exc_value, traceback): # Code to release resources Example:\n#implementatio of own file handeling context manager class MeroHandle: def __init__(self,filename,mode): self.filename = filename self.mode = mode def __enter__(self): self.file = open(self.filename,self.mode) return self.file def __exit__(self,exc_type,exc_value,traceback): self.file.close() #using the context manager with MeroHandle(\u0026#34;example.txt\u0026#34;,\u0026#34;r\u0026#34;) as file: data = file.read() print(data) Normal way of file handeling try: file = open(\u0026#34;example.txt\u0026#34;,\u0026#34;r\u0026#34;) data = file.read() print(data) file.close() except: print(\u0026#34;Error Occured\u0026#34;) Advantage of context manager Over normal code When we use normal code shown above then when error occured in try block before file.close() then it will not close the file(i.e file will not be closed) and it will lead to resource leakage . But when we use context manager then it will automatically close the file just because __exit__ method is called after the code block is executed whether error occured or not. but in normal code we can manage this by using finally block but it is not recommended as it is not pythonic way of doing things. try: file = open(\u0026#34;example.txt\u0026#34;,\u0026#34;r\u0026#34;) data = file.read() print(data) except: print(\u0026#34;Error Occured\u0026#34;) finally: file.close() This will work but it is not pythonic way of doing things.Just because we have to write whole try,except,finally block for just opening and closing the file. which make code more complex and lengthy.\n","permalink":"http://localhost:1313/posts/pages/python/python_filehandeling/","summary":"An in-depth look at File Handeling.","title":"Python Fundamentals: Understanding File Handeling (Part 9)"},{"content":"Python Fundamentals: Some Important Package to Know In Python programming, packages are collections of modules that provide additional functionality to your programs. Python has a rich ecosystem of packages that can help you perform a wide range of tasks, from data analysis and visualization to web development and machine learning. In this guide, we will explore some of the most important packages in Python that you should be familiar with.\n1.json The json package in Python provides functions for encoding and decoding JSON data. JSON (JavaScript Object Notation) is a lightweight data interchange format that is easy for humans to read and write and easy for machines to parse and generate. The json package allows you to work with JSON data in Python by converting Python objects to JSON strings and vice versa.\nConversion of Python dictionary to JSON string We can convert a Python dictionary to a JSON string using the json.dumps() function. This function takes a Python object as input and returns a JSON string representation of the object. Example:\nimport json # Create a Python dictionary data = { \u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34; } # Convert the dictionary to a JSON string json_string = json.dumps(data) print(json_string) Conversion of JSON string to Python dictionary We can convert a JSON string to a Python dictionary using the json.loads() function. This function takes a JSON string as input and returns a Python object (usually a dictionary) representing the JSON data. Example:\nimport json # JSON string json_string = \u0026#39;{\u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;}\u0026#39; # Convert the JSON string to a Python dictionary data = json.loads(json_string) print(data) 2.os The os package in Python provides functions for interacting with the operating system.You can get indepth knowladge of os using its own documentation.but the most common methods are:\nos.path.join(\u0026quot;C:\u0026quot;,\u0026quot;users\u0026quot;,\u0026quot;bin\u0026quot;): Join one or more path components intelligently. os.rename(\u0026quot;old\u0026quot;,\u0026quot;new\u0026quot;): Rename a file or directory. 3.time The time package in Python provides functions for working with time-related tasks. You can use the time package to get the current time, sleep for a specified duration, and measure the execution time of your code.\ntime.time(): Returns the current time in seconds since the epoch. time.sleep(seconds): Suspends the execution of the current thread for the given number of seconds. 4.uuid The uuid package in Python provides functions for generating and working with UUIDs (Universally Unique Identifiers). UUIDs are unique identifiers that are used to identify objects in a distributed computing environment. The uuid package allows you to generate UUIDs based on various algorithms and formats.\nGenerating a UUID You can generate a UUID using the uuid.uuid4() function, which generates a random UUID. Example:\nimport uuid # Generate a random UUID uuid_value = uuid.uuid4() print(uuid_value) 5.Datetime The datetime package in Python provides classes for working with dates and times. You can use the datetime package to create, manipulate, and format dates and times in your Python programs.\nCreating a datetime object You can create a datetime object using the datetime.datetime() constructor, which takes the year, month, day, hour, minute, second, and microsecond as input. Example:\nimport datetime # Create a datetime object dt = datetime.datetime(2022, 11, 27, 10, 30, 0) print(dt) Output:\n2022-11-27 10:30:00 get current date and time You can get the current date and time using the datetime.now() method. Example:\nimport datetime # Get the current date and time now = datetime.datetime.now() print(now) Output:\n2022-11-27 10:30:00 Formatting a datetime object some Properties of datetime object:\nyear: The year of the datetime object month: The month of the datetime object (1-12) day: The day of the datetime object (1-31) hour: The hour of the datetime object (0-23) minute: The minute of the datetime object (0-59) second: The second of the datetime object (0-59) import datetime # Create a datetime object dt = datetime.datetime.now() # Format the datetime object print(dt.month()) print(dt.day()) print(dt.year()) print(dt.hour()) print(dt.minute()) print(dt.second()) Output:\n11\r27\r2022\r10\r30\r0 ","permalink":"http://localhost:1313/posts/pages/python/python_extrapackage/","summary":"An in-depth look at frequently used important package.","title":"Python Fundamentals: Some Important Package to Know (Part 10)"},{"content":"Shared References in Python: How Changes Propagate Across Variables In Python, variables are references to objects in memory. When you assign a value to a variable, you are creating a reference to the object that holds that value. In some cases, multiple variables can refer to the same object in memory. This is known as a shared reference.\nMutability and Shared References in Python: How Changes Propagate Across Variables List Lists are mutable, so if two variables reference the same list, changes through one variable will affect the other.\n# Create a list list1 = [1, 2, 3] # Create a reference to the list list2 = list1 # Modify the list through one reference list2.append(4) # Check the original list print(list1) # Output: [1, 2, 3, 4] Dictionary Dictionaries are mutable as well. If two variables point to the same dictionary, any change made through one will reflect in the other.\n# Create a dictionary dict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30} # Create a reference to the dictionary dict2 = dict1 # Modify the dictionary through one reference dict2[\u0026#34;age\u0026#34;] = 31 # Check the original dictionary print(dict1) # Output: {\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 31} Set Sets are mutable, so changes made through one reference will affect the other if two variables point to the same set.\n# Create a set set1 = {1, 2, 3} # Create a reference to the set set2 = set1 # Modify the set through one reference set2.add(4) # Check the original set print(set1) # Output: {1, 2, 3, 4} Custom Objects\nclass Person: def __init__(self, name, age): self.name = name self.age = age # Create an instance of the Person class person1 = Person(\u0026#34;Alice\u0026#34;, 30) # Create a reference to the instance person2 = person1 # Modify the instance through one reference person2.age = 31 # Check the original instance print(person1.age) # Output: 31 Note: Mutable objects like lists, dictionaries, sets, and custom objects allow changes to propagate across variables that reference the same object. Immutable objects like integers, strings, and tuples do not exhibit this behavior.\n","permalink":"http://localhost:1313/posts/pages/python/python_shared_references/","summary":"An in-depth look at shared references in Python.","title":"Python Fundamentals : Shared References in Python (part 11)"},{"content":"Object oriented programming in python Object oriented programming is a programming paradigm that provides a means of structuring programs so that properties and behaviors are bundled into individual objects.\n1. Class and Object Class is a blueprint for creating objects (a particular data structure), providing initial values for state (member variables or attributes), and implementations of behavior (member functions or methods).\nObject is an instance of a class. When class is defined, only the description for the object is defined. Therefore, no memory or storage is allocated.\n1.1 Creating a class We can create a class using the class keyword followed by the class name. The class definition can contain class variables, instance variables, methods, and constructors.\nSyntax:\nclass ClassName: #code block Example:\nclass Person: name=\u0026#34;Nirajan\u0026#34; age=20 classes=\u0026#34;Bachelor\u0026#34; 1.2 Creating an object To create an object of a class, we use the class name followed by parentheses. This calls the constructor method of the class and returns an object.\nSyntax:\nobject_name = ClassName() Example:\nperson1 = Person() 1.3 Accessing class attributes We can access the attributes of a class using the dot operator (.) followed by the attribute name.\nSyntax:\nobject_name.attribute_name Example:\nprint(person1.name) # Output: Nirajan print(person1.age) # Output: 20 print(person1.classes) # Output: Bachelor 1.4 Modifying class attributes We can modify the attributes of a class using the dot operator (.) followed by the attribute name.\nSyntax:\nobject_name.attribute_name = new_value Example:\nperson1.age = 21 print(person1.age) # Output: 21 1.5 Creating a member function We can create a member function (method) inside a class using the def keyword followed by the function name. The first parameter of the method should be self, which refers to the current instance of the class.we will see about self in next part.\nSyntax:\nclass ClassName: def method_name(self, parameters): #code block Example:\nclass Person: name=\u0026#34;Nirajan\u0026#34; age=20 classes=\u0026#34;Bachelor\u0026#34; def display(self): print(f\u0026#34;Name: {self.name}\u0026#34;) print(f\u0026#34;Age: {self.age}\u0026#34;) print(f\u0026#34;Class: {self.classes}\u0026#34;) 1.6 Calling a member function We can call a member function of a class using the dot operator (.) followed by the function name and parentheses.\nSyntax:\nobject_name.method_name(arguments) Example:\nperson1.display() 1.7 Nested member function We can call a member function from another member function of the same class using the self keyword.\nSyntax:\nclass ClassName: def method1(self): #code block self.method2() def method2(self): #code block Example:\nclass Person: name=\u0026#34;Nirajan\u0026#34; age=20 classes=\u0026#34;Bachelor\u0026#34; def display(self): print(f\u0026#34;Name: {self.name}\u0026#34;) print(f\u0026#34;Age: {self.age}\u0026#34;) print(f\u0026#34;Class: {self.classes}\u0026#34;) self.greet() def greet(self): print(\u0026#34;Hello, Welcome to the class\u0026#34;) 1.8 self parameter The self parameter is a reference to the current instance of the class, and is used to access variables and methods of the class. It is the first parameter of any method in a class.\nSyntax:\nclass ClassName: def method_name(self, parameters): #code block Example:\nclass Person: name=\u0026#34;Nirajan\u0026#34; age=20 classes=\u0026#34;Bachelor\u0026#34; def display(self): print(f\u0026#34;Name: {self.name}\u0026#34;) print(f\u0026#34;Age: {self.age}\u0026#34;) print(f\u0026#34;Class: {self.classes}\u0026#34;) self.greet() def greet(self): print(\u0026#34;Hello, Welcome to the class\u0026#34;) 2. Constructor in Python A constructor is a special type of method (function) which is used to initialize the instance members of the class. It is called when an object of the class is created.\n2.1 Creating a constructor In Python, the constructor method is called __init__. It is a special method that is automatically called when an object is created.\nSyntax:\nclass ClassName: def __init__(self, parameters): #code block Example:\nclass Person: def __init__(self, name, age, classes): self.name = name self.age = age self.classes = classes def display(self): print(f\u0026#34;Name: {self.name}\u0026#34;) print(f\u0026#34;Age: {self.age}\u0026#34;) print(f\u0026#34;Class: {self.classes}\u0026#34;) 2.2 Creating an object with constructor When an object is created, the constructor method is automatically called with the arguments passed to the class.\nSyntax:\nobject_name = ClassName(arguments) Example:\nperson1 = Person(\u0026#34;Nirajan\u0026#34;, 20, \u0026#34;Bachelor\u0026#34;) 3. Getters and Setters in Python 3.1. Getters Getters are methods is implementes by using the @property decorator. They are specially used\nto act as an value ie data instead of a method. to access the value of a private attribute without directly accessing it. Syntax:\nclass ClassName: @property def method_name(self): #code block Example:\nclass Person: def __init__(self, name, age): self._name = name self._age = age @property def display(self): return f\u0026#34;Name: {self._name}, Age: {self._age}\u0026#34; person1 = Person(\u0026#34;Nirajan\u0026#34;, 20) print(person1.display) # Output: Name: Nirajan, Age: 20 3.2. Setters Setters are methods is implementes by using the @method_name.setter decorator. They are specially used\nto set the value of a private attribute without directly setting it. to perform validation before setting the value of an attribute. Syntax:\nclass ClassName: @method_name.setter def method_name(self, value): #code block Example:\nclass Person: def __init__(self, name, age): self._name = name self._age = age @property def display(self): return f\u0026#34;Name: {self._name}, Age: {self._age}\u0026#34; @display.setter def display(self, value): self._name, self._age = value.split(\u0026#34;,\u0026#34;) self._age = int(self._age) person1 = Person(\u0026#34;Nirajan\u0026#34;, 20) print(person1.display) # Output: Name: Nirajan, Age: 20 person1.display = \u0026#34;Alice, 30\u0026#34; print(person1.display) # Output: Name: Alice, Age: 30 4. Inheritance in Python Inheritance is a mechanism in which one class acquires the properties and behavior of another class. The class which inherits the properties and behavior is known as the child class, and the class whose properties and behavior are inherited is known as the parent class.\n4.1. Creating a child class To create a child class that inherits from a parent class, we specify the parent class in parentheses after the child class name.\nSyntax:\nclass ChildClassName(ParentClassName): #code block Example:\nclass Employee: def __init__(self,name,age,id): self.name=name self.age=age self.id=id def display(self): print(f\u0026#34;Name: {self.name}\u0026#34;) print(f\u0026#34;Age: {self.age}\u0026#34;) print(f\u0026#34;ID: {self.id}\u0026#34;) class Manager(Employee):# it has all the properties of Employee class so we can access the # properties of Employee class also its method using object of Manager class def task(self): self.display() print(\u0026#34;Assigning tasks to employees\u0026#34;) class Developer(Employee): # it has all the properties of Employee class so we can access # the properties of Employee class also its method using object of Developer class def task(self): self.display() print(\u0026#34;Developing software applications\u0026#34;) manager1 = Manager(\u0026#34;Alice\u0026#34;, 30, 101) manager1.task() developer1 = Developer(\u0026#34;Bob\u0026#34;, 25, 102) developer1.task() Note : Only public and protected members are inherited by the child class. Private members are not inherited by the child class.\n5.Ascess Specifiers in Python 5.1. Public members Public members are accessible from outside the class. They can be accessed using the dot operator (.) from outside the class.\nExample:\nclass Person: name = \u0026#34;Alice\u0026#34; # Public member person1 = Person() print(person1.name) # Output: Alice 5.2. Protected members Protected members are accessible within the class and its subclasses. They are denoted by a single underscore (_) before the member name.\nExample:\nclass Person: _age = 30 # Protected member class Student(Person): def display(self): print(self._age) # Accessing protected member student1 = Student() student1.display() # Output: 30 Example of protected variable and method\nclass Person: _name = \u0026#34;Alice\u0026#34; # Protected variable def _display(self): # Protected method print(f\u0026#34;Name: {self._name}\u0026#34;) class Student(Person): def display(self): self._display() # Accessing protected metho student1 = Student() student1.display() # Output: Name: Alice 5.3. Private members Private members are accessible only within the class. They are denoted by a double underscore (__) before the member name.\nExample:\nclass Person: __city = \u0026#34;New York\u0026#34; # Private member person1 = Person() print(person1.__city) # Error: \u0026#39;Person\u0026#39; object has no attribute \u0026#39;__city\u0026#39; Example of private variable and method\nclass Person: __name = \u0026#34;Alice\u0026#34; # Private variable def __display(self): # Private method print(f\u0026#34;Name: {self.__name}\u0026#34;) person1 = Person() print(person1.__name) # Error: \u0026#39;Person\u0026#39; object has no attribute \u0026#39;__name\u0026#39; person1.__display() # Error: \u0026#39;Person\u0026#39; object has no attribute \u0026#39;__display\u0026#39; Table of Access Specifiers in Python:\nAccess Specifier Accessible from class Accessible from subclass Accessible from outside class Public Yes Yes Yes Protected Yes Yes No Private Yes No No Static Method in Python Static Method is those method that can be called without creating an object of the class. They are defined using the @staticmethod decorator. They can be called using the class name . Syntax: class ClassName: @staticmethod def method_name(parameters): #code block Example:\nclass Calculator: @staticmethod def add(a, b): return a + b result = Calculator.add(5, 3) print(result) # Output: 8 #Can call using object also calculator = Calculator() result = calculator.add(5, 3) print(result) # Output: 8 #this is also valid but it is not recommended Class Method in Python They are defined using the @classmethod decorator.The useage of class method is to access the class variable and change class variable. ie when we change variable using class method it will change for all the object of the class.THey can be called using the class name. Syntax:\nclass ClassName: @classmethod def method_name(cls, parameters): #code block Example:\nclass copany : copany=\u0026#34;Google\u0026#34; @classmethod def change_company(cls,new_company): cls.copany=new_company print(copany.copany) #Output: Google copany.change_company(\u0026#34;Microsoft\u0026#34;) print(copany.copany) #Output: Microsoft c1=copany() print(c1.copany) #Output: Microsoft c1.change_company(\u0026#34;Apple\u0026#34;) c2=copany() print(c2.copany) #Output: Applex Dir and dict method in Python dir() method is used to return a list of attributes and methods of any object. It returns a list of valid attributes and methods of the object. Syntax:\ndir(object) Example:\nclass Person: name = \u0026#34;Alice\u0026#34; age = 30 person1 = Person() print(dir(person1)) # Output: [\u0026#39;__class__\u0026#39;, \u0026#39;__delattr__\u0026#39;, \u0026#39;__dict__\u0026#39;, \u0026#39;__dir__\u0026#39;, \u0026#39;__doc__\u0026#39;, \u0026#39;__eq__\u0026#39;, \u0026#39;__format__\u0026#39;, \u0026#39;__ge__\u0026#39;, \u0026#39;__getattribute__\u0026#39;, \u0026#39;__gt__\u0026#39;, \u0026#39;__hash__\u0026#39;, \u0026#39;__init__\u0026#39;, \u0026#39;__init_subclass__\u0026#39;, \u0026#39;__le__\u0026#39;, \u0026#39;__lt__\u0026#39;, \u0026#39;__module__\u0026#39;, \u0026#39;__ne__\u0026#39;, \u0026#39;__new__\u0026#39;, \u0026#39;__reduce__\u0026#39;, \u0026#39;__reduce_ex__\u0026#39;, \u0026#39;__repr__\u0026#39;, \u0026#39;__setattr__\u0026#39;, \u0026#39;__sizeof__\u0026#39;, \u0026#39;__str__\u0026#39;, \u0026#39;__subclasshook__\u0026#39;, \u0026#39;__weakref__\u0026#39;, \u0026#39;age\u0026#39;, \u0026#39;name\u0026#39;] Example:\nl=[1,2,3] print(dir(l)) # Output: [\u0026#39;__add__\u0026#39;, \u0026#39;__class__\u0026#39;, \u0026#39;__class_getitem__\u0026#39;, \u0026#39;__contains__\u0026#39;, \u0026#39;__delattr__\u0026#39;, \u0026#39;__delitem__\u0026#39;, \u0026#39;__dir__\u0026#39;, \u0026#39;__doc__\u0026#39;, \u0026#39;__eq__\u0026#39;, \u0026#39;__format__\u0026#39;, \u0026#39;__ge__\u0026#39;, \u0026#39;__getattribute__\u0026#39;, \u0026#39;__getitem__\u0026#39;, \u0026#39;__getstate__\u0026#39;, \u0026#39;__gt__\u0026#39;, \u0026#39;__hash__\u0026#39;, \u0026#39;__iadd__\u0026#39;, \u0026#39;__imul__\u0026#39;, \u0026#39;__init__\u0026#39;, \u0026#39;__init_subclass__\u0026#39;, \u0026#39;__iter__\u0026#39;, \u0026#39;__le__\u0026#39;, \u0026#39;__len__\u0026#39;, \u0026#39;__lt__\u0026#39;, \u0026#39;__mul__\u0026#39;, \u0026#39;__ne__\u0026#39;, \u0026#39;__new__\u0026#39;, \u0026#39;__reduce__\u0026#39;, \u0026#39;__reduce_ex__\u0026#39;, \u0026#39;__repr__\u0026#39;, \u0026#39;__reversed__\u0026#39;, \u0026#39;__rmul__\u0026#39;, \u0026#39;__setattr__\u0026#39;, \u0026#39;__setitem__\u0026#39;, \u0026#39;__sizeof__\u0026#39;, \u0026#39;__str__\u0026#39;, \u0026#39;__subclasshook__\u0026#39;, \u0026#39;append\u0026#39;, \u0026#39;clear\u0026#39;, \u0026#39;copy\u0026#39;, \u0026#39;count\u0026#39;, \u0026#39;extend\u0026#39;, \u0026#39;index\u0026#39;, \u0026#39;insert\u0026#39;, \u0026#39;pop\u0026#39;, \u0026#39;remove\u0026#39;, \u0026#39;reverse\u0026#39;, \u0026#39;sort\u0026#39;] __dict__ method is used to return a dictionary containing the attributes of an object. It returns a dictionary containing the attributes of the object.\nSyntax:\nobject.__dict__ Example:\nclass Person: name = \u0026#34;Alice\u0026#34; age = 30 person1 = Person() print(person1.__dict__) # Output: {\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 30} 9.super() method in Python When a parent class and a child class define a method with the same name, and we create an object of the child class, invoking the method on the child class object will execute the method defined in the child class, not the one in the parent class. To explicitly call the parent class\u0026rsquo;s method, we can use the super() function.\nTo explicitly invoke the parent class\u0026rsquo;s version of the method, the super() function is used. This is especially useful when the child class\u0026rsquo;s method needs to build upon or extend the functionality of the parent class\u0026rsquo;s method.\nSyntax:\nsuper().method_name() Example:\nclass Person: def display(self): print(\u0026#34;Person class\u0026#34;) class Student(Person): def display(self): super().display() print(\u0026#34;Student class\u0026#34;) student1 = Student() student1.display() # Output: # Person class # Student class Example:\nclass Person: def __init__(self,name,age): self.name=name self.age=age class Student(Person): def __init__(self,name,age,roll): super().__init__(name,age) self.roll=roll def display(self): print(f\u0026#34;Name: {self.name}\u0026#34;) print(f\u0026#34;Age: {self.age}\u0026#34;) print(f\u0026#34;Roll: {self.roll}\u0026#34;) student1 = Student(\u0026#34;Alice\u0026#34;, 30, 101) student1.display() # Output: # Name: Alice # Age: 30 # Roll: 101 Note: Use super for single inheritance only. For multiple inheritance, use the class name directly.\nMagic/dunder methods in Python Magic methods are special methods that have double underscores at the beginning and end of their names. They are also known as dunder methods (short for \u0026ldquo;double underscore\u0026rdquo;). Magic methods are used to define the behavior of objects. They are automatically called when certain operations are performed on objects. Some of the commonly used magic methods are:\n__init__: Constructor method, called when an object is created. __str__: Called by the str() built-in function to return a string representation of an object. __repr__: Called by the repr() built-in function to return an unambiguous string representation of an object. __add__: Called by the + operator to perform addition. __len__: Called by the len() built-in function to return the length of an object. __call__: Called when an object is called as a function. Note : All magic method can be seen using dir(objectname) method and we can override the magic method in our class.\nexample of all method:\nclass Person: def __init__(self, name, age): self.name = name self.age = age def __str__(self): return f\u0026#34;Name: {self.name}, Age: {self.age}\u0026#34; def __repr__(self): return f\u0026#34;Person(\u0026#39;{self.name}\u0026#39;, {self.age})\u0026#34; def __add__(self, other): return self.age + other.age def __len__(self): return len(self.name) def __call__(self): return f\u0026#34;Name: {self.name}, Age: {self.age}\u0026#34; person1 = Person(\u0026#34;Alice\u0026#34;, 30) person2 = Person(\u0026#34;Bob\u0026#34;, 25) print(person1) # Output: Name: Alice, Age: 30 print(repr(person1)) # Output: Person(\u0026#39;Alice\u0026#39;, 30) print(person1 + person2) # Output: 55 print(len(person1)) # Output: 5 print(person1()) # Output: Name: Alice, Age: 30 Method Overriding Method overriding is a feature of object-oriented programming that allows a subclass to provide a specific implementation of a method that is already provided by its parent class. When a method in a subclass has the same name, same parameters or signature, and same return type as a method in its parent class, then the method in the subclass is said to override the method in the parent class. Example:\nclass Person: def display(self): print(\u0026#34;Person class\u0026#34;) class Student(Person): def display(self): print(\u0026#34;Student class\u0026#34;) student1 = Student() student1.display() # Output: Student class We can also call the parent class\u0026rsquo;s method from the overridden method using the super() function.\nExample:\nclass Person: def display(self): print(\u0026#34;Person class\u0026#34;) class Student(Person): def display(self): super().display() #Or Person.display(self) print(\u0026#34;Student class\u0026#34;) student1 = Student() student1.display() # Output: # Person class # Student class Operator overloading in Python Operator overloading is a feature of object-oriented programming that allows us to define the behavior of operators for user-defined objects. It allows us to define the behavior of operators such as +, -, *, /, ==, !=, etc., for objects of a class. To overload an operator, we need to define a special method in the class that corresponds to the operator. These special methods are called magic methods or dunder methods.\nExample:\nclass Point: def __init__(self, x, y): self.x = x self.y = y def __add__(self, other): x = self.x + other.x y = self.y + other.y return Point(x, y) def __str__(self): return f\u0026#34;({self.x}, {self.y})\u0026#34; point1 = Point(1, 2) point2 = Point(3, 4) point3 = point1 + point2 print(point3) # Output: (4, 6) Types of Inheritance in Python Inheritance is a mechanism in which one class acquires the properties and behavior of another class. There are different types of inheritance in Python: Single Inheritance: In single inheritance, a class inherits from only one parent class. The pictorial representation of single inheritance is:\nA\r|\rB Syntax:\nclass ParentClass: #code block class ChildClass(ParentClass): #code block Example:\nclass Person: def __init__(self, name, age): self.name = name self.age = age def display(self): return f\u0026#34;Name: {self.name}, Age: {self.age}\u0026#34; def __str__(self): return f\u0026#34;Name: {self.name}, Age: {self.age}\u0026#34; def __repr__(self): return f\u0026#34;Person(\u0026#39;{self.name}\u0026#39;, {self.age})\u0026#34; def __call__(self): return f\u0026#34;Name: {self.name}, Age: {self.age}\u0026#34; class Student(Person): def __init__(self,naem,age,id): super().__init__(name,age) #or Person.__init__(self,name,age) self.id=id def display(self): print(f\u0026#34;ID: {self.id}\u0026#34;,super().display()) #or Person.display(self) student1 = Student(\u0026#34;Alice\u0026#34;, 30, 101) student1.display() # Output: # ID: 101 # Name: Alice, Age: 30 Multiple Inheritance: In multiple inheritance, a class inherits from more than one parent class. The pictorial representation of multiple inheritance is:\nA B\r\\ /\rC Syntax:\nclass ParentClass1: #code block class ParentClass2: #code block class ChildClass(ParentClass1, ParentClass2): #code block Example:\nclass Person: def __init__(self, name, age): self.name = name self.age = age def display(self): return f\u0026#34;Name: {self.name}, Age: {self.age}\u0026#34; class Address: def __init__(self,city,state): self.city=city self.state=state def display(self): return f\u0026#34;City: {self.city}, State: {self.state}\u0026#34; class Student(Person,Address): def __init__(self,name,age,id,city,state): Person.__init__(self,name,age) Address.__init__(self,city,state) self.id=id def display(self): print(f\u0026#34;ID: {self.id}\u0026#34;,Person.display(self),Address.display(self)) student1 = Student(\u0026#34;Alice\u0026#34;, 30, 101,\u0026#34;New York\u0026#34;,\u0026#34;New York\u0026#34;) student1.display() # Output: # ID: 101 # Name: Alice, Age: 30 # City: New York, State: New York Multilevel Inheritance: In multilevel inheritance, a class inherits from a parent class, and another class inherits from the child class. The pictorial representation of multilevel inheritance is:\nA\r|\rB\r|\rC Syntax:\nclass ParentClass: #code block class ChildClass(ParentClass): #code block class GrandChildClass(ChildClass): #code block Example:\nclass Person: def __init__(self, name, age): self.name = name self.age = age def display(self): return f\u0026#34;Name: {self.name}, Age: {self.age}\u0026#34; class Student(Person): def __init__(self,name,age,id): super().__init__(name,age) # or Person.__init__(self,name,age) self.id=id def display(self): print(f\u0026#34;ID: {self.id}\u0026#34;,super().display()) # print(f\u0026#34;ID: {self.id}\u0026#34;,Person.display(self)) class CollegeStudent(Student): def __init__(self,name,age,id,classes): super().__init__(name,age,id) #or Student.__init__(self,name,age,id) self.classes=classes def display(self): print(f\u0026#34;Class: {self.classes}\u0026#34;,super().display()) #or print(f\u0026#34;Class: {self.classes}\u0026#34;,Student.display(self)) student1 = CollegeStudent(\u0026#34;Alice\u0026#34;, 30, 101,\u0026#34;Bachelor\u0026#34;) student1.display() # Output: # Class: Bachelor # ID: 101 # Name: Alice, Age: 30 Hierarchical Inheritance: In hierarchical inheritance, more than one class inherits from a single parent class. The pictorial representation of hierarchical inheritance is:\nA\r/ \\\rB C Syntax:\nclass ParentClass: #code block class ChildClass1(ParentClass): #code block class ChildClass2(ParentClass): #code block Example:\nclass Person: def __init__(self, name, age): self.name = name self.age = age def display(self): return f\u0026#34;Name: {self.name}, Age: {self.age}\u0026#34; class Student(Person): def __init__(self,name,age,id): super().__init__(name,age) #or Person.__init__(self,name,age) self.id=id def display(self): print(f\u0026#34;ID: {self.id}\u0026#34;,super().display()) #or print(f\u0026#34;ID: {self.id}\u0026#34;,Person.display(self)) class Employee(Person): def __init__(self,name,age,emp_id): super().__init__(name,age) #or Person.__init__(self,name,age) self.emp_id=emp_id def display(self): print(f\u0026#34;Emp ID: {self.emp_id}\u0026#34;,super().display()) #or print(f\u0026#34;Emp ID: {self.emp_id}\u0026#34;,Person.display(self)) student1 = Student(\u0026#34;Alice\u0026#34;, 30, 101) student1.display() employee1 = Employee(\u0026#34;Bob\u0026#34;, 25, 201) employee1.display() # Output: # ID: 101 # Name: Alice, Age: 30 # Emp ID: 201 # Name: Bob, Age: 25 Note: Hybrid inheritance is a combination of two or more types of inheritance.\n14. MRO (Method Resolution Order) in Python Method Resolution Order (MRO) is the order in which methods are resolved in the inheritance hierarchy. It defines the order in which the base classes are searched when executing a method.\nfor example:\nclass C: f=\u0026#34;dirajan\u0026#34; class A(C): f=\u0026#34;nirajan\u0026#34; class B(C): f=\u0026#34;kirajan\u0026#34; class D(A,B): pass def display(self): print(self.f) d=D() print(D.__mro__) d.display() Output:\n(\u0026lt;class \u0026#39;__main__.D\u0026#39;\u0026gt;, \u0026lt;class \u0026#39;__main__.A\u0026#39;\u0026gt;, \u0026lt;class \u0026#39;__main__.B\u0026#39;\u0026gt;, \u0026lt;class \u0026#39;__main__.C\u0026#39;\u0026gt;, \u0026lt;class \u0026#39;object\u0026#39;\u0026gt;)\rnirajan It means it will search for the method in the order of D-\u0026gt;A-\u0026gt;B-\u0026gt;C-\u0026gt;object if the method is not found in the D it will search in A and so on. but if the method is found in the D it will not search in the A,B,C and object.\n15.Class Inside a Class in Python A class can be defined inside another class. The class inside the class is known as nested class. The nested class can access the attributes and methods of the outer class.\nSyntax:\nclass OuterClass: class InnerClass: #code block Example:\nclass OuterClass: def __init__(self): self.name = \u0026#34;Alice\u0026#34; self.age = 30 class InnerClass: def display(self, outer): print(f\u0026#34;Name: {outer.name}\u0026#34;) print(f\u0026#34;Age: {outer.age}\u0026#34;) outer1 = OuterClass() inner1 = outer1.InnerClass() inner1.display(outer1) # Output: # Name: Alice # Age: 30 16. Nested class in Python A class can be defined inside another class. The class inside the class is known as nested class. The nested class can access the attributes and methods of the outer class.\nSyntax:\nclass OuterClass: class InnerClass: #code block Creating an object of the nested class: Syntax:\nouter_object = OuterClass() inner_object = outer_object.InnerClass() Example:\nclass OuterClass: def __init__(self): self.name = \u0026#34;Alice\u0026#34; self.age = 30 class InnerClass: def display(self, outer): print(f\u0026#34;Name: {outer.name}\u0026#34;) print(f\u0026#34;Age: {outer.age}\u0026#34;) outer1 = OuterClass() inner1 = outer1.InnerClass() inner1.display(outer1) # Output: # Name: Alice # Age: 30 creating an object of the nested class inside the outer class:\nclass OuterClass: def __init__(self): self.name = \u0026#34;Alice\u0026#34; self.age = 30 self.inner = self.InnerClass() class InnerClass: def display(self, outer): print(f\u0026#34;Name: {outer.name}\u0026#34;) print(f\u0026#34;Age: {outer.age}\u0026#34;) outer1 = OuterClass() outer1.inner.display(outer1) # Output: # Name: Alice # Age: 30 ","permalink":"http://localhost:1313/posts/pages/python/python_object_oriented1/","summary":"This is the first part of series of Object Oriented Programming in Python","title":"Python Fundamentals: Exploring OOP (Part 12)"},{"content":"DOM (Document Object Model) Theory The DOM is a programming interface for HTML and XML documents. It represents the document as a tree structure where each node is an object representing a part of the document. This allows programming languages to interact with the document structure, style, and content.\n1. DOM Selection Methods a) document.getElementById() Selects an element by its ID attribute.\n\u0026lt;!-- HTML --\u0026gt; \u0026lt;div id=\u0026#34;myDiv\u0026#34;\u0026gt;Hello\u0026lt;/div\u0026gt; // JavaScript const element = document.getElementById(\u0026#39;myDiv\u0026#39;); console.log(element.innerText); // Output: // \u0026#34;Hello\u0026#34; b) document.getElementsByClassName() Returns a collection of elements with the specified class name.\n\u0026lt;!-- HTML --\u0026gt; \u0026lt;div class=\u0026#34;myClass\u0026#34;\u0026gt;Item 1\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;myClass\u0026#34;\u0026gt;Item 2\u0026lt;/div\u0026gt; // JavaScript const elements = document.getElementsByClassName(\u0026#39;myClass\u0026#39;); for (let i = 0; i \u0026lt; elements.length; i++) { console.log(elements[i].innerText); } // Output: // \u0026#34;Item 1\u0026#34; // \u0026#34;Item 2\u0026#34; c) document.getElementsByTagName() Returns a collection of elements with the specified tag name.\n\u0026lt;!-- HTML --\u0026gt; \u0026lt;p\u0026gt;Paragraph 1\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Paragraph 2\u0026lt;/p\u0026gt; // JavaScript const paragraphs = document.getElementsByTagName(\u0026#39;p\u0026#39;); for (let i = 0; i \u0026lt; paragraphs.length; i++) { console.log(paragraphs[i].innerText); // Output: // \u0026#34;Paragraph 1\u0026#34; // \u0026#34;Paragraph 2\u0026#34; d) document.querySelector() Returns the first element that matches the CSS selector.\n\u0026lt;!-- HTML --\u0026gt; \u0026lt;div class=\u0026#34;myClass\u0026#34;\u0026gt;First Element\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;myClass\u0026#34;\u0026gt;Second Element\u0026lt;/div\u0026gt; // JavaScript const firstElement = document.querySelector(\u0026#39;.myClass\u0026#39;); console.log(firstElement.innerText); // Output: // \u0026#34;First Element\u0026#34; e) document.querySelectorAll() Returns all elements that match the CSS selector.\n\u0026lt;!-- HTML --\u0026gt; \u0026lt;div class=\u0026#34;myClass\u0026#34;\u0026gt;First Element\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;myClass\u0026#34;\u0026gt;Second Element\u0026lt;/div\u0026gt; // JavaScript const allElements = document.querySelectorAll(\u0026#39;.myClass\u0026#39;); allElements.forEach(el =\u0026gt; console.log(el.innerText)); // Output: // \u0026#34;First Element\u0026#34; // \u0026#34;Second Element\u0026#34; 2. DOM Properties a) innerText Gets or sets the text content of an element.\n\u0026lt;!-- HTML --\u0026gt; \u0026lt;div id=\u0026#34;textElement\u0026#34;\u0026gt;Original Text\u0026lt;/div\u0026gt; // JavaScript const element = document.getElementById(\u0026#39;textElement\u0026#39;); element.innerText = \u0026#39;Hello World\u0026#39;; console.log(element.innerText); // Output: // \u0026#34;Hello World\u0026#34; b) innerHTML Gets or sets the HTML content of an element.\n\u0026lt;!-- HTML --\u0026gt; \u0026lt;div id=\u0026#34;htmlElement\u0026#34;\u0026gt;Original Content\u0026lt;/div\u0026gt; // JavaScript const element = document.getElementById(\u0026#39;htmlElement\u0026#39;); element.innerHTML = \u0026#39;\u0026lt;span\u0026gt;Hello World\u0026lt;/span\u0026gt;\u0026#39;; console.log(element.innerHTML); // Output: // \u0026#34;\u0026lt;span\u0026gt;Hello World\u0026lt;/span\u0026gt;\u0026#34; c) textContent Gets or sets the text content of a node and its descendants.\n\u0026lt;!-- HTML --\u0026gt; \u0026lt;div id=\u0026#34;contentElement\u0026#34;\u0026gt;Original Content\u0026lt;/div\u0026gt; // JavaScript const element = document.getElementById(\u0026#39;contentElement\u0026#39;); element.textContent = \u0026#39;Hello World\u0026#39;; console.log(element.textContent); // Output: // \u0026#34;Hello World\u0026#34; d) style Gets or sets inline styles of an element.\n\u0026lt;!-- HTML --\u0026gt; \u0026lt;div id=\u0026#34;styledElement\u0026#34;\u0026gt;Style Me\u0026lt;/div\u0026gt; // JavaScript const element = document.getElementById(\u0026#39;styledElement\u0026#39;); element.style.backgroundColor = \u0026#39;red\u0026#39;; element.style.fontSize = \u0026#39;16px\u0026#39;; // Result: Element with red background and font size of 16px 3. Events in JavaScript Events are actions that occur in a web page that can be detected by JavaScript.\nClick Event Example \u0026lt;!-- HTML --\u0026gt; \u0026lt;button id=\u0026#34;clickButton\u0026#34;\u0026gt;Click Me\u0026lt;/button\u0026gt; // JavaScript const button = document.getElementById(\u0026#39;clickButton\u0026#39;); button.addEventListener(\u0026#39;click\u0026#39;, function(e) { console.log(\u0026#39;Clicked!\u0026#39;); }); // Output when clicked: // \u0026#34;Clicked!\u0026#34; Mouse Over Event Example \u0026lt;!-- HTML --\u0026gt; \u0026lt;div id=\u0026#34;hoverElement\u0026#34;\u0026gt;Hover Over Me\u0026lt;/div\u0026gt; // JavaScript const element = document.getElementById(\u0026#39;hoverElement\u0026#39;); element.addEventListener(\u0026#39;mouseover\u0026#39;, function(e) { console.log(\u0026#39;Mouse over!\u0026#39;); }); // Output when hovered: // \u0026#34;Mouse over!\u0026#34; ","permalink":"http://localhost:1313/posts/pages/js/domevents/","summary":"A complete reference guide for DOM manipulation and Events","title":"Javascript : Dom and Events"},{"content":"Asynchronous Programming in JavaScript Asynchronous programming allows a program to perform multiple tasks simultaneously. It enables non-blocking operations, making it possible to execute long-running tasks without freezing the main program.\nFor example:\nconsole.log(\u0026#39;Start\u0026#39;); setTimeout(() =\u0026gt; { console.log(\u0026#39;This message is delayed by 2 seconds\u0026#39;); }, 2000); console.log(\u0026#39;End\u0026#39;); When you run this code, the output will be:\nStart\rEnd\rThis message is delayed by 2 seconds Explanation:\nconsole.log('Start'); is executed, and \u0026ldquo;Start\u0026rdquo; is printed. setTimeout() sets up a callback function to run after 2000 milliseconds (2 seconds) but does not block the next line. console.log('End'); is executed immediately after, and \u0026ldquo;End\u0026rdquo; is printed. After 2 seconds, the callback function in setTimeout() is executed, and \u0026ldquo;This message is delayed by 2 seconds\u0026rdquo; is printed. This demonstrates how asynchronous functions like setTimeout() work without blocking the execution of subsequent code.\nPromises Promises are a way to handle asynchronous operations in JavaScript. They represent a value that may be available now, in the future, or never. Promises can be in one of three states: pending, fulfilled, or rejected. They allow us to run code when the promise is fulfilled or rejected using the .then() and .catch() methods.\nSyntax to create a new Promise:\nconst promise = new Promise((resolve, reject) =\u0026gt; { // Perform an asynchronous operation // If successful, call resolve(value) // If an error occurs, call reject(error) }); Why We Use Promises Consider the following code:\nfunction main() { setTimeout(() =\u0026gt; { console.log(\u0026#34;Hello\u0026#34;); }, 1000); } main(); main(); main(); This code waits for 1 second and then logs \u0026ldquo;Hello\u0026rdquo; three times instantly. But what if we want to wait for the first to be completed before the second?\nThis can be solved using promises:\nfunction promise() { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { console.log(\u0026#34;Hello\u0026#34;); resolve(\u0026#34;Done\u0026#34;); }, 2000); }); } let data = promise(); When a promise is called, it returns a promise object instantly in a pending state. When the asynchronous operation completes, the promise is either fulfilled or rejected.\nHandling Promises To do a task when the promise is fulfilled (resolved):\ndata.then((data) =\u0026gt; { console.log(data); }); To do a task when the promise is rejected:\ndata.catch((err) =\u0026gt; { console.log(\u0026#34;Promise rejected\u0026#34;, err); }); Handling Multiple Promises function promise1() { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { console.log(\u0026#34;Promise 1 resolved\u0026#34;); resolve(\u0026#34;Done 1\u0026#34;); }, 2000); }); } function promise2() { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { console.log(\u0026#34;Promise 2 resolved\u0026#34;); resolve(\u0026#34;Done 2\u0026#34;); }, 2000); }); } function promise3() { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { console.log(\u0026#34;Promise 3 resolved\u0026#34;); resolve(\u0026#34;Done 3\u0026#34;); }, 2000); }); } let data1 = promise1(); let data2 = promise2(); let data3 = promise3(); How Promises Work:\npromise1 is called. promise2 is called immediately. promise3 is called immediately, regardless of whether the previous promises are resolved. To execute promises one by one:\nlet data1 = promise1(); data1.then((data) =\u0026gt; { console.log(data); return promise2(); }).then((data) =\u0026gt; { console.log(data); return promise3(); }).then((data) =\u0026gt; { console.log(data); }).catch((err) =\u0026gt; { console.log(\u0026#34;Error\u0026#34;, err); }); Here, the first promise will run, then the second, then the third, and so on, one by one.\nAsync and Await Async functions always return a promise. await is used to wait for a promise to be resolved, such that the code below it will not run until the promise is resolved.\nTo use await, we need to use an async function:\nasync function main() { console.log(\u0026#34;Hello\u0026#34;); } main(); Example with await:\nlet promise = new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { resolve(\u0026#34;Done\u0026#34;); }, 2000); }); async function main() { console.log(\u0026#34;Hello\u0026#34;); await promise; console.log(\u0026#34;Hello again\u0026#34;); } main(); console.log(\u0026#34;Hi\u0026#34;); What happens here is the main function is called, it prints \u0026ldquo;Hello\u0026rdquo;, then waits for 2 seconds to resolve. During that time, it prints \u0026ldquo;Hi\u0026rdquo;. When the promise is resolved, it prints \u0026ldquo;Hello again\u0026rdquo;.\nWhen await is called, the function pauses its execution until the promise is resolved. Then it continues the execution of the function, such that code below await will not run until the promise is resolved, but the code outside the function will run.\nasync function main() { console.log(\u0026#34;Hello\u0026#34;); await promise; await promise; await promise; console.log(\u0026#34;Hello again\u0026#34;); } Here, the first promise is resolved, then the second is resolved, and so on.\n","permalink":"http://localhost:1313/posts/pages/js/asyncronous/","summary":"A complete guide to asynchronous programming in JavaScript, covering promises and async/await.","title":"Asynchronous Programming in JavaScript"},{"content":"Basics of Vim Vim is a powerful text editor, often used in the command line, that is known for its efficiency and speed once mastered. Here are the basic commands and modes that you need to get started.\nOpening a File To open a file in Vim, use the following command:\nvim filename Replace filename with the name of the file you wish to open.\nBasic Modes in Vim Vim operates in different modes, and understanding these modes is crucial for using Vim effectively:\nNormal Mode: This is the default mode when you open a file. In this mode, you can navigate, delete, copy, and paste text. To return to Normal Mode from other modes, press Esc.\nInsert Mode: This mode allows you to insert text into the file. To enter Insert Mode, press i. After you\u0026rsquo;re done typing, press Esc to go back to Normal Mode.\nCommon Commands Here are some essential commands for working with files in Vim:\nSave the current file:\n:w This writes (saves) changes to the file.\nQuit Vim:\n:q To quit Vim. If there are unsaved changes, Vim will warn you. You can force quit without saving using:\n:q! Save changes and quit:\n:wq or\n:x These commands save changes and then exit Vim.\nTips for Beginners Press Esc frequently to return to Normal Mode, as it helps you avoid unintended actions while in other modes. Practice using both Normal and Insert modes to become comfortable with the flow of editing and saving files in Vim. Vim can be intimidating at first, but with practice, it becomes an extremely efficient tool for editing text files, especially in programming and development environments. ","permalink":"http://localhost:1313/posts/pages/linux/vim_basics_guide/","summary":"Learn the basics of using Vim, including navigation, saving, and quitting.","title":"Basics of Vim"},{"content":"Docker Cheat Sheet: Commands and Concepts This guide covers essential Docker commands, from creating containers, managing images, building Dockerfiles, to working with volumes.\n🚀 Creating and Running Containers 1. Run a Container from an Image To create and run a container from an image:\ndocker run image 2. Run a Container in Interactive Mode To run a container and open its terminal:\ndocker run -it image After the container starts, you can interact with it directly in the terminal. 3. Name a Container To give a container a specific name:\ndocker run --name container_name image 4. Port Mapping To map a port from your computer to the container:\ndocker run -p computer_port:container_port image Incoming traffic to computer_port will be forwarded to container_port in the container. 5. Run a Container in the Background (Detached Mode) To run the container in the background:\ndocker run -d image 6. Passing Environment Variables to a Container To pass environment variables to a container:\ndocker run -e key=value image 🛠️ Managing Containers 7. Start a Container To start an existing container:\ndocker start container_id 8. Stop a Container To stop a running container:\ndocker stop container_id 9. Remove a Container To remove a container:\ndocker rm container_id Note: The container must be stopped before removal. 10. Execute a Command in a Running Container To start a terminal session inside a running container:\ndocker exec -it container_id bash 11. View Running Containers To list all currently running containers:\ndocker ps 12. View All Containers (Running and Stopped) To see all containers, including those that are stopped:\ndocker ps -a 🧱 Building Docker Images 13. Creating a Dockerfile A Dockerfile is a script used to build Docker images. Here’s an example of common Dockerfile commands:\n# Set the base image for your container FROM base_image # Run commands during the image build process RUN command # Copy files from your local machine to the container COPY source /path/in/container # Set environment variables ENV key=value # Expose a port for the container EXPOSE 8080 # Define the command to run when the container starts CMD [\u0026#34;executable\u0026#34;] # Optionally, run commands automatically when the container starts ENTRYPOINT [\u0026#34;/path/to/script\u0026#34;] # Set the working directory in the container WORKDIR /app # Copy all files from the local directory to the container, excluding files listed in .dockerignore COPY . . 14. Building a Docker Image To build a Docker image from a Dockerfile:\ndocker build -t image_name /path/to/Dockerfile 📂 Managing Docker Files 15. Using the .dockerignore File The .dockerignore file helps exclude unnecessary files from being copied into the Docker image, improving build speed and reducing image size:\nnode_modules/ .git/ 16. COPY Command in Dockerfile The COPY command copies files from your local system to the container:\nCopy all files from the current directory to the container: COPY . /path/in/container Copy a specific file: COPY ./filename.extension /path/in/container Copy an entire folder: COPY ./foldername /path/in/container Copy contents of a folder (not the folder itself): COPY ./foldername/ /path/in/container 📦 Working with Volumes 17. Mounting Volumes Volumes allow data to persist even if the container is deleted. To mount a folder from your host to the container:\ndocker run -it -v /path/on/host:/path/in/container image Example: docker run -it -v /home/user/backup:/app/data ubuntu This will map /home/user/backup on your host to /app/data inside the container. Use Cases for Volumes: Data Persistence: Preserve data even after the container is removed. Backups: Easily back up container data to the host. Shared Data: Share data between multiple containers or between host and container. 💾 Publishing Docker Images 18. Pushing an Image to Docker Hub To publish an image to Docker Hub:\nTag the image with your Docker Hub username: docker tag image_name username/image_name Log in to Docker Hub: docker login Push the image to your repository: docker push username/image_name This guide gives you the essentials for working with Docker. With these commands, you\u0026rsquo;ll be able to manage containers, build images, use volumes, and more effectively.\n","permalink":"http://localhost:1313/posts/pages/docker/docker_basics/","summary":"A guide to understanding Docker commands and concepts.","title":"Docker Basic: Commands and Concepts"},{"content":"Docker Compose Documentation Introduction Docker Compose is a tool for defining and running multi-container Docker applications. With Docker Compose, you can use a YAML file to configure your application\u0026rsquo;s services and create and start all the services from your configuration with a single command.\nBasic docker-compose.yml Structure The docker-compose.yml file is where you define the services that make up your app. A typical file might look like this:\nversion: \u0026#39;3.8\u0026#39; services: service_name: image: image_name:tag ports: - \u0026#34;host_port:container_port\u0026#34; environment: - ENV_VAR=value volumes: - \u0026#34;host_path:container_path\u0026#34; depends_on: - dependency_service Example Configurations Example 1: Basic Setup with PostgreSQL and Redis version: \u0026#39;3.8\u0026#39; services: postgres: image: postgres ports: - \u0026#34;5432:5432\u0026#34; environment: POSTGRES_USER: postgres POSTGRES_DB: review POSTGRES_PASSWORD: password redis: image: redis ports: - \u0026#34;80:80\u0026#34; Example 2: Real-World Application version: \u0026#39;3\u0026#39; services: pythonapp: image: your-python-image:tag ports: - \u0026#34;8000:8000\u0026#34; volumes: - /Users/data:/src/bin/data depends_on: - db - redis db: image: postgres environment: POSTGRES_DB: mydatabase POSTGRES_USER: myuser POSTGRES_PASSWORD: mypassword redis: image: redis volumes: - /path/to/local/directory:/data Example 3: Building from Dockerfile version: \u0026#39;3\u0026#39; services: pythonapp: build: context: . dockerfile: Dockerfile ports: - \u0026#34;8000:8000\u0026#34; volumes: - /Users/desktop:/src/bin/desktop depends_on: - db - redis db: image: postgres environment: POSTGRES_DB: mydatabase POSTGRES_USER: myuser POSTGRES_PASSWORD: mypassword redis: image: redis volumes: - /path/to/local/directory:/data Example 4: Django Application with PostgreSQL and Redis version: \u0026#39;3.8\u0026#39; services: django-app: container_name: django-app image: django-app:latest # Replace with your actual Django image name/tag ports: - \u0026#34;8000:8000\u0026#34; # Expose Django app on port 8000 environment: - DEBUG=1 # Set Django debug mode to 1 for development - POSTGRES_HOST=postgres # PostgreSQL host - POSTGRES_DB_NAME=nirajan # PostgreSQL database name - POSTGRES_DB_PASSWORD=nirajan@9845 # PostgreSQL database password - REDIS_URL=redis://redis:6379/0 # Redis URL depends_on: - postgres - redis volumes: - static_volume:/code/static # Volume for Django static files - media_volume:/code/media # Volume for Django media files postgres: container_name: postgres image: postgres:latest environment: POSTGRES_DB: nirajan # Database name POSTGRES_USER: nirajan # Database username POSTGRES_PASSWORD: nirajan@9845 # Database password volumes: - postgres_data:/var/lib/postgresql/data redis: container_name: redis image: redis:latest ports: - \u0026#34;6379:6379\u0026#34; Service Names as Hostnames In Docker Compose, the names of the services defined in the docker-compose.yml file are used as hostnames for inter-service communication.\nService Names as Hostnames Each service name in the docker-compose.yml file acts as a hostname for that service. For example, in the configuration above:\nThe django-app service can connect to the postgres service using POSTGRES_HOST=postgres. The django-app service can connect to the redis service using REDIS_URL=redis://redis:6379/0. Example In the django-app service:\nPostgreSQL Host: POSTGRES_HOST=postgres — The Django app connects to the PostgreSQL service using the hostname postgres, which matches the name of the PostgreSQL service defined in Docker Compose. Redis Host: REDIS_URL=redis://redis:6379/0 — The Django app connects to the Redis service using the hostname redis, which matches the name of the Redis service defined in Docker Compose. Note: In Docker, services within a Docker Compose setup are typically connected to the same network by default. This allows containers to communicate with each other using service names as hostnames.\nDocker Compose Commands To start the containers defined in docker-compose.yml:\nsudo docker compose up To stop and remove all containers, networks, and volumes created by docker-compose up:\nsudo docker compose down To run the containers in the background (detached mode):\nsudo docker compose up -d Tips Use depends_on to specify dependencies between services. This ensures that the dependent services start in the correct order. Use volumes to persist data outside of your containers, which is especially useful for databases. Use environment variables to configure your services and avoid hardcoding sensitive information. Conclusion Docker Compose simplifies the process of managing multi-container Docker applications. By defining your services in a docker-compose.yml file, you can easily spin up your entire application stack with a single command. This guide provides a solid starting point for using Docker Compose to manage multi-container applications effectively.\n","permalink":"http://localhost:1313/posts/pages/docker/docker_compose/","summary":"Learn how to define and manage services in Docker Compose.","title":"Docker Compose Documentation"},{"content":"Docker CPU and Memory Limits When you want to control the CPU and memory usage of Docker containers, you can use specific options in both Docker CLI commands and Docker Compose files. Here\u0026rsquo;s a detailed guide on how to use these options:\nDocker CLI Commands Setting CPU Limits:\nOption: --cpus Usage: Specifies the number of CPUs that the container can use. Example: docker run --cpus=\u0026#34;1.5\u0026#34; my-image The --cpus option limits the container to 1.5 CPU cores. Setting Memory Limits:\nOption: --memory or -m\nUsage: Sets the maximum amount of memory the container can use.\nExample:\ndocker run --memory=\u0026#34;500m\u0026#34; my-image This command limits the container to 500MB of RAM. If the limit is exceeded, the container will be throttled or terminated.\nNote: The options take a positive integer followed by suffixes such as b, k, m, or g to indicate bytes, kilobytes, megabytes, or gigabytes.\nSoft Memory Limits:\nOption: --memory-reservation Example: docker run --memory=\u0026#34;1g\u0026#34; --memory-reservation=\u0026#34;512m\u0026#34; nginx This reserves 512MB of memory while setting a hard limit of 1GB. Docker Compose Configuration In Docker Compose, you can define resource limits under the deploy section for version 3.x or directly under the services section for version 2.x.\nSetting CPU and Memory Limits in Docker Compose (Version 2.x):\nversion: \u0026#39;2\u0026#39; services: my-service: image: my-image deploy: resources: limits: cpus: \u0026#39;1.5\u0026#39; memory: 500M This limits the service to 1.5 CPUs and 500MB of memory.\nSetting CPU and Memory Limits in Docker Compose (Version 3.x and above):\nversion: \u0026#39;3.8\u0026#39; services: my-service: image: my-image deploy: resources: limits: cpus: \u0026#39;1.5\u0026#39; memory: \u0026#39;500M\u0026#39; This limits the service to 1.5 CPUs and 500MB of memory.\nNotes: Swap Memory: You can enable swap memory using the --memory-swap option in CLI. For example:\ndocker run --memory=\u0026#34;512m\u0026#34; --memory-swap=\u0026#34;1g\u0026#34; nginx CPU Shares: Set CPU priorities between containers using --cpu-shares, with 1024 being the default.\nBy using these options, you can ensure that your Docker containers use resources efficiently, preventing them from overwhelming the host machine.\n","permalink":"http://localhost:1313/posts/pages/docker/docker_cpu_memory_limits_guide/","summary":"Control the CPU and memory usage of Docker containers with CLI and Docker Compose configurations.","title":"Docker CPU and Memory Limits"},{"content":"Docker Networking and Port Access In Docker, containers are isolated by default, meaning:\nContainers cannot access the host machine\u0026rsquo;s ports directly. Containers cannot access the ports of other containers directly. Container ports are not accessible from outside the host machine unless configured. 🛠️ Accessing Container Ports from Outside To access a container\u0026rsquo;s port from outside (e.g., from the host or another machine), you can use port mapping:\n1. Port Mapping docker run -p host_port:container_port imagename This command maps a container\u0026rsquo;s port to a port on the host machine. 2. Host Network To share the host\u0026rsquo;s network namespace with the container:\ndocker run --network host imagename 🌐 Accessing Container Ports from Another Container To allow inter-container communication, you need to create and use a custom Docker network.\nSteps: 1. Create a Docker Network docker network create my_network 2. Run Containers in the Same Network docker run --network my_network --name container1 imagename docker run --network my_network --name container2 imagename 3. Access One Container from Another Use the container name and port to access one container from another:\ncontainer1:port Example Scenario Create a Network docker network create my_network Run First Container docker run --network my_network --name webserver -d nginx Run Second Container docker run --network my_network --name client -it alpine /bin/sh Access Web Server from Client Inside the client container, use the following commands to access the web server: wget -qO- http://webserver or\ncurl http://webserver 📝 Important Notes Container-to-Container Access: Containers in the same custom network can communicate using their names as hostnames. Host Machine Access: Containers cannot directly access the host machine\u0026rsquo;s ports. External Access: Use port mapping or host networking to access container ports from outside the host machine. List Docker Networks To list all available Docker networks and verify the existence of custom networks:\ndocker network ls ","permalink":"http://localhost:1313/posts/pages/docker/docker_networking_guide/","summary":"Understanding Docker networking and inter-container communication.","title":"Docker Networking and Port Access"},{"content":" 1. Configure Git To set up your Git username and email globally on your machine:\ngit config --global user.name \u0026#34;username\u0026#34; # Set your Git username git config --global user.email \u0026#34;email\u0026#34; # Set your Git email git config --list # Display the current Git configuration (username and email) 2. Git Status and Git Clone Clone a remote repository to your local machine:\ngit clone \u0026lt;url\u0026gt; # Copy repository to the local machine Check the status of your local repository:\ngit status # Show the current status of the repository Git Status Breakdown: untracked: A new file that has not been added or committed. unstaged: A file that has been added but not committed. unchanged: No changes have been made. changed: Changes have been made but not yet added or committed. 3. Git Add and Commit Add specific files or all changes and commit them:\ngit add \u0026lt;filename\u0026gt; # Add a specific file to the staging area git add . # Add all changes (modified and untracked files) git commit -m \u0026#34;Your commit message\u0026#34; # Commit the changes with a message 4. Push Local Repo to Remote To upload your local repository changes to the remote repository:\ngit push [alias] [branch] # Push changes to a specific alias and branch git remote add \u0026lt;alias\u0026gt; \u0026lt;url\u0026gt; # Add a remote alias (e.g., \u0026#39;origin\u0026#39;) git push -u [alias] [branch] # Save the alias and branch for future pushes 5. Git Initialization Initialize a new Git repository:\ngit init # Initialize a new Git repository 6. Git Branches Manage Git branches with the following commands:\ngit branch # List all local branches git branch -m \u0026lt;oldbranch\u0026gt; \u0026lt;newbranch\u0026gt; # Rename a branch git checkout \u0026lt;branchname\u0026gt; # Switch to another branch git checkout -b \u0026lt;branchname\u0026gt; # Create and switch to a new branch git branch -d \u0026lt;branchname\u0026gt; # Delete a branch (ensure you\u0026#39;re not on it) git diff \u0026lt;branchname\u0026gt; # Compare the current branch with another 7. Git Merge Merge changes from one branch into another:\ngit merge \u0026lt;branchname\u0026gt; # Merge changes from \u0026lt;branchname\u0026gt; into the current branch 8. Pull Request and Syncing Changes To pull updates from the remote repository to your local one:\ngit pull # Pull the latest changes from the remote repository git pull [alias] [branch] # Pull changes from a specific alias and branch 9. Undoing Changes If You Have Only Added Changes: git reset \u0026lt;filename\u0026gt; # Unstage a file from the staging area git reset # Unstage all files that have been added If You Have Committed Changes: git reset HEAD~1 # Undo the last commit (one step back) git reset \u0026lt;commit_hash\u0026gt; # Reset to a specific commit hash git reset --hard \u0026lt;commit_hash\u0026gt; # Hard reset to a commit and reflect changes in your editor git log # View all commit hashes and logs 10. Forking Repositories When contributing to open-source projects, you can fork a repository, which creates a copy of the repo under your GitHub account. Afterward, you can make changes and submit a pull request:\n# Fork a repository on GitHub and clone it locally git clone \u0026lt;forked_repo_url\u0026gt; # Clone your forked repository Make changes, commit them, and push to your fork. Finally, create a pull request on GitHub to merge your changes into the original repository.\nIF ANY CONCEPT IS LAGGING THEN: Watch this helpful video\n","permalink":"http://localhost:1313/posts/pages/git/git-cheetsheet/","summary":"A brief tutorial on github recipe and git command","title":"Git Commands and Configuration Guide"},{"content":"How to Create Content for Hugo Using Markdown Hugo, a static site generator, uses Markdown (.md) files to generate content. In this guide, we will explain how you can create content for Hugo using Markdown.\n1. Front Matter Every Markdown file in Hugo requires front matter, which is metadata placed at the top of the file. It helps Hugo understand how to process the file.\nExample:\n--- title: \u0026#34;My First Hugo Post\u0026#34; date: 2024-10-18 tags: [\u0026#34;Hugo\u0026#34;, \u0026#34;Markdown\u0026#34;] summary: \u0026#34;A brief summary of the post.\u0026#34; --- 2. Headers Headers are used to organize content. Use one # for an H1 header, two ## for H2, and so on.\nExample:\n# H1 Header ## H2 Header ### H3 Header Output:\nH3 Header 3. Text Formatting Markdown supports several text formatting options:\nExample:\n**Bold Text** *Italic Text* ~~Strikethrough~~ Output: Bold Text\nItalic Text\nStrikethrough\n4. Spacing and Line Breaks In Markdown, you can create paragraphs by leaving a blank line between lines of text.\nExample:\nThis is the first paragraph. This is the second paragraph. Output: This is the first paragraph.\nThis is the second paragraph.\n5. Horizontal Rules You can create horizontal lines (dividers) using three or more dashes (---), asterisks (***), or underscores (___).\nExample:\n--- Output:\n6. Lists Create unordered lists with - or *, and ordered lists with numbers followed by periods.\nExample:\n- Item 1 - Item 2 1. First item 2. Second item Output:\nItem 1 Item 2 First item Second item 7. Links and Images Add links and images with square brackets [] and parentheses ().\nExample:\n[Hugo Documentation](https://gohugo.io) ![Hugo Logo](/images/hugo.webp) Output: Hugo Documentation\n8. Code Blocks For inline code, use backticks. For block code, use triple backticks.\nExample:\nInline code: `print(\u0026#34;Hello World\u0026#34;)` Output: Inline code: print(\u0026quot;Hello World\u0026quot;)\nExample:\nBlock Code: def hello(): print(\u0026#34;Hello, Hugo!\u0026#34;) def hello(): print(\u0026#34;Hello, Hugo!\u0026#34;) 9. Blockquotes Use the greater than symbol (\u0026gt;) to create blockquotes.\nExample:\n\u0026gt; This is a blockquote in Hugo. Output:\nThis is a blockquote in Hugo.\n10. Tables You can create tables using pipes | and dashes -.\nExample:\n| Column 1 | Column 2 | |----------|----------| | Row 1 | Data 1 | | Row 2 | Data 2 | Output:\nColumn 1 Column 2 Row 1 Data 1 Row 2 Data 2 11. Task Lists Create task lists by using square brackets []. An x in the brackets [x] marks a task as completed.\nExample:\n- [ ] Task 1 - [x] Task 2 (Completed) Output:\nTask 1 Task 2 (Completed) 12. Syntax Highlighting Hugo supports syntax highlighting for various programming languages. You can specify the language after the triple backticks(```).\nExample: Output:\ndef greet(): print(\u0026#34;Hello, Hugo!\u0026#34;) 12. Task Lists Create task lists by using square brackets []. An x in the brackets [x] marks a task as completed.\nExample:\n- [ ] Task 1 - [ ] Sub-task 1 - [x] Sub-task 2 (Completed) - [x] Task 2 (Completed) Output:\nTask 1 Sub-task 1 Sub-task 2 (Completed) Task 2 (Completed) 13. Escaping Special Characters To use special characters like #, escape them using a backslash \\.\nExample:\n\\# This is not a header Output: # This is not a header\n14. Backtick To display backtick use four space before it as\n``` 15. Consistency It\u0026rsquo;s important to maintain consistent formatting throughout your Markdown files to ensure a clean and readable structure.\nBy following these steps, you can effectively create well-formatted content for your Hugo site using Markdown.\n","permalink":"http://localhost:1313/posts/pages/hugo/markdown_hugo_content_guide/","summary":"A tutorial on creating content with Markdown in Hugo.","title":"How to Create Content for Hugo"},{"content":"JavaScript Reference Behavior: Objects and Arrays Introduction In JavaScript, both objects and arrays are considered reference types. This means that when you assign an object or an array to another variable, you’re not creating a new copy of that object or array. Instead, the new variable holds a reference to the original object or array in memory. Understanding this concept is crucial because it directly affects how data is manipulated and shared within your code.\nObject Reference Behavior 1. Overview When you work with objects in JavaScript, it\u0026rsquo;s essential to recognize that assigning an object to a new variable does not create a new object. Instead, it creates a reference to the original object. This means that any changes made through the new reference will affect the original object.\n2. Example const person = { name: \u0026#34;Alice\u0026#34;, address: { city: \u0026#34;Wonderland\u0026#34; } }; const newPerson = person.address; // newPerson now references the same object as person.address newPerson.city = \u0026#34;New Wonderland\u0026#34;; // modifying newPerson affects the original object console.log(person); // Output: { name: \u0026#39;Alice\u0026#39;, address: { city: \u0026#39;New Wonderland\u0026#39; } } ## JavaScript Reference Behavior: Objects and Arrays ### Introduction In JavaScript, both objects and arrays are considered reference types. This means that when you assign an object or an array to another variable, you’re not creating a new copy of that object or array. Instead, the new variable holds a reference to the original object or array in memory. Understanding this concept is crucial because it directly affects how data is manipulated and shared within your code. ### Object Reference Behavior #### 1. Overview When you work with objects in JavaScript, it\u0026#39;s essential to recognize that assigning an object to a new variable does not create a new object. Instead, it creates a reference to the original object. This means that any changes made through the new reference will affect the original object. #### 2. Example ```javascript const person = { name: \u0026#34;Alice\u0026#34;, address: { city: \u0026#34;Wonderland\u0026#34; } }; const newPerson = person.address; // newPerson now references the same object as person.address newPerson.city = \u0026#34;New Wonderland\u0026#34;; // modifying newPerson affects the original object console.log(person); // Output: { name: \u0026#39;Alice\u0026#39;, address: { city: \u0026#39;New Wonderland\u0026#39; } } 3. Explanation Object Reference: When you create const newPerson = person.address;, you\u0026rsquo;re not making a copy of the address object. Instead, newPerson references the same address object that person.address references. Thus, when you update newPerson.city = \u0026quot;New Wonderland\u0026quot;;, it directly modifies the person.address object because both newPerson and person.address are pointing to the same location in memory. Output: The console logs the person object, which now reflects the change: { name: 'Alice', address: { city: 'New Wonderland' } }. Array Reference Behavior 1. Overview Arrays in JavaScript behave similarly to objects in terms of reference handling. When you assign an array to another variable, you create a reference to the original array. As a result, any modifications through this reference will affect the original array.\n2. Example const numbers = [1, 2, 3]; const moreNumbers = numbers; // moreNumbers now references the same array as numbers moreNumbers[0] = 99; // modifying moreNumbers affects the original array console.log(numbers); // Output: [99, 2, 3] 3. Explanation Array Reference: When you create const moreNumbers = numbers;, you\u0026rsquo;re not creating a new array. Instead, moreNumbers becomes a reference to the same array that numbers references. Any changes to moreNumbers, such as moreNumbers[0] = 99, directly modify the numbers array because both variables point to the same array in memory. Output: The console logs the numbers array, which now reflects the change: [99, 2, 3]. Key Takeaways Reference Types: Both objects and arrays are reference types in JavaScript, meaning that variables assigned to them hold references to the same data in memory. Shared Modifications: Changes made to an object or array through one reference will affect all other references to that same object or array. Memory Efficiency: This reference behavior allows for memory-efficient data management but requires careful handling to avoid unintended side effects. JavaScript References with filter() and find() In JavaScript, the way references work with methods like filter() and find() is different, leading to distinct behaviors. Understanding these differences is crucial for working effectively with arrays and avoiding unintended side effects.\nfilter(): Creating a New Array 1. Overview The filter() method in JavaScript creates a new array that contains only the elements that satisfy the provided condition. This means that a new array is returned, and it does not affect the original array. However, if the elements in the array are objects, the references to these objects are retained, meaning any modifications to the objects in the new array will also affect the original array.\n2. Example const originalArray = [ { id: 1, name: \u0026#34;Alice\u0026#34; }, { id: 2, name: \u0026#34;Bob\u0026#34; }, { id: 3, name: \u0026#34;Charlie\u0026#34; } ]; const filteredArray = originalArray.filter(item =\u0026gt; item.id !== 2); // Modify an object in the filtered array filteredArray[0].name = \u0026#34;Alicia\u0026#34;; console.log(originalArray); // Output: [{ id: 1, name: \u0026#39;Alicia\u0026#39; }, { id: 2, name: \u0026#39;Bob\u0026#39; }, { id: 3, name: \u0026#39;Charlie\u0026#39; }] console.log(filteredArray); // Output: [{ id: 1, name: \u0026#39;Alicia\u0026#39; }, { id: 3, name: \u0026#39;Charlie\u0026#39; }] 3. Explanation New Array Creation: The filter() method creates a new array (filteredArray) that includes all elements from originalArray except the one with id 2. However, the objects within the new array are still references to the original objects in originalArray. Shared References: When you modify the name property of the first object in filteredArray (filteredArray[0].name = \u0026quot;Alicia\u0026quot;;), it also changes in originalArray because both arrays reference the same object in memory. Output: The original array shows that the name of the first object has been changed to \u0026ldquo;Alicia\u0026rdquo;, indicating that the object references are shared. find(): Returning a Single Element Reference 1. Overview The find() method returns the first element in the array that satisfies the provided condition. This element is not a copy but a reference to the original element in the array. As a result, any modification to this element directly affects the original array.\n2. Example const originalArray = [ { id: 1, name: \u0026#34;Alice\u0026#34; }, { id: 2, name: \u0026#34;Bob\u0026#34; }, { id: 3, name: \u0026#34;Charlie\u0026#34; } ]; const foundItem = originalArray.find(item =\u0026gt; item.id === 2); // Modify the found item foundItem.name = \u0026#34;Robert\u0026#34;; console.log(originalArray); // Output: [{ id: 1, name: \u0026#39;Alice\u0026#39; }, { id: 2, name: \u0026#39;Robert\u0026#39; }, { id: 3, name: \u0026#39;Charlie\u0026#39; }] console.log(foundItem); // Output: { id: 2, name: \u0026#39;Robert\u0026#39; } 3. Explanation Element Reference: The find() method returns a reference to the first element that meets the condition (item.id === 2). In this case, foundItem references the same object in memory as the element in originalArray with id: 2. Direct Modification: When you modify the name property of foundItem (foundItem.name = \u0026quot;Robert\u0026quot;;), it directly alters the corresponding object in originalArray because they are the same object in memory. Output: The original array now shows that the name of the object with id: 2 has been changed to \u0026ldquo;Robert\u0026rdquo;, demonstrating that the reference was modified. Key Differences Between filter() and find() New Array vs. Single Element: filter(): Returns a new array containing references to elements that meet the condition. find(): Returns a reference to the first element that meets the condition. Impact on Original Array: filter(): The original array remains unchanged, but the objects within the new array are still references to the original objects. find(): The original array can be directly modified through the returned element. Use Cases: Use filter() when you need a subset of the original array without altering it directly. Use find() when you need to retrieve and possibly modify a specific element from the array. Conclusion Understanding how references work with methods like filter() and find() is crucial in JavaScript. While filter() returns a new array that retains references to the original objects, find() returns a direct reference to a single element. Being aware of these behaviors helps prevent unintended modifications to your data.\n","permalink":"http://localhost:1313/posts/pages/js/referencebehavious/","summary":"Learn about reference types in JavaScript, including objects and arrays, and how methods like filter() and find() handle references.","title":"JavaScript Reference Behavior: Objects and Arrays"},{"content":"JavaScript Reference Guide 1. Console.log() Method Purpose: Prints output to the console, useful for debugging. Syntax: console.log(value); Example: const name = \u0026#39;John\u0026#39;; console.log(name); // Output: John 2. Variables: let, const let: Block-scoped variable that can be updated but not accessed before declaration.\nlet x = 10; if (true) { let x = 20; // Block-scoped console.log(x); // 20 } console.log(x); // 10 const: Block-scoped variable that cannot be reassigned and must be initialized when declared.\nconst pi = 3.14; // pi = 3.1415; // Error: Cannot reassign 3. JavaScript Data Types String\nExplanation: Represents a sequence of characters. Can be enclosed in single quotes, double quotes, or backticks (for template literals). Syntax: const str = 'Hello, World!'; Example: const greeting = \u0026#34;Hello, \u0026#34; + \u0026#34;World!\u0026#34;; // Output: Hello, World! Number\nExplanation: Represents both integer and floating-point numbers. JavaScript numbers range from -(2^53 - 1) to 2^53 - 1. Syntax: const num = 123; Example: const amount = 25; // Output: 25 BigInt\nExplanation: Represents integers with arbitrary precision. Denoted by appending an n to the end of the number. Syntax: const bigNum = 1234567890123456789012345678901234567890n; Example: const bigNumber = 1234567890123456789012345678901234567890n; Boolean\nExplanation: Represents a value that is either true or false. Syntax: const isTrue = true; Example: const isActive = Boolean(1); // Output: true Null\nExplanation: Represents the intentional absence of any value. Syntax: const emptyValue = null; Example: const noValue = null; Undefined\nExplanation: Represents a variable that has been declared but not assigned a value. Syntax: let uninitialized; Example: let value; console.log(value); // Output: undefined For Checking Data Type We Use: typeof variableName; 4. Explicit Type Conversion To String: String(value) or value.toString()\nlet str = String(123); // \u0026#39;123\u0026#39; To Number: Number(value), parseInt(value), or parseFloat(value)\nlet num = Number(\u0026#39;456\u0026#39;); // 456 To Boolean: Boolean(value)\nlet bool = Boolean(\u0026#39;hello\u0026#39;); // true 5. JavaScript Operators i) Comparison Operators Greater than: a \u0026gt; b Less than: a \u0026lt; b Greater than or equal to: a \u0026gt;= b Less than or equal to: a \u0026lt;= b Not equal to: a != b Equal to: a == b Strictly equal to: a === b Examples:\nconsole.log(\u0026#34;2\u0026#34; == 2); // true console.log(\u0026#34;2\u0026#34; === 2); // false ii) Logical Operators AND: operand1 \u0026amp;\u0026amp; operand2 OR: operand1 || operand2 NOT: !operand Examples:\nconsole.log(true \u0026amp;\u0026amp; false); // false console.log(true || false); // true console.log(!true); // false iii) Arithmetic Operators Addition: operand1 + operand2 Subtraction: operand1 - operand2 Multiplication: operand1 * operand2 Division: operand1 / operand2 Modulo: operand1 % operand2 Increment: operand++ Decrement: operand-- Examples:\nconsole.log(5 + 3); // 8 console.log(5 - 3); // 2 console.log(5 * 3); // 15 console.log(6 / 3); // 2 console.log(5 % 3); // 2 6. String Methods and Operations 1. Concatenation Explanation: Combines two or more strings into one. Syntax: string1 + string2 Returns: A new string combining the original strings. Example: let a = \u0026#39; My name is nirajan \u0026#39;; let b = \u0026#34;nirajan\u0026#34;; console.log(a + b + \u0026#34;Khatiwada\u0026#34;); // Output: \u0026#39; My name is nirajan nirajanKhatiwada\u0026#39; 2. Simple Form (String Boilerplate) Explanation: Uses template literals to embed expressions within a string. Syntax: ${expression} Returns: A new string with evaluated expressions. Example: let a = \u0026#39; My name is nirajan \u0026#39;; let b = \u0026#34;nirajan\u0026#34;; console.log(`${a}${b}khatiwada`); // Output: \u0026#39; My name is nirajan nirajankhatiwada\u0026#39; 3. Accessing Element of String Explanation: Retrieves the character at a specified index. Syntax: string[index] Returns: The character at the given index (or undefined if out of range). Example: let a = \u0026#39; My name is nirajan \u0026#39;; console.log(a[0]); // Output: \u0026#39; \u0026#39; 4. Finding Length of String Explanation: Gets the number of characters in the string. Syntax: string.length Returns: The length of the string as a number. Example: let a = \u0026#39; My name is nirajan \u0026#39;; console.log(a.length); // Output: 21 5. To Uppercase Explanation: Converts all characters in the string to uppercase. Syntax: string.toUpperCase() Returns: A new string with all characters in uppercase. Example: let a = \u0026#39; My name is nirajan \u0026#39;; console.log(a.toUpperCase()); // Output: \u0026#39; MY NAME IS NIRAJAN \u0026#39; 6. To Lowercase Explanation: Converts all characters in the string to lowercase. Syntax: string.toLowerCase() Returns: A new string with all characters in lowercase. Example: let a = \u0026#39; My name is nirajan \u0026#39;; console.log(a.toLowerCase()); // Output: \u0026#39; my name is nirajan \u0026#39; 8. String Slicing Explanation: Extracts a section of the string based on start and end indices. Syntax: string.slice(start, end) Returns: A new string containing the extracted section. Example: let a = \u0026#39; My name is nirajan \u0026#39;; console.log(a.slice(0, 4)); // Output: \u0026#39; My\u0026#39; 9. Trim Explanation: Removes whitespace from both ends of the string. Syntax: string.trim() Returns: A new string with whitespace removed from both ends. Example: let a = \u0026#39; My name is nirajan \u0026#39;; console.log(a.trim()); // Output: \u0026#39;My name is nirajan\u0026#39; 10. Replace Explanation: Replaces the first occurrence of a specified substring or pattern with a new substring. Syntax: string.replace(search, replacement) Returns: A new string with the specified substring replaced. Example: let a = \u0026#39; My name is nirajan \u0026#39;; console.log(a.replace(\u0026#34;nirajan\u0026#34;, \u0026#34;kirajan\u0026#34;)); // Output: \u0026#39; My name is kirajan \u0026#39; 11. Split Explanation: Splits the string into an array of substrings based on a separator. Syntax: string.split(separator, limit) Returns: An array of substrings. Example: let a = \u0026#39; My name is nirajan \u0026#39;; console.log(a.split(\u0026#34; \u0026#34;)); // Output: [\u0026#39; My\u0026#39;, \u0026#39;name\u0026#39;, \u0026#39;is\u0026#39;, \u0026#39;nirajan\u0026#39;] 7. Number Methods 1. toFixed() Explanation: Formats a number using fixed-point notation with a specified number of decimal places. Syntax: number.toFixed(digits); Returns: A string representing the number with the specified number of decimal places. Example: let c = 10.001; console.log(c.toFixed(10)); // Output: \u0026#39;10.0010000000\u0026#39; 2. Math.ceil() Explanation: Rounds a number up to the nearest integer. Syntax: Math.ceil(number); Returns: The smallest integer greater than or equal to the given number. Example: let a = 1.1000; console.log(Math.ceil(a)); // Output: 2 3. Math.floor() Explanation: Rounds a number down to the nearest integer. Syntax: Math.floor(number); Returns: The largest integer less than or equal to the given number. Example: console.log(Math.floor(a)); // Output: 1 4. Math.round() Explanation: Rounds a number to the nearest integer. Syntax: Math.round(number); Returns: The value of the number rounded to the nearest integer. Example: console.log(Math.round(a)); // Output: 1 5. Math.random() Explanation: Returns a pseudo-random floating-point number between 0 (inclusive) and 1 (exclusive). Syntax: Math.random(); Returns: A floating-point number between 0 (inclusive) and 1 (exclusive). Example: console.log(Math.random()); // Output: A random number between 0 and 1 8. Non-Primitive Data Types in JavaScript 1. Object Explanation: Objects are collections of key-value pairs. Keys are usually strings (or symbols) and values can be any data type. Syntax: let objectName = { key1: value1, key2: value2, // more key-value pairs }; Example: let data = { \u0026#34;name\u0026#34;: \u0026#34;nirajan\u0026#34;, \u0026#34;age\u0026#34;: 20 }; 2. Array Explanation: Arrays are ordered collections of values. Values can be of any data type and are accessed by their index. Syntax: let arrayName = [value1, value2, value3, ...]; Example: let a = [\u0026#34;nirajan\u0026#34;, \u0026#34;kirajan\u0026#34;, \u0026#34;birajan\u0026#34;]; 3. Function Explanation: Functions are blocks of code designed to perform a particular task. They can be invoked (called) to execute their code. Syntax: function functionName(parameters) { // code to be executed } Example: function outer() { console.log(\u0026#34;hi\u0026#34;); } outer(); // Output: hi 9. Array Methods 1. Indexing in Array Accessing Elements: Description: Arrays are zero-indexed, so the first element is at index 0. Returns: Value of the element at the specified index. Example: console.log(a[0]); // Output: 1 console.log(a[3]); // Output: 4 2. Slicing in Array Slicing: Description: Extracts a section of the array and returns it as a new array. Syntax: array.slice(startIndex, endIndex) Returns: A new array containing the elements from startIndex up to, but not including, endIndex. Example: console.log(a.slice(0, 2)); // Output: [1, 2] 3. Length of Array Description: Returns the number of elements in the array. Returns: Integer (length of the array). Example: console.log(a.length); // Output: 4 4. Push Description: Adds one or more elements to the end of the array. Returns: The new length of the array. Example: a.push(5); console.log(a); // Output: [1, 2, 3, 4, 5] 5. Pop Description: Removes the last element from the array. Returns: The removed element. Example: a.pop(); console.log(a); // Output: [1, 2, 3, 4] 6. Shift Description: Removes the first element from the array. Returns: The removed element. Example: a.shift(); console.log(a); // Output: [2, 3, 4] 7. Unshift Description: Adds one or more elements to the beginning of the array. Returns: The new length of the array. Example: a.unshift(0); console.log(a); // Output: [0, 1, 2, 3, 4] 8. Join Description: Joins all elements of an array into a string, separated by a specified separator. Returns: A string representing the array elements joined by the specified separator. Example: let data = a.join(\u0026#34; \u0026#34;); console.log(data); // Output: \u0026#34;1 2 3 4\u0026#34; 9. Concatenation of Two Arrays Description: Merges two or more arrays into one. Returns: A new array containing the elements of the original arrays. Example: let a2 = [5, 4, 1, 3, 4]; console.log(a.concat(a2)); // Output: [1, 2, 3, 4, 5, 4, 1, 3, 4] 10. Sort Description: Sorts the elements of an array in place. Returns: The sorted array. Example: a2.sort(); console.log(a2); // Output: [1, 3, 4, 4, 5] 11. Reverse Description: Reverses the order of the elements in the array. Returns: The reversed array. Example: a2.reverse(); console.log(a2); // Output: [5, 4, 4, 3, 1] 12. Removing Elements from a Specific Position Description: Changes the contents of an array by removing or replacing existing elements. Syntax: array.splice(index, numberOfElementsToRemove) Returns: An array containing the removed elements. Example: let newData = [1, 2, 3, 4]; newData.splice(1, 2); // Removes 2 elements starting at index 1 console.log(newData); // Output: [1, 4] 13. Inserting Elements at a Specific Position Description: Inserts elements into the array. Syntax: array.splice(index, 0, element1, element2, ...) Returns: An array containing the removed elements (empty if no elements were removed). Example: let lasrData = [1, 4]; lasrData.splice(1, 0, 2, 3); // Inserts elements 2 and 3 at index 1 console.log(lasrData); // Output: [1, 2, 3, 4] 14. Spread Operator (\u0026hellip;) Description: Spreads out elements of an array into another array or function arguments. Returns: A new array containing the elements spread from the original arrays. Example: let finalData = [...newData, ...lasrData]; console.log(finalData); // Output: [1, 4, 1, 2, 3, 4] 15. Array Destructuring Description: Allows unpacking values from arrays into distinct variables in a concise and readable way. Basic Syntax: const [var1, var2, var3] = array; Example: const numbers = [1, 2, 3]; const [first, second, third] = numbers; console.log(first); // Output: 1 console.log(second); // Output: 2 console.log(third); // Output: 3 10. Object in Js i. Defining an Object An object in JavaScript is a collection of key-value pairs. Each key (also known as a property) is a unique identifier, and the value can be anything: a string, number, array, function, or even another object. Example:\nconst myObject = { name: \u0026#34;Nirajan\u0026#34;, // String property class: \u0026#34;Bachelor\u0026#34;, // String property is_topper: \u0026#34;No\u0026#34;, // Boolean property (as a string) greet: function (from) { // Method (function inside an object) console.log(`Welcome ${this.name}. From ${from}`); } }; ii. Accessing There are two common ways to access properties in an object:\nDot Notation: console.log(myObject.name); // Output: nirajan This is the most common and preferred method when you know the property name in advance. Bracket Notation: console.log(myObject[\u0026#39;name\u0026#39;]); // Output: nirajan Bracket notation is useful when the property name is stored in a variable or when it contains special characters or spaces. iii. Modifying Object Properties You can modify an object\u0026rsquo;s properties using dot or bracket notation:\nDot Notation: Use when you know the property name.\nmyObject.name = \u0026#34;Kirajan\u0026#34;; // Modifies the \u0026#39;name\u0026#39; property Bracket Notation: Use when the property name is dynamic or contains special characters.\nmyObject[\u0026#39;class\u0026#39;] = \u0026#34;Master\u0026#39;s\u0026#34;; // Modifies the \u0026#39;class\u0026#39; property iv. Adding New Properties You can dynamically add new key-value pairs to an object.\nmyObject.lol = \u0026#34;lol\u0026#34;; console.log(myObject.lol); // Output: lol v. Using the this Keyword The this keyword inside an object’s method refers to the object itself, allowing you to access its properties. Example:\nconst person = { name: \u0026#34;Kirajan\u0026#34;, greet: function() { console.log(`Hello, my name is ${this.name}`); } }; person.greet(); // Output: Hello, my name is Kirajan vi. Objects Inside Objects Objects can contain other objects, allowing you to create complex data structures. Example:\nconst a = { details: { name: \u0026#34;Nirajan\u0026#34;, age: 20 } }; console.log(a.details.name); // Output: Nirajan vii. Spread Operator (\u0026hellip;) The spread operator lets you copy, merge, or combine objects efficiently.\nCopying Properties: const original = { name: \u0026#34;Kirajan\u0026#34;, class: \u0026#34;Bachelor\u0026#34; }; const copy = { ...original }; console.log(copy); // Output: { name: \u0026#34;Kirajan\u0026#34;, class: \u0026#34;Bachelor\u0026#34; } Merging Objects: const info1 = { name: \u0026#34;Kirajan\u0026#34;, class: \u0026#34;Bachelor\u0026#34; }; const info2 = { age: 21, is_topper: true }; const combined = { ...info1, ...info2 }; console.log(combined); // Output: { name: \u0026#34;Kirajan\u0026#34;, class: \u0026#34;Bachelor\u0026#34;, age: 21, is_topper: true } viii. Object Destructuring Destructuring allows you to extract properties from an object and assign them to variables. Example:\nconst lol = { name: \u0026#34;Nirajan\u0026#34;, class: 12, rollno: \u0026#34;11\u0026#34; }; const { name, rollno } = lol; console.log(name); // Output: Nirajan console.log(rollno); // Output: 11 Also, Renaming in Destructuring: const lol = { name: \u0026#34;Nirajan\u0026#34;, class: 12, rollno: \u0026#34;11\u0026#34; }; const { name: studentName, rollno: studentRollNo } = lol; console.log(studentName); // Output: Nirajan console.log(studentRollNo); // Output: 11 ix. Object Methods Objects can have methods—functions that are properties of the object. These methods can perform actions using the object’s data. Example:\nconst calculator = { add: function(a, b) { return a + b; }, subtract: function(a, b) { return a - b; } }; console.log(calculator.add(5, 3)); // Output: 8 console.log(calculator.subtract(5, 3)); // Output: 2 11. JavaScript Functions Function Definitions: Function Expression: const add1 = function(a, b) { return a + b; }; Creates a function and assigns it to a variable. You call the function using the variable name. Arrow Function: const add2 = (a, b) =\u0026gt; { return a + b; }; Provides a shorter syntax and does not have its own this context. Function Declaration: function add3(a, b) { return a + b; } Defines a function with a name. It is hoisted, so it can be called before its declaration. Comparison: add3 has its own this context, while add1 and add2 do not. Using the Spread Operator: function add(...data) { let sum = 0; for (let i = 0; i \u0026lt; data.length; i++) { sum += data[i]; } return sum; } console.log(add(1, 2, 3)); // Output: 6 The ...data syntax lets the function accept any number of arguments as an array.\nImmediately Invoked Function Expression (IIFE): ( function add(a, b) { console.log(a + b); } )(2, 3); // Output: 5 An IIFE is a function that runs immediately after its definition, creating a local scope to avoid affecting the global scope.\n12. Control Flow in JavaScript Conditional Statements: if-else Statement: Executes code blocks based on a condition. let a = 2; if (a === 1) { console.log(1); } else if (a === 2) { console.log(2); } else { console.log(\u0026#34;None\u0026#34;); } Truthy and Falsy Values: Falsy Values: Values that evaluate to false in a boolean context. console.log(Boolean(false)); // false console.log(Boolean(0)); // false console.log(Boolean(-0)); // false console.log(Boolean(0n)); // false console.log(Boolean(\u0026#34;\u0026#34;)); // false console.log(Boolean(null)); // false console.log(Boolean(undefined)); // false console.log(Boolean(NaN)); // false Truthy Values: Any value that is not falsy. console.log(Boolean(true)); // true console.log(Boolean(1)); // true console.log(Boolean(-1)); // true console.log(Boolean(\u0026#34;hello\u0026#34;)); // true console.log(Boolean(\u0026#34; \u0026#34;)); // true console.log(Boolean({})); // true console.log(Boolean([])); // true console.log(Boolean(function() {})); // true console.log(Boolean(Symbol())); // true console.log(Boolean(1n)); // true Nullish Coalescing Operator (??): Provides a default value when dealing with null or undefined. let val1 = null; let val2 = val1 ?? 10; console.log(val2); // Output: 10 Ternary Operator (?:): A shorthand for the if-else statement. let c = 10; let b = 10; let largest = (c \u0026gt; b) ? c : b; console.log(largest); // Output: 10 13. Loops in JavaScript For Loop // Syntax: for(initialization; condition; increment/decrement) { ... } for (let i = 0; i \u0026lt; 10; i++) { console.log(i); } While Loop // Syntax: while(condition) { ... } let i = 0; while (i \u0026lt; 10) { console.log(i); i++; } Do-While Loop // Syntax: do { ... } while(condition); let i = 0; do { console.log(i); i++; } while (i \u0026lt; 10); For-Of Loop Usage: Iterates over arrays and strings const array = [1, 2, 3]; for (const x of array) { console.log(x); } For-In Loop Usage: Iterates over the properties of an object, indices of an array, or characters of a string const obj = { \u0026#34;name\u0026#34;: \u0026#34;nirajan\u0026#34;, \u0026#34;lol\u0026#34;: \u0026#34;lol\u0026#34; }; const arr = [\u0026#34;nirajan\u0026#34;, \u0026#34;lol\u0026#34;]; const str = \u0026#34;mynameisnirajan\u0026#34;; for (const key in obj) { console.log(key); // Prints the keys of the object } for (const index in arr) { console.log(arr[index]); // Prints the values of the array } for (const index in str) { console.log(str[index]); // Prints the characters of the string } For-Each Loop Usage: Iterates over array elements const array = [1, 2, 3]; array.forEach((data) =\u0026gt; { console.log(data); }); Break and Continue Statements break: Exits the loop continue: Skips the current iteration and continues with the next iteration 14. Map, Filter, and Reduce in JavaScript i. filter() Purpose: Creates a new array with elements that pass a test. Example: To get all odd numbers from an array: const a = [1, 2, 3, 4, 5, 6]; const filtered = a.filter(num =\u0026gt; num % 2); // [1, 3, 5] ii. map() Method Purpose: map() creates a new array populated with the results of calling a provided function on every element in the calling array. It’s used to transform each element in the array. Example: Create an array of squares from an existing array. const a = [1, 2, 3, 4, 5, 6]; const squares = a.map((num) =\u0026gt; num * num); console.log(squares); // Output: [1, 4, 9, 16, 25, 36] Here, the function num * num is applied to each element, resulting in a new array of squared numbers. iii. reduce() Method Purpose: reduce() executes a reducer function on each element of the array, resulting in a single output value. It’s used to accumulate or combine values from the array into a single result. Example: Sum up all the numbers in the array. const a = [1, 2, 3, 4, 5, 6]; const sum = a.reduce((accumulator, currentValue) =\u0026gt; accumulator + currentValue, 0); console.log(sum); // Output: 21 Here, accumulator starts at 0 and currentValue iterates over each element, summing them up. iv. Method Chaining Purpose: You can chain filter(), map(), and other array methods together to perform multiple operations in a single, readable statement. Example: Filter out odd numbers and then square them. const a = [1, 2, 3, 4, 5, 6]; const result = a.filter((num) =\u0026gt; num % 2) .map((num) =\u0026gt; num * num); console.log(result); // Output: [1, 9, 25] Here, filter() first selects the odd numbers, and then map() squares those numbers, producing a new array with the squared values of the odd numbers. Summary filter(): Selects elements that meet a specific condition. map(): Transforms elements based on a function. reduce(): Reduces the array to a single value based on a function. Method Chaining: Combines multiple array operations in a concise and readable manner. These methods are powerful tools for processing and transforming arrays in JavaScript. 15. Importing and Exporting in JavaScript Default Export Only one default export is allowed per module. Use for the primary function, class, or object in a module. // utils.js export default function primaryFunction() { console.log(\u0026#34;This is the primary function\u0026#34;); } // main.js import primaryFunction from \u0026#39;./utils.js\u0026#39;; primaryFunction(); // Output: This is the primary function Named Export Allows multiple exports per module. Use to export multiple functions, variables, or objects. // utils.js function function1() { console.log(\u0026#34;This is function1\u0026#34;); } function function2() { console.log(\u0026#34;This is function2\u0026#34;); } export { function1, function2 }; // main.js import { function1, function2 } from \u0026#39;./utils.js\u0026#39;; function1(); // Output: This is function1 function2(); // Output: This is function2 Summary Default Export: One per module, no curly braces during import. Named Export: Multiple per module, use curly braces during import. 16. Error Handling Try-catch blocks are used to handle errors gracefully.\ntry { // Code that might throw an error let result = nonExistentFunction(); } catch (error) { // Code to handle the error console.log(\u0026#39;An error occurred:\u0026#39;, error.message); } finally { // Code that always executes console.log(\u0026#39;This always executes\u0026#39;); } // Output: // \u0026#34;An error occurred: nonExistentFunction is not defined\u0026#34; // \u0026#34;This always executes\u0026#34; 16.1. Custom Error Throwing You can throw custom errors using the throw statement.\nfunction divide(a, b) { if (b === 0) { throw new Error(\u0026#39;Division by zero is not allowed\u0026#39;); } return a / b; } try { console.log(divide(4, 2)); console.log(divide(4, 0)); } catch (error) { console.log(\u0026#39;Error:\u0026#39;, error.message); } // Output: // 2 // \u0026#34;Error: Division by zero is not allowed\u0026#34; 17. Timers setTimeout Schedules a function to be executed after a specified delay (in milliseconds).\nconst timeoutId = setTimeout(() =\u0026gt; { console.log(\u0026#39;Executed after 1 second\u0026#39;); }, 1000); setInterval Repeatedly executes a function at specified intervals (in milliseconds).\nconst intervalId = setInterval((a, b) =\u0026gt; { console.log(a); // Output: hi console.log(b); // Output: oi }, 20, \u0026#34;hi\u0026#34;, \u0026#34;oi\u0026#34;); clearInterval Stops a function from being executed repeatedly by clearing the interval.\nclearInterval(intervalId); clearTimeout Cancels a timeout previously established by setTimeout.\nclearTimeout(timeoutId); 18. Local Storage Local storage is a way to store data in the browser that persists even after the browser is closed.\nStoring Data localStorage.setItem(\u0026#39;name\u0026#39;, \u0026#39;Nirajan\u0026#39;); Retrieving Data const name = localStorage.getItem(\u0026#39;name\u0026#39;); console.log(name); // Output: Nirajan 19. JSON JSON (JavaScript Object Notation) is a lightweight data interchange format that is easy for humans to read and write and easy for machines to parse and generate.\nConverting Objects to JSON const person = { name: \u0026#39;Nirajan\u0026#39;, age: 20 }; const json = JSON.stringify(person); console.log(json); // Output: {\u0026#34;name\u0026#34;:\u0026#34;Nirajan\u0026#34;,\u0026#34;age\u0026#34;:20} Converting JSON to Objects const json = \u0026#39;{\u0026#34;name\u0026#34;:\u0026#34;Nirajan\u0026#34;,\u0026#34;age\u0026#34;:20}\u0026#39;; const person = JSON.parse(json); console.log(person.name); // Output: Nirajan 20. Fetch API Fetch is used to make HTTP requests and returns a promise that resolves to the response of the request.\nBasic Usage fetch(\u0026#39;https://api.example.com/data\u0026#39;) .then(response =\u0026gt; response.json()) .then(data =\u0026gt; console.log(data)) .catch(error =\u0026gt; console.error(\u0026#39;Error:\u0026#39;, error)); ","permalink":"http://localhost:1313/posts/pages/js/javascript/","summary":"A complete reference guide for JavaScript including data types, functions, DOM manipulation, and modern ES6+ features","title":"JavaScript Reference Guide"},{"content":" Linux Commands and Directories Guide Important Directories Default Web Server Root Directory\nLocation: /var/www/html\nThis is the standard location for serving web content on Apache.\nDownloads Folder\nLocation: /home/username/Downloads\nThis is where files downloaded from the internet are usually saved by default.\nDocuments Folder\nLocation: /home/username/Documents\nA common directory for storing personal documents and files.\nDesktop Folder\nLocation: /home/username/Desktop\nThis is the location for files and shortcuts displayed on your desktop screen.\nCommon Commands cd Change the current directory to another one.\nUsage: cd [directory]\nExample: cd /var/www/html changes to the web server root directory.\nls List files and directories in the current location or specified path.\nUsage: ls [options] [path]\nExample: ls -l lists files in a detailed format.\npwd Print the path of the current working directory.\nUsage: pwd\nThis command shows where you are in the filesystem.\nsudo su Switch to the superuser (root) account, allowing you to perform administrative tasks.\nUsage: sudo su\nAfter entering your password, you\u0026rsquo;ll have root access.\nsudo Execute a command with elevated privileges.\nUsage: sudo [command]\nExample: sudo apt update runs the update command as an administrator.\nmkdir Create a new directory.\nUsage: mkdir [directory name]\nExample: mkdir new_folder creates a directory named \u0026ldquo;new_folder\u0026rdquo;.\ndir List files and directories, similar to ls.\nUsage: dir [options] [path]\nThis command can be used interchangeably with ls.\nmv Move or rename files and directories.\nUsage: mv [source] [destination]\nExample: mv /home/username/Downloads/file.txt /home/username/Documents/ moves the file to a different directory.\ncp Copy files or directories.\nUsage: cp [source] [destination]\nExample: cp /home/username/Downloads/file.txt /home/username/Documents/ copies the file.\nrm Remove files or directories.\nUsage: rm [options] [file/directory]\nExample: To remove a directory and its contents, use rm -r [directory].\ntouch Create an empty file or update the timestamp of an existing file.\nUsage: touch [filename]\nExample: touch newfile.txt creates an empty file named \u0026ldquo;newfile.txt\u0026rdquo;.\ncat Display the contents of a file in the terminal.\nUsage: cat [filename]\nExample: cat file.txt shows the content of \u0026ldquo;file.txt\u0026rdquo;.\ngedit Open the Gedit text editor to edit files.\nUsage: gedit [filename]\nExample: gedit notes.txt opens \u0026ldquo;notes.txt\u0026rdquo; for editing.\nkill Terminate a process using its process ID (PID).\nUsage: kill [PID]\nExample: kill 1234 stops the process with the ID 1234.\ntop Display real-time information about system processes and resource usage.\nUsage: top\nThis command helps monitor system performance.\napt-get update Update the package lists for upgrades and new package installations.\nUsage: apt-get update\nThis command fetches the latest package information.\napt install path_of_.deb_file Install a .deb file package.\nUsage: apt install ./filename.deb\nExample: apt install ./main.deb installs the specified Debian package.\napt-get upgrade Upgrade all installed packages to their latest versions.\nUsage: apt-get upgrade\nThis command updates your installed software.\napt-get install package Install a specific software package.\nUsage: apt-get install [package]\nExample: apt-get install vim installs the Vim text editor.\nman Display the manual page for a command, providing detailed information.\nUsage: man [command]\nExample: man ls shows the manual for the ls command.\nwhoami Show the currently logged-in user\u0026rsquo;s username.\nUsage: whoami\nThis command is useful for confirming your user identity.\nzip Compress a directory and its contents into a zip file.\nUsage: zip -r [filename.zip] [foldername]\nExample: zip -r archive.zip myfolder creates a zip file of \u0026ldquo;myfolder\u0026rdquo;.\nunzip Extract files from a zip archive.\nUsage: unzip [filename]\nExample: unzip archive.zip extracts files from \u0026ldquo;archive.zip\u0026rdquo;.\napt install apache2 Install the Apache web server.\nUsage: apt install apache2\nThis command sets up Apache on your system.\nservice apache2 start Start the Apache web server.\nUsage: service apache2 start\nUse this to begin serving web content.\nservice apache2 restart Restart the Apache web server.\nUsage: service apache2 restart\nThis is useful for applying configuration changes.\nservice apache2 stop Stop the Apache web server.\nUsage: service apache2 stop\nUse this command to halt the server.\napt install redis Install the Redis database server.\nUsage: apt install redis\nThis sets up Redis for use.\nservice redis start Start the Redis server.\nUsage: service redis start\nThis command activates the Redis service.\nservice redis restart Restart the Redis server.\nUsage: service redis restart\nUse this to refresh the Redis service.\nservice redis stop Stop the Redis server.\nUsage: service redis stop\nThis halts the Redis service.\napt install mysql-server Install the MySQL server.\nUsage: apt install mysql-server\nThis command installs the MySQL database management system.\nchmod Change file or directory permissions.\nUsage: chmod [permissions] [file/folder]\nExample: chmod +rwx file.txt grants read, write, and execute permissions.\nTo remove permissions, use chmod -r file.txt.\nImportant Notes Folder Names with Spaces:\nIf a folder name contains spaces, enclose it in double quotes.\nmkdir \u0026quot;New Folder\u0026quot; creates a single folder named \u0026ldquo;New Folder\u0026rdquo;. mkdir New Folder creates two separate folders named \u0026ldquo;New\u0026rdquo; and \u0026ldquo;Folder\u0026rdquo;. Using Wildcards for Operations:\nTo perform operations on:\nAll files/folders: use *. Files with a specific extension (e.g., .exe): use *.exe. Files/folders starting with \u0026ldquo;hello\u0026rdquo;: use hello*. Use Relative Paths:\nPrefer using relative paths whenever possible to simplify navigation.\nExample: mv /home/username/Downloads/index.html /var/www/html/index.html moves a file to the web server directory. ","permalink":"http://localhost:1313/posts/pages/linux/linux_cheatsheet/","summary":"A practical guide to navigating and managing files in Linux.","title":"Linux Commands and Directories Guide"},{"content":"Learning Journey Topics I Have Learned So Far Docker Linux Celery Django Channels Git Celery Python Django JavaScript React Basics HTML CSS Tailwind Css What I Plan to Learn In third Semester Django Rest Framework (DRF) Django ORM Deep Dive React Advanced Git Advanced Docker Advanced WebSOcket Deep Dive in Django Celery Deep Dive Plan to learn in future WebSocket Deep Dive in Django Celery Deep Dive Redis for Cache Kafka Basics + Advanced Docker Advanced + Kubernetes Message Brokers Django Rest Framework (DRF) Django ORM Deep Dive React Advanced Git Advanced Django Docs+Advance Like class based views Additional Topics for Future Learning Real-time WebSocket usage in Django. Kafka streaming for handling large data volumes. Implementing Kubernetes for containerized applications. ","permalink":"http://localhost:1313/posts/pages/readinglist/my_reading/","summary":"A detailed overview of my learning journey and future plans.","title":"Learning Journey"},{"content":"46.Sending request to the server In react we can send request to the server using fetch api.\nExample:\nimport React, { useState } from \u0026#39;react\u0026#39;; const App = () =\u0026gt; { const [data, setData] = useState([]); const fetchData = async () =\u0026gt; { const response = await fetch(\u0026#39;https://jsonplaceholder.typicode.com/posts\u0026#39;); const data = await response.json(); setData(data); } return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={fetchData}\u0026gt;Fetch Data\u0026lt;/button\u0026gt; \u0026lt;ul\u0026gt; {data.map((item) =\u0026gt; ( \u0026lt;li key={item.id}\u0026gt;{item.title}\u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ) } ","permalink":"http://localhost:1313/posts/pages/react/react11/","summary":"\u003ch2 id=\"46sending-request-to-the-server\"\u003e46.Sending request to the server\u003c/h2\u003e\n\u003cp\u003eIn react we can send request to the server using fetch api.\u003c/p\u003e\n\u003cp\u003eExample:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-jsx\" data-lang=\"jsx\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eimport\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eReact\u003c/span\u003e, { \u003cspan style=\"color:#a6e22e\"\u003euseState\u003c/span\u003e } \u003cspan style=\"color:#a6e22e\"\u003efrom\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;react\u0026#39;\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eApp\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e () =\u0026gt; {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e [\u003cspan style=\"color:#a6e22e\"\u003edata\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003esetData\u003c/span\u003e] \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003euseState\u003c/span\u003e([]);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003efetchData\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003easync\u003c/span\u003e () =\u0026gt; {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eresponse\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eawait\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003efetch\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;https://jsonplaceholder.typicode.com/posts\u0026#39;\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003edata\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eawait\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eresponse\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ejson\u003c/span\u003e();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003esetData\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003edata\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e (\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u0026lt;\u003cspan style=\"color:#f92672\"\u003ediv\u003c/span\u003e\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u0026lt;\u003cspan style=\"color:#f92672\"\u003ebutton\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eonClick\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e{\u003cspan style=\"color:#a6e22e\"\u003efetchData\u003c/span\u003e}\u0026gt;\u003cspan style=\"color:#a6e22e\"\u003eFetch\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eData\u003c/span\u003e\u0026lt;/\u003cspan style=\"color:#f92672\"\u003ebutton\u003c/span\u003e\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u0026lt;\u003cspan style=\"color:#f92672\"\u003eul\u003c/span\u003e\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                {\u003cspan style=\"color:#a6e22e\"\u003edata\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003emap\u003c/span\u003e((\u003cspan style=\"color:#a6e22e\"\u003eitem\u003c/span\u003e) =\u0026gt; (\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    \u0026lt;\u003cspan style=\"color:#f92672\"\u003eli\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ekey\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e{\u003cspan style=\"color:#a6e22e\"\u003eitem\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eid\u003c/span\u003e}\u0026gt;{\u003cspan style=\"color:#a6e22e\"\u003eitem\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003etitle\u003c/span\u003e}\u0026lt;/\u003cspan style=\"color:#f92672\"\u003eli\u003c/span\u003e\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                ))}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u0026lt;/\u003cspan style=\"color:#f92672\"\u003eul\u003c/span\u003e\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u0026lt;/\u003cspan style=\"color:#f92672\"\u003ediv\u003c/span\u003e\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    )\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":""}]