[{"content":"What is Tanstack Query? Tanstack query is a powerful data-fetching library for React, Vue, Svelte, and Solid. It provides a simple and efficient way to manage server state in your applications. With Tanstack Query, you can easily fetch, cache, and synchronize data from your server, making it easier to build fast and responsive applications.\nAdvantages of Tanstack Query Data Fetching: Tanstack Query simplifies the process of fetching data from APIs, allowing you to focus on building your application rather than managing data-fetching logic. Caching: Tanstack Query automatically caches the data it fetches, reducing the number of network requests and improving performance. Buildin Loading and Error Handling: Tanstack Query provides built-in loading and error handling states, making it easy to manage the user experience during data fetching. Automatic Refetching: Tanstack Query can automatically refetch data when it becomes stale or when the user focuses on the application, ensuring that your data is always up to date. Pagination and infinite scrolling: Tanstack Query provides built-in support for pagination and infinite scrolling, making it easy to manage large datasets. ** ","permalink":"http://localhost:1313/posts/pages/networkreact/tanstack/","summary":"A detailed guide explaining how to use Tanstack query for data fetching in React applications, including query keys, query functions, and query hooks.","title":"A complete guide to Tanstack query"},{"content":"Introduction Instead of relying on print statements to examine variable values during code execution, VS Code\u0026rsquo;s built-in debugger offers a more powerful and efficient approach to troubleshooting. The debugger allows you to inspect variables, track program flow, and identify issues with precision.\nWhat is a Debugger? A debugger is a specialized development tool that enables you to:\nExecute your code line by line Pause execution at specific points Examine the state of variables and objects at any moment Monitor the execution flow of your program This approach provides significantly more insight than simple print statements, making the debugging process more efficient and thorough.\nHow to Use the Debugger in VS Code Setting Breakpoints Breakpoints are markers that tell the debugger where to pause code execution. They are essential for examining the program state at specific points.\nHow to set a breakpoint:\nLocate the line of code where you want to pause execution Click in the left margin (gutter) next to the line number A red dot will appear, indicating a successful breakpoint placement Types of breakpoints: Normal Breakpoint: This is the most common type of breakpoint. It pauses execution at a specific line of code. Conditional Breakpoint: This type of breakpoint only pauses execution if a specific condition is met. To set a conditional breakpoint, right-click on the red dot and select \u0026ldquo;Edit Breakpoint\u0026rdquo;. You can then enter a condition that must be true for the breakpoint to be hit. for exmaple a condition like x \u0026gt; 5 will only hit the breakpoint if the value of x is greater than 5. Hit Count Breakpoint: This type of breakpoint only pauses execution after it has been hit a specific number of times. To set a hit count breakpoint, right-click on the red dot and select \u0026ldquo;Edit Breakpoint\u0026rdquo;. You can then enter a hit count that must be reached for the breakpoint to be hit. for example a hit count like 5 will only hit the breakpoint after it has been hit 5 times. Logpoint: This type of breakpoint does not pause execution but logs a message to the console when it is hit. To set a logpoint, right-click on the red dot and select \u0026ldquo;Edit Breakpoint\u0026rdquo;. You can then enter a message that will be logged to the console when the logpoint is hit. for example a logpoint like x = {x} will log the value of x to the console when the logpoint is hit. Debugging After setting breakpoints, you can start debugging your code. To do this, click on the green play button in the debug panel or press F5. This will start the debugger and run your code until it hits a breakpoint. When the debugger hits a breakpoint, it will pause execution and allow you to inspect variables and see the flow of execution and required information.\nInspecting Variables When the debugger hits a breakpoint, you can inspect the values of variables in the debug panel. This allows you to see the current state of your code and find issues more efficiently than using print statements. You can also hover over variables in the code editor to see their values.It look like Here is a breakdown of the different sections of the debug panel:\nVariables: This section shows the current values of all variables in the current scope. You can expand objects and arrays to see their properties and values.Also You can change their values by double-clicking on them and entering a new value. Watch: This section allows to watch a specific variable or expression. You can add variables or expressions to the watch list by clicking on the plus icon and entering the variable or expression you want to watch. This is useful for tracking the value of a variable or expression over time. Call Stack: This section shows the current call stack, which is the list of functions that have been called to get to the current point in the code. You can click on a function in the call stack to see its code and inspect its variables. This is useful for understanding the flow of execution and seeing how functions interact with each other. After running the debugger, you will see a new panel at the top of the screen with several options. These options allow you to control the flow of execution and inspect variables.\nContinue: This option allows you to continue execution until the next breakpoint is hit. Step Over: This option allows you to execute the current line of code and move to the next line. If the current line contains a function call, it will execute the entire function and move to the next line without stepping into the function. Step Into: This option allows you to step into a function call and see the flow of execution inside the function. This is useful for debugging functions and seeing how they work. Step Out: This option allows you to step out of the current function and return to the calling function. This is useful for debugging nested functions and seeing how they interact with each other. Restart: This option allows you to restart the debugger and run your code from the beginning. This is useful for testing changes to your code without having to stop and start the debugger manually. Stop: This option allows you to stop the debugger and end the debugging session. This is useful for stopping the debugger when you are finished debugging your code. Example of Debugging\nFirst, Add breakpoints to your code by clicking on the left margin next to the line number where you want to pause execution.\nSecond, Start debugging your code by clicking on the green play button in the debug panel or pressing F5. This will start the debugger and run your code until it hits a breakpoint.\nThen , When the debugger hits a breakpoint, it will pause execution and allow you to inspect variables and see the flow of execution. You can use the debug panel to see the current values of variables, watch specific variables or expressions, and see the call stack and change the values of variables.\nAfter that ,Your can use debug pannel to control the flow of execution. You can continue execution.\n","permalink":"http://localhost:1313/posts/pages/debugger/debug/","summary":"Learn how to use the debugger in Visual Studio Code to inspect variables, track program flow, and identify issues with precision.","title":"A Complete Guide to Debugger in VS Code"},{"content":"Using React Hook Form As we have seen in the previous sections, managing form state and validation can be a complex task in React. However, with the introduction of libraries like React Hook Form, this process has become much simpler and more efficient.A react Hook Form is a library that helps you manage form state and validation in React applications with ease. It provides a simple API and integrates well with existing UI libraries.\nInstallation To get started with React Hook Form, you need to install it in your project. You can do this using npm :\nnpm install react-hook-form Basic Usage To use React Hook Form, you need to import the useForm hook from the library and use it in your component. Here\u0026rsquo;s a simple example of how to create a form with validation using React Hook Form:\nimport React from \u0026#39;react\u0026#39;; import { useForm } from \u0026#39;react-hook-form\u0026#39;; import \u0026#39;./App.css\u0026#39;; import { useState } from \u0026#39;react\u0026#39;; const App = () =\u0026gt; { const { register, handleSubmit, formState: { errors , isSubmitting} } = useForm(); const [formData, setFormData] = useState(null); const onSubmit = (data) =\u0026gt; { setFormData(data); }; return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;React Hook Form Example\u0026lt;/h1\u0026gt; \u0026lt;form onSubmit={handleSubmit(onSubmit)}\u0026gt; \u0026lt;div\u0026gt; \u0026lt;label htmlFor=\u0026#34;name\u0026#34;\u0026gt;Name:\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;name\u0026#34; {...register(\u0026#39;name\u0026#39;, { required: true,minLength: 10 })} /\u0026gt; {errors.name \u0026amp;\u0026amp; \u0026lt;span\u0026gt;This field is required above 10 characters\u0026lt;/span\u0026gt;} \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;label htmlFor=\u0026#34;email\u0026#34;\u0026gt;Email:\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;email\u0026#34; id=\u0026#34;email\u0026#34; {...register(\u0026#39;email\u0026#39;, { required: true })} /\u0026gt; {errors.email \u0026amp;\u0026amp; \u0026lt;span\u0026gt;This field is required\u0026lt;/span\u0026gt;} \u0026lt;/div\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34; disabled={isSubmitting}\u0026gt;Submit\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; {formData \u0026amp;\u0026amp; ( \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;Form Data:\u0026lt;/h2\u0026gt; \u0026lt;div\u0026gt;Name: {formData.name}\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;Email: {formData.email}\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;isSubmitting: {isSubmitting ? \u0026#39;true\u0026#39; : \u0026#39;false\u0026#39;}\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; )} \u0026lt;/div\u0026gt; ); }; export default App; Explanation useForm: This hook provides methods to manage form state and validation. register: This method is used to register input fields and their validation rules. handleSubmit: This method is used to handle form submission. formState: This object contains the form state, including errors and submission status. errors: This object contains validation errors for each field. isSubmitting: This boolean indicates whether the form is currently being submitted. Validation List of validation rules:\nrequired: This rule makes the field required. minLength: This rule sets a minimum length for the field. maxLength: This rule sets a maximum length for the field. pattern: This rule sets a regex pattern for the field. min: This rule sets a minimum value for the field. max: This rule sets a maximum value for the field. validate: This rule allows you to define custom validation logic. we can use the combination of these rules to create complex validation logic.like\n\u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;name\u0026#34; {...register(\u0026#39;name\u0026#39;, { required: true,minLength: 10 })} /\u0026gt; Disable Prop The disabled prop is used to disable the input field. This can be useful when you want to prevent users from interacting with the field until certain conditions are met.\n\u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;name\u0026#34; {...register(\u0026#39;name\u0026#39;, { required: true,minLength: 10 })} disabled={isSubmitting} /\u0026gt; Conclusion React Hook Form is a powerful library that simplifies form management and validation in React applications. It provides a simple API and integrates well with existing UI libraries, making it a great choice for developers looking to streamline their form handling process.\n","permalink":"http://localhost:1313/posts/pages/react/react16/","summary":"A comprehensive guide on using React Hook Form for form management and validation in React applications.","title":"Using React Hook Form"},{"content":"Axios Interceptors in React (Request \u0026amp; Response) Axios Interceptors in React (Request \u0026amp; Response) Axios Interceptors are functions that Axios executes before a request is sent or after a response is received. They are commonly used in React apps for:\nAttaching authentication tokens (JWT, API keys) to requests. Handling global error responses (e.g., token expiration, server errors). Modifying request/response data (e.g., logging, transforming responses). Retrying failed requests automatically. Note : You can intercept requests or responses before they are handled by then or catch.\n1.Request Interceptors The request interceptor is executed before a request is sent. It can modify the request headers, URL, or data.\nUse case:\nAttaching an authentication token to the request headers. Logging the request details. Transforming the request data before sending it. Example: import axios from \u0026#34;axios\u0026#34;; // Create an Axios instance const api = axios.create({ baseURL: \u0026#34;https://api.example.com\u0026#34;, }); // Add request interceptor api.interceptors.request.use( (config) =\u0026gt; { // Do something before request is sent // Get the token from local storage (or context, Redux, etc.) const token = localStorage.getItem(\u0026#34;access_token\u0026#34;); if (token) { config.headers.Authorization = `Bearer ${token}`; } console.log(\u0026#34;Request Interceptor:\u0026#34;, config); return config; }, (error) =\u0026gt; { // Do something with request error return Promise.reject(error); // Forward error to the calling function } ); export default api; Explanation:\nBefore sending a request, the interceptor checks if there is an authentication token in local storage. If the token exists, it adds it to the request headers. If there’s an error (e.g., no config object), it returns a rejected promise. WHen which function is called?\nThe config function is called when the request is sent. The error function is called when there is an error in the request (e.g., network error, timeout). WHat if dont mention the error function?\n2.Response Interceptors The response interceptor is executed after a response is received. It is used to handle responses globally.\nUse case:\nHandling global error responses (e.g., token expiration, server errors). Transforming the response data before it reaches the calling function. Logging the response details. Centralized error handling for API responses. Example:(Handeling 401 Unauthorized) import axios from \u0026#34;axios\u0026#34;; // Create an Axios instance const api = axios.create({ baseURL: \u0026#34;https://api.example.com\u0026#34;, }); api.interceptors.response.use( (response) =\u0026gt; { // Any status code that lie within the range of 2xx cause this function to trigger // Do something with response data return response; }, async (error) =\u0026gt; { // Any status codes that falls outside the range of 2xx cause this function to trigger // Do something with response error const originalRequest = error.config; // If the error is a 401 (Unauthorized) and the request was not retried already if (error.response.status === 401 \u0026amp;\u0026amp; !originalRequest._retry) { originalRequest._retry = true; // Mark this request as retried try { // Attempt to refresh the token const refreshToken = localStorage.getItem(\u0026#34;refresh_token\u0026#34;); const { data } = await axios.post(\u0026#34;https://api.example.com/auth/refresh\u0026#34;, { refresh_token: refreshToken }); // Store the new token localStorage.setItem(\u0026#34;access_token\u0026#34;, data.access_token); // Update the original request headers api.defaults.headers.Authorization = `Bearer ${data.access_token}`; originalRequest.headers.Authorization = `Bearer ${data.access_token}`; // Retry the original request return api(originalRequest); } catch (refreshError) { console.error(\u0026#34;Token refresh failed:\u0026#34;, refreshError); localStorage.removeItem(\u0026#34;access_token\u0026#34;); localStorage.removeItem(\u0026#34;refresh_token\u0026#34;); window.location.href = \u0026#34;/login\u0026#34;; // Redirect to login page return Promise.reject(refreshError); } } return Promise.reject(error); } ); export default api; Explanation: If the response is 401 (Unauthorized), it checks if the request has already been retried. If not, it sends a request to refresh the token. If the refresh is successful:\nThe new token is saved. The original request is updated with the new token and retried. If the refresh fails: The user is logged out (tokens removed). They are redirected to the login page. ","permalink":"http://localhost:1313/posts/pages/networkreact/axios2/","summary":"A detailed guide explaining how to use Axios interceptors in React to manage request and response handling, including token refresh and error handling.","title":"React : Axios Interceptors for Request \u0026 Response Handling"},{"content":"CRUD Operations with Axios in React What is Axios? Axios is a promise-based HTTP client for the browser and Node.js. It is a library that helps in making HTTP requests to external resources. It is a promise-based library that can be used in both client-side and server-side applications.\nWhy Axios over Fetch API? Some of the reasons why Axios is preferred over Fetch API are:\nEasier syntax and cleaner code Better Build-in error handling Better support for older browsers Automatic transformation of JSON data Installation To use Axios in your React project, you need to install it using npm or yarn. You can install Axios by running the following command:\nnpm install axios Simple Data Fetching using Fetch API import React, { useState, useEffect } from \u0026#39;react\u0026#39;; const App = () =\u0026gt; { const [data, setData] = useState([]); const [loading, setLoading] = useState(true); const [error, setError] = useState(null); useEffect(()=\u0026gt;{ async function fetchData(){ try{ const response = await fetch(\u0026#39;https://jsonplaceholder.typicode.com/posts\u0026#39;); const data = await response.json(); if(!response.ok){ throw new Error(\u0026#39;Failed to fetch data\u0026#39;); } setData(data); setLoading(false); }catch(error){ setError(error); setLoading(false); } } }) return ( \u0026lt;div\u0026gt; {loading ? \u0026lt;p\u0026gt;Loading...\u0026lt;/p\u0026gt; : error ? \u0026lt;p\u0026gt;{error.message}\u0026lt;/p\u0026gt; : data.map(post =\u0026gt; \u0026lt;p key={post.id}\u0026gt;{post.title}\u0026lt;/p\u0026gt;)} \u0026lt;/div\u0026gt; ) } export default App; The main defect of this code are:\nIt is not supported in older browsers It does not have built-in error handling as we have to check the response.ok property to check if the request was successful or not. It does not automatically transform JSON data as we have to call response.json() to parse the JSON data. Simple Data Fetching using Axios import React, { useState, useEffect } from \u0026#39;react\u0026#39;; import axios from \u0026#39;axios\u0026#39;; const App = () =\u0026gt; { const [data, setData] = useState([]); const [loading, setLoading] = useState(true); const [error, setError] = useState(null); useEffect(()=\u0026gt;{ async function fetchData(){ try{ const response = await axios.get(\u0026#39;https://jsonplaceholder.typicode.com/posts\u0026#39;); setData(response.data); setLoading(false); }catch(error){ setError(error); setLoading(false); //error.message //error.response //error.response.status } } }) return ( \u0026lt;div\u0026gt; {loading ? \u0026lt;p\u0026gt;Loading...\u0026lt;/p\u0026gt; : error ? \u0026lt;p\u0026gt;{error.message}\u0026lt;/p\u0026gt; : data.map(post =\u0026gt; \u0026lt;p key={post.id}\u0026gt;{post.title}\u0026lt;/p\u0026gt;)} \u0026lt;/div\u0026gt; ) } export default App; It is a better way to fetch data from an API as it has built-in error handling and automatically transforms JSON data.\nProper Ways of structuring Axios requests We can put all the axios code in same file but it is not a good practice. We should create a separate file for axios requests and then import it in the component where we want to use it.\nCreating a separate file for Axios requests src ├── api │ └── getData.js └── components └── App.js getData.js import axios from \u0026#39;axios\u0026#39;; const api=axios.create({ baseURL:\u0026#39;https://jsonplaceholder.typicode.com\u0026#39; }); export const getData=()=\u0026gt;{ return api.get(\u0026#39;/posts\u0026#39;) }; App.js import React, { useState, useEffect } from \u0026#39;react\u0026#39;; import { getData } from \u0026#39;../api/getData\u0026#39;; const App = () =\u0026gt; { const [data, setData] = useState([]); const [loading, setLoading] = useState(true); const [error, setError] = useState(null); async function fetchData(){ try{ const response = await getData(); setData(response.data); setLoading(false); }catch(error){ setError(error); setLoading(false); } } useEffect(()=\u0026gt;{ fetchData(); },[]); return ( \u0026lt;div\u0026gt; {loading ? \u0026lt;p\u0026gt;Loading...\u0026lt;/p\u0026gt; : error ? \u0026lt;p\u0026gt;{error.message}\u0026lt;/p\u0026gt; : data.map(post =\u0026gt; \u0026lt;p key={post.id}\u0026gt;{post.title}\u0026lt;/p\u0026gt;)} \u0026lt;/div\u0026gt; ) } export default App; CRUD Operations with Axios Create an api folder in the src directory and create a file named crud.js. In this file, we will create functions for performing CRUD operations using Axios.\nSending Get,Post,Put and Delete requests Using axios crud.js import axios from \u0026#39;axios\u0026#39;; const api=axios.create({ baseURL:\u0026#39;https://jsonplaceholder.typicode.com\u0026#39; }); export const getPosts=()=\u0026gt;{ return api.get(\u0026#39;/posts\u0026#39;); }; export const addPost=(post)=\u0026gt;{ return api.post(\u0026#39;/posts\u0026#39;,post); }; export const updatePost=(id,post)=\u0026gt;{ return api.put(`/posts/${id}`,post); }; export const deletePost=(id)=\u0026gt;{ return api.delete(`/posts/${id}`); }; App.js(Perform CRUD operations with input fields to add and update posts) import React, { useState, useEffect } from \u0026#39;react\u0026#39;; import { getPosts, addPost, updatePost, deletePost } from \u0026#39;../api/crud\u0026#39;; const App =()=\u0026gt;{ const [posts, setPosts] = useState([]); const [loading, setLoading] = useState(true); const [error, setError] = useState(null); const [title, setTitle] = useState(\u0026#39;\u0026#39;); const [body, setBody] = useState(\u0026#39;\u0026#39;); const [id, setId] = useState(null); async function fetchData(){ try{ const response = await getPosts(); setPosts(response.data); setLoading(false); }catch(error){ setError(error); setLoading(false); } } useEffect(()=\u0026gt;{ fetchData(); },[]); const handleAddPost=async()=\u0026gt;{ try{ const response = await addPost({title:title,body:body}); setPosts([...posts,response.data]); setTitle(\u0026#39;\u0026#39;); setBody(\u0026#39;\u0026#39;); }catch(error){ setError(error); } } const handleDeletePost=async(id)=\u0026gt;{ try{ await deletePost(id); setPosts(posts.filter(post=\u0026gt;post.id!==id)); }catch(error){ setError(error); } } const handleUpdatePost=async(id)=\u0026gt;{ try{ const response = await updatePost(id,{title:title,body:body}); setPosts(posts.map(post=\u0026gt;post.id===id?response.data:post)); setTitle(\u0026#39;\u0026#39;); setBody(\u0026#39;\u0026#39;); setId(null); }catch(error){ setError(error); } } const handleEditPost=(id,title,body)=\u0026gt;{ setTitle(title); setBody(body); setId(id); } return ( \u0026lt;div\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; value={title} onChange={(e)=\u0026gt;setTitle(e.target.value)} placeholder=\u0026#34;Enter Title\u0026#34;/\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; value={body} onChange={(e)=\u0026gt;setBody(e.target.value)} placeholder=\u0026#34;Enter Body\u0026#34;/\u0026gt; \u0026lt;button onClick={id?()=\u0026gt;handleUpdatePost(id):handleAddPost}\u0026gt;{id?\u0026#39;Update Post\u0026#39;:\u0026#39;Add Post\u0026#39;}\u0026lt;/button\u0026gt; {loading ? \u0026lt;p\u0026gt;Loading...\u0026lt;/p\u0026gt; : error ? \u0026lt;p\u0026gt;{error.message}\u0026lt;/p\u0026gt; : posts.map(post =\u0026gt; \u0026lt;div key={post.id}\u0026gt; \u0026lt;p\u0026gt;{post.title}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;{post.body}\u0026lt;/p\u0026gt; \u0026lt;button onClick={()=\u0026gt;handleEditPost(post.id,post.title,post.body)}\u0026gt;Edit\u0026lt;/button\u0026gt; \u0026lt;button onClick={()=\u0026gt;handleDeletePost(post.id)}\u0026gt;Delete\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt;)} \u0026lt;/div\u0026gt; ) } Note:\nresp.data contains the response data resp.status contains the response status seding data in request api.post('/posts',post); here post is the data you want to send in the request\nKey Takeaways: Axios automatically raises an error if the response status is not in the range of 200-299. This makes it easier to handle errors in Axios as compared to Fetch API. Axios also automatically transforms JSON data and has better support for older browsers. It is a better choice for making HTTP requests in React applications.\n","permalink":"http://localhost:1313/posts/pages/networkreact/axios1/","summary":"A detailed guide explaining how to perform CRUD operations using Axios in React, comparing it with Fetch API, and implementing proper API request structures.","title":"React : CRUD Operations with Axios"},{"content":"Permissions Together with authentication and throttling, permissions determine whether a request should be granted or denied access.\nPermission checks are always run at the very start of the view, before any other code is allowed to proceed. Permission checks will typically use the authentication information in the request.user and request.auth properties to determine if the incoming request should be permitted.\nPermissions are used to grant or deny access for different classes of users to different parts of the API.\nThe simplest style of permission would be to allow access to any authenticated user, and deny access to any unauthenticated user. This corresponds to the IsAuthenticated class in REST framework.\nA slightly less strict style of permission would be to allow full access to authenticated users, but allow read-only access to unauthenticated users. This corresponds to the IsAuthenticatedOrReadOnly class in REST framework.\nHow permissions are determined Permissions in REST framework are always defined as a list of permission classes.Before running the main body of the view each permission in the list is checked. If any permission check fails, an exceptions.PermissionDenied or exceptions.NotAuthenticated exception will be raised, and the main body of the view will not run.When the permission checks fail, either a \u0026ldquo;403 Forbidden\u0026rdquo; or a \u0026ldquo;401 Unauthorized\u0026rdquo; response will be returned.\nSetting the permission policy The default permission policy may be set globally, using the DEFAULT_PERMISSION_CLASSES setting. For example.\nREST_FRAMEWORK = { \u0026#39;DEFAULT_PERMISSION_CLASSES\u0026#39;: [ \u0026#39;rest_framework.permissions.IsAuthenticated\u0026#39;, ] } If not specified, this setting defaults to allowing unrestricted access:\n\u0026#39;DEFAULT_PERMISSION_CLASSES\u0026#39;: [ \u0026#39;rest_framework.permissions.AllowAny\u0026#39;, ] You can also set the authentication policy on a per-view, or per-viewset basis, using the APIView class-based views.\nfrom rest_framework.permissions import IsAuthenticated from rest_framework.response import Response from rest_framework.views import APIView class ExampleView(APIView): permission_classes = [IsAuthenticated] def get(self, request, format=None): content = { \u0026#39;status\u0026#39;: \u0026#39;request was permitted\u0026#39; } return Response(content) when you set new permission classes via the class attribute or decorators you\u0026rsquo;re telling the view to ignore the default list set in the settings.py file.\nList of permissions AllowAny Allow any access whether authenticated or not.Useful for views that need to be publicly accessible (e.g., login or registration).This permission is not strictly required, since you can achieve the same result by using an empty list or tuple for the permissions setting.\nIsAuthenticated The IsAuthenticated permission class will deny permission to any unauthenticated user, and allow permission otherwise.This permission is suitable if you want your API to only be accessible to registered users.\nIsAdminUser The IsAdminUser permission class will deny permission to any user, unless user.is_staff is True in which case permission will be allowed.This permission is suitable if you want your API to only be accessible to a subset of trusted administrators\nIsAuthenticatedOrReadOnly The IsAuthenticatedOrReadOnly will allow authenticated users to perform any request. Requests for unauthenticated users will only be permitted if the request method is one of the \u0026ldquo;safe\u0026rdquo; methods; GET, HEAD or OPTIONS.This permission is suitable if you want to your API to allow read permissions to anonymous users, and only allow write permissions to authenticated users.\nExample Of Using Permissions\nfrom rest_framework import permissions from rest_framework.response import Response from rest_framework.views import APIView class ExampleView(APIView): permission_classes = [permissions.IsAuthenticated] def get(self, request, format=None): content = { \u0026#39;status\u0026#39;: \u0026#39;request was permitted\u0026#39; } return Response(content) Custom Permissions To implement a custom permission, override BasePermission and implement either, or both, of the following methods:\nhas_permission(self, request, view) Should return True if the request should be granted access, and False otherwise. has_object_permission(self, request, view, obj) Should return True if the request should be granted access to the object obj, and False otherwise. Note: The instance-level has_object_permission method will only be called if the view-level has_permission checks have already passed. Also note that in order for the instance-level checks to run, the view code should explicitly call .check_object_permissions(request, obj)\nExample Of HasPermission for example, if you want to allow access to only admin users, you can create a custom permission class like this:\nfrom rest_framework.permissions import BasePermission from rest_framework.response import Response from rest_framework.views import APIView class IsAdminUser(BasePermission): def has_permission(self, request, view): return request.user and request.user.is_staff class ExampleView(APIView): permission_classes = [IsAdminUser] def get(self, request, format=None): content = { \u0026#39;status\u0026#39;: \u0026#39;request was permitted\u0026#39; } return Response(content) Ip blacklisting is another example of custom permission\nfrom rest_framework.permissions import BasePermission from rest_framework.response import Response from rest_framework.views import APIView class BlacklistPermission(BasePermission): def has_permission(self, request, view): ip = request.META[\u0026#39;REMOTE_ADDR\u0026#39;] blacklisted = Blacklist.objects.filter(ip=ip).exists() return not blacklisted class ExampleView(APIView): permission_classes = [BlacklistPermission] def get(self, request, format=None): content = { \u0026#39;status\u0026#39;: \u0026#39;request was permitted\u0026#39; } return Response(content) Example of has_object_permission The following example demonstrates how to implement a custom permission that only allows owners of an object to edit it. This permission checks if the user is the owner of the object.\nfrom rest_framework.permissions import BasePermission,IsAuthenticated from rest_framework.response import Response from rest_framework.views import APIView from .models import ExampleModel from .serializers import ExampleSerializer class IsOwner(BasePermission): def has_object_permission(self, request, view, obj): return obj.owner == request.user class ExampleView(APIView): permission_classes = [IsAuthenticated,IsOwner] def get(self, request, format=None): content = { \u0026#39;status\u0026#39;: \u0026#39;request was permitted\u0026#39; } return Response(content) def put(self, request, pk): example = ExampleModel.objects.get(pk=pk) self.check_object_permissions(request, example) serializer = ExampleSerializer(example, data=request.data) if serializer.is_valid(): serializer.save() return Response(serializer.data) return Response(serializer.errors, status=400) Instead of using this custom permission we can use for this\nclass ExampleView(APIView): def get(self, request, format=None): content = { \u0026#39;status\u0026#39;: \u0026#39;request was permitted\u0026#39; } return Response(content) def put(self, request, pk): example = ExampleModel.objects.get(pk=pk) if example.owner != request.user: return Response({\u0026#39;error\u0026#39;: \u0026#39;You do not have permission to edit this object\u0026#39;}) serializer = ExampleSerializer(example, data=request.data) if serializer.is_valid(): serializer.save() return Response(serializer.data) return Response(serializer.errors, status=400) combining has_permission and has_object_permission from rest_framework.permissions import BasePermission,IsAuthenticated from rest_framework.response import Response from rest_framework.views import APIView from .models import ExampleModel from .serializers import ExampleSerializer class IsOwner(BasePermission): def has_permission(self, request, view): return request.user and request.user.is_authenticated def has_object_permission(self, request, view, obj): return obj.owner == request.user class ExampleView(APIView): permission_classes = [IsOwner] def get(self, request, format=None): content = { \u0026#39;status\u0026#39;: \u0026#39;request was permitted\u0026#39; } return Response(content) def put(self, request, pk): example = ExampleModel.objects.get(pk=pk) self.check_object_permissions(request, example) serializer = ExampleSerializer(example, data=request.data) if serializer.is_valid(): serializer.save() return Response(serializer.data) return Response(serializer.errors, status=400) first, the has_permission method is called to check if the user is authenticated. If the user is authenticated, It will run the view and then the has_object_permission method is invoked to check if the user is the owner of the object if the user is the owner of the object then it will allow the user to edit the object otherwise it will return an error message.\nThrottling Throttling is used to limit the number of requests that a user can make to an API within a certain timeframe. It is used to prevent abuse of the API.The order of execution is\nAuthentication Permission Throttling View How throttling works As with permissions and authentication, throttling in REST framework is always defined as a list of classes.Before running the main body of the view each throttle in the list is checked. If any throttle check fails an exceptions.Throttled exception will be raised, and the main body of the view will not run.\nSetting the throttling policy The default throttling policy may be set globally, using the DEFAULT_THROTTLE_CLASSES setting. For example.\nREST_FRAMEWORK = { \u0026#39;DEFAULT_THROTTLE_CLASSES\u0026#39;: [ \u0026#39;rest_framework.throttling.AnonRateThrottle\u0026#39;, \u0026#39;rest_framework.throttling.UserRateThrottle\u0026#39; ], \u0026#39;DEFAULT_THROTTLE_RATES\u0026#39;: { \u0026#39;anon\u0026#39;: \u0026#39;100/day\u0026#39;, \u0026#39;user\u0026#39;: \u0026#39;1000/day\u0026#39; } } The rate descriptions used in DEFAULT_THROTTLE_RATES may include second, minute, hour or day as the throttle period.\nYou can also set the throttling policy on a per-view or per-viewset basis, using the APIView class-based views.\nfrom rest_framework.response import Response from rest_framework.throttling import UserRateThrottle from rest_framework.views import APIView class ExampleView(APIView): throttle_classes = [UserRateThrottle] def get(self, request, format=None): content = { \u0026#39;status\u0026#39;: \u0026#39;request was permitted\u0026#39; } return Response(content) How Clients are identified The X-Forwarded-For HTTP header and REMOTE_ADDR WSGI variable are used to uniquely identify client IP addresses for throttling. If the X-Forwarded-For header is present then it will be used, otherwise the value of the REMOTE_ADDR variable from the WSGI environment will be used.\nAPI Reference AnonRateThrottle The AnonRateThrottle will only ever throttle unauthenticated users. The IP address of the incoming request is used to generate a unique key to throttle against.The allowed number of requests is determined by the \u0026lsquo;anon\u0026rsquo; key in the DEFAULT_THROTTLE_RATES setting.AnonRateThrottle is suitable if you want to restrict the rate of requests from unknown sources.\nUserRateThrottle The UserRateThrottle will throttle users to a given rate of requests across the API. The user id is used to generate a unique key to throttle against. Unauthenticated requests will fall back to using the IP address of the incoming request to generate a unique key to throttle against.The allowed number of requests is determined by the \u0026lsquo;user\u0026rsquo; key in the DEFAULT_THROTTLE_RATES setting.UserRateThrottle.\nScopedRateThrottle The ScopedRateThrottle class can be used to restrict access to specific parts of the API. This throttle will only be applied if the view that is being accessed includes a .throttle_scope property. The unique throttle key will then be formed by concatenating the \u0026ldquo;scope\u0026rdquo; of the request with the unique user id or IP address.\nThe allowed request rate is determined by the DEFAULT_THROTTLE_RATES setting using a key from the request \u0026ldquo;scope\u0026rdquo;.\nFor example, given the following views\u0026hellip;\nclass ContactListView(APIView): throttle_classes = [ScopedRateThrottle] throttle_scope = \u0026#39;contacts\u0026#39; ... class ContactDetailView(APIView): throttle_classes = [ScopedRateThrottle] throttle_scope = \u0026#39;contacts\u0026#39; ... class UploadView(APIView): throttle_classes = [ScopedRateThrottle] throttle_scope = \u0026#39;uploads\u0026#39; ... \u0026hellip;and the following settings.\nREST_FRAMEWORK = { \u0026#39;DEFAULT_THROTTLE_CLASSES\u0026#39;: [ \u0026#39;rest_framework.throttling.ScopedRateThrottle\u0026#39;, ], \u0026#39;DEFAULT_THROTTLE_RATES\u0026#39;: { \u0026#39;contacts\u0026#39;: \u0026#39;1000/day\u0026#39;, \u0026#39;uploads\u0026#39;: \u0026#39;20/day\u0026#39; } } User requests to either ContactListView or ContactDetailView would be restricted to a total of 1000 requests per-day. User requests to UploadView would be restricted to 20 requests per day.\nStatus To send status code in response rest_framework provides a class called status which is used to send status code in response.\nfrom rest_framework import status from rest_framework.response import Response from rest_framework.views import APIView class ExampleView(APIView): def get(self, request, format=None): content = { \u0026#39;status\u0026#39;: \u0026#39;request was permitted\u0026#39; } return Response(content, status=status.HTTP_200_OK) For other status code you can visit here\nReturning Url To return url in response rest_framework provides reverse which is used to return url in response.\nfrom rest_framework.reverse import reverse from rest_framework.response import Response from rest_framework.views import APIView class ExampleView(APIView): def get(self, request, format=None): content = { \u0026#39;status\u0026#39;: \u0026#39;request was permitted\u0026#39;, \u0026#39;url\u0026#39;: reverse(\u0026#39;example-view\u0026#39;, request=request,args=[1,2,3,4]) } return Response(content) Pagination YOu can implement your own pagination using request.query_params like this\nfrom rest_framework.api import APIView from rest_framework.response import Response class ExampleView(APIView): def get(self, request, format=None): page = int(request.query_params.get(\u0026#39;page\u0026#39;, 1)) limit = int(request.query_params.get(\u0026#39;limit\u0026#39;, 10)) offset = (page - 1) * limit data = ExampleModel.objects.all()[offset:offset+limit] return Response(data) ","permalink":"http://localhost:1313/posts/pages/drf/drf4/","summary":"A comprehensive guide on managing permissions and throttling in Django REST framework, covering custom permissions, rate limiting, and more.","title":"DRF : Day 4"},{"content":"Serializer Relationships Relational fields are used to represent model relationships. They can be applied to ForeignKey, ManyToManyField and OneToOneField relationships, as well as to reverse relationships\nConsider the following models:\nfrom django.db import models class Author(models.Model): name = models.CharField(max_length=100) class Book(models.Model): title = models.CharField(max_length=100) author = models.ForeignKey(Author, on_delete=models.CASCADE) Primary Key Related Field A primary key related field should present either the queryset or read_only attributed to true.Normally ModelSerializer uses the primary key related field to represent the relationship.PrimaryKeyRelatedField may be used to represent the target of the relationship using its primary key.\nfor example:\nfrom rest_framework import serializers from .models import Author, Book class BookSerializer(serializers.ModelSerializer): class Meta: model = Book fields = [\u0026#39;title\u0026#39;, \u0026#39;author\u0026#39;] from rest_framework import serializers from .models import Author, Book class BookSerializer(serializers.Serializer): title = serializers.CharField(max_length=100) author = serializers.PrimaryKeyRelatedField(queryset=Author.objects.all()) Will serialize like this:\n{ \u0026#34;title\u0026#34;: \u0026#34;The Great Gatsby\u0026#34;, \u0026#34;author\u0026#34;: 1 } Saving and Updating Instance of Primary Key Related Field One To One Relationship Request format: { \u0026#34;title\u0026#34;: \u0026#34;The Great Gatsby\u0026#34;, \u0026#34;author\u0026#34;: 1 } Model Serializer:\nfrom rest_framework import serializers from .models import Author, Book class BookSerializer(serializers.ModelSerializer): class Meta: model = Book fields = [\u0026#39;title\u0026#39;, \u0026#39;author\u0026#39;] Normal Serializer:\nfrom rest_framework import serializers from .models import Author, Book class BookSerializer(serializers.Serializer): title = serializers.CharField(max_length=100) author = serializers.PrimaryKeyRelatedField(queryset=Author.objects.all()) def create(self, validated_data): author = validated_data.pop(\u0026#39;author\u0026#39;) author_instance = Author.objects.get(id=author) return Book.objects.create(author=author_instance, **validated_data) def update(self, instance, validated_data): author = validated_data.pop(\u0026#39;author\u0026#39;) author_instance = Author.objects.get(id=author) instance.author = author_instance instance.title = validated_data.get(\u0026#39;title\u0026#39;, instance.title) instance.save() return instance Using it in API view to update and save the instance and get the instance:\nfrom rest_framework import APIView from rest_framework.response import Response from .models import Author, Book from .serializers import BookSerializer class BookView(APIView): def post(self, request): serializer = BookSerializer(data=request.data) if serializer.is_valid(): serializer.save() return Response(serializer.data) return Response(serializer.errors) def get(self, request): book = Book.objects.get(id=1) serializer = BookSerializer(book) return Response(serializer.data) def patch(self,request,id): book = Book.objects.get(id=id) serializer = BookSerializer(book, data=request.data, partial=True) if serializer.is_valid(): serializer.save() return Response(serializer.data) return Response(serializer.errors) Foreign Key Relationship Request format:\n{ \u0026#34;title\u0026#34;: \u0026#34;The Great Gatsby\u0026#34;, \u0026#34;author\u0026#34;: 1 } Model Serializer:\nfrom rest_framework import serializers from .models import Author, Book class BookSerializer(serializers.ModelSerializer): class Meta: model = Book fields = [\u0026#39;title\u0026#39;, \u0026#39;author\u0026#39;] Normal Serializer:\nfrom rest_framework import serializers from .models import Author, Book class BookSerializer(serializers.Serializer): title = serializers.CharField(max_length=100) author = serializers.PrimaryKeyRelatedField(queryset=Author.objects.all()) def create(self, validated_data): author = validated_data.pop(\u0026#39;author\u0026#39;) author_instance = Author.objects.get(id=author) return Book.objects.create(author=author_instance, **validated_data) def update(self, instance, validated_data): author = validated_data.pop(\u0026#39;author\u0026#39;) author_instance = Author.objects.get(id=author) instance.author = author_instance instance.title = validated_data.get(\u0026#39;title\u0026#39;, instance.title) instance.save() return instance Using it in API view to update and save the instance and get the instance:\nfrom rest_framework import APIView from rest_framework.response import Response from .models import Author, Book from .serializers import BookSerializer class BookView(APIView): def post(self, request): serializer = BookSerializer(data=request.data) if serializer.is_valid(): serializer.save() return Response(serializer.data) return Response(serializer.errors) def get(self, request): book = Book.objects.get(id=1) serializer = BookSerializer(book) return Response(serializer.data) def patch(self,request,id): book = Book.objects.get(id=id) serializer = BookSerializer(book, data=request.data, partial=True) if serializer.is_valid(): serializer.save() return Response(serializer.data) return Response(serializer.errors) Many To Many Relationship Request format:\n{ \u0026#34;title\u0026#34;: \u0026#34;The Great Gatsby\u0026#34;, \u0026#34;author\u0026#34;: [1, 2] } Model Serializer:\nfrom rest_framework import serializers from .models import Author, Book class BookSerializer(serializers.ModelSerializer): class Meta: model = Book fields = [\u0026#39;title\u0026#39;, \u0026#39;author\u0026#39;] Normal Serializer:\nfrom rest_framework import serializers from .models import Author, Book class BookSerializer(serializers.Serializer): title = serializers.CharField(max_length=100) author = serializers.PrimaryKeyRelatedField(queryset=Author.objects.all(), many=True) def create(self, validated_data): authors = validated_data.pop(\u0026#39;author\u0026#39;) book = Book.objects.create(**validated_data) author_instances = Author.objects.filter(id__in=authors) book.author.add(*author_instances) return book def update(self, instance, validated_data): authors = validated_data.pop(\u0026#39;author\u0026#39;) book = instance book.title = validated_data.get(\u0026#39;title\u0026#39;, book.title) book.save() author_instances = Author.objects.filter(id__in=authors) book.author.set(author_instances) return book Using it in API view to update and save the instance and get the instance:\nfrom rest_framework import APIView from rest_framework.response import Response from .models import Author, Book from .serializers import BookSerializer class BookView(APIView): def post(self, request): serializer = BookSerializer(data=request.data) if serializer.is_valid(): serializer.save() return Response(serializer.data) return Response(serializer.errors) def get(self, request): book = Book.objects.get(id=1) serializer = BookSerializer(book) return Response(serializer.data) def patch(self,request,id): book = Book.objects.get(id=id) serializer = BookSerializer(book, data=request.data, partial=True) if serializer.is_valid(): serializer.save() return Response(serializer.data) return Response(serializer.errors) Nested Relationships As opposed to previously discussed references to another entity, the referred entity can instead also be embedded or nested in the representation of the object that refers to it. Such nested relationships can be expressed by using serializers as fields.\nIf the field is used to represent a to-many relationship, you should add the many=True flag to the serializer field.\nExample:\nModel:\nfrom django.db import models class Author(models.Model): name = models.CharField(max_length=100) class Book(models.Model): title = models.CharField(max_length=100) author = models.ManyToManyField(Author,releted_name=\u0026#39;books\u0026#39;) Model Serializer:\nfrom rest_framework import serializers from .models import Author, Book class AuthorSerializer(serializers.ModelSerializer): class Meta: model = Author fields = [\u0026#39;id\u0026#39;,\u0026#39;name\u0026#39;] class BookSerializer(serializers.ModelSerializer): author = AuthorSerializer(many=True) class Meta: model = Book fields = [\u0026#39;title\u0026#39;, \u0026#39;author\u0026#39;] Normal Serializer:\nfrom rest_framework import serializers from .models import Author, Book class AuthorSerializer(serializers.Serializer): id = serializers.IntegerField() name = serializers.CharField(max_length=100) class BookSerializer(serializers.Serializer): title = serializers.CharField(max_length=100) author = AuthorSerializer(many=True) def create(self, validated_data): authors = validated_data.pop(\u0026#39;author\u0026#39;) book = Book.objects.create(**validated_data) for author in authors: author_instance = Author.objects.get(id=author[\u0026#39;id\u0026#39;]) book.author.add(author_instance) return book def update(self, instance, validated_data): authors = validated_data.pop(\u0026#39;author\u0026#39;) book = instance book.title = validated_data.get(\u0026#39;title\u0026#39;, book.title) book.save() for author in authors: author_instance = Author.objects.get(id=author[\u0026#39;id\u0026#39;]) book.author.add(author_instance) return book Would serialize to a nested representation like this:\n{ \u0026#34;title\u0026#34;: \u0026#34;The Great Gatsby\u0026#34;, \u0026#34;author\u0026#34;: [ { \u0026#34;title\u0026#34;: \u0026#34;F. Scott Fitzgerald\u0026#34;, \u0026#34;author\u0026#34;: 1 }, { \u0026#34;title\u0026#34;: \u0026#34;Ernest Hemingway\u0026#34;, \u0026#34;author\u0026#34;: 2 } ] } Writable Nested Representations By default nested serializers are read-only. If you want to support write-operations to a nested serializer field you\u0026rsquo;ll need to create create() and/or update() methods in order to explicitly specify how the child relationships should be saved.\nNote: Model Serializer by default usages the primary key related field to represent the relationship such that we need not define the create() and update() methods but in case of nested serializer we need to define the create() and update() methods.\nModel Serializer: from rest_framework import serializers from .models import Author, Book class AuthorSerializer(serializers.ModelSerializer): class Meta: model = Author fields = [\u0026#39;id\u0026#39;, \u0026#39;name\u0026#39;] class BookSerializer(serializers.ModelSerializer): author = AuthorSerializer(many=True) class Meta: model = Book fields = [\u0026#39;title\u0026#39;, \u0026#39;author\u0026#39;] def create(self, validated_data): authors = validated_data.pop(\u0026#39;author\u0026#39;) book = Book.objects.create(**validated_data) for author in authors: author_instance = Author.objects.get(id=author[\u0026#39;id\u0026#39;]) book.author.add(author_instance) return book def update(self, instance, validated_data): authors = validated_data.pop(\u0026#39;author\u0026#39;) book = instance book.title = validated_data.get(\u0026#39;title\u0026#39;, book.title) book.save() for author in authors: author_instance = Author.objects.get(id=author[\u0026#39;id\u0026#39;]) book.author.add(author_instance) return book Normal Serializer: from rest_framework import serializers from .models import Author, Book class AuthorSerializer(serializers.Serializer): id = serializers.IntegerField() name = serializers.CharField(max_length=100) class BookSerializer(serializers.Serializer): title = serializers.CharField(max_length=100) author = AuthorSerializer(many=True) def create(self, validated_data): authors = validated_data.pop(\u0026#39;author\u0026#39;) book = Book.objects.create(**validated_data) for author in authors: author_instance = Author.objects.get(id=author[\u0026#39;id\u0026#39;]) book.author.add(author_instance) return book def update(self, instance, validated_data): authors = validated_data.pop(\u0026#39;author\u0026#39;) book = instance book.title = validated_data.get(\u0026#39;title\u0026#39;, book.title) book.save() for author in authors: author_instance = Author.objects.get(id=author[\u0026#39;id\u0026#39;]) book.author.add(author_instance) return book Using it in API view to update and save the instance and get the instance:\nfrom rest_framework import APIView from rest_framework.response import Response from .models import Author, Book from .serializers import BookSerializer class BookView(APIView): def post(self, request): serializer = BookSerializer(data=request.data) if serializer.is_valid(): serializer.save() return Response(serializer.data) return Response(serializer.errors) def get(self, request): book = Book.objects.get(id=1) serializer = BookSerializer(book) return Response(serializer.data) def patch(self,request,id): book = Book.objects.get(id=id) serializer = BookSerializer(book, data=request.data, partial=True) if serializer.is_valid(): serializer.save() return Response(serializer.data) return Response(serializer.errors) Further Notes: Queryset attribute: In version 2.x a serializer class could sometimes automatically determine the queryset argument if a ModelSerializer class was being used.This behavior is now replaced with always using an explicit queryset argument for writable relational fields. Reverse Relations Note that reverse relationships are not automatically included by the ModelSerializer class. You\u0026rsquo;ll need to add an explicit field for the reverse relationship.for example:\nusing model serializer:\nfrom rest_framework import serializers from .models import Author, Book class AuthorSerializer(serializers.ModelSerializer): books = serializers.PrimaryKeyRelatedField(many=True, read_only=True) class Meta: model = Author fields = [\u0026#39;id\u0026#39;, \u0026#39;name\u0026#39;, \u0026#39;books\u0026#39;] using normal serializer:\nfrom rest_framework import serializers from .models import Author, Book class AuthorSerializer(serializers.Serializer): id = serializers.IntegerField() name = serializers.CharField(max_length=100) books = serializers.PrimaryKeyRelatedField(many=True, read_only=True) You\u0026rsquo;ll normally want to ensure that you\u0026rsquo;ve set an appropriate related_name argument on the relationship, that you can use as the field name. For example:\nclass Author(models.Model): name = models.CharField(max_length=100) class Book(models.Model): title = models.CharField(max_length=100) author = models.ForeignKey(Author, related_name=\u0026#39;books\u0026#39;, on_delete=models.CASCADE) API view like this:\nfrom rest_framework import APIView from rest_framework.response import Response from .models import Author, Book from .serializers import AuthorSerializer class AuthorView(APIView): def get(self, request): author = Author.objects.get(id=1) serializer = AuthorSerializer(author) return Response(serializer.data) Now the AuthorSerializer will include a field named books that represents the reverse relationship.like this:\nAPI Response:\n{ \u0026#34;id\u0026#34;: 1, \u0026#34;name\u0026#34;: \u0026#34;F. Scott Fitzgerald\u0026#34;, \u0026#34;books\u0026#34;: [ 1, 2 ] } Authentications Authentication is the process of verifying the identity of a user. Authentication always runs at the very start of the view, before the permission and throttling checks occur, and before any other code is allowed to proceed.\nThe request.user property will typically be set to an instance of the contrib.auth package\u0026rsquo;s User class.\nThe request.auth property is used for any additional authentication information, for example, it may be used to represent an authentication token that the request was signed with.\nNote: Don\u0026rsquo;t forget that authentication by itself won\u0026rsquo;t allow or disallow an incoming request, it simply identifies the credentials that the request was made with.The permission class then decides if the request should be authorized or not.\nHow Authentication is determined The authentication schemes are always defined as a list of classes. REST framework will attempt to authenticate with each class in the list, and will set request.user and request.auth using the return value of the first class that successfully authenticates.If no class authenticates, request.user will be set to an instance of django.contrib.auth.models.AnonymousUser, and request.auth will be set to None\nSetting the authentication scheme The default authentication schemes may be set globally, using the DEFAULT_AUTHENTICATION_CLASSES setting. For example.\nREST_FRAMEWORK = { \u0026#39;DEFAULT_AUTHENTICATION_CLASSES\u0026#39;: [ \u0026#39;rest_framework.authentication.BasicAuthentication\u0026#39;, \u0026#39;rest_framework.authentication.SessionAuthentication\u0026#39;, ] } You can also set the authentication scheme on a per-view or per-viewset basis, using the APIView class-based views.\nfrom rest_framework.authentication import SessionAuthentication, BasicAuthentication from rest_framework.permissions import IsAuthenticated from rest_framework.response import Response from rest_framework.views import APIView class ExampleView(APIView): authentication_classes = [SessionAuthentication, BasicAuthentication] permission_classes = [IsAuthenticated] def get(self, request, format=None): content = { \u0026#39;user\u0026#39;: str(request.user), # `django.contrib.auth.User` instance. \u0026#39;auth\u0026#39;: str(request.auth), # None } return Response(content) Insted of using Token,session and basic authentication we can also use custom authentication.\nJWT Authentication In this section, we will learn how to implement JWT authentication in Django REST framework.\nWhat is JWT? JSON Web Token is a fairly new standard which can be used for token-based authentication. Unlike the built-in TokenAuthentication scheme, JWT Authentication doesn\u0026rsquo;t need to use a database to validate a token because it is self-validated. This means that the server doesn\u0026rsquo;t need to query the database to check if the token is valid.\nHow JWT works? When a user logs in, the server will generate a token and send it to the client. The client will store the token and send it with every request. The server will then validate the token and allow the user to access protected resources.\nInstalling JWT To install JWT, you need to install the djangorestframework_simplejwt package. You can install it using pip:\npip install djangorestframework-simplejwt Project Configuration Then, your django project must be configured to use the library. In settings.py, add rest_framework_simplejwt.authentication.JWTAuthentication to the list of authentication classes:\nThis set default authentication to JWTAuthentication globally.\nREST_FRAMEWORK = { \u0026#39;DEFAULT_AUTHENTICATION_CLASSES\u0026#39;: [ \u0026#39;rest_framework_simplejwt.authentication.JWTAuthentication\u0026#39;, #other authentication classes ], } but you can also set it on a per-view basis.\nfrom rest_framework_simplejwt.authentication import JWTAuthentication from rest_framework.permissions import IsAuthenticated from rest_framework.response import Response from rest_framework.views import APIView class ExampleView(APIView): authentication_classes = [JWTAuthentication] permission_classes = [IsAuthenticated] def get(self, request, format=None): content = { \u0026#39;user\u0026#39;: str(request.user), # `django.contrib.auth.User` instance. \u0026#39;auth\u0026#39;: str(request.auth), # None } return Response(content) Note view level authentication will have more priority than global authentication. In every request authentication will be check if authentication is set either in view or globally.and authentication winot restrict the request but it will only identify the user so we have to use permission classes to restrict the request.\nGenerating Tokens To generate a token, you can use the TokenObtainPairView view. This view will generate a token for a user. You can use this token to authenticate the user in subsequent requests.\nfrom rest_framework_simplejwt.views import TokenObtainPairView urlpatterns = [ path(\u0026#39;api/token/\u0026#39;, TokenObtainPairView.as_view(), name=\u0026#39;token_obtain_pair\u0026#39;), ] The request on /api/token/ will return a response like this:\n{ \u0026#34;username\u0026#34;: \u0026#34;admin\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;admin\u0026#34; } will return a response like this:\n{ \u0026#34;access\u0026#34;: \u0026#34;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyX2lkIjoyLCJ1c2VybmFtZSI6ImFkbWluIiwiZXhwIjoxNjI5MzYwNjY4LCJlbWFpbCI6IiJ9.7Z\u0026#34;, \u0026#34;refresh\u0026#34;: \u0026#34;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyX2lkIjoyLCJ1c2VybmFtZSI6ImFkbWluIiwiZXhwIjoxNjI5MzYwNjY4LCJlbWFpbCI6IiJ9.7Z\u0026#34; } The refresh token is used to get a new access token when the access token expires.The ascess token is send in every request where authentication class determines which user is making the request while permission class determines whether the user is allowed to make the request or not.if not allowed then it will return 403 forbidden.\nProblem In it: TokenObtainPairView will always user username and password to generate the token but in some cases we need to use email and password to generate the token so we can create our own view to generate the token.so if we have custom user model and authentication then we can create our own view to generate the token.\nfrom rest_framework_simplejwt.tokens import RefreshToken from django.contrib.auth import authenticate from rest_framework.views import APIView from rest_framework.response import Response from rest_framework import serializers class TokenSerializer(serializer.Serializer): email = serializers.EmailField() password = serializers.CharField(max_length=100) class GetToken(APIView): def post(self, request): credentials = TokenSerializer(data=request.data) if(credentials.is_valid()): user = authenticate(email=credentials.validated_data[\u0026#39;email\u0026#39;], password=credentials.validated_data[\u0026#39;password\u0026#39;]) if user is not None: refresh = RefreshToken.for_user(user) return Response({ \u0026#39;refresh\u0026#39;: str(refresh), \u0026#39;access\u0026#39;: str(refresh.access_token) }) else: return Response({ \u0026#39;error\u0026#39;: \u0026#39;Invalid Credentials\u0026#39; }) else: return Response({ \u0026#39;error\u0026#39;: \u0026#39;Invalid Data\u0026#39; }) Using Refresh Token If the ascess token is expired then we can use the refresh token to get the new access token.\nfrom rest_framework_simplejwt.views import TokenRefreshView urlpatterns = [ path(\u0026#39;api/token/refresh/\u0026#39;, TokenRefreshView.as_view(), name=\u0026#39;token_refresh\u0026#39;), ] { \u0026#34;refresh\u0026#34;: \u0026#34;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyX2lkIjoyLCJ1c2VybmFtZSI6ImFkbWluIiwiZXhwIjoxNjI5MzYwNjY4LCJlbWFpbCI6IiJ9.7Z\u0026#34; } The request on /api/token/refresh/ will return a response like this:\n{ \u0026#34;access\u0026#34;: \u0026#34;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyX2lkIjoyLCJ1c2VybmFtZSI6ImFkbWluIiwiZXhwIjoxNjI5MzYwNjY4LCJlbWFpbCI6IiJ9.7Z\u0026#34; } Verifying Tokens To verify a token, you can use the TokenVerifyView view. This view will verify a token and return a response.\nfrom rest_framework_simplejwt.views import TokenVerifyView urlpatterns = [ path(\u0026#39;api/token/verify/\u0026#39;, TokenVerifyView.as_view(), name=\u0026#39;token_verify\u0026#39;), ] Backlisting the token First add the blacklist app to your installed apps:\nINSTALLED_APPS = [ ... \u0026#39;rest_framework_simplejwt.token_blacklist\u0026#39;, ] Then run python manage.py migrate to create the necessary database tables.\nThen to backlist token you can use .blacklist() method of the token object.\nfrom rest_framework_simplejwt.views import APIView from rest_framework.response import Response from rest_framework_simplejwt.tokens import RefreshToken class LogoutView(APIView): def post(self, request): try: refresh_token = request.data.get[\u0026#39;refresh\u0026#39;] token = RefreshToken(refresh_token) token.blacklist() return Response({\u0026#39;message\u0026#39;: \u0026#39;Token blacklisted\u0026#39;}) except Exception as e: return Response({\u0026#39;error\u0026#39;: str(e)}) else you can use the TokenBlacklistView view to blacklist the token.\nfrom rest_framework_simplejwt.views import TokenBlacklistView urlpatterns = [ path(\u0026#39;api/token/blacklist/\u0026#39;, TokenBlacklistView.as_view(), name=\u0026#39;token_blacklist\u0026#39;), # Add any other urlpatterns here if needed ] This is specifically for blacklisting the token. when the same token won\u0026rsquo;t be used again.and used to logout the user.\nHow to send token in request for authentication and authorization suppose the route /api/shop is protected by authentication and authorization then we have to send the token in the request header.\nAuthorization : Bearer \u0026lt;token\u0026gt; json { \u0026#34;name\u0026#34;: \u0026#34;book\u0026#34;, \u0026#34;price\u0026#34;: 100 } Some Expiration settings SIMPLE_JWT = {\u0026#34;ACCESS_TOKEN_LIFETIME\u0026#34;: timedelta(minutes=5), \u0026#34;REFRESH_TOKEN_LIFETIME\u0026#34;: timedelta(days=1), } This will set the access token lifetime to 5 minutes and the refresh token lifetime to 1 day.\n","permalink":"http://localhost:1313/posts/pages/drf/drf3/","summary":"A comprehensive guide on implementing JWT authentication in Django REST framework, covering installation, configuration, and usage.","title":"DRF : Day 3"},{"content":"22. Serializer Field Boolean field A boolean representation.\nfrom rest_framework import serializers class BooleanSerializer(serializers.Serializer): boolean_field = serializers.BooleanField() Char Field A text representation. Optionally validates the text to be shorter than max_length and longer than min_length List of parameters it take:\nmax_length - Validates that the input contains no more than this number of characters. min_length - Validates that the input contains no fewer than this number of characters. allow_blank - If set to True then the empty string should be considered a valid value. If set to False then the empty string is considered invalid and will raise a validation error. Defaults to False. trim_whitespace - If set to True then leading and trailing whitespace is trimmed. Defaults to True. from rest_framework import serializers class CharSerializer(serializers.Serializer): char_field = serializers.CharField(max_length=100, min_length=10) Email Field A text representation, validates the text to be a valid e-mail address.\nfrom rest_framework import serializers class EmailSerializer(serializers.Serializer): email_field = serializers.EmailField(max_length=100, min_length=10) Slug Field A text representation, validates the text to be a valid slug.\nfrom rest_framework import serializers class SlugSerializer(serializers.Serializer): slug_field = serializers.SlugField(max_length=100, min_length=10) URL Field A text representation, validates the text to be a valid URL.\nfrom rest_framework import serializers class URLSerializer(serializers.Serializer): url_field = serializers.URLField(max_length=100, min_length=10) UUID Field A text representation, validates the text to be a valid UUID.\nfrom rest_framework import serializers class UUIDSerializer(serializers.Serializer): uuid_field = serializers.UUIDField(max_length=100, min_length=10) Ip Address Field A text representation, validates the text to be a valid IP address.\nfrom rest_framework import serializers class IpAddressSerializer(serializers.Serializer): ip_address_field = serializers.IPAddressField(max_length=100, min_length=10) Integer Field An integer representation. Optionally validates the integer to be greater than max_value and lesser than min_value.\nfrom rest_framework import serializers class IntegerSerializer(serializers.Serializer): integer_field = serializers.IntegerField(max_value=100, min_value=10) Float Field A float representation. Optionally validates the float to be greater than max_value and lesser than min_value.\nfrom rest_framework import serializers class FloatSerializer(serializers.Serializer): float_field = serializers.FloatField(max_value=100, min_value=10) Decimal Field A decimal representation. Optionally validates the decimal to be greater than max_value and lesser than min_value.\nfrom rest_framework import serializers class DecimalSerializer(serializers.Serializer): decimal_field = serializers.DecimalField(max_value=100, min_value=10) Date Field A date representation.\nfrom rest_framework import serializers class DateSerializer(serializers.Serializer): date_field = serializers.DateField() DateTime Field A datetime representation.\nfrom rest_framework import serializers class DateTimeSerializer(serializers.Serializer): datetime_field = serializers.DateTimeField() Time Field A time representation.\nfrom rest_framework import serializers class TimeSerializer(serializers.Serializer): time_field = serializers.TimeField() Choice Field A choice representation. Optionally validates the choice to be in the choices list.\nfrom rest_framework import serializers class ChoiceSerializer(serializers.Serializer): choice_field = serializers.ChoiceField(choices==( (\u0026#39;choice1\u0026#39;, \u0026#39;Choice 1\u0026#39;), (\u0026#39;choice2\u0026#39;, \u0026#39;Choice 2\u0026#39;), (\u0026#39;choice3\u0026#39;, \u0026#39;Choice 3\u0026#39;), )) Example:\n{ \u0026#34;choice_field\u0026#34;: \u0026#34;choice1\u0026#34; } // This is correct, but { \u0026#34;choice_field\u0026#34;: \u0026#34;choice4\u0026#34; } // THis is incorrect because choice4 is not in the choices list. Multiple Choice Field A multiple choice representation. Optionally validates the choice to be in the choices list.\nfrom rest_framework import serializers class MultipleChoiceSerializer(serializers.Serializer): multiple_choice_field = serializers.MultipleChoiceField(choices==( (\u0026#39;choice1\u0026#39;, \u0026#39;Choice 1\u0026#39;), (\u0026#39;choice2\u0026#39;, \u0026#39;Choice 2\u0026#39;), (\u0026#39;choice3\u0026#39;, \u0026#39;Choice 3\u0026#39;), )) Example:\n{ \u0026#34;multiple_choice_field\u0026#34;: [\u0026#34;choice1\u0026#34;, \u0026#34;choice2\u0026#34;] } // This is correct, but { \u0026#34;multiple_choice_field\u0026#34;: [\u0026#34;choice1\u0026#34;, \u0026#34;choice4\u0026#34;] } // THis is incorrect because choice4 is not in the choices list. File Field A file representation. Optionally validates the file to be of a certain type.\nfrom rest_framework import serializers class FileSerializer(serializers.Serializer): file_field = serializers.FileField() Image Field An image representation. Optionally validates the image to be of a certain type.\nfrom rest_framework import serializers class ImageSerializer(serializers.Serializer): image_field = serializers.ImageField() List Field A list representation. Optionally validates the list to be of a certain type.\nfrom rest_framework import serializers class ListSerializer(serializers.Serializer): list_field = serializers.ListField(child=serializers.CharField()) Example:\n{ \u0026#34;list_field\u0026#34;: [\u0026#34;item1\u0026#34;, \u0026#34;item2\u0026#34;] } // This is correct, but { \u0026#34;list_field\u0026#34;: [\u0026#34;item1\u0026#34;, 1] } // THis is incorrect because 1 is not a string. Serializer Method Field A serializer method representation. Optionally validates the method to be of a certain type.It is read-only field\nfrom rest_framework import serializers class SerializerMethodSerializer(serializers.Serializer): serializer_method_field = serializers.SerializerMethodField() def get_serializer_method_field(self, obj): return obj.method_field ","permalink":"http://localhost:1313/posts/pages/drf/drf2/","summary":"Explore different serializer fields in Django Rest Framework, their parameters, and how to use them effectively in your projects.","title":"DRF : Day 2"},{"content":"1. Installation Step 1: Install Django Rest Framework pip install djangorestframework Step 2: Add \u0026lsquo;rest_framework\u0026rsquo; to your INSTALLED_APPS setting. INSTALLED_APPS = [ ... \u0026#39;rest_framework\u0026#39;, ] 2.Views We can Define class based views in django rest framework by inheriting from APIView class.\nstep 1: Import APIView from rest_framework.views import APIView from rest_framework.response import Response step 2: Define a class based view class HelloApiView(APIView): def get(self, request): #code here we can define post, put, patch, delete methods also.\nNote: Only defined methods will be allowed to access the view.Like here we are only allowing get method to access the view.\n3. URL Configuration from django.urls import path from . import views urlpatterns = [ path(\u0026#39;hello-view/\u0026#39;, views.HelloApiView.as_view()), ] Note: APIView Base class always return a Response object.\n4. Response To return a response from a view we can use Response object from rest_framework.response module\nExample from rest_framework.response import Response from rest_framework.views import APIView class HelloApiView(APIView): def get(self, request): return Response({\u0026#39;message\u0026#39;: \u0026#39;Hello From Rest Framework!\u0026#39;}) 5.request If you\u0026rsquo;re doing REST-based web service stuff.you should ignore request.POST.\nrequest.data request.data returns the parsed content of the request body. This is similar to the standard request.POST and request.FILES attributes except that:\nIt includes all parsed content, including file and non-file inputs. It supports parsing the content of HTTP methods other than POST, meaning that you can access the content of PUT and PATCH requests. It supports REST framework\u0026rsquo;s flexible request parsing, rather than just supporting form data. For example, you can handle incoming JSON data in the same way that you handle incoming form data. request.query_params request.query_params is a more correctly named synonym for request.GET.For clarity inside your code, we recommend using request.query_params instead of the Django\u0026rsquo;s standard request.GET. Doing so will help keep your codebase more correct and obvious - any HTTP method type may include query parameters, not just GET requests.\nExample class DemoApiView(APIView): def post(self, request): data = request.data return Response({\u0026#39;message\u0026#39;: \u0026#39;Hello From Rest Framework!\u0026#39;, \u0026#39;data\u0026#39;: data}) def get(self, request): query_params = request.query_params return Response({\u0026#39;message\u0026#39;: \u0026#39;Hello From Rest Framework!\u0026#39;, \u0026#39;query_params\u0026#39;: query_params}) Note: All th concept of django are applied in DRF also.\nDifferent HTTP Methods GET: Retrieve data from the server. POST: Send data to the server. DELETE: Delete data from the server. PUT: Update data on the server. PATCH: Update data partially on the server. 6. Serializer Serializer is used to convert complex data types like querysets and model instances to native Python datatypes that can then be easily rendered into JSON, XML or other content types. Serializers also provide deserialization, allowing parsed data to be converted back into complex types, after first validating the incoming data. Serializer is used in DRF for:\nParsing the incoming request data and validating it. Converting complex data types to native python datatypes. 7. Creating Serializer Creating a serializer in DRF is similar to creating a form in Django.For now,We will create a simple serializer name comment.\nCreate a serializer from rest_framework import serializers class CommentSerializer(serializers.Serializer): name = serializers.CharField(max_length=100) email = serializers.EmailField() content = serializers.CharField() Note: The field name of serializer should be same as the field name of model. Note: Note all the field that are written in serializer should be present in the model but all the fields present in the model are not necessary to be present in the serializer but always remember the parameter like required and read_only can affects.\n8. Using Serializer Using Serializer to convert complex data types to native python datatypes. comment = Comment.objects.get(id=1) serializer = CommentSerializer(comment) serializer.data # {\u0026#39;name\u0026#39;: \u0026#39;John\u0026#39;, \u0026#39;email\u0026#39;: \u0026#39;john@gmail.com\u0026#39;, \u0026#39;content\u0026#39;: \u0026#39;Hello World!\u0026#39;} Example:\nfrom .serializers import CommentSerializer from .models import Comment from rest_framework.response import Response from rest_framework.views import APIView class CommentApiView(APIView): def get(self, request): comments = Comment.objects.get(pk=1) serializer = CommentSerializer(comments) return Response(serializer.data) 9. Using Serializer to validate incoming data Example commentSer=CommentSerializer(data=request.data) if commentSer.is_valid(): # Returns True if the data is valid print(commentSer.cleaned_data) # Returns the validated data #code else: return Response(commentSer.errors) TO be able to be validated the request.data should follow the same structure as the serializer and should have the same field name as the serializer.\n10.Saving the data To save the data in the database we can define it in APIView itself.\nExample from .serializers import CommentSerializer from .models import Comment from rest_framework.response import Response from rest_framework.views import APIView class CommentApiView(APIView): def post(self, request): commentSer=CommentSerializer(data=request.data) if commentSer.is_valid(): data=Comment.objects.create(**commentSer.validated_data) return Response(CommentSerializer(data).data) else: return Response(commentSer.errors) But it is not a good practice to define the save method in the APIView itself. We can define the save method in the serializer itself with the help of create or update method.\nExample from rest_framework import serializers from .models import Comment class CommentSerializer(serializers.Serializer): name = serializers.CharField(max_length=100) email = serializers.EmailField() content = serializers.CharField() def create(self, validated_data): return Comment.objects.create(**validated_data) def update(self,instance,validated_data): instance.name=validated_data.get(\u0026#39;name\u0026#39;,instance.name) instance.email=validated_data.get(\u0026#39;email\u0026#39;,instance.email) instance.content=validated_data.get(\u0026#39;content\u0026#39;,instance.content) instance.save() return instance using the above serializer we can remove the save method from the APIView.\nExample from .serializers import CommentSerializer from .models import Comment from rest_framework.response import Response from rest_framework.views import APIView class CommentApiView(APIView): def post(self, request): commentSer=CommentSerializer(data=request.data) if commentSer.is_valid(): data=commentSer.save() return Response(CommentSerializer(data).data) else: return Response(commentSer.errors) # .save() will create a new instance. serializer = CommentSerializer(data=data) # .save() will update the existing `comment` instance. serializer = CommentSerializer(comment, data=data) save() method Internally, the save() method will call either .create() or .update() depending on whether an instance was passed when instantiating the serializer.\nBut if you doesnt create the create or update data in database then you can override the save method in the serializer.\nFor example: You take the form data and send the mail to the user and you dont want to save the data in the database then you can override the save method in the serializer.\nExample from rest_framework import serializers from .models import Comment class CommentSerializer(serializers.Serializer): name = serializers.CharField(max_length=100) email = serializers.EmailField() content = serializers.CharField() def save(self): name=self.validated_data.get(\u0026#39;name\u0026#39;) email=self.validated_data.get(\u0026#39;email\u0026#39;) content=self.validated_data.get(\u0026#39;content\u0026#39;) #code to send mail 11. Validation When deserializing data, you always need to call is_valid() before attempting to access the validated data, or save an object instance. If any validation errors occur, the .errors property will contain a dictionary representing the resulting error messages. For example:\nserializer = CommentSerializer(data={\u0026#39;email\u0026#39;: \u0026#39;foobar\u0026#39;, \u0026#39;content\u0026#39;: \u0026#39;baz\u0026#39;}) serializer.is_valid() # False serializer.errors # {\u0026#39;email\u0026#39;: [\u0026#39;Enter a valid e-mail address.\u0026#39;], \u0026#39;created\u0026#39;: [\u0026#39;This field is required.\u0026#39;]} Defining field-level validation You can specify custom validation for a field by adding .validate_\u0026lt;field_name\u0026gt; methods to your Serializer subclass. These are similar to the .clean_\u0026lt;field_name\u0026gt; methods on Django forms. For example:\nfrom rest_framework import serializers class CommentSerializer(serializers.Serializer): name = serializers.CharField(max_length=100) email = serializers.EmailField() content = serializers.CharField() def validate_name(self, value): if value == \u0026#39;admin\u0026#39;: raise serializers.ValidationError(\u0026#34;Name can\u0026#39;t be admin\u0026#34;) return value Defining object-level validation You can also add .validate() method to a Serializer subclass. This method is used to validate the entire object, rather than a specific field. For example:\nfrom rest_framework import serializers class CommentSerializer(serializers.Serializer): name = serializers.CharField(max_length=100) email = serializers.EmailField() content = serializers.CharField() def validate(self, data): if data[\u0026#39;name\u0026#39;] == \u0026#39;admin\u0026#39;: raise serializers.ValidationError(\u0026#34;Name can\u0026#39;t be admin\u0026#34;) return data validators You can also add validators to the fields in the serializer.\nExample from rest_framework import serializers def name_validator(value): if value == \u0026#39;admin\u0026#39;: raise serializers.ValidationError(\u0026#34;Name can\u0026#39;t be admin\u0026#34;) else: return value class CommentSerializer(serializers.Serializer): name = serializers.CharField(max_length=100, validators=[name_validator]) email = serializers.EmailField() content = serializers.CharField() 12. Partial update To validate data using a serializer, we typically need to provide all the required fields. However, if we want to update only specific fields, we can use the partial argument in the serializer. This allows us to validate only the fields that are included in the request.\nExample from .serializers import CommentSerializer from .models import Comment from rest_framework.response import Response class CommentApiView(APIView): def patch(self, request): comment = Comment.objects.get(pk=1) commentSer = CommentSerializer(comment, data=request.data, partial=True) if commentSer.is_valid(): commentSer.save() return Response(commentSer.data) else: return Response(commentSer.errors) 13.Nested Serializer We can make nested serializer in DRF by defining the serializer inside the serializer.\nExample from rest_framework import serializers class UserSerializer(serializers.Serializer): name = serializers.CharField(max_length=100) email = serializers.EmailField() class CommentSerializer(serializers.Serializer): user = UserSerializer() content = serializers.CharField(max_length=100) Sending data to nested serializer data = { \u0026#39;user\u0026#39;: { \u0026#39;name\u0026#39;: \u0026#39;John\u0026#39;, \u0026#39;email\u0026#39;: \u0026#39; }, \u0026#39;content\u0026#39;: \u0026#39;Hello World!\u0026#39; } Saving data to nested serializer def create(self, validated_data): user_data = validated_data.pop(\u0026#39;user\u0026#39;) user = User.objects.create(**user_data) comment = Comment.objects.create(user=user, **validated_data) return comment def update(self, instance, validated_data): user_data = validated_data.pop(\u0026#39;user\u0026#39;) user = instance.user user.name = user_data.get(\u0026#39;name\u0026#39;, user.name) user.email = user_data.get(\u0026#39;email\u0026#39;, user.email) user.save() instance.content = validated_data.get(\u0026#39;content\u0026#39;, instance.content) instance.save() return instance 14. Dealing with multiple objects To serialize a queryset or list of objects instead of a single object instance, you should pass the many=True flag when instantiating the serializer. You can then pass a queryset or list of objects to be serialized.\nExample comments = Comment.objects.all() serializer = CommentSerializer(comments, many=True) # [ # {\u0026#39;id\u0026#39;: 0, \u0026#39;title\u0026#39;: \u0026#39;The electric kool-aid acid test\u0026#39;, \u0026#39;author\u0026#39;: \u0026#39;Tom Wolfe\u0026#39;}, # {\u0026#39;id\u0026#39;: 1, \u0026#39;title\u0026#39;: \u0026#39;If this is a man\u0026#39;, \u0026#39;author\u0026#39;: \u0026#39;Primo Levi\u0026#39;}, # {\u0026#39;id\u0026#39;: 2, \u0026#39;title\u0026#39;: \u0026#39;The wind-up bird chronicle\u0026#39;, \u0026#39;author\u0026#39;: \u0026#39;Haruki Murakami\u0026#39;} # ] Including extra context You can include additional context when instantiating the serializer, by passing additional keyword arguments. This context is not used directly by the serializer, but is passed through to any custom field or method that accepts additional arguments.\nExample serializer = CommentSerializer(comments, many=True, context={\u0026#39;request\u0026#39;: request}) using it in the serializer\nclass CommentSerializer(serializers.Serializer): def hello(self): request = self.context.get(\u0026#39;request\u0026#39;) 15. ModelSerializer The ModelSerializer class is the same as a regular Serializer class, except that:\nIt will automatically generate a set of fields for you, based on the model. It will automatically generate validators for the serializer, such as unique_together validators. It includes simple default implementations of .create() and .update(). Declaring a simple ModelSerializer from rest_framework import serializers from .models import Comment class CommentSerializer(serializers.ModelSerializer): class Meta: model = Comment fields = \u0026#39;__all__\u0026#39; Specifying which fields to include class CommentSerializer(serializers.ModelSerializer): class Meta: model = Comment fields = [\u0026#39;name\u0026#39;, \u0026#39;email\u0026#39;, \u0026#39;content\u0026#39;,\u0026#39;user\u0026#39;] \u0026#39;\u0026#39;\u0026#39; { \u0026#39;name\u0026#39;: \u0026#39;John\u0026#39;, \u0026#39;email\u0026#39;: \u0026#39;john@gmail.com\u0026#39;, \u0026#39;content\u0026#39;: \u0026#39;Hello World!\u0026#39;, \u0026#39;user\u0026#39;: 1 } \u0026#39;\u0026#39;\u0026#39; Note: Any relationships such as foreign keys on the model will be mapped to PrimaryKeyRelatedField by default.\nSpecifying which fields to exclude class CommentSerializer(serializers.ModelSerializer): class Meta: model = Comment exclude = [\u0026#39;created\u0026#39;] Note: The fields attribute is used to specify which fields should be included in the serialized output. Also, In post request validation,The fields attribute is used to specify which fields should be required.\nNote: To make required=False in the serializer we can use blank=True in the model.\nFor example: I we want to show the created field in the response but we dont want to make it required in the post request then we can use blank=True in the model.\n16. Specifying the nested serializer The default ModelSerializer uses primary keys for relationships, but you can also easily generate nested representations using the depth option:\nExample class CommentSerializer(serializers.ModelSerializer): class Meta: model = Comment fields = [\u0026#39;name\u0026#39;, \u0026#39;email\u0026#39;, \u0026#39;content\u0026#39;, \u0026#39;user\u0026#39;] depth = 1 \u0026#39;\u0026#39;\u0026#39; Before: { \u0026#39;name\u0026#39;: \u0026#39;John\u0026#39;, \u0026#39;email\u0026#39;: \u0026#39;johj@gmail.com\u0026#34;, \u0026#39;user\u0026#39;: 1 \u0026#39;content\u0026#39;: \u0026#39;Hello World!\u0026#39;, } After: { \u0026#39;name\u0026#39;: \u0026#39;John\u0026#39;, \u0026#39;email\u0026#39;: \u0026#39;johj@gmail.com\u0026#34;, \u0026#39;user\u0026#39;: { \u0026#39;name\u0026#39;: \u0026#39;John\u0026#39;, \u0026#39;email\u0026#39;: \u0026#39;johj@gmail.com\u0026#34;, }, \u0026#39;content\u0026#39;: \u0026#39;Hello World!\u0026#39;, } Note: Depth are specially used in get request to show the nested serializer.For post request we have to use the nested serializer. Note: But by default model serializer can handel primary key related field but if we want to handle nested serializer then we can override the create method in the serializer.\n17. Overriding the create method By default model serializer can handel primary key related field but if we want to handle nested serializer then we can override the create method in the serializer.\nExample class UserSerializer(serializers.ModelSerializer): class Meta: model = User fields = [\u0026#39;name\u0026#39;, \u0026#39;email\u0026#39;] class CommentSerializer(serializers.ModelSerializer): user = UserSerializer() class Meta: model = Comment fields = [\u0026#39;name\u0026#39;, \u0026#39;email\u0026#39;, \u0026#39;content\u0026#39;, \u0026#39;user\u0026#39;] depth = 1 def create(self, validated_data): user_data = validated_data.pop(\u0026#39;user\u0026#39;) user = User.objects.create(**user_data) comment = Comment.objects.create(user=user, **validated_data) return comment def update(self, instance, validated_data): user.name = user_data.get(\u0026#39;name\u0026#39;, user.name) user.email = user_data.get(\u0026#39;email\u0026#39;, user.email) user.save() instance.content = validated_data.get(\u0026#39;content\u0026#39;, instance.content) instance.save() return instance 18. Defining Field Explicitly By default, all the fields of the model are included in the serializer but if we want to define the field explicitly then we can define it in the serializer.\nExample class CommentSerializer(serializers.ModelSerializer): name = serializers.CharField(max_length=100) email = serializers.EmailField() content = serializers.CharField() class Meta: model = Comment fields = [\u0026#39;name\u0026#39;, \u0026#39;email\u0026#39;, \u0026#39;content\u0026#39;] 19. Specifying read_only fields By default, all the fields of the model are included in the serializer but if we want to make some fields read-only then we can define it in the serializer.\nExample class CommentSerializer(serializers.ModelSerializer): class Meta: model = Comment fields = [\u0026#39;name\u0026#39;, \u0026#39;email\u0026#39;, \u0026#39;content\u0026#39;] read_only_fields = [\u0026#39;name\u0026#39;] Note: If we have editable=False,By default, the field is read-only. But if we want to make the field editable then we can use read_only_fields.\nNote: The field that are read-only are not required in the post request but it is displayed in the response.\n20.Additional Keyword arguments We can add additional arguments in the serializer as:\nclass Serializer(serializers.ModelSerializer): name = serializers.CharField(max_length=100) email = serializers.EmailField(required=False) class Meta: model = Comment fields = [\u0026#39;name\u0026#39;, \u0026#39;email\u0026#39;, \u0026#39;content\u0026#39;] But here we need to define the field name in the serializer that are already present in the model serializer but if we want to add additional arguments in the serializer without redefining then we can use extra_kwargs in the Meta class.\nExample class CommentSerializer(serializers.ModelSerializer): class Meta: model = Comment fields = [\u0026#39;name\u0026#39;, \u0026#39;email\u0026#39;, \u0026#39;content\u0026#39;] extra_kwargs = { \u0026#39;email\u0026#39;: {\u0026#39;required\u0026#39;: False} } 21. Serializer Fields Each serializer field class constructor takes at least these arguments. Some Field classes take additional, field-specific arguments, but the following should always be accepted:\nread_only: Boolean. Read-only fields are included in the API output, but should not be included in the input during create or update operations. Any \u0026lsquo;read_only\u0026rsquo; fields that are incorrectly included in the serializer input will be ignored. Set this to True to ensure that the field is used when we serialize a representation, but is not used when we create or update an instance during deserialization.\nDefaults to False\nwrite_only: Boolean. Write-only fields are not included in the API output, but are accepted on input. When deserializing data, write-only fields are ignored. Set this to True to ensure that the field may be used when updating or creating an instance, but is not included when serializing the representation.\nDefaults to False\nrequired:Boolean. Normally an error will be raised if a field is not supplied during deserialization. Set to false if this field is not required to be present during deserialization. Defaults to True. If you\u0026rsquo;re using Model Serializer default value will be False if you have specified blank=True or default or null=True at your field in your Model.\ndefault: The default value to use when a field is not provided in the input data. The default is not applied during partial update operations. In the partial update case only fields that are provided in the incoming data will have a validated value returned. When serializing the instance, default will be used if the object attribute or dictionary key is not present in the instance.\nNote that setting a default value implies that the field is not required. Including both the default and required keyword arguments is invalid and will raise an error.\nallow_null: Boolean. Normally an error will be raised if None is passed to a field. Set to True if None should be considered a valid value.\nvalidators: A list of validator functions which should be applied to the incoming field input when validating the field.\nNote: serialization is the process of converting complex data types to native Python datatypes that can then be easily rendered into JSON, XML, or other content types. Deserialization is the reverse process of converting native Python datatypes to complex data types.\n22. Adding custom fields in ModelSerializer If we want to add custom fields in the serializer then we can add it in the serializer.\nExample from rest_framework import serializers class CommentSerializer(serializers.ModelSerializer): custom_field = serializers.CharField(write_only=True) class Meta: model = Comment fields = [\u0026#39;name\u0026#39;, \u0026#39;email\u0026#39;, \u0026#39;content\u0026#39;] If we want to add the custom field in the request because its is not present in the model then we can use write_only in the custom field.But if we add this we should also add the create and update method explicitly in the serializer.\n22. Adding custom fields during Response If we want to add custom fields in the response then we can add it in the serializer.\nExample from rest_framework import serializers class CommentSerializer(serializers.ModelSerializer): custom_field = serializers.SerializerMethodField() class Meta: model = Comment fields = [\u0026#39;name\u0026#39;, \u0026#39;email\u0026#39;, \u0026#39;content\u0026#39;] def get_custom_field(self, obj): return \u0026#39;Hello World!\u0026#39; Note: SerializerMethodField is used to add custom fields in the response.\n23. Handling Complex and Internal Logic During the user registration process, we need to hash the password before saving it to the database. But model serializer only saves the data to the database but if we want to hash the password before saving it to the database then we should override the create method in the serializer.\nExample from rest_framework import serializers from .models import User class UserSerializer(serializers.ModelSerializer): class Meta: model = User fields = [\u0026#39;name\u0026#39;, \u0026#39;email\u0026#39;, \u0026#39;password\u0026#39;] extra_kwargs = {\u0026#39;password\u0026#39;: {\u0026#39;write_only\u0026#39;: True}} def create(self, validated_data): password=validated_data.pop(\u0026#39;password\u0026#39;) user = User.objects.create_user(**validated_data) user.set_password(password) user.save() return user ","permalink":"http://localhost:1313/posts/pages/drf/drf-1/","summary":"Learn how to use Django Rest Framework with this comprehensive guide, including installation steps, view creation, serializer usage, and handling complex logic.","title":"DRF - DAY 1"},{"content":"If you want to go back to learn DJANGO.Then add the following Topics\nTemplates Django Forms Context Processor select_related() prefetch_related() Annotations ","permalink":"http://localhost:1313/posts/pages/django/django-10/","summary":"Some Left over topics","title":"Django : Day 10"},{"content":"Sending Email Using Django Django provide an inbuild support to send email. To send email using DJango you need to configure the email settings in the settings.py file.\nEMAIL_HOST: The host to use for sending email. EMAIL_PORT: The port to use for the SMTP server. EMAIL_HOST_USER: The username to use for the SMTP server. EMAIL_HOST_PASSWORD: The password to use for the SMTP server. EMAIL_USE_SSL: Whether to use an SSL (secure) connection. EMAIL_USE_TLS: Whether to use a TLS (secure) connection Then we can send email using EmailMultiAlternatives class. This class is used to send email with both HTML and text content. Below is the example to send email using Django.\nfrom django.core.mail import EmailMultiAlternatives function send_email(request): email = EmailMultiAlternatives( \u0026#39;Subject here\u0026#39;, \u0026#39;Here is the message.\u0026#39;, \u0026#39;ID NAME \u0026lt;sender email\u0026gt;\u0026#39;, [receiver email] ) email.attach_alternative(\u0026#39;\u0026lt;h1\u0026gt;Here is the message.\u0026lt;/h1\u0026gt;\u0026#39;, \u0026#34;text/html\u0026#34;) email.send() return HttpResponse(\u0026#39;Email sent\u0026#39;) Note: Message will be send if the html content is not supported by the email client.\nrendertostring() method rendertostring() method is used to render a template to a string. This method is used to render a template to a string instead of rendering it to an HttpResponse object. Below is the example to render a template to a string.They are specially useful when you want to send the rendered template as an email.\nfrom django.template.loader import rendertostring def my_view(request): context = {\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;} output = rendertostring(\u0026#39;index.html\u0026#39;, context) return HttpResponse(output) Django Middleware Between each request and response in Django, there is a middleware layer. Middleware is a framework of hooks into Django\u0026rsquo;s request/response processing. It\u0026rsquo;s a light, low-level plugin system for globally altering Django\u0026rsquo;s input or output.There are two level of middleware in django\nGlobal Middleware: Global middleware is applied to all the views in the Django application. Local Middleware: Local middleware is applied to a specific view in the Django application. Defining Middleware To define a middleware in Django, you need to create a class with the following methods:\n__init__(self, get_response): This method is called when the middleware is initialized. It takes a get_response parameter, which is a callable that can be used to get the response from the next middleware in the chain. __call__(self, request): This method is called for each request. It takes a request parameter, which is the request object. It should return a response object or call the get_response callable to get the response from the next middleware in the chain. class MyMiddleware: def __init__(self, get_response): self.get_response = get_response def __call__(self, request): # Code to be executed for each request before # the view (and later middleware) are called. response = self.get_response(request) # Code to be executed for each request/response after # the view is called. return response Global Middleware To add this middleware to each request, you need to add the middleware class to the MIDDLEWARE setting in the settings.py file.\nMIDDLEWARE = [ ... \u0026#39;myapp.middleware.MyMiddleware\u0026#39;, ... ] Local Middleware To add this middleware to a specific view, you need to use the @middleware_classes decorator on the view function.\nfrom middleware import MyMiddleware @MyMiddleware def my_view(request): ... In class based view you can use the middleware_classes attribute to add the middleware to the view.\nfrom middleware import MyMiddleware from django.utils.decorators import method_decorator class MyView(View): @method_decorator(MyMiddleware) def get(self, request): ... Generating Tokens There are two types of tokens generator in Django\nPassword Reset Token: Django provides a built-in password reset token generator that can be used to generate tokens for resetting passwords. Default Token Generator: Django provides a default token generator that can be used to generate tokens for various purposes. Password Reset Token To generate a password reset token, you can use the PasswordResetTokenGenerator class from the django.contrib.auth.tokens module. You can create an instance of this class and call the make_token() method to generate a token for a user.\nfrom django.contrib.auth.tokens import PasswordResetTokenGenerator def generate_reset_token(request): user = request.user token_generator = PasswordResetTokenGenerator().make_token(user) return HttpResponse(token) from django.contrib.auth.tokens import PasswordResetTokenGenerator def check_reset_token(request, token): user = request.user token_generator = PasswordResetTokenGenerator().check_token(user, token) if token_generator: return HttpResponse(\u0026#39;Token is valid\u0026#39;) else: return HttpResponse(\u0026#39;Token is invalid\u0026#39;) Default Token Generator To generate a default token, you can use the default_token_generator from the django.utils.token module. You can call the make_token() method to generate a token for a user.\nfrom django.contrib.auth.tokens import default_token_generator def generate_token(request): user = request.user token = default_token_generator.make_token(user) return HttpResponse(token) from django.contrib.auth.tokens import default_token_generator def check_token(request, token): user = request.user token_generator = default_token_generator.check_token(user, token) if token_generator: return HttpResponse(\u0026#39;Token is valid\u0026#39;) else: return HttpResponse(\u0026#39;Token is invalid\u0026#39;) User object in django The User object in Django is a built-in model that represents a user account.The inbuilt User model in Django provides the following fields:\nusername password email first_name last_name is_active is_staff is_superuser date_joined staff Are the user who can access the admin interface.\nsuperuser Are the user who have all the permissions in the Django application.\nis_active Are the user who are active in the Django application.Only active user can login to the Django application.This three fields are boolean fields and have default value False.\nCreating a User TO create a user you can use create() method of the User model.\nfrom django.contrib.auth.models import User user = User.objects.create(username=\u0026#39;alice\u0026#39;,email=\u0026#39;alice@gmail.com\u0026#39;) user.set_password(\u0026#39;password\u0026#39;) user.save() Note: set_password() method is used to set the password of the user in the hashed format.\nNote: you can use get_user_model() method to get the user model in Django.\nfrom django.contrib.auth import get_user_model User = get_user_model() user = User.objects.create(username=\u0026#39;alice\u0026#39;,username=\u0026#39;alice\u0026#39;,email=\u0026#39;alice@gmail.com\u0026#39;) user.set_password(\u0026#39;password\u0026#39;) user.save() Authenticating a User TO learn authentication in django be familiar with the following methods\nrequest.user : The user object of the currently logged in user. request.user.is_authenticated : A boolean value that indicates whether the user is authenticated or not. request.user.is_staff : A boolean value that indicates whether the user is a staff member or not. request.user.is_superuser : A boolean value that indicates whether the user is a superuser or not. Authenticate To authenticate a user, you can use the authenticate() method from the django.contrib.auth module. This method takes the request, username and password as arguments and returns the user object if the credentials are valid.\nfrom django.contrib.auth import authenticate user = authenticate(request, username=\u0026#39;alice\u0026#39;, password=\u0026#39;password\u0026#39;) Login To login a user, you can use the login() method from the django.contrib.auth module. This method takes the request and the user object as arguments and logs in the user.\nfrom django.contrib.auth import login login(request, user) Logout To logout a user, you can use the logout() method from the django.contrib.auth module. This method takes the request as an argument and logs out the user.\nfrom django.contrib.auth import logout logout(request) Combination of authenticate(),login() and logout() from django.contrib.auth import authenticate, login, logout def login_view(request): if request.method == \u0026#39;POST\u0026#39;: username = request.POST[\u0026#39;username\u0026#39;] password = request.POST[\u0026#39;password\u0026#39;] user = authenticate(request, username=username, password=password) if user is not None: login(request, user) return HttpResponse(\u0026#39;User logged in successfully\u0026#39;) else: return HttpResponse(\u0026#39;Invalid username or password\u0026#39;) return render(request, \u0026#39;login.html\u0026#39;) Protected Views To protect a view so that only authenticated users can access it, you can use the login_required decorator from the django.contrib.auth.decorators module.\nfrom django.contrib.auth.decorators import login_required @login_required(login_url=\u0026#39;login\u0026#39;) def protected_view(request): return HttpResponse(\u0026#39;This is a protected view\u0026#39;) Note: The login_url argument is used to redirect the user to the login page if they are not authenticated and login is name of the login url.\nCustom User Model Everytime you create a new Django project, Django creates a default User model for you. But sometimes you may want to customize the User model to add additional fields or change the existing fields.So there are two ways to create a custom user model in Django.\nUsing Abstract User(Contains all the fields of the default User model and you can add additional fields to it) Using Abstract Base User( Contain the authentication fields only and you can add additional fields to it) Using Abstract User You choose this option if you want to add additional fields to the default .You choose this if you want a small change in the default User model.\nProcess to create a custom user model using Abstract User Step 1: Create a new model that inherits from AbstractUser models.py\nfrom django.contrib.auth.models import AbstractUser class CustomUser(AbstractUser): age = models.PositiveIntegerField(null=True, blank=True) address = models.CharField(max_length=100, null=True, blank=True) phone = models.CharField(max_length=15, null=True, blank=True) Note : There is existing field and age,address,phone are the additional fields that we have added to the User model.\nStep 2: Update the AUTH_USER_MODEL setting in settings.py settings.py\nAUTH_USER_MODEL = \u0026#39;myapp.CustomUser\u0026#39; Note: AUTH_USER_MODEL is used to specify which model to use for the user authentication.get_user_model() method is used to get the user model in Django which is specified in the AUTH_USER_MODEL setting.\nStep 3: Create a new migration and apply it python manage.py makemigrations python manage.py migrate Step 4: Create a new user from myapp.models import CustomUser user = CustomUser.objects.create(username=\u0026#39;alice\u0026#39;,email=\u0026#39;alice@gmail.com\u0026#39;,age=20,address=\u0026#39;New York\u0026#39;,phone=\u0026#39;1234567890\u0026#39;) user.set_password(\u0026#39;password\u0026#39;) user.save() or,\nfrom django.contrib.auth import get_user_model CustomUser = get_user_model() user = CustomUser.objects.create(username=\u0026#39;alice\u0026#39;,email=\u0026#39;alice@gmail.com\u0026#39;,age=20,address=\u0026#39;New York\u0026#39;,phone=\u0026#39;1234567890\u0026#39;) user.set_password(\u0026#39;password\u0026#39;) user.save() Registering with admin interface To make the custom user model available in the admin interface, you need to register it with the admin interface.\nfrom django.contrib import admin from myapp.models import CustomUser admin.site.register(CustomUser) Using Abstract Base User In Abstract Base user it contains only the authentication functionality but no actual fields exceptpassword and lastlogin.\nProcess to create a custom user model using Abstract Base User Step 1: Create a new model that inherits from AbstractBaseUser models.py\nfrom django.contrib.auth.models import AbstractBaseUser, BaseUserManager,PermissionsMixin class CustomUser(AbstractBaseUser,PermissionsMixin): email = models.EmailField(unique=True) age = models.PositiveIntegerField(null=True, blank=True) address = models.CharField(max_length=100, null=True, blank=True) phone = models.CharField(max_length=15, null=True, blank=True) is_staff = models.BooleanField(default=False) is_active = models.BooleanField(default=True) objects = CustomUserManager() USERNAME_FIELD = \u0026#39;email\u0026#39; REQUIRED_FIELDS = [\u0026#39;phone\u0026#39;] def __str__(self): return self.email Note: USERNAME_FIELD is used to specify the field that is used for authentication and REQUIRED_FIELDS is used to specify the fields that are required when creating a user using the createsuperuser command.\nNote: AbstractBaseUser only contains password and lastlogin fields and you need to define the fields that you want to add to the user model.\nNote: PermissionMinxing contains the permission fields is_superuser,groups and user_permissions fields.\nStep 2: Create a new manager class that inherits from BaseUserManager BaseUserManager is used to create a user and superuser.Django internally uses this manager to create a user and superuser.\nmodels.py\nfrom django.contrib.auth.models import BaseUserManager class CustomUserManager(BaseUserManager): def create_user(self,email,password=None,**extra_fields): if not email: raise ValueError(\u0026#39;The Email field must be set\u0026#39;) if not password: raise ValueError(\u0026#39;The Password field must be set\u0026#39;) email = self.normalize_email(email) user = self.model(email=email,**extra_fields) user.set_password(password) user.save(using=self._db) return user def create_superuser(self,email,password=None,**extra_fields): extra_fields.setdefault(\u0026#39;is_staff\u0026#39;,True) extra_fields.setdefault(\u0026#39;is_superuser\u0026#39;,True) return self.create_user(email,password,**extra_fields) Step 3: Update the AUTH_USER_MODEL setting in settings.py settings.py\nAUTH_USER_MODEL = \u0026#39;myapp.CustomUser\u0026#39; Step 4: Create a new migration and apply it python manage.py makemigrations python manage.py migrate Step 5: Setting The Admin Interface using UserAdmin To make the custom user model available in the admin interface, you need to create a new class that inherits from UserAdmin and register it with the admin interface.\nfrom django.contrib import admin from django.contrib.auth.admin import UserAdmin from myapp.models import CustomUser class CustomUserAdmin(UserAdmin): model = CustomUser fieldsets = ( (\u0026#34;Basic Information\u0026#34;, {\u0026#39;fields\u0026#39;: (\u0026#39;email\u0026#39;, \u0026#39;password\u0026#39;)}), (\u0026#34;Personal Information\u0026#34;, {\u0026#39;fields\u0026#39;: (\u0026#39;age\u0026#39;, \u0026#39;address\u0026#39;, \u0026#39;phone\u0026#39;)}), (\u0026#34;Permissions\u0026#34;, {\u0026#39;fields\u0026#39;: (\u0026#39;is_active\u0026#39;, \u0026#39;is_staff\u0026#39;, \u0026#39;is_superuser\u0026#39;)}), ) add_fieldsets = ( (\u0026#34;Basic Information\u0026#34;, {\u0026#39;fields\u0026#39;: (\u0026#39;email\u0026#39;, \u0026#39;password1\u0026#39;, \u0026#39;password2\u0026#39;)}), (\u0026#34;Personal Information\u0026#34;, {\u0026#39;fields\u0026#39;: (\u0026#39;age\u0026#39;, \u0026#39;address\u0026#39;, \u0026#39;phone\u0026#39;)}), (\u0026#34;Permissions\u0026#34;, {\u0026#39;fields\u0026#39;: (\u0026#39;is_active\u0026#39;, \u0026#39;is_staff\u0026#39;, \u0026#39;is_superuser\u0026#39;)}), ) ordering = (\u0026#39;email\u0026#39;,) list_display = (\u0026#39;email\u0026#39;, \u0026#39;age\u0026#39;, \u0026#39;address\u0026#39;, \u0026#39;phone\u0026#39;, \u0026#39;is_active\u0026#39;, \u0026#39;is_staff\u0026#39;, \u0026#39;is_superuser\u0026#39;) admin.site.register(CustomUser, CustomUserAdmin) Custom Authentication In Django All the authentication in Django is done using the authenticate() method from the django.contrib.auth module. This method takes the request, username and password as arguments and returns the user object if the credentials are valid.But sometimes you may want to customize the authentication process in Django. You can do this by creating a custom authentication backend.\nProcess to create a custom authentication backend Step 1: Create a new class that inherits from BaseBackend You need to create a new class that inherits from BaseBackend and implement the authenticate() method. This method should take the request, username and password as arguments and return the user object if the credentials are valid.\nfrom django.contrib.auth.backends import BaseBackend from django.contrib.auth import get_user_model class CustomBackend(BaseBackend): def authenticate(self, request, username=None, password=None): User = get_user_model() try: user = User.objects.get(email=username) if user.check_password(password): return user except User.DoesNotExist: return None def get_user(self, user_id): User = get_user_model() try: return User.objects.get(pk=user_id) except User.DoesNotExist: return None Step 2: Update the AUTHENTICATION_BACKENDS setting in settings.py You need to update the AUTHENTICATION_BACKENDS setting in the settings.py file to include the path to the custom authentication backend.\nAUTHENTICATION_BACKENDS = [ \u0026#39;myapp.backends.CustomBackend\u0026#39;, \u0026#39;django.contrib.auth.backends.ModelBackend\u0026#39;, ] Step 3: Authenticate the user using the custom authentication backend You can now authenticate the user using the custom authentication backend by calling the authenticate() method from the django.contrib.auth module.\nfrom django.contrib.auth import authenticate user = authenticate(request,usernmae=\u0026#39;alice\u0026#39;,password=\u0026#39;password\u0026#39;) Groups in Django Groups in Django are a way to categorize users into different groups based on their roles or permissions. Each group can have multiple permissions, and each user can belong to multiple groups. Groups are useful for managing permissions and access control in Django applications.\nCreating a Group To create a group, you can use the Group model from the django.contrib.auth.models module. You can create an instance of this model and call the save() method to save the group to the database.\nfrom django.contrib.auth.models import Group group = Group(name=\u0026#39;Admins\u0026#39;) group.save() Get Group By Name To get a group by name, you can use the get() method of the Group model. This method takes the name of the group as an argument and returns the group object if it exists.\nfrom django.contrib.auth.models import Group group = Group.objects.get(name=\u0026#39;Admins\u0026#39;) Adding User TO Group To add a user to a group, you can use the user.groups.add() method. This method takes the group object as an argument and adds the user to the group.\nfrom django.contrib.auth.models import User, Group user = User.objects.get(username=\u0026#39;alice\u0026#39;) group1 = Group.objects.get(name=\u0026#39;Admins\u0026#39;) group2 = Group.objects.get(name=\u0026#39;Editors\u0026#39;) user.groups.add(group1, group2) Removing User From Group To remove a user from a group, you can use the user.groups.remove() method. This method takes the group object as an argument and removes the user from the group.\nfrom django.contrib.auth.models import User, Group user = User.objects.get(username=\u0026#39;alice\u0026#39;) group1 = Group.objects.get(name=\u0026#39;Admins\u0026#39;) group2 = Group.objects.get(name=\u0026#39;Editors\u0026#39;) user.groups.remove(group1, group2) Clear All The Groups To remove all the groups from a user, you can use the user.groups.clear() method. This method removes all the groups from the user.\nfrom django.contrib.auth.models import User user = User.objects.get(username=\u0026#39;alice\u0026#39;) user.groups.clear() Get All The Groups Of A User To get all the groups of a user, you can use the user.groups.all() method. This method returns all the groups that the user belongs to.\nfrom django.contrib.auth.models import User user = User.objects.get(username=\u0026#39;alice\u0026#39;) groups = user.groups.all() Permissions in Django Permission is given to user so that they can perform certain actions in the Django application from the admin interface.\nDefault Permissions Django provides the following default permissions:\nadd_modelname: Allows the user to add new objects of the model. change_modelname: Allows the user to change existing objects of the model. delete_modelname: Allows the user to delete objects of the model. view_modelname: Allows the user to view objects of the model. Custom Permissions Every time the default permissions are not sufficient for the application, you can create custom permissions using the Permission model from the django.contrib.auth.models or by using the Meta class in the model.\nUsing Meta Class class MyModelName(models.Model): # code class Meta: permissions = [ (\u0026#39;have_special\u0026#39;, \u0026#39;Have Special Feature\u0026#39;), ] Using Code Creating a Permission from django.contrib.auth.models import Permission from django.contrib.contenttypes.models import ContentType content_type = ContentType.objects.get_for_model(MyModelName) permission = Permission.objects.create( codename=\u0026#39;have_special\u0026#39;, name=\u0026#39;Have Special Feature\u0026#39;, content_type=content_type, ) Some Useful Methods of Permission Get Permission object using codename from django.contrib.auth.models import Permission permission = Permission.objects.get(codename=\u0026#39;have_special\u0026#39;) Delete Permission from django.contrib.auth.models import Permission permission = Permission.objects.get(codename=\u0026#39;have_special\u0026#39;) permission.delete() Assigning Permission to User from django.contrib.auth.models import User, Permission from myapp.models import User user = User.objects.get(username=\u0026#39;alice\u0026#39;) permission1 = Permission.objects.get(codename=\u0026#39;have_special\u0026#39;) permission2 = Permission.objects.get(codename=\u0026#39;add_mymodelname\u0026#39;) user.user_permissions.add(permission1, permission2) Removing Permission from User from django.contrib.auth.models import User, Permission user = User.objects.get(username=\u0026#39;alice\u0026#39;) permission1 = Permission.objects.get(codename=\u0026#39;have_special\u0026#39;) permission2 = Permission.objects.get(codename=\u0026#39;add_mymodelname\u0026#39;) user.user_permissions.remove(permission1, permission2) Clear All The Permissions from django.contrib.auth.models import User user = User.objects.get(username=\u0026#39;alice\u0026#39;) user.user_permissions.clear() See All The Permissions Of A User from django.contrib.auth.models import User user = User.objects.get(username=\u0026#39;alice\u0026#39;) permissions = user.user_permissions.all() Assigning Permission to Group from django.contrib.auth.models import Group, Permission group = Group.objects.get(name=\u0026#39;Admins\u0026#39;) permission1 = Permission.objects.get(codename=\u0026#39;have_special\u0026#39;) permission2 = Permission.objects.get(codename=\u0026#39;add_mymodelname\u0026#39;) group.permissions.add(permission1, permission2) Removing Permission from Group from django.contrib.auth.models import Group, Permission group = Group.objects.get(name=\u0026#39;Admins\u0026#39;) permission1 = Permission.objects.get(codename=\u0026#39;have_special\u0026#39;) permission2 = Permission.objects.get(codename=\u0026#39;add_mymodelname\u0026#39;) group.permissions.remove(permission1, permission2) See All The Permissions Of A Group from django.contrib.auth.models import Group group = Group.objects.get(name=\u0026#39;Admins\u0026#39;) permissions = group.permissions.all() Check whether the user has permission user.has_perm(\u0026#39;myapp.have_special\u0026#39;) Restricting Access to Views To restrict access to a view based on permissions, you can use the permission_required decorator from the django.contrib.auth.decorators module.\nfrom django.contrib.auth.decorators import permission_required @permission_required(\u0026#39;myapp.have_special\u0026#39;) def special_view(request): return HttpResponse(\u0026#39;This is a special view\u0026#39;) Model Manager and Custom Model Manager By default, Django adds a Manager with the name objects to every Django model class. However, if you want to use objects as a field name, or if you want to use a name other than objects for the Manager, you can rename it on a per-model basis. To rename the Manager for a given class, define a class attribute of type models.Manager() on that model.\nfrom django.db import models class Person(models.Model): first_name = models.CharField(max_length=30) last_name = models.CharField(max_length=30) people = models.Manager() Using this example model, Person.objects will generate an AttributeError exception, but Person.people.all() will provide a list of all Person objects.\nCustom Model Manager You can use custom managers to add extra manager methods to your models. This is useful for adding custom query methods. For example, to add a method that only give user who are not deleted, you can create a custom manager like this:\nfrom django.db import models class PersonManager(models.Manager): def get_queryset(self): return super().get_queryset().filter(deleted=False) class Person(models.Model): first_name = models.CharField(max_length=30) last_name = models.CharField(max_length=30) deleted = models.BooleanField(default=False) objects = models.Manager() people = PersonManager() Here Person.objects.all() will return all the objects that is deleted as well as not deleted but Person.people.all() will return only the objects which are not deleted.\nSignals in Django Signals are used to allow decoupled applications to get notified when certain actions occur elsewhere in the application. In Django, signals are used to allow certain senders to notify a set of receivers when some action has taken place.\nDefining a Signal from django.db.models.signals import pre_save from django.dispatch import receiver @receiver(pre_save, sender=MyModel) def my_handler(sender, **kwargs): # code Available Signals pre_save: This signal is sent just before a model\u0026rsquo;s save() method is called. post_save: This signal is sent just after a model\u0026rsquo;s save() method is called. pre_delete: This signal is sent just before a model\u0026rsquo;s delete() method is called. post_save : This signal is sent just after a model\u0026rsquo;s delete() method is called. pre_init: This signal is sent when a model\u0026rsquo;s init() method is called. post_init: This signal is sent when a model\u0026rsquo;s init() method is called. This will be enough to learn DRF. I hope you enjoyed this series. If you have any questions or suggestions, feel free to ask. Thank you for reading. Happy coding!🚀🚀🚀 ","permalink":"http://localhost:1313/posts/pages/django/django-9/","summary":"A comprehensive guide on sending emails, using middleware, generating tokens, and managing users in Django.","title":"Django : Day 9"},{"content":"Session in Django: Practical Examples Django provides an easy-to-use session framework that allows you to manage user sessions and store data across requests. Below are common tasks related to working with session data in Django.A session ID is a unique identifier that represents a user\u0026rsquo;s session. It\u0026rsquo;s a random string generated by Django and stored in a cookie on the user\u0026rsquo;s browser. When a user makes a request to a Django application, the session ID is sent along with the request. Django uses this ID to retrieve the corresponding session data from the server.\n1. Adding Session Data To add data to a session, you can use the request.session dictionary-like object. This allows you to store values that will persist across user requests.\nExample:\n# Storing session data def set_session_data(request): request.session[\u0026#39;username\u0026#39;] = \u0026#39;antone\u0026#39; request.session[\u0026#39;email\u0026#39;] = \u0026#39;antone@example.com\u0026#39; return HttpResponse(\u0026#39;Session data has been set!\u0026#39;) In this example, the username and email are stored in the session. This data will be available in subsequent requests, as long as the session remains active.\n2. Retrieving Session Data You can retrieve session data using the request.session.get() method. This method ensures that if the session data doesn\u0026rsquo;t exist, it won’t raise an error and can return a default value.\nExample:\n# Retrieving session data def get_session_data(request): username = request.session.get(\u0026#39;username\u0026#39;, \u0026#39;Guest\u0026#39;) # Default value is \u0026#39;Guest\u0026#39; email = request.session.get(\u0026#39;email\u0026#39;, \u0026#39;Not Available\u0026#39;) return HttpResponse(f\u0026#39;Username: {username}, Email: {email}\u0026#39;) Here, if the session data for 'username' or 'email' doesn’t exist, default values are provided.\n3. Checking if Session Data Exists Before retrieving session data, you might want to check if it exists to prevent returning default values unnecessarily.\nExample:\n# Checking if session data exists def check_session_data(request): if \u0026#39;username\u0026#39; in request.session: username = request.session[\u0026#39;username\u0026#39;] return HttpResponse(f\u0026#39;Welcome back, {username}!\u0026#39;) else: return HttpResponse(\u0026#39;Session data not found. Please log in.\u0026#39;) This example checks if the username exists in the session and retrieves it if available.\n4. Modifying Session Data You can modify existing session data by simply assigning new values to the session key.\nExample:\n# Modifying session data def update_session_data(request): if \u0026#39;username\u0026#39; in request.session: request.session[\u0026#39;username\u0026#39;] = \u0026#39;updated_antone\u0026#39; return HttpResponse(\u0026#39;Session data has been updated!\u0026#39;) else: return HttpResponse(\u0026#39;No username found in the session.\u0026#39;) In this case, if the session contains a username, it will be updated to a new value.\n5. Deleting Session Data You can delete specific session data by using the del statement or the pop() method. Deleting session data ensures that it will no longer persist across requests.\nExample:\n# Deleting specific session data def delete_session_data(request): try: del request.session[\u0026#39;username\u0026#39;] # Deleting a specific key return HttpResponse(\u0026#39;Session data for username has been deleted.\u0026#39;) except KeyError: return HttpResponse(\u0026#39;No username found in session.\u0026#39;) # Or using pop() def pop_session_data(request): username = request.session.pop(\u0026#39;username\u0026#39;, None) # Removes \u0026#39;username\u0026#39; from session if exists if username: return HttpResponse(f\u0026#39;{username} has been removed from the session.\u0026#39;) else: return HttpResponse(\u0026#39;No username to remove from session.\u0026#39;) 6. Creating a New Session When a user logs in or logs out, Django generates a new session ID to ensure security and prevent unauthorized access to session data. However, the session data itself remains unchanged. Even if the session ID changes, the user’s information and preferences are preserved.\nDjango handles this persistence internally, ensuring that session data remains consistent across session ID changes.\nExample:\n# Creating a new session and persisting data across session ID changes def session_example(request): request.session.create() # Start a new session request.session[\u0026#39;username\u0026#39;] = \u0026#39;antone\u0026#39; print(request.session.get(\u0026#39;username\u0026#39;)) # Should print \u0026#39;antone\u0026#39; print(request.session.session_key) # Prints current session ID request.session.create() # Create a new session (invalidates previous session) print(request.session.session_key) # New session ID print(request.session.get(\u0026#39;username\u0026#39;)) # Still prints \u0026#39;antone\u0026#39; In this example:\nA new session is created and a username is stored. The session ID and the stored username are printed. A new session is created again, which invalidates the previous session. The username persists across session ID changes, illustrating Django’s session data persistence. 7. Clearing All Session Data If you want to clear all session data, you can use the clear() method on the session object. This will remove all keys and values stored in the session.\nExample:\n# Clearing all session data def clear_session_data(request): request.session.clear() # Clears all session data return HttpResponse(\u0026#39;All session data has been cleared.\u0026#39;) 8.Get the session ID You can get the session ID using the session_key attribute of the session object.\nExample:\n# Get the session ID def get_session_id(request): session_id = request.session.session_key return HttpResponse(f\u0026#39;Session ID: {session_id}\u0026#39;) 9.Create a new session You can create a new session using the create() method of the session object.\nExample:\n# Create a new session def create_new_session(request): request.session.create() # Create a new session return HttpResponse(\u0026#39;New session created!\u0026#39;) Summary of Key Session Operations Adding Session Data:\nUse request.session['key'] = value.\nRetrieving Session Data:\nUse request.session.get('key').\nModifying Session Data:\nSimply reassign the value with request.session['key'] = new_value.\nDeleting Specific Session Data:\nUse del request.session['key'] or request.session.pop('key').\nClearing All Session Data:\nUse request.session.clear().\nCreating a New Session:\nUse request.session.create() to generate a new session and retain data across session ID changes.\n","permalink":"http://localhost:1313/posts/pages/django/django-8/","summary":"A comprehensive guide on managing user sessions in Django, covering key operations like adding, retrieving, modifying, and deleting session data.","title":"Django : Day 8"},{"content":"Request object for Form Data request.method: Returns the request method (GET, POST, etc.). def my_view(request): if request.method == \u0026#39;GET\u0026#39;: return HttpResponse(\u0026#39;This is a GET request\u0026#39;) elif request.method == \u0026#39;POST\u0026#39;: return HttpResponse(\u0026#39;This is a POST request\u0026#39;) request.GET: A dictionary-like object containing all the GET parameters. def my_view(request): name = request.GET.get(\u0026#39;name\u0026#39;, \u0026#39;\u0026#39;) return HttpResponse(f\u0026#39;Hello, {name}\u0026#39;) request.POST: A dictionary-like object containing all the POST parameters. def my_view(request): name = request.POST.get(\u0026#39;name\u0026#39;, \u0026#39;\u0026#39;) return HttpResponse(f\u0026#39;Hello, {name}\u0026#39;) request.PUT: A dictionary-like object containing all the PUT parameters. def my_view(request): name = request.PUT.get(\u0026#39;name\u0026#39;, \u0026#39;\u0026#39;) return HttpResponse(f\u0026#39;Hello, {name}\u0026#39;) request.META: A dictionary containing all the HTTP headers. def my_view(request): user_agent = request.META.get(\u0026#39;HTTP_USER_AGENT\u0026#39;, \u0026#39;\u0026#39;) http_referer = request.META.get(\u0026#39;HTTP_REFERER\u0026#39;, \u0026#39;\u0026#39;) http_host = request.META.get(\u0026#39;HTTP_HOST\u0026#39;, \u0026#39;\u0026#39;) return HttpResponse(f\u0026#39;User Agent: {user_agent}\u0026#39;) request.FILES: A dictionary-like object containing all the uploaded files. Handeling File Uploads By User The file uploaded by user are called Media files in Django. Django provides a FileField and ImageField to handle file uploads. The FileField and ImageField are used to upload files and images respectively.\nSetting Up Media Files To handle media files in Django, you need to set up the MEDIA_URL and MEDIA_ROOT in the settings.py file.\nMEDIA_URL: The URL that handles the media files. MEDIA_URL = \u0026#39;/media/\u0026#39; MEDIA_ROOT: The directory where the media files are stored. MEDIA_ROOT = os.path.join(BASE_DIR, \u0026#39;media\u0026#39;) Note: All the media file is stored in the MEDIA_ROOT directory and they are served using the MEDIA_URL.\nServing Media Files By default media file is not served like static files.To serve media files during development, you need to add the following code to the urls.py file.\nfrom django.conf import settings from django.conf.urls.static import static urlpatterns = [ # Your URL patterns ] if settings.DEBUG: urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT) let us consider a file structure like this:\nproject │ ├── media | |── file.jpg | |── file2.jpg | ├── myapp | |── models.py | |── views.py | Then wehn user visit to http://localhost:8000/media/ then the folder media will be resolved. similarly if user visit to http://localhost:8000/media/file.jpg then the file file.jpg will be resolved.\nFileField or ImageField FileField: It is used to upload files. from django.db import models class Document(models.Model): name = models.CharField(max_length=100) file = models.FileField(upload_to=\u0026#39;documents/\u0026#39;) ImageField: It is used to upload images. from django.db import models class Image(models.Model): name = models.CharField(max_length=100) image = models.ImageField(upload_to=\u0026#39;images/\u0026#39;) when we save the file using FileField then the file will be saved in the MEDIA_ROOT folder and its url will contain the MEDIA_URL in the database followed by the file name.\nExample of File Upload models.py\nfrom django.db import models class Document(models.Model): name = models.CharField(max_length=100) file = models.FileField(upload_to=\u0026#39;documents/\u0026#39;) settings.py\nMEDIA_URL = \u0026#39;/media/\u0026#39; MEDIA_ROOT = os.path.join(BASE_DIR, \u0026#39;media\u0026#39;) urls.py\nfrom django.conf import settings from django.conf.urls.static import static urlpatterns = [ # Your URL patterns ] if settings.DEBUG: urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT) views.py\nfrom django.shortcuts import render from .models import Document def upload_file(request): if request.method == \u0026#39;POST\u0026#39;: name = request.POST.get(\u0026#39;name\u0026#39;, \u0026#39;\u0026#39;) file = request.FILES.get(\u0026#39;file\u0026#39;, None) if file: document = Document(name=name, file=file) document.save() return HttpResponse(\u0026#39;File uploaded successfully\u0026#39;) return render(request, \u0026#39;upload_file.html\u0026#39;) To find the url of the file document = Document.objects.get(id=1) url = document.file.url # /media/documents/file.jpg ","permalink":"http://localhost:1313/posts/pages/django/django-7/","summary":"A comprehensive guide on handling form data and file uploads in Django, covering request methods, media file setup, and file field usage.","title":"Django : Day 7"},{"content":"Django Setting in Brief Setting files are the files that contain the configuration of django project.Whats in the setting file?\nBASE_DIR : The directory where the project is located. SECRET_KEY : A secret key used for cryptographic signing such as sessions,cookie,password reset tokens,cross-site request forgery protection,etc. DEBUG : A boolean that turns on/off the debug mode. ALLOWED_HOSTS : A list of strings representing the host/domain names that the django site can serve. INSTALLED_APPS : A list of application names that are enabled in the project. MIDDLEWARE : A list of middleware that is applied to the request/response cycle for each request. ROOT_URLCONF :The base URL from which all URL patterns are derived. TEMPLATES : A list of dictionaries containing the configuration of the template engine. BACKEND : The engine to use for rendering templates. DIRS : A list of directories where the template engine should look for template source files.Used To make global templates folder context_processors : A list of context processors that are applied to each request. Note: Template are not used in DRF -WSGI_APPLICATION : The full Python path of the WSGI application object that Django’s built-in servers (e.g. runserver) will use.\nDATABASES : A dictionary containing the database configuration. AUTH_PASSWORD_VALIDATORS : A list of validators that are used to check the strength of the password. TIME_ZONE : The time zone of the project. LANGUAGE_CODE : The language code for the project.\u0026rsquo;en-us\u0026rsquo; is the default language code. DEFAULT_AUTO_FIELD : The default primary key field for the project. ","permalink":"http://localhost:1313/posts/pages/django/django-6/","summary":"Learn essential Django project settings including BASE_DIR, SECRET_KEY, DEBUG, ALLOWED_HOSTS, database configuration, middleware setup, and other critical configuration options.","title":"Django: Day 6"},{"content":"Django Relations In Django, there are three main types of relationships between models: OneToOne, OneToMany, and ManyToMany.\nSome Important Terms related_name: This attribute is used to define the reverse relation from the related model back to the model that defines the relationship. on_delete: It specifies the behavior to adopt when the object referenced by a foreign key is deleted. on_delete Options models.CASCADE: When the referenced object is deleted, also delete the objects that have a foreign key to it. models.PROTECT: Prevent deletion of the referenced object by raising a ProtectedError exception. models.SET_NULL: Set the foreign key to NULL when the referenced object is deleted. models.SET_DEFAULT: Set the foreign key to its default value when the referenced object is deleted. models.SET(): Set the foreign key to the value passed to SET() when the referenced object is deleted. models.DO_NOTHING: Do nothing when the referenced object is deleted. Note: In most cases, models.CASCADE is used.\nOneToOne Relation In a OneToOne relationship, each record of one model is related to exactly one record of another model. For example, a student can have only one student profile, meaning one object cannot be related to multiple objects. If this is attempted, an error will occur.\nDefining OneToOne Relation You can define a OneToOne relation using OneToOneField.\nfrom django.db import models class Student(models.Model): name = models.CharField(max_length=100) age = models.IntegerField() class StudentProfile(models.Model): student = models.OneToOneField(Student, on_delete=models.CASCADE, related_name=\u0026#39;profile\u0026#39;) address = models.TextField() phone = models.CharField(max_length=15) Note: The related_name should be unique in the model. It is used to access the StudentProfile object from the Student object.\nCreating OneToOne Relation student = Student.objects.create(name=\u0026#39;John\u0026#39;, age=20) profile = StudentProfile.objects.create(student=student, address=\u0026#39;New York\u0026#39;, phone=\u0026#39;1234567890\u0026#39;) You can assign an existing student object to the profile object like this:\nstudent = Student.objects.get(name=\u0026#39;John\u0026#39;) profile = StudentProfile.objects.create(student=student, address=\u0026#39;New York\u0026#39;, phone=\u0026#39;1234567890\u0026#39;) Updating OneToOne Relation student = Student.objects.get(name=\u0026#39;John\u0026#39;) profile = student.profile profile.address = \u0026#39;California\u0026#39; profile.save() Finding the Student Profile by Student Name Way 1 (using the __ double underscore): studentprofile = StudentProfile.objects.get(student__name=\u0026#39;John\u0026#39;) Way 2 student = Student.objects.get(name=\u0026#39;John\u0026#39;) studentprofile = StudentProfile.objects.get(student=student) Way 3 (using related_name): student = Student.objects.get(name=\u0026#39;John\u0026#39;) studentprofile = student.profile Accessing the Student Object from the Profile studentprofile = StudentProfile.objects.get(address=\u0026#39;California\u0026#39;) student = studentprofile.student Related Name in Action You can use related_name to access the related object from the parent object.\nclass Author(models.Model): name = models.CharField(max_length=100) age = models.IntegerField() class Book(models.Model): author = models.OneToOneField(Author, on_delete=models.CASCADE, related_name=\u0026#39;book\u0026#39;) title = models.CharField(max_length=100) To access the Book object from the Author object:\nauthor = Author.objects.get(name=\u0026#39;John\u0026#39;) book = author.book OneToMany Relation In a OneToMany relationship, each record of one model is related to multiple records of another model. For example, a student can have multiple subjects.\nDefining OneToMany Relation You can define a OneToMany relation using the ForeignKey field.\nfrom django.db import models class Subject(models.Model): name = models.CharField(max_length=100) class Student(models.Model): name = models.CharField(max_length=100) age = models.IntegerField() subjects = models.ForeignKey(Subject, on_delete=models.CASCADE, related_name=\u0026#39;students\u0026#39;) Creating OneToMany Relation subject1 = Subject.objects.create(name=\u0026#39;Maths\u0026#39;) subject2 = Subject.objects.create(name=\u0026#39;Science\u0026#39;) student1 = Student.objects.create(name=\u0026#39;John\u0026#39;, age=20) student2 = Student.objects.create(name=\u0026#39;Doe\u0026#39;, age=22) student3 = Student.objects.create(name=\u0026#39;Smith\u0026#39;, age=21) student1.subjects.add(subject1, subject2) student2.subjects.add(subject1) Updating OneToMany Relation student = Student.objects.get(name=\u0026#39;John\u0026#39;) subject = student.subjects subject.name = \u0026#39;Science\u0026#39; subject.save() Finding the Student by Subject Name Way 1: student = Student.objects.get(subjects__name=\u0026#39;Maths\u0026#39;) Way 2: subject = Subject.objects.get(name=\u0026#39;Maths\u0026#39;) students = Student.objects.filter(subjects=subject) Way 3 (using related_name): subject = Subject.objects.get(name=\u0026#39;Maths\u0026#39;) students = subject.students.all() # You can use filter() instead of all() Accessing the Subject Object from the Student Object student = Student.objects.get(name=\u0026#39;John\u0026#39;) subject = student.subjects Related Name in Action class Author(models.Model): name = models.CharField(max_length=100) age = models.IntegerField() class Book(models.Model): author = models.ForeignKey(Author, on_delete=models.CASCADE, related_name=\u0026#39;books\u0026#39;) title = models.CharField(max_length=100) You can access the books associated with an author:\nauthor = Author.objects.get(name=\u0026#39;John\u0026#39;) books = author.books.all() ManyToMany Relation In a ManyToMany relationship, each record of one model is related to multiple records of another model and vice versa. For example, a student can have multiple subjects, and a subject can have multiple students.\nNote: The ManyToMany relation does not have an on_delete option.\nDefining ManyToMany Relation You can define a ManyToMany relation using the ManyToManyField field.\nfrom django.db import models class Subject(models.Model): name = models.CharField(max_length=100) class Student(models.Model): name = models.CharField(max_length=100) age = models.IntegerField() subjects = models.ManyToManyField(Subject, related_name=\u0026#39;students\u0026#39;) add() and remove() Methods add(): Adds related objects to the parent object. remove(): Removes related objects from the parent object. Creating ManyToMany Relation subject1 = Subject.objects.create(name=\u0026#39;Maths\u0026#39;) subject2 = Subject.objects.create(name=\u0026#39;Science\u0026#39;) student1 = Student.objects.create(name=\u0026#39;John\u0026#39;, age=20) student1.subjects.add(subject1, subject2) student2 = Student.objects.create(name=\u0026#39;Doe\u0026#39;, age=22) student2.subjects.add(subject1) Structure:\nJohn -\u0026gt; Maths, Science\rDoe -\u0026gt; Maths\rMaths -\u0026gt; John, Doe\rScience -\u0026gt; John Updating ManyToMany Relation student = Student.objects.get(name=\u0026#39;John\u0026#39;) subjects = student.subjects.all() # Get all subjects of John. You can use filter() instead of all(). subject = subjects[0] subject.name = \u0026#39;History\u0026#39; subject.save() Finding All Students Corresponding to a Subject subject = Subject.objects.get(name=\u0026#39;Maths\u0026#39;) students = subject.students.all() # You can use filter() instead of all(). Accessing the Subjects from a Student Object student = Student.objects.get(name=\u0026#39;John\u0026#39;) subjects = student.subjects.all() # You can use filter() instead of all(). remove() ManyToMany Relation student = Student.objects.get(name=\u0026#39;John\u0026#39;) subject = Subject.objects.get(name=\u0026#39;Maths\u0026#39;) student.subjects.remove(subject) Note: The remove() method removes the relation between the student and the subject but does not delete the subject object.\n","permalink":"http://localhost:1313/posts/pages/django/django-5/","summary":"Detailed guide on Django model relationships, covering OneToOne, OneToMany, and ManyToMany relations. Essential for managing complex data relationships in Django.","title":"Django: Day 5"},{"content":"Django Admin Interface Django provided a buildin admin interface that can be used to manage the data in the database.\n21.1 Creating a superuser To access the admin interface, we need to create a superuser. We can create a superuser using the createsuperuser command.\npython manage.py createsuperuser 21.2 Registering models with the admin interface To make the model available in the admin interface we need to register the model with the admin interface.\nfrom django.contrib import admin from myapp.models import Person admin.site.register(Person) 21.3 Customizing the admin interface We can change the site header, title, and index title of the admin interface by overriding the admin.site.site_header, admin.site.site_title, and admin.site.index_title respectively.\nadmin.site.site_header = \u0026#39;My Site Admin\u0026#39; admin.site.site_title = \u0026#39;My Site Admin\u0026#39; 21.4 Customizing the model admin We can customize the model admin by creating a class that inherits from admin.ModelAdmin and then registering it with the model.\nCustomizing Admin List Display By default, the admin list view only displays the __str__() method of the model. You can customize it using the list_display attribute.This makes it easier to view important information at a glance. class StudentAdmin(admin.ModelAdmin): list_display = (\u0026#39;id\u0026#39;, \u0026#39;name\u0026#39;, \u0026#39;age\u0026#39;, \u0026#39;grade\u0026#39;) # Fields to display in the list view Adding Search Functionality Purpose: Enable a search bar to search through specific fields in the model. Use the search_fields attribute to specify which fields should be searchable class StudentAdmin(admin.ModelAdmin): search_fields = (\u0026#39;name\u0026#39;, \u0026#39;grade\u0026#39;) # Enable search for name and grade fields Ordering the List Purpose: Sort the list view by a specific field. Use the ordering attribute to specify the default ordering of the list view. class StudentAdmin(admin.ModelAdmin): ordering = (\u0026#39;name\u0026#39;,) # Order the list view by name Fieldsets Purpose: Group related fields together in the admin interface. Use the fieldsets attribute to group fields together. class StudentAdmin(admin.ModelAdmin): fieldsets = ( (\u0026#39;Personal Information\u0026#39;, { \u0026#39;fields\u0026#39;: (\u0026#39;name\u0026#39;, \u0026#39;age\u0026#39;) }), (\u0026#39;Academic Information\u0026#39;, { \u0026#39;fields\u0026#39;: (\u0026#39;grade\u0026#39;, \u0026#39;subject\u0026#39;) }), ) 21.5 Combining all customizations admin.py\nfrom django.contrib import admin from myapp.models import Student class StudentAdmin(admin.ModelAdmin): list_display = (\u0026#39;id\u0026#39;, \u0026#39;name\u0026#39;, \u0026#39;age\u0026#39;, \u0026#39;grade\u0026#39;) search_fields = (\u0026#39;name\u0026#39;, \u0026#39;grade\u0026#39;) ordering = (\u0026#39;name\u0026#39;,) fieldsets = ( (\u0026#39;Personal Information\u0026#39;, { \u0026#39;fields\u0026#39;: (\u0026#39;name\u0026#39;, \u0026#39;age\u0026#39;) }), (\u0026#39;Academic Information\u0026#39;, { \u0026#39;fields\u0026#39;: (\u0026#39;grade\u0026#39;, \u0026#39;subject\u0026#39;) }), ) admin.site.register(Student, StudentAdmin) ","permalink":"http://localhost:1313/posts/pages/django/django-4/","summary":"Comprehensive guide to Django\u0026rsquo;s admin interface, covering superuser creation, model registration, and various customizations to improve admin functionality.","title":"Django: Day 4"},{"content":"20. CRUD Operations in Django 20.1 Inserting Data using save() method To insert data into the database,\nUsing save() method we create an instance of the model and call the save() method on it.\nfrom myapp.models import Person person = Person(name=\u0026#39;Alice\u0026#39;, age=25) person.save() Here we create a new object of the Person model with the name Alice and age 25 and save it to the database.\nUsing create() method We can also use the create() method to create and save an object in a single step.\nperson = Person.objects.create(name=\u0026#39;Alice\u0026#39;, age=25) This return the object that is created.\nNote:save() method is used to save the data in database and create() method is used to create and save the data in database.\n20.2 Reading Data 20.2.1 Get all data To get all the data from the database we use the all() method.\nfrom myapp.models import Person persons = Person.objects.all() This returns all the objects of the Person model.ie return all the rows of the table.\n20.3 Updating Data To update the data in the database, we first get the object we want to update, change its attributes, and then call the save() method on it.\nfrom myapp.models import Person person = Person.objects.get(id=1) person.age = 26 person.save() 20.4 Deleting Data To delete data from the database, we first get the object we want to delete and then call the delete() method on it.\nfrom myapp.models import Person person = Person.objects.get(id=1) person.delete() 20.4 Deleting all data To delete all the data from the database we use the all() method to get all the objects and then call the delete() method on it.\nfrom myapp.models import Person persons = Person.objects.all() persons.delete() 20.5 Filtering Data We can use the following methods to filter the data in the database.\n20.5.1 filter() The filter() method is used to filter the data based on the given condition.\nfrom myapp.models import Person persons = Person.objects.filter(age=25) In the above example, we are filtering the data based on the age of the person.It returns all the objects that have the age equal to 25 in the form of a queryset(List)\n20.5.2 exclude() The exclude() method is used to exclude the data based on the given condition.\nfrom myapp.models import Person persons = Person.objects.exclude(age=25) In the above example, we are excluding the data based on the age of the person.It returns all the objects that have the age not equal to 25 in the form of a queryset(List)\n20.5.3 get() The get() method is used to get the single object based on the given condition.\nfrom myapp.models import Person person = Person.objects.get(id=1) In the above example, we are getting the object based on the id of the person.It returns the object that has the id equal to 1.\nNote:If there are more than one object or no object that satisfies the condition then get() will raise an error but filter() and exclude() will return an empty queryset.\nOperation that can be performed on queryset like all(),filter(),exclude() 20.6.order_by() The order_by() method is used to order the data based on the given field.\nfrom myapp.models import Person persons = Person.objects.all().order_by(\u0026#39;field_name\u0026#39;) In the above example, we are ordering the data based on the field name in ascending order. If you want to order the data in descending order then you can use the - sign before the field name.\nfrom myapp.models import Person persons = Person.objects.all().order_by(\u0026#39;-field_name\u0026#39;) 20.7.count() The count() method is used to count the number of objects in the queryset.\nfrom myapp.models import Person count = Person.objects.all().count() 20.8 reverse() The reverse() method is used to reverse the order of the queryset.\nfrom myapp.models import Person persons = Person.objects.all().reverse() 20.9.first() The first() method is used to get the first object from the queryset.\nfrom myapp.models import Person person = Person.objects.all().first() 20.10.last() The last() method is used to get the last object from the queryset.\nfrom myapp.models import Person person = Person.objects.all().last() 20.11.exists() The exists() method is used to check if the queryset contains any objects.\nfrom myapp.models import Person exists = Person.objects.all().exists() 21. And, Or, Not in filter We can use \u0026amp; for and, | for or, and ~ for not in the filter method.\nPerforming and operation in filter\nfrom myapp.models import Person persons = Person.objects.filter(age=25, name=\u0026#39;Alice\u0026#39;) or\nfrom myapp.models import Person from django.db.models import Q persons = Person.objects.filter(Q(age=25) \u0026amp; Q(name=\u0026#39;Alice\u0026#39;)) Performing or operation in filter\nfrom myapp.models import Person persons = Person.objects.filter(Q(age=25) | Q(name=\u0026#39;Alice\u0026#39;)) Performing not operation in filter\nfrom myapp.models import Person persons = Person.objects.filter(~Q(age=25)) or\nfrom myapp.models import Person persons = Person.objects.exclude(age=25) 21.1 Combining and, or, not operation in filter,get,exclude from myapp.models import Person from django.db.models import Q persons = Person.objects.filter(Q(age=25) \u0026amp; Q(name=\u0026#39;Alice\u0026#39;) | ~Q(age=25)) 22. Comparision operators in filter,get,exclude We can use the following comparision operators in the filter,get,exclude method.\n22.1 Comparision operators for integer 1.greater than gt\nfrom myapp.models import Person persons = Person.objects.filter(age__gt=25) 2.greater than or equal to gte\nfrom myapp.models import Person persons = Person.objects.filter(age__gte=25) 3.less than lt\nfrom myapp.models import Person persons = Person.objects.filter(age__lt=25) 4.less than or equal to lte\nfrom myapp.models import Person persons = Person.objects.filter(age__lte=25) 5.not equal to ne\nfrom myapp.models import Person persons = Person.objects.filter(age__ne=25) 6.equal\nfrom myapp.models import Person persons = Person.objects.filter(age=25) 22.2 Comparision operators for string 1.exact\nfrom myapp.models import Person persons = Person.objects.filter(name__exact=\u0026#39;Alice\u0026#39;) 2.iexact\nfrom myapp.models import Person persons = Person.objects.filter(name__iexact=\u0026#39;alice\u0026#39;) 3.contains\nfrom myapp.models import Person persons = Person.objects.filter(name__contains=\u0026#39;li\u0026#39;) 4.icontains\nfrom myapp.models import Person persons = Person.objects.filter(name__icontains=\u0026#39;li\u0026#39;) 5.startswith\nfrom myapp.models import Person persons = Person.objects.filter(name__startswith=\u0026#39;A\u0026#39;) 6.istartswith\nfrom myapp.models import Person persons = Person.objects.filter(name__istartswith=\u0026#39;a\u0026#39;) 7.endswith\nfrom myapp.models import Person persons = Person.objects.filter(name__endswith=\u0026#39;e\u0026#39;) 8.iendswith\nfrom myapp.models import Person persons = Person.objects.filter(name__iendswith=\u0026#39;e\u0026#39;) 9.in\nfrom myapp.models import Person persons = Person.objects.filter(name__in=[\u0026#39;Alice\u0026#39;,\u0026#39;Bob\u0026#39;]) Note:i in iexact,icontains,istartswith,iendswith stands for case-insensitive.\n23. Limiting Queryset We can limit the number of objects returned by the queryset using the [:n] syntax.\nfrom myapp.models import Person persons = Person.objects.all()[:5] 24. Aggregation Its used to perform some operation on the queryset like counting the number of objects, finding the average, sum, min, max, etc.\n24.1 Count The count() method is used to count the number of objects in the queryset.\nfrom myapp.models import Person count = Person.objects.all().count() 24.2 Sum The sum() method is used to find the sum of the field in the queryset.\nfrom myapp.models import Person sum = Person.objects.all().aggregate(Sum(\u0026#39;field_name\u0026#39;)) 24.3 Avg The avg() method is used to find the average of the field in the queryset.\nfrom myapp.models import Person avg = Person.objects.all().aggregate(Avg(\u0026#39;field_name\u0026#39;)) 24.4 Min The min() method is used to find the minimum value of the field in the queryset.\nfrom myapp.models import Person min = Person.objects.all().aggregate(Min(\u0026#39;field_name\u0026#39;)) 24.5 Max The max() method is used to find the maximum value of the field in the queryset.\nfrom myapp.models import Person max = Person.objects.all().aggregate(Max(\u0026#39;field_name\u0026#39;)) ","permalink":"http://localhost:1313/posts/pages/django/django-3/","summary":"Deep dive into Django Models covering field types, model options, database configuration, migrations, and model methods. Essential knowledge for database operations in Django.","title":"Django: Day 3"},{"content":"19.Introduction to Django Models A model is a class that represents a table in our database. Each model is a Python class that subclasses django.db.models.Model. Each attribute of the model represents a database field. With all of this, Django gives you an automatically-generated database-access API; see Making queries.\n19.1 setting up a database By default, Django uses SQLite as its database. SQLite is included in Python, so you won’t need to install anything else to support your database. When starting a new project, you can specify the database to use by setting the ENGINE setting to the appropriate database backend. Here’s the full list of built-in database backends that Django supports:\ndjango.db.backends.sqlite3 django.db.backends.postgresql django.db.backends.mysql django.db.backends.oracle for example, if you want to use mysql as your database you can set the ENGINE setting to django.db.backends.mysql in the settings.py file.\nDATABASES = { \u0026#39;default\u0026#39;: { \u0026#39;ENGINE\u0026#39;: \u0026#39;django.db.backends.mysql\u0026#39;, \u0026#39;NAME\u0026#39;: \u0026#39;mydatabase\u0026#39;, \u0026#39;USER\u0026#39;: \u0026#39;mydatabase\u0026#39;, \u0026#39;PASSWORD\u0026#39;: \u0026#39;mypassword\u0026#39;, \u0026#39;HOST\u0026#39;: \u0026#39;\u0026#39;, \u0026#39;PORT\u0026#39;: \u0026#39;3306\u0026#39;, } } 19.2 Fields Fields are specified by class attributes. Be careful not to choose field names that conflict with the models API like clean, save, or delete.\nFiled Types: Please go to Django Documentation to see the list of all field types.\n19.3 Field options null:If null is set to True, the field will accept empty values. i.e Databse will store NULL values for this field if null=True is set and no value is provided. name = models.CharField(max_length=100, null=True) blank:If blank is set to True, the field will be allowed to be blank. i.e form validation will allow entry of an empty value if blank=True is set and no value is provided name = models.CharField(max_length=100, blank=True) Note that this is different than null. null is purely database-related, whereas blank is validation-related. If a field has blank=True, form validation will allow entry of an empty value.\nchoices:Used to set the choices for the field. CHOICES=((\u0026#39;M\u0026#39;,\u0026#39;MALE\u0026#39;),(\u0026#39;F\u0026#39;,\u0026#39;FEMALE\u0026#39;),(\u0026#39;O\u0026#39;,\u0026#39;OTHER\u0026#39;),) class Person(models.Model): gender=models.CharField(max_length=1,choices=CHOICES) default:The default value for the field .When the model is saved and no value is provided for the field, the default value will be used. name = models.CharField(max_length=100, default=\u0026#39;SOME STRING\u0026#39;) primary_key:If True, this field is the primary key for the model. name = models.CharField(max_length=100, primary_key=True) unique:If True, this field must be unique throughout the table. name = models.CharField(max_length=100, unique=True) -db_index:If True, an index will be created for this field.due to which the query operation like filter,order_by will be faster.\nname = models.CharField(max_length=100, db_index=True) -editable:If False, the field will not be displayed in the admin or any other forms.\nname = models.CharField(max_length=100, editable=False) validators:List of validators to run for this field.We can create custom validators for the field. from django.core.exceptions import ValidationError def validate_even(value): if value % 2 != 0: raise ValidationError( (\u0026#39;%(value)s is not an even number\u0026#39;), params={\u0026#39;value\u0026#39;: value}, ) class MyModel(models.Model): even_field = models.IntegerField(validators=[validate_even]) verbose_name:A human-readable name for the field. name = models.CharField(max_length=100, verbose_name=\u0026#39;Full Name\u0026#39;) 19.4 meta class The Meta class inside the model contains metadata. It is used to define metadata for the model class. Some of the metadata options are:\nabstract:If True, this model will not be used to create any database table instead it will be used as a base class for other models.for exampple: class Animal(models.Model): breed=models.CharField(max_length=100) class Meta: abstract=True class Dog(Animal): name=models.CharField(max_length=100) Here Animal model will not create any table in the database but Dog model will create a table with fields breed and name.\nverbose_name:A human-readable name for the model. class MyModel(models.Model): class Meta: verbose_name=\u0026#39;My Model\u0026#39; verbose_name_plural:A human-readable plural name for the model. class MyModel(models.Model): class Meta: verbose_name_plural=\u0026#39;My Models\u0026#39; 19.5 Simple Model Example from django.db import models class Person(models.Model): name = models.CharField(max_length=100) age = models.IntegerField(default=0) class Meta: verbose_name=\u0026#39;Person\u0026#39; verbose_name_plural=\u0026#39;Persons\u0026#39; class __str__(self): return self.name 19.6 MakeMigration and Migrate After creating the model we run\npython manage.py makemigrations :his command is used to create migrations for changes made to models. It generates a migration file in the migrations folder, which contains the necessary schema changes (e.g., creating or modifying tables) for the model. python manage.py migrate :This command is used to apply the migrations to the database. It reads the migration files in the migrations folder and updates the database schema by creating or altering the database tables accordingly. Use python manage.py flush to delete all the data in the database. Use python manage.py shell to open the python shell with the Django environment. Use python manage.py createsuperuser to create a superuser for the admin panel. 19.7 Using methods in models To do operation related to the model we can define methods in the model class itself.\nfrom django.db import models class Person(models.Model): name = models.CharField(max_length=100) age = models.IntegerField(default=0) grade = models.IntegerField(default=0) def is_adult(self): return self.age\u0026gt;=18 def is_pass(self): return self.grade\u0026gt;=40 def __str__(self): return self.name Now we can use this method in the views or templates.\nperson=Person.objects.get(id=1) print(person.is_adult()) print(person.is_pass()) ","permalink":"http://localhost:1313/posts/pages/django/django-2/","summary":"Deep dive into Django Models covering field types, model options, database configuration, migrations, and model methods. Essential knowledge for database operations in Django.","title":"Django: Day 2"},{"content":"In this Series we will cover all the concept of django that we need to learn drf(Django Rest Framework)\n1.Installation of Django pip install django 2.Project and App in Django Project is the collection of Apps and APP is the individual module of the project. For Example: A e-commerce website is a project and the modules like products,orders,users,search are the apps.\n3.Creating a Django Project To create a project in django we need to run the following command\ndjango-admin startproject project_name 4.Folder Structure of Django Project project_name |__project_name | |__settings.py | |__urls.py | |__wsgi.py | |__asgi.py |__manage.py settings.py: This file contains all the settings of the project like installed apps, middleware, database configuration, static files, media files etc. urls.py: This file contains all the urls of this project. When send a request to the server then this file will decide which view function will be called. wsgi.py: This file is used for deployment purpose. asgi.py: This file is used for deployment purpose. manage.py: This file is used to run the server, create apps, create superuser etc. 5.Running the Server To run the server we need to run the following command\npython manage.py runserver 6.Creating a Django App To create a app in django we need to run the following command\npython manage.py startapp app_name 7.Folder Structure of Django App app_name |__migrations |__admin.py |__apps.py |__models.py |__tests.py |__views.py migrations: This folder contains all the migrations files. admin.py: This file is used to register the models in the admin panel. apps.py: This file is used to configure the app. models.py: This file is used to create the models. tests.py: This file is used to write the test cases. views.py: This file is used to write the views. 8.Registering the App in the Project To register the app in the project we need to add the app name in the INSTALLED_APPS list in the settings.py file.\nINSTALLED_APPS = [ \u0026#39;django.contrib.admin\u0026#39;, \u0026#39;django.contrib.auth\u0026#39;, \u0026#39;django.contrib.contenttypes\u0026#39;, \u0026#39;django.contrib.sessions\u0026#39;, \u0026#39;django.contrib.messages\u0026#39;, \u0026#39;django.contrib.staticfiles\u0026#39;, \u0026#39;app_name\u0026#39;, ] 9. Why register the app in the project? Here are the reasons: -makemigrations and migrate commands will work for the app. if we don\u0026rsquo;t register the app in the project then the makemigrations and migrate commands will not work for the app.\n-static and templates folder will work for the app. If we don\u0026rsquo;t register the app in the project then the static and templates folder will not recognize by the django.\n10.Routes in Django In Django we define the routes in the urls.py file of project but it will be difficult to manage all the routes in the urls.py so we create a urls.py file in the app and include that file in the project urls.py file and define the routes in the app urls.py file.\nsteps:\nCreate a urls.py file in the app. include the app urls.py file in the project urls.py file. Define the routes in the app urls.py file. for example:\n# home/urls.py from django.urls import path from . import views urlpatterns = [ path(\u0026#39;\u0026#39;, views.home, name=\u0026#39;home\u0026#39;), path(\u0026#39;about/\u0026#39;, views.about, name=\u0026#39;about\u0026#39;), ] #search/urls.py from django.urls import path from . import views urlpatterns = [ path(\u0026#39;\u0026#39;, views.search, name=\u0026#39;search\u0026#39;), path(\u0026#39;result/\u0026#39;, views.result, name=\u0026#39;result\u0026#39;), ] # project/urls.py from django.contrib import admin from django.urls import path, include urlpatterns = [ path(\u0026#39;admin/\u0026#39;, admin.site.urls), path(\u0026#39;\u0026#39;, include(\u0026#39;app.urls\u0026#39;)), path(\u0026#39;search/\u0026#39;, include(\u0026#39;search.urls\u0026#39;)), ] When user send request to localhost:8000/search/ then it will call the search app urls.py and from there view will be decided name is used later for redirection purpose.\n11. Views in Django In Django views are the functions that take a request and return a response. Views are the heart of the django application. Views are the functions that are called when the user send a request to the server.\n12. Creating a View To create a view we need to create a function in the views.py file of the app.\nfor example:\n# views.py from django.http import HttpResponse def home(request): return HttpResponse(\u0026#39;Home Page\u0026#39;) def about(request): return HttpResponse(\u0026#39;About Page\u0026#39;) 13. Registering the View in the urls To register the view in the urls we need to import the view in the urls.py file of the app and define the path.\nfor example:\n# urls.py from django.urls import path from . import views urlpatterns = [ path(\u0026#39;\u0026#39;, views.home, name=\u0026#39;home\u0026#39;), path(\u0026#39;about/\u0026#39;, views.about, name=\u0026#39;about\u0026#39;), ] 14.Dynamic URL Routing In Django we can pass the dynamic data in the url and get that data in the view function.\nfor example:\n# urls.py from django.urls import path from . import views urlpatterns = [ path(\u0026#39;post/\u0026lt;int:id\u0026gt;/\u0026#39;, views.post, name=\u0026#39;post\u0026#39;), path(\u0026#39;post/\u0026lt;int:id\u0026gt;/\u0026lt;int:str\u0026gt;\u0026#39;, views.post, name=\u0026#39;post\u0026#39;), ] # views.py from django.http import HttpResponse def post(request, id): return HttpResponse(f\u0026#39;Post {id}\u0026#39;) def post(request, id, str): return HttpResponse(f\u0026#39;Post {id} {str}\u0026#39;) we can use\nint for integer ex: localhost:8000/post/1/ =\u0026gt;1 str for string ex: localhost:8000/post/abs =\u0026gt;abs slug for slug ex: localhost:8000/post/this-is-slug =\u0026gt;this-is-slug uuid for uuid ex: localhost:8000/post/123e4567-e89b-12d3-a456-426614174000 =\u0026gt;123e4567-e89b-12d3-a456-426614174000 path for path ex: localhost:8000/post/this/is/path =\u0026gt;this/is/path 15.reverse() function In Django we can use the reverse() function to get the url of the view by using the name of the view.\nfor example:\n# urls.py from django.urls import path from . import views urlpatterns = [ path(\u0026#39;\u0026#39;, views.home, name=\u0026#39;home\u0026#39;), path(\u0026#39;about/\u0026#39;, views.about, name=\u0026#39;about\u0026#39;), ] # views.py from django.http import HttpResponse from django.urls import reverse def home(request): return HttpResponse(reverse(\u0026#39;home\u0026#39;)) def about(request): return HttpResponse(reverse(\u0026#39;about\u0026#39;)) The reverse('home') will return the url of the home view as / and reverse('about') will return the url of the about view as /about/.\n16.Redirecting the URL In Django we can redirect the url to another url by using the redirect() function as well as the reverse() function and HttpResponseRedirect() function. for example:\n# views.py from django.http import HttpResponseRedirect from django.shortcuts import redirect from django.urls import reverse def home(request): return HttpResponseRedirect(reverse(\u0026#39;last\u0026#39;)) def about(request): return redirect(\u0026#39;last\u0026#39;) def last(request): return HttpResponse(\u0026#39;Last Page\u0026#39;) The HttpResponseRedirect(reverse('last')) will redirect the user to the last view and redirect('last') will also redirect the user to the last view.\n17.Handeling Static Files 17.1 What are Static Files? Static files are the files that are used in the frontend of the website like css, js, images etc and these files are not changed dynamically.\n17.2 Where to put the Static Files? In Django we put the static files in the static folder of the app for example:\napp_name |__static |__app_name |__css |__js |__images 17.2 Setting Global Static Files if we want to set global level static file outside the app then\nwe create a folder for instance static in the project for example: project_name |__static |__css |__js |__images add the path in the settings.py file STATICFILES_DIRS = [ os.path.join(BASE_DIR, \u0026#39;static\u0026#39;) ] Other Setting for Static Files STATIC_ROOT This setting is used to define the path where the static files will be collected.\nSTATIC_ROOT = os.path.join(BASE_DIR, \u0026#39;staticfiles\u0026#39;) When we run the collectstatic command then all the static files will be collected in the staticfiles folder.\nSTATICFILES_DIRS This setting is used to define the path of the static filess specially for global level static files.\nSTATICFILES_DIRS = [ os.path.join(BASE_DIR, \u0026#39;static\u0026#39;) ] STATIC_URL This setting is used to define the url of the static files.\nSTATIC_URL = \u0026#39;/static/\u0026#39; for example:\nstatic |-css | |-style.css | |-style1.css | |-js | |-script.js | |-script1.js then we can access the css file as localhost:8000/static/css/style.css and js file as localhost:8000/static/js/script.js due to the STATIC_URL setting.\nNote: python manage.py collectstatic command is used to collect all the static files in the STATIC_ROOT folder.\n18.Serving Static Files If django.contrib.staticfiles is included in your INSTALLED_APPS,runserver will automatically serve static files when DEBUG is set to True but If you don’t have django.contrib.staticfiles in INSTALLED_APPS, you can still manually serve static files using static().\nfrom django.conf import settings from django.conf.urls.static import static urlpatterns = [ # ... the rest of your URLconf goes here ... ] + static(settings.STATIC_URL, document_root=settings.STATIC_ROOT) Note: This is not suitable for production use!\n","permalink":"http://localhost:1313/posts/pages/django/django-1/","summary":"Master core Django concepts including project structure, app creation, URL routing, views, static files management and more. A foundational guide for Django REST Framework.","title":"Django: Day 1"},{"content":"Deploying React App to deploy the react app we need to build the app first and then deploy the build folder to the server.\nBuild the App To build the app run the following command:\nnpm run build This command will create a build folder in the root directory of the project.\nDeploy the App We can deploy this to any static file server like Netlify,Vercel,Github Pages etc.\nLeft Over Topics Authentication Tanstack Query Axios intercept React Toastify Go to the React Toastify website to learn more\nReact loading skeleton Go to the React loading skeleton website to learn more\nSome Behaviour of useState Note the state of the component is lost when the component is unmounted. So, if you want to persist the state value even after the component is unmounted, you can move it to the parent component that is not unmounted and pass it as a prop to the child component.\nMake a menu import React, { useState } from \u0026#39;react\u0026#39;; const data = [ { menu: \u0026#39;Home\u0026#39;, value: \u0026#39;I love home page\u0026#39;, }, { menu: \u0026#39;About\u0026#39;, value: \u0026#39;I love about page\u0026#39;, }, { menu: \u0026#39;Contact\u0026#39;, value: \u0026#39;I love contact page\u0026#39;, }, ]; const Menu = () =\u0026gt; { const [menu, setMenu] = useState(0); return ( \u0026lt;div\u0026gt; \u0026lt;ul\u0026gt; {data.map((item, index) =\u0026gt; ( \u0026lt;li key={index} onClick={() =\u0026gt; setMenu(index)}\u0026gt; {item.menu} \u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;div\u0026gt;{data[menu].value}\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); }; export default Menu; Stale Value of stateVariable in useEffect, useMemo, and useCallback import React, { useState, useEffect } from \u0026#39;react\u0026#39;; const StaleValue = () =\u0026gt; { const [count, setCount] = useState(0); useEffect(() =\u0026gt; { const interval = setInterval(() =\u0026gt; { console.log(count); }, 1000); return () =\u0026gt; clearInterval(interval); }, []); const HandleInteral = () =\u0026gt; { setCount((prevCount) =\u0026gt; prevCount + 1); } return \u0026lt;div onClick={HandleInteral}\u0026gt;Click me\u0026lt;/div\u0026gt;; }; What is the output of the above code if i click the div element? The output will be always 0 because the count value is not updated in the useEffect hook as the count value is not passed in the dependency array of the useEffect hook. So, the initial value of the count is used in the useEffect hook every time.\nSolution to the above problem import React, { useState, useEffect } from \u0026#39;react\u0026#39;; const StaleValue = () =\u0026gt; { const [count, setCount] = useState(0); useEffect(() =\u0026gt; { const interval = setInterval(() =\u0026gt; { console.log(count); }, 1000); return () =\u0026gt; clearInterval(interval); }, [count]); const HandleInteral = () =\u0026gt; { setCount((prevCount) =\u0026gt; prevCount + 1); } return \u0026lt;div onClick={HandleInteral}\u0026gt;Click me\u0026lt;/div\u0026gt;; }; Here, the output will reflect the updated value of count because count is passed in the dependency array of the useEffect hook. This ensures that the useEffect hook re-runs whenever count changes with the updated value of count , preventing stale values from being used.\nStale Value in useMemo and useCallback Similarly, the useMemo and useCallback hooks can also suffer from stale values if the state variable is not included in their dependency arrays.\nNon-Stale Variables in useEffect, useMemo, and useCallback Generally, the useEffect, useMemo, and useCallback hooks will rerun whenever the reference of an element in the dependency array changes. However, in the case of the useRef hook, the reference remains the same across re-renders, even if the value of ref.current changes. On the other hand, a state variable\u0026rsquo;s reference and value both change when updated.\nThis means that ref has no significance in the dependency array of useEffect, useMemo, and useCallback hooks.\nWhen dealing with stale values in useRef it will always have the updated value in useEffect, useMemo, and useCallback hooks, even if they are not included in the dependency array.\nFor example, consider useRef:\nimport React, { useEffect, useRef } from \u0026#39;react\u0026#39;; const StaleValue = () =\u0026gt; { const countRef = useRef(0); useEffect(() =\u0026gt; { const interval = setInterval(() =\u0026gt; { console.log(countRef.current); }, 1000); return () =\u0026gt; clearInterval(interval); }, []); const handleInterval = () =\u0026gt; { countRef.current += 1; }; return \u0026lt;div onClick={handleInterval}\u0026gt;Click me\u0026lt;/div\u0026gt;; }; In the above code, the output will always be the updated value of countRef.current, even though countRef.current is not included in the dependency array of the useEffect hook.\nNote: Normal function never contain the stale value of a function. It always contain the updated value of the function.\nWhich Which component will rerender when we dispatch an action in Redux? When we dispatch an action in Redux, the component that is using useSelector will rerender. This is because the component is subscribed to the store and will update whenever the store changes.\nWhich Which component will rerender when context api value changes? When the value of a context API changes, the component that is using useContext will rerender. This is because the component is subscribed to the context and will update whenever the context value changes.\n","permalink":"http://localhost:1313/posts/pages/react/react15/","summary":"A guide on building and deploying a React app, including commands and server options.","title":"Deploying React App"},{"content":"52.React Router Dom React Router Dom is the routing library that is used in react for defining the routes in application\n52.1 Installation npm install react-router-dom 52.2 Defining Routes We can serve different components for different routes using react-router-dom library. App.jsx\nimport { createBrowserRouter,RouterProvider } from \u0026#39;react-router-dom\u0026#39;; import Home from \u0026#39;./Home\u0026#39;; import About from \u0026#39;./About\u0026#39;; import Contact from \u0026#39;./Contact\u0026#39;; const router=createBrowserRouter([ {path:\u0026#39;/\u0026#39;,element:\u0026lt;Home/\u0026gt;}, {path:\u0026#39;/about\u0026#39;,element:\u0026lt;About/\u0026gt;}, {path:\u0026#39;/contact\u0026#39;,element:\u0026lt;Contact/\u0026gt;} ]); function App(){ return \u0026lt;RouterProvider router={router}/\u0026gt; } export default App; Note:Home,About,Contact are the components that are rendered for the respective routes and they are called pages so it is better to create a folder named pages and keep all the pages in that folder.\n52.3 Navigation Between Routes using Link Normally we use anchor tag for navigation between routes but in react we use Link component from react-router-dom for navigation between routes just because anchor tag will reload the page and react will lose its state and data.\nimport {Link} from \u0026#39;react-router-dom\u0026#39;; function Home(){ return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Home\u0026lt;/h1\u0026gt; \u0026lt;Link to=\u0026#34;/about\u0026#34;\u0026gt;About\u0026lt;/Link\u0026gt; \u0026lt;Link to=\u0026#34;/contact\u0026#34;\u0026gt;Contact\u0026lt;/Link\u0026gt; \u0026lt;/div\u0026gt; ) } Here to attribute is used to define the path to navigate to.\n52.4 Layouts And Nested Routes import { createBrowserRouter,RouterProvider } from \u0026#39;react-router-dom\u0026#39;; import Home from \u0026#39;./Home\u0026#39;; import About from \u0026#39;./About\u0026#39;; import Contact from \u0026#39;./Contact\u0026#39;; import Layout from \u0026#39;./Layout\u0026#39;; const router=createBrowserRouter([ { path:\u0026#39;/\u0026#39;, element:\u0026lt;Layout/\u0026gt;, children:[ {path:\u0026#39;/\u0026#39;,element:\u0026lt;Home/\u0026gt;}, {path:\u0026#39;/about\u0026#39;,element:\u0026lt;About/\u0026gt;}, {path:\u0026#39;/contact\u0026#39;,element:\u0026lt;Contact/\u0026gt;} ] }, ]); function App(){ return \u0026lt;RouterProvider router={router}/\u0026gt; } export default App; Layout.jsx\nimport {Outlet} from \u0026#39;react-router-dom\u0026#39;; impoet Header from \u0026#39;./Header\u0026#39;; import Footer from \u0026#39;./Footer\u0026#39;; function Layout(){ return ( \u0026lt;div\u0026gt; \u0026lt;Header/\u0026gt; \u0026lt;Outlet/\u0026gt; \u0026lt;Footer/\u0026gt; \u0026lt;/div\u0026gt; ) } export default Layout; Layout.jsx will render the Header, Footer always and the child component depending on the route.\nNote:Layout is only applied when the route prefix is start with / as we have defined the layout for / route.\n52.5 Handeling 404 Page We can handle 404 page with the help of ErrorElement in react-router-dom. When we define the ErrorElement it will be rendered if an Error occurs.As the error will occur when the route is not defined in the routes array so we can define the ErrorElement at the end of the routes array.\nimport { createBrowserRouter,RouterProvider,ErrorElement } from \u0026#39;react-router-dom\u0026#39;; import Home from \u0026#39;./Home\u0026#39;; import About from \u0026#39;./About\u0026#39;; import Contact from \u0026#39;./Contact\u0026#39;; import Layout from \u0026#39;./Layout\u0026#39;; import NotFound from \u0026#39;./NotFound\u0026#39;; const router=createBrowserRouter([ { path:\u0026#39;/\u0026#39;, element:\u0026lt;Layout/\u0026gt;, errorElement:\u0026lt;NotFound/\u0026gt;, children:[ { path:\u0026#39;/\u0026#39;, element:\u0026lt;Home/\u0026gt; }, { path:\u0026#39;/about\u0026#39;, element:\u0026lt;About/\u0026gt; }, { path:\u0026#39;/contact\u0026#39;, element:\u0026lt;Contact/\u0026gt; } ] }, ]); 52.6 NavLink Component The NavLink component, similar to the Link component,but it is used to style to the link when it is active.\nimport {NavLink} from \u0026#39;react-router-dom\u0026#39;; function Header(){ return ( \u0026lt;div\u0026gt; \u0026lt;NavLink to=\u0026#34;/\u0026#34; className={(isActive)?\u0026#34;active\u0026#34;:\u0026#34;\u0026#34;}\u0026gt;Home\u0026lt;/NavLink\u0026gt; \u0026lt;NavLink to=\u0026#34;/about\u0026#34; className={(isActive)?\u0026#34;active\u0026#34;:\u0026#34;\u0026#34;}\u0026gt;About\u0026lt;/NavLink\u0026gt; \u0026lt;NavLink to=\u0026#34;/contact\u0026#34; className={(isActive)?\u0026#34;active\u0026#34;:\u0026#34;\u0026#34;}\u0026gt;Contact\u0026lt;/NavLink\u0026gt; \u0026lt;/div\u0026gt; ) } Here isActive is a boolean variable that is used to check whether the link is active or not\nFor example: when the route is /about then the NavLink with to=\u0026quot;/about\u0026quot; will have the class active and the other links will not have the class active.\nwhen the route is /contact then the NavLink with to=\u0026quot;/contact\u0026quot; will have the class active and the other links will not have the class active.\n52.7 Navigation Programmatically We can navigate between routes programmatically using useNavigate hook from react-router-dom.\nIt is used when we want to navigate to a route when a button is clicked or when a form is submitted or redirecting to a route after some time delay.\nimport {useNavigate} from \u0026#39;react-router-dom\u0026#39;; function Home(){ const navigate=useNavigate(); return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Home\u0026lt;/h1\u0026gt; \u0026lt;button onClick={()=\u0026gt;navigate(\u0026#39;/about\u0026#39;)}\u0026gt;About\u0026lt;/button\u0026gt; \u0026lt;button onClick={()=\u0026gt;navigate(\u0026#39;/contact\u0026#39;)}\u0026gt;Contact\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } 52.8 Dynamic Routes In some cases, we need to pass some data in the route so that we can use that data in the component that is rendered for that route for example when we want to show the details of a product then we can pass the product\nimport { createBrowserRouter,RouterProvider } from \u0026#39;react-router-dom\u0026#39;; import Home from \u0026#39;./Home\u0026#39;; import About from \u0026#39;./About\u0026#39;; import Contact from \u0026#39;./Contact\u0026#39;; import Product from \u0026#39;./Product\u0026#39;; const router=createBrowserRouter([ { path:\u0026#39;/\u0026#39;, element:\u0026lt;Home/\u0026gt; }, { path:\u0026#39;/about\u0026#39;, element:\u0026lt;About/\u0026gt; }, { path:\u0026#39;/contact\u0026#39;, element:\u0026lt;Contact/\u0026gt; }, { path:\u0026#39;/product/:id\u0026#39;, element:\u0026lt;Product/\u0026gt; } ]); function App(){ return \u0026lt;RouterProvider router={router}/\u0026gt; } export default App; Product.jsx\nimport {useParams} from \u0026#39;react-router-dom\u0026#39;; function Product(){ const {id}=useParams(); return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Product {id}\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ) } Here :id is the dynamic part of the route and we can access that part using useParams hook from react-router-dom.\n52.9 Absolute and Relative Paths Absolute paths are the paths that are defined from the root of the application and relative paths are the paths that are defined from the current route path.\nIn Absolute paths, we use the / at the start of the path and in relative paths, we don\u0026rsquo;t use / at the start of the path.\nExample:\nimport {createBrowserRouter,RouterProvider} from \u0026#39;react-router-dom\u0026#39;; import Home from \u0026#39;./Home\u0026#39;; import About from \u0026#39;./About\u0026#39;; import Contact from \u0026#39;./Contact\u0026#39;; import Product from \u0026#39;./Product\u0026#39;; //using absolute paths const router=createBrowserRouter([ { path:\u0026#39;/home\u0026#39;, element:\u0026lt;Home/\u0026gt; children:[ { path:\u0026#39;/home/about\u0026#39;, element:\u0026lt;About/\u0026gt; }, { path:\u0026#39;/home/contact\u0026#39;, element:\u0026lt;Contact/\u0026gt; } } ]) //using relative paths const router=createBrowserRouter([ { path:\u0026#39;home\u0026#39;, element:\u0026lt;Home/\u0026gt; children:[ { path:\u0026#39;about\u0026#39;, element:\u0026lt;About/\u0026gt; }, { path:\u0026#39;contact\u0026#39;, element:\u0026lt;Contact/\u0026gt; } ] } ]) 52.10 Index Routes const router=createBrowserRouter([ { path:\u0026#39;/\u0026#39;, element:\u0026lt;Layout/\u0026gt;, errorElement:\u0026lt;NotFound/\u0026gt;, children:[ { path:\u0026#39;/\u0026#39;, element:\u0026lt;Home/\u0026gt; }, { path:\u0026#39;/about\u0026#39;, element:\u0026lt;About/\u0026gt; }, { path:\u0026#39;/contact\u0026#39;, element:\u0026lt;Contact/\u0026gt; } ] }, ]); Here the route / is the index route and it is the default route that is rendered when the route is / so we can define the index route as the first route in the routes array.\nconst router=createBrowserRouter([ { path:\u0026#39;/\u0026#39;, element:\u0026lt;Layout/\u0026gt;, errorElement:\u0026lt;NotFound/\u0026gt;, children:[ { index:true, element:\u0026lt;Home/\u0026gt; }, { path:\u0026#39;/about\u0026#39;, element:\u0026lt;About/\u0026gt; }, { path:\u0026#39;/contact\u0026#39;, element:\u0026lt;Contact/\u0026gt; } ] }, ]); 52.11 useSearchParams Hook The useSearchParams hook is used to access the search parameters in the URL. It returns an array of two elements where the first element is the search parameters object and the second element is the function to update the search parameters.\nimport {useSearchParams} from \u0026#39;react-router-dom\u0026#39;; function Home(){ const [searchParams,setSearchParams]=useSearchParams(); return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Home\u0026lt;/h1\u0026gt; \u0026lt;h2\u0026gt;I am {searchParams.get(\u0026#39;name\u0026#39;)??\u0026#39;undefined\u0026#39;}\u0026lt;/h2\u0026gt; \u0026lt;button onClick={()=\u0026gt;setSearchParams({name:\u0026#39;active\u0026#39;})}\u0026gt;Set Name\u0026lt;/button\u0026gt; \u0026lt;button onClick={()=\u0026gt;setSearchParams({})}\u0026gt;Clear Name\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } It is like the useState hook but it is used to update the search parameters in the URL ad this also re-renders the component when the search parameters are updated.searchParams.get will always return a string.\n","permalink":"http://localhost:1313/posts/pages/react/react14/","summary":"Learn how to implement client-side routing in React applications using React Router Dom, including route setup, navigation, layouts, error handling, and dynamic routes.","title":"React : Day 14"},{"content":"50. StateManagement using react-redux 1. Introduction Reduct is the popular library for state management in react . To manage the state in react we can use the react-redux and @reduxjs/toolkit. In this article we will see how to use the react-redux and @reduxjs/toolkit to manage the state in react.\n2. Installation To install the react-redux and @reduxjs/toolkit we can use the following command.\nnpm install react-redux @reduxjs/toolkit 3. Create a store Folder Folder structure\nsrc |__store | |__index.js | |__counterSlice.js | |__toggleSlice.js Note: The folder structure is not mandatory. You can create the store folder anywhere in the src folder but its a good practice to create a separate folder for the store.\n4. Create a Slice A slice is a collection of reducer functions and actions for a specific feature. A slice is created using the createSlice function from the @reduxjs/toolkit. A slice contains the following properties.\nname: The name of the slice. initialState: The initial state of the slice. reducers: An object containing the reducer functions to handle the actions. Syntax:\nimport { createSlice } from \u0026#39;@reduxjs/toolkit\u0026#39;; const sliceName = createSlice({ name: \u0026#39;sliceName\u0026#39;, initialState: initialState, reducers: { reducerName: (state, action) =\u0026gt; { // reducer logic //action contain data send by dispatch function using action.payload }, reducerName: (state, action) =\u0026gt; { // reducer logic //action contain data send by dispatch function using action.payload } } }); action is optional. If the action does not require any parameter then we can skip the action. To get data from the action we must use action.payload otherwise it will not work. reducer function must be synncronous,pure function and must not have any side effect.\nExample of counterSlice.js\nimport { createSlice } from \u0026#39;@reduxjs/toolkit\u0026#39;; const counterSlice = createSlice({ name: \u0026#39;counter\u0026#39;, initialState: { value: 0 }, reducers: { increment: (state) =\u0026gt; { state.value += 1; }, decrement: (state) =\u0026gt; { state.value -= 1; }, incrementByAmount: (state, action) =\u0026gt; { state.value += action.payload; } } }); export const counterActions = counterSlice.actions; export default counterSlice; Example of toggleSlice.js\nimport { createSlice } from \u0026#39;@reduxjs/toolkit\u0026#39;; const toggleSlice = createSlice({ name: \u0026#39;toggle\u0026#39;, initialState: { value: false }, reducers: { toggle: (state) =\u0026gt; { state.value = !state.value; } } }); export const toggleActions = toggleSlice.actions; export default toggleSlice; Note: In Redux Toolkit, we can directly modify the state object instead of returning a completely new state object. This is possible because Redux Toolkit uses the Immer library under the hood. Immer automatically creates a new state object based on the changes we make to the current state.However, if we explicitly return a new state object, Redux Toolkit will skip Immer\u0026rsquo;s functionality and directly use the new state object as the updated state.\n5. Create a Store The store is created using the configureStore function from the @reduxjs/toolkit. The configureStore function takes an object as an argument with the following properties.\nreducer: An object containing the slices. Note: There is only one Store in the whole application.\nGeneral Syntax:\nimport { configureStore } from \u0026#39;@reduxjs/toolkit\u0026#39;; import SliceName from \u0026#39;./SliceName\u0026#39;; const store = configureStore({ reducer: { sliceName1: SliceName1.reducer SliceName2: SliceName2.reducer SliceName3: SliceName3.reducer } }); export default store; Note: The slicer name of key can be anything but the value should be the reducer function of the slice.\nExample of index.js\nimport { configureStore } from \u0026#39;@reduxjs/toolkit\u0026#39;; import counterSlice from \u0026#39;./counterSlice\u0026#39;; import toggleSlice from \u0026#39;./toggleSlice\u0026#39;; const store = configureStore({ reducer: { counter: counterSlice.reducer, toggle: toggleSlice.reducer } }); export default store; 6. Provide the Store The store is provided to the application using the Provider component from the react-redux. The Provider component takes the store as a prop.\nNote: Always wrap the root component of the application with the Provider component just because only warapped component and its children can access the store.\nExample of main.js/index.jsx\nimport React from \u0026#39;react\u0026#39;; import ReactDOM from \u0026#39;react-dom\u0026#39;; import { Provider } from \u0026#39;react-redux\u0026#39;; import store from \u0026#39;./store\u0026#39;; import App from \u0026#39;./App\u0026#39;; ReactDOM.render( \u0026lt;Provider store={store}\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/Provider\u0026gt;, document.getElementById(\u0026#39;root\u0026#39;) ); 7. Dispatch an Action To dispatch an action we can use the useDispatch hook from the react-redux. The useDispatch hook returns a reference to the dispatch function. We can use the dispatch function to dispatch an action.\nSyntax:\nimport { useDispatch } from \u0026#39;react-redux\u0026#39;; import { actionName } from \u0026#39;./sliceName\u0026#39;; function ComponentName() { const dispatch = useDispatch(); const handleClick = () =\u0026gt; { dispatch(actionName(parameter)); }; } Note: The parameter is optional. If the action does not require any parameter then we can skip the parameter.\nExample of Counter.js\nimport React from \u0026#39;react\u0026#39;; import { useDispatch } from \u0026#39;react-redux\u0026#39;; import { counterActions } from \u0026#39;./counterSlice\u0026#39;; import {toggleActions} from \u0026#39;./toggleSlice\u0026#39;; function Counter() { const dispatch = useDispatch(); const increment = () =\u0026gt; { dispatch(counterActions.increment()); }; const decrement = () =\u0026gt; { dispatch(counterActions.decrement()); }; const incrementByAmount = () =\u0026gt; { dispatch(counterActions.incrementByAmount(5)); }; const toggle = () =\u0026gt; { dispatch(toggleActions.toggle()); }; return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Counter\u0026lt;/h1\u0026gt; \u0026lt;button onClick={increment}\u0026gt;Increment\u0026lt;/button\u0026gt; \u0026lt;button onClick={decrement}\u0026gt;Decrement\u0026lt;/button\u0026gt; \u0026lt;button onClick={incrementByAmount}\u0026gt;Increment By 5\u0026lt;/button\u0026gt; \u0026lt;button onClick={toggle}\u0026gt;Toggle\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } export default Counter; When dispatch function is called all the components that are using the useSelector hook( using the state of the slice ) will be re-rendered.\n8. Access the State To access the state we can use the useSelector hook from the react-redux. The useSelector hook takes a function as an argument. The function takes the state as an argument and returns the part of the state that we want to access.\nSyntax:\nimport { useSelector } from \u0026#39;react-redux\u0026#39;; function ComponentName() { const state = useSelector((state) =\u0026gt; state.sliceName); } Example of Counter.js\nimport React from \u0026#39;react\u0026#39;; import { useSelector } from \u0026#39;react-redux\u0026#39;; function Counter() { const counter = useSelector((state) =\u0026gt; state.counter.value); const toggle = useSelector((state) =\u0026gt; state.toggle.value); return ( \u0026lt;div\u0026gt; {toggle \u0026amp;\u0026amp; \u0026lt;h1\u0026gt;Toggle\u0026lt;/h1\u0026gt;} \u0026lt;h1\u0026gt;Counter\u0026lt;/h1\u0026gt; \u0026lt;h2\u0026gt;{counter}\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; ); } export default Counter; ","permalink":"http://localhost:1313/posts/pages/react/react12/","summary":"Learn how to integrate Redux and Redux Toolkit in React for efficient state management, including slices, actions, and reducers.","title":"React : Day 12"},{"content":"51. Handling Asynchronous Data in redux Since the reducer function should be a pure function, it should not have any side effects. This means that we cannot make any API calls or perform any asynchronous operations inside the reducer function. To handle this, we can use\nPutting the asynchronous logic inside the component using useEffect hook. Here we dispatch when the component mounts and fetch the data from the API. Inside the action creator 51.1 Using useEffect hook In here we use useEffect to fetch the data from the API and dispatch the action to the reducer.Such that reducer updates the state.\nExample: Write a code to fetch the cart items from the API and update the state and when user adds an item to the cart, it should be updated in the state and also in the API.\n//cartSlice.js import { createSlice } from \u0026#39;@reduxjs/toolkit\u0026#39;; const cartSlice = createSlice({ name: \u0026#39;cart\u0026#39;, initialState: { items: [], totalQuantity: 0, changed: false }, reducers: { replaceCart(state, action) { state.totalQuantity = action.payload.totalQuantity; state.items = action.payload.items; }, addItemToCart(state, action) { const newItem = action.payload; const existingItem = state.items.find(item =\u0026gt; item.id === newItem.id); state.totalQuantity++; state.changed = true; if (!existingItem) { state.items.push({ id: newItem.id, price: newItem.price, quantity: 1, totalPrice: newItem.price }); } else { existingItem.quantity++; existingItem.totalPrice = existingItem.totalPrice + newItem.price; } }, removeItemFromCart(state, action) { const id = action.payload; const existingItem = state.items.find(item =\u0026gt; item.id === id); state.totalQuantity--; state.changed = true; if (existingItem.quantity === 1) { state.items = state.items.filter(item =\u0026gt; item.id !== id); } else { existingItem.quantity--; existingItem.totalPrice = existingItem.totalPrice - existingItem.price; } } } }); export const sendCartData = cartSlice.actions.sendCartData; export default cartSlice; //store/index.js import { configureStore } from \u0026#39;@reduxjs/toolkit\u0026#39;; import cartSlice from \u0026#39;./cart-slice\u0026#39;; const store = configureStore({ reducer: { cart: cartSlice.reducer } }); export default store; //App.js // App.js import React, { useEffect } from \u0026#39;react\u0026#39;; import { useDispatch, useSelector } from \u0026#39;react-redux\u0026#39;; import { cartActions } from \u0026#39;./store/cart-slice\u0026#39;; const DUMMY_PRODUCTS = [ { id: \u0026#39;p1\u0026#39;, price: 6, title: \u0026#39;My First Book\u0026#39;, description: \u0026#39;The first book I ever wrote\u0026#39; }, { id: \u0026#39;p2\u0026#39;, price: 5, title: \u0026#39;My Second Book\u0026#39;, description: \u0026#39;The second book I ever wrote\u0026#39; } ]; let isInitial = true; function App() { const dispatch = useDispatch(); const cart = useSelector(state =\u0026gt; state.cart); // Fetch cart data from an API on component mount useEffect(() =\u0026gt; { const fetchCartData = async () =\u0026gt; { const response = await fetch(\u0026#39;https://api.example.com/cart\u0026#39;); if (!response.ok) { throw new Error(\u0026#39;Could not fetch cart data!\u0026#39;); } const data = await response.json(); dispatch(cartActions.replaceCart({ items: data.items || [], totalQuantity: data.totalQuantity || 0, })); }; fetchCartData().catch(error =\u0026gt; { console.error(\u0026#39;Error fetching cart data:\u0026#39;, error); }); }, [dispatch]); // Send cart data to the API whenever the cart changes (except on initial load) useEffect(() =\u0026gt; { if (isInitial) { isInitial = false; return; } const sendCartData = async () =\u0026gt; { const response = await fetch(\u0026#39;https://api.example.com/cart\u0026#39;, { method: \u0026#39;PUT\u0026#39;, body: JSON.stringify(cart), headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39;, }, }); if (!response.ok) { throw new Error(\u0026#39;Sending cart data failed!\u0026#39;); } }; if (cart.changed) { sendCartData().catch(error =\u0026gt; { console.error(\u0026#39;Error sending cart data:\u0026#39;, error); }); } }, [cart]); // Add item to cart handler const addToCartHandler = (item) =\u0026gt; { dispatch(cartActions.addItemToCart(item)); }; return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Products\u0026lt;/h1\u0026gt; \u0026lt;ul\u0026gt; {DUMMY_PRODUCTS.map(product =\u0026gt; ( \u0026lt;li key={product.id}\u0026gt; \u0026lt;h2\u0026gt;{product.title}\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;{product.description}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;${product.price}\u0026lt;/p\u0026gt; \u0026lt;button onClick={() =\u0026gt; addToCartHandler(product)}\u0026gt;Add to Cart\u0026lt;/button\u0026gt; \u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; Whats Happen Here\nHere we use useEffect to fetch the cart data from the API and update after the data is fetched using dispatch. 51.2 Using action creator Thunk Same problem can be solved using action creator thunk. Here we can make the API call inside the action creator and dispatch the action to the reducer.\nHere we will call one dispatch and inside the dispatch we will call another dispatch to update the state.\nHere is the consice code\nconst Dispatch1=function (data)=\u0026gt;{ return async (dispatch)=\u0026gt;{ //code //APICALL //dispatch another action //dispatch(action) } } //App.js function App(){ const dispatch=useDispatch(); const Call=()=\u0026gt;{ dispatch(Dispatch1(data)) } return( \u0026lt;div\u0026gt; \u0026lt;button onClick={Call}\u0026gt;Click\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } =\u0026gt; Here when we call dispatch it will call the Dispatch1 function and inside the Dispatch1 function we can make the API call and dispatch the action to the reducer.\nfor example:\n// cart-slice.js import { createSlice } from \u0026#39;@reduxjs/toolkit\u0026#39;; const cartSlice = createSlice({ name: \u0026#39;cart\u0026#39;, initialState: { items: [], totalQuantity: 0, changed: false, }, reducers: { replaceCart(state, action) { state.totalQuantity = action.payload.totalQuantity; state.items = action.payload.items; }, addItemToCart(state, action) { const newItem = action.payload; const existingItem = state.items.find((item) =\u0026gt; item.id === newItem.id); state.totalQuantity++; state.changed = true; if (!existingItem) { state.items.push({ id: newItem.id, price: newItem.price, quantity: 1, totalPrice: newItem.price, }); } else { existingItem.quantity++; existingItem.totalPrice += newItem.price; } }, removeItemFromCart(state, action) { const id = action.payload; const existingItem = state.items.find((item) =\u0026gt; item.id === id); state.totalQuantity--; state.changed = true; if (existingItem.quantity === 1) { state.items = state.items.filter((item) =\u0026gt; item.id !== id); } else { existingItem.quantity--; existingItem.totalPrice -= existingItem.price; } }, }, }); export const cartActions = cartSlice.actions; // Async Action Creator Thunks export const fetchCartData = () =\u0026gt; { return async (dispatch) =\u0026gt; { const fetchData = async () =\u0026gt; { const response = await fetch(\u0026#39;https://api.example.com/cart\u0026#39;); if (!response.ok) { throw new Error(\u0026#39;Could not fetch cart data!\u0026#39;); } const data = await response.json(); return data; }; try { const cartData = await fetchData(); dispatch( cartActions.replaceCart({ items: cartData.items || [], totalQuantity: cartData.totalQuantity || 0, }) ); } catch (error) { console.error(\u0026#39;Fetching cart data failed:\u0026#39;, error); } }; }; export const sendCartData = (cart) =\u0026gt; { return async () =\u0026gt; { const sendRequest = async () =\u0026gt; { const response = await fetch(\u0026#39;https://api.example.com/cart\u0026#39;, { method: \u0026#39;PUT\u0026#39;, body: JSON.stringify(cart), headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39;, }, }); if (!response.ok) { throw new Error(\u0026#39;Sending cart data failed!\u0026#39;); } }; try { await sendRequest(); } catch (error) { console.error(\u0026#39;Error sending cart data:\u0026#39;, error); } }; }; export default cartSlice; store/index.js\n// store/index.js import { configureStore } from \u0026#39;@reduxjs/toolkit\u0026#39;; import cartSlice from \u0026#39;./cart-slice\u0026#39;; const store = configureStore({ reducer: { cart: cartSlice.reducer }, }); export default store; App.js\n// App.js import React, { useEffect } from \u0026#39;react\u0026#39;; import { useDispatch, useSelector } from \u0026#39;react-redux\u0026#39;; import { cartActions, fetchCartData, sendCartData } from \u0026#39;./store/cart-slice\u0026#39;; const DUMMY_PRODUCTS = [ { id: \u0026#39;p1\u0026#39;, price: 6, title: \u0026#39;My First Book\u0026#39;, description: \u0026#39;The first book I ever wrote\u0026#39; }, { id: \u0026#39;p2\u0026#39;, price: 5, title: \u0026#39;My Second Book\u0026#39;, description: \u0026#39;The second book I ever wrote\u0026#39; }, ]; let isInitial = true; function App() { const dispatch = useDispatch(); const cart = useSelector((state) =\u0026gt; state.cart); // Fetch cart data on mount useEffect(() =\u0026gt; { dispatch(fetchCartData()); }, [dispatch]); // Send cart data when it changes (except for the initial load) useEffect(() =\u0026gt; { if (isInitial) { isInitial = false; return; } if (cart.changed) { dispatch(sendCartData(cart)); } }, [cart, dispatch]); const addToCartHandler = (item) =\u0026gt; { dispatch(cartActions.addItemToCart(item)); }; return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Products\u0026lt;/h1\u0026gt; \u0026lt;ul\u0026gt; {DUMMY_PRODUCTS.map((product) =\u0026gt; ( \u0026lt;li key={product.id}\u0026gt; \u0026lt;h2\u0026gt;{product.title}\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;{product.description}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;${product.price}\u0026lt;/p\u0026gt; \u0026lt;button onClick={() =\u0026gt; addToCartHandler(product)}\u0026gt;Add to Cart\u0026lt;/button\u0026gt; \u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; 51.3 React dev tools React dev tools is a browser extension that allows you to inspect the React component hierarchy in the browser.\nNote: Redux and Context API is used to manage global level state in react application . Remember we always use usestate,usereducers to manage local state in react application.\n","permalink":"http://localhost:1313/posts/pages/react/react13/","summary":"Learn how to handle asynchronous data in Redux using useEffect and action creator thunks, and explore React Dev Tools for debugging.","title":"React : Day 13"},{"content":"46.Sending request to the server In react we can send request to the server using fetch api.\nExample:\nimport React, { useState } from \u0026#39;react\u0026#39;; const App = () =\u0026gt; { const [data, setData] = useState([]); const fetchData = async () =\u0026gt; { const response = await fetch(\u0026#39;https://jsonplaceholder.typicode.com/posts\u0026#39;); const data = await response.json(); setData(data); } return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={fetchData}\u0026gt;Fetch Data\u0026lt;/button\u0026gt; \u0026lt;ul\u0026gt; {data.map((item) =\u0026gt; ( \u0026lt;li key={item.id}\u0026gt;{item.title}\u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ) } 47.Custom Hook in React Custom hooks are JavaScript functions that utilize hooks to enable the reuse of stateful logic across different components.\n47.1 Folder Structure src\r|__hooks\r| |__useFetch.js\r|__components\r| |__App.js There is no any specific folder structure for custom hooks. You can create a folder named hooks and put all custom hooks in it for better organization.\n47.2 Creating Custom Hook We can create a custom hook by prefixing the function name with use keyword.\n// useFetch.js import { useState, useEffect } from \u0026#39;react\u0026#39;; const useFetch = (url) =\u0026gt; { const [data, setData] = useState([]); const [loading, setLoading] = useState(true); useEffect(() =\u0026gt; { const fetchData = async () =\u0026gt; { setLoading(true); const response = await fetch(url); const data = await response.json(); setData(data); setLoading(false); } fetchData(); }, [url]); return { data, loading }; } export default useFetch; 47.3 Using Custom Hook // App.js import React from \u0026#39;react\u0026#39;; import useFetch from \u0026#39;../hooks/useFetch\u0026#39;; const App = () =\u0026gt; { const { data, loading } = useFetch(\u0026#39;https://jsonplaceholder.typicode.com/posts\u0026#39;); return ( \u0026lt;div\u0026gt; {loading ? \u0026lt;p\u0026gt;Loading...\u0026lt;/p\u0026gt; : ( \u0026lt;ul\u0026gt; {data.map((item) =\u0026gt; ( \u0026lt;li key={item.id}\u0026gt;{item.title}\u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; )} \u0026lt;/div\u0026gt; ) } export default App; Note: Custom hook are isolated with each other. They can\u0026rsquo;t share state or logic between them.\n48.React Form In react we can handle form using multiple ways.\nuseState Hook useRef Hook Formdata API 48.1 Removing default behavior When i submit a form, the page reloads. To prevent this default behavior, we can use e.preventDefault() method.\nimport React, { useState } from \u0026#39;react\u0026#39;; const App = () =\u0026gt; { const [name, setName] = useState(\u0026#39;\u0026#39;); const handleSubmit = (e) =\u0026gt; { e.preventDefault(); console.log(name); } return ( \u0026lt;form onSubmit={handleSubmit}\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; value={name} onChange={(e) =\u0026gt; setName(e.target.value)} /\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;Submit\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; ) } export default App; 48.2 Form Data with useState import React, { useState } from \u0026#39;react\u0026#39;; const App = () =\u0026gt; { const [formData, setFormData] = useState({ name: \u0026#39;\u0026#39;, email: \u0026#39;\u0026#39; }); const handleSubmit = (e) =\u0026gt; { e.preventDefault(); console.log(formData); } return ( \u0026lt;form onSubmit={handleSubmit}\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; value={formData.name} onChange={(e) =\u0026gt; setFormData({ ...formData, name: e.target.value })} /\u0026gt; \u0026lt;input type=\u0026#34;email\u0026#34; value={formData.email} onChange={(e) =\u0026gt; setFormData({ ...formData, email: e.target.value })} /\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;Submit\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; ) } export default App; 48.3 Form Data with useRef import React, { useRef } from \u0026#39;react\u0026#39;; const App = () =\u0026gt; { const nameRef = useRef(); const emailRef = useRef(); const handleSubmit = (e) =\u0026gt; { e.preventDefault(); console.log(nameRef.current.value, emailRef.current.value); } return ( \u0026lt;form onSubmit={handleSubmit}\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; ref={nameRef} /\u0026gt; \u0026lt;input type=\u0026#34;email\u0026#34; ref={emailRef} /\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;Submit\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; ) } export default App; 48.4 Form Data with FormData API import React from \u0026#39;react\u0026#39;; const App = () =\u0026gt; { const handleSubmit = (e) =\u0026gt; { e.preventDefault(); const formData = new FormData(e.target); console.log(formData.get(\u0026#39;name\u0026#39;), formData.get(\u0026#39;email\u0026#39;)); } return ( \u0026lt;form onSubmit={handleSubmit}\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;name\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;email\u0026#34; name=\u0026#34;email\u0026#34; /\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;Submit\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; ) } export default App; Using FormData API, we can easily get form data without using useState or useRef hooks.\nimport React from \u0026#39;react\u0026#39;; const App = () =\u0026gt; { const handleSubmit = (e) =\u0026gt; { e.preventDefault(); const formData = new FormData(e.target); const data=Object.fromEntries(formData.entries()); console.log(data); data.check=formData.getAll(\u0026#39;check\u0026#39;); console.log(data); } return ( \u0026lt;form onSubmit={handleSubmit}\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;name\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;email\u0026#34; name=\u0026#34;email\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;check\u0026#34; value=\u0026#34;i want coffee\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;check\u0026#34; calue=\u0026#34;i want gold\u0026#34; /\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;Submit\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; ) } export default App; get(name) : Returns the first value associated with a given key from within a FormData object.\ngetAll(name) : Returns all the values associated with a given key from within a FormData object.\n48.5 Reseating Form Data Of useState import React, { useState } from \u0026#39;react\u0026#39;; const App = () =\u0026gt; { const [formData, setFormData] = useState({ name: \u0026#39;\u0026#39;, email: \u0026#39;\u0026#39; }); const handleSubmit = (e) =\u0026gt; { e.preventDefault(); console.log(formData); setFormData({ name: \u0026#39;\u0026#39;, email: \u0026#39;\u0026#39; }); } return ( \u0026lt;form onSubmit={handleSubmit}\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; value={formData.name} onChange={(e) =\u0026gt; setFormData({ ...formData, name: e.target.value })} /\u0026gt; \u0026lt;input type=\u0026#34;email\u0026#34; value={formData.email} onChange={(e) =\u0026gt; setFormData({ ...formData, email: e.target.value })} /\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;Submit\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; ) } export default App; Of useRef import React, { useRef } from \u0026#39;react\u0026#39;; const App = () =\u0026gt; { const nameRef = useRef(); const emailRef = useRef(); const handleSubmit = (e) =\u0026gt; { e.preventDefault(); console.log(nameRef.current.value, emailRef.current.value); nameRef.current.value = \u0026#39;\u0026#39;; emailRef.current.value = \u0026#39;\u0026#39;; } return ( \u0026lt;form onSubmit={handleSubmit}\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; ref={nameRef} /\u0026gt; \u0026lt;input type=\u0026#34;email\u0026#34; ref={emailRef} /\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;Submit\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; ) } export default App; Of FormData API import React from \u0026#39;react\u0026#39;; const App = () =\u0026gt; { const handleSubmit = (e) =\u0026gt; { e.preventDefault(); const formData = new FormData(e.target); console.log(formData.get(\u0026#39;name\u0026#39;), formData.get(\u0026#39;email\u0026#39;)); e.target.reset(); } return ( \u0026lt;form onSubmit={handleSubmit}\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;name\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;email\u0026#34; name=\u0026#34;email\u0026#34; /\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;Submit\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; ) } export default App; 49. Validation in React In react we can validate form data using multiple ways.\nvalidate on every keystroke(using useState) validate on form submission(using useRef) validate on blur (onBlur event) validate on focus(onFocus event) using browser validation Combining all types of validation in a single form. ","permalink":"http://localhost:1313/posts/pages/react/react11/","summary":"Explore how to send server requests with fetch, build custom hooks for data fetching, and handle form submissions using useState, useRef, or the FormData API.","title":"React : Day 11"},{"content":"44. Optimizing Performance 44.1. memo memo is a higher-order function in React that optimizes functional components by preventing unnecessary re-renders. It returns a new component that behaves the same as the original one but only re-renders if its props change or internal state changes not every time the parent component re-renders.\nWhy Use memo? When a parent component re-renders, all its child components also re-render by default—even if their props remain unchanged. This behavior can lead to performance bottlenecks. Using memo, we can avoid these unnecessary re-renders for child components.\nExample:\nimport { memo } from \u0026#39;react\u0026#39;; const MyComponent = memo((props) =\u0026gt; { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;{props.title}\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ); }); export default MyComponent; In the above example, the MyComponent functional component is wrapped with the memo function. This ensures that the component will only re-render if its props have changed or if its satate has been change not every time the parent component re-renders.\nUse Case:\nBefore using memo: In this example, the Custom component re-renders unnecessarily whenever the parent component re-renders, even if its props haven\u0026rsquo;t changed or internal state hasn\u0026rsquo;t changed. Custom.js import { useState } from \u0026#39;react\u0026#39;; const Custom = ({ title }) =\u0026gt; { const [count, setCount] = useState(0); return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;{title}\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;{count}\u0026lt;/p\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;Increment\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); }; export default Custom; App.js\nimport { useState } from \u0026#39;react\u0026#39;; import Custom from \u0026#39;./Custom\u0026#39;; function App() { const [count, setCount] = useState(0); return ( \u0026lt;div\u0026gt; \u0026lt;Custom title=\u0026#34;Counter\u0026#34; /\u0026gt; \u0026lt;p\u0026gt;{count}\u0026lt;/p\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;Increment Parent Count\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; Problem: The Custom component re-renders whenever the count state in the App component changes, even though the title prop remains the same. This can cause unnecessary rendering and reduce performance.i.e child component re-renders even if the props are not changed when the parent component re-renders.\nAfter using memo: Using memo, we can optimize the Custom component to only re-render when its props change. Custom.jsx import { useState, memo } from \u0026#39;react\u0026#39;; const Custom = memo(({ title }) =\u0026gt; { const [count, setCount] = useState(0); return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;{title}\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;{count}\u0026lt;/p\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;Increment\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); }); export default Custom; App.js\nimport { useState } from \u0026#39;react\u0026#39;; import Custom from \u0026#39;./Custom\u0026#39;; function App() { const [count, setCount] = useState(0); return ( \u0026lt;div\u0026gt; \u0026lt;Custom title=\u0026#34;Counter\u0026#34; /\u0026gt; \u0026lt;p\u0026gt;{count}\u0026lt;/p\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;Increment Parent Count\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; After using memo the Custom component will only re-render when its props change or state change i.e when the title prop changes or the count state of the Custom component changes . It will not re-render when the count state of the App component changes, which optimizes performance in this scenario as that change does not affect the Custom component.\n44.2. useCallback In every rerender of a component, the functions defined inside the component are recreated. This can lead to performance issues, especially when passing functions as props to child components. useCallback is a hook in React that memoizes functions to prevent unnecessary re-creations.\nSyntax:\nuseCallback(fn, dependencies) fn: The function value that you want to cache. It can take any arguments and return any values. React will return (not call!) your function back to you during the initial render. On next renders, React will give you the same function again if the dependencies have not changed since the last render. Otherwise, it will give you the function that you have passed during the current render, and store it in case it can be reused later. React will not call your function. The function is returned to you so you can decide when and whether to call it. dependencies: An array of values that, when changed, will cause the function to be re-created. If the dependencies array is empty, the function will only be created once, and will not be re-created on subsequent renders. Whats the use of dependencies array in useCallback? just because dependency array the function is recreated with the new values of the dependencies.\nBefore using useCallback:\nimport { useState,memo } from \u0026#39;react\u0026#39;; const Child = memo(({ handleClick }) =\u0026gt; { return ( \u0026lt;button onClick={handleClick}\u0026gt;Click Me\u0026lt;/button\u0026gt; ); }); const Parent = () =\u0026gt; { const [count, setCount] = useState(0); const handleClick = () =\u0026gt; { setCount(count + 1); }; return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;{count}\u0026lt;/p\u0026gt; \u0026lt;Child handleClick={handleClick} /\u0026gt; \u0026lt;/div\u0026gt; ); }; In the above example, the handleClick function is re-created on every re-render of the Parent component. As a result, the reference to the handleClick function passed as a prop to the Child component changes on every re-render of the Parent component. This causes the Child component to re-render unnecessarily, even though the handleClick function remains logically the same After using useCallback:\nimport { useState, useCallback, memo } from \u0026#39;react\u0026#39;; const Child = memo(({ handleClick }) =\u0026gt; { return ( \u0026lt;button onClick={handleClick}\u0026gt;Click Me\u0026lt;/button\u0026gt; ); }); const Parent = () =\u0026gt; { const [count, setCount] = useState(0); const handleClick = useCallback(() =\u0026gt; { setCount(count + 1); }, [count]); return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;{count}\u0026lt;/p\u0026gt; \u0026lt;Child handleClick={handleClick} /\u0026gt; \u0026lt;/div\u0026gt; ); }; By using useCallback, the handleClick function is memoized and will only be re-created when the count state changes. The reference to the handleClick function remains the same across re-renders of the Parent component unless the dependencies specified in the dependency array (in this case, [count]) change. This ensures that the Child component only re-renders when the count state changes, and not when the handleClick function reference changes, thus improving performance.\n44.3. useMemo useMemo is a hook in React that memoizes the result of a function. It is similar to useCallback, but instead of memoizing a function, it memoizes the result of a function.\nSyntax:\nconst cachedValue = useMemo(calculateValue, dependencies) calculateValue: The function calculating the value that you want to cache. It should be pure, should take no arguments, and should return a value of any type. React will call your function during the initial render. On next renders, React will return the same value again if the dependencies have not changed since the last render. Otherwise, it will call calculateValue, return its result, and store it so it can be reused later. dependencies: An array of values that, when changed, will cause the function to be re-executed.\nreturn On the initial render, useMemo returns the result of calling calculateValue with no arguments.During next renders, it will either return an already stored value from the last render (if the dependencies haven’t changed), or call calculateValue again, and return the result that calculateValue has returned.\nBefore using useMemo:\nimport { useState, memo } from \u0026#39;react\u0026#39;; const fibonacci = (n) =\u0026gt; { if (n \u0026lt;= 1) { return n; } return fibonacci(n - 1) + fibonacci(n - 2); }; const Fib = ()=\u0026gt;{ const [count, setCount] = useState(1); const result = fibonacci(100000000000); return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;{result} and count is {count}\u0026lt;/p\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;Increase Count\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } In the above example, the fibonacci function is called on every re-render of the Fib component. This can lead to performance issues, especially when the function is computationally expensive. In this case, the fibonacci function is called with a large number, which can cause the component to freeze or crash.\nAfter using useMemo:\nimport { useState, useMemo } from \u0026#39;react\u0026#39;; const fibonacci = (n) =\u0026gt; { if (n \u0026lt;= 1) { return n; } return fibonacci(n - 1) + fibonacci(n - 2); }; const Fib = ()=\u0026gt;{ const [count, setCount] = useState(1); const result = useMemo(() =\u0026gt; fibonacci(100000000000), []); return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;{result} and count is {count}\u0026lt;/p\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;Increase Count\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } By using useMemo, the result of the fibonacci function is memoized and will only be re-calculated when the dependencies specified in the dependency array change. In this case, the fibonacci function is only called once during the initial render of the Fib component, and the result is stored and reused on subsequent renders. This optimizes performance by preventing unnecessary re-calculation of the fibonacci function on every re-render of the component.\n45.Key conside a scenarion where your base component state variable need to be initialized with the value of the props passed to the component. since the state variable is initialized with the props value, the state variable will not be updated when the props value changes as it is initialized only. to handle we can either use useEffect or we can use key prop.\nUsing useEffect:\nimport { useEffect, useState } from \u0026#39;react\u0026#39;; const Parent = () =\u0026gt; { const [value, setValue] = useState(0); return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={() =\u0026gt; setValue(value + 1)}\u0026gt;Increment\u0026lt;/button\u0026gt; \u0026lt;Child value={value} /\u0026gt; \u0026lt;/div\u0026gt; ); }; const Child = ({ value }) =\u0026gt; { const [stateValue, setStateValue] = useState(value); useEffect(() =\u0026gt; { setStateValue(value); }, [value]); return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;State Value: {stateValue}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Props Value: {value}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); }; stateValue is initialized with the value prop and const [stateValue, setStateValue] = useState(value); runs only once during initial render so useEffect is used to update the stateValue when the value prop changes.\nUsing key prop:\nimport { useState } from \u0026#39;react\u0026#39;; const Parent = () =\u0026gt; { const [value, setValue] = useState(0); return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={() =\u0026gt; setValue(value + 1)}\u0026gt;Increment\u0026lt;/button\u0026gt; \u0026lt;Child key={value} value={value} /\u0026gt; \u0026lt;/div\u0026gt; ); }; const Child = ({ value }) =\u0026gt; { const [stateValue, setStateValue] = useState(value); return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;State Value: {stateValue}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Props Value: {value}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); }; IN the above example,When a key changes between renders, React will create a new instance of the component. By using the key prop with the value prop, we ensure that a new instance of the Child component is created whenever the value prop changes. This allows the stateValue to be initialized with the new value prop on every render, without the need for useEffect.\nNote:The useState() hook us run only one time during the initial render of the component. If the state variable is initialized with a prop value, it will not be updated when the prop value changes. To handle this scenario, we can use the useEffect() hook to update the state variable when the prop value changes. Alternatively, we can use the key prop to create a new instance of the component whenever the prop value changes, allowing the state variable to be initialized with the new prop value on every render. Similar goes for useReducer() and useRef() hooks as well.\n","permalink":"http://localhost:1313/posts/pages/react/react10/","summary":"Learn how to optimize React applications using memo for component memoization, useCallback for function memoization, and useMemo for value memoization.","title":"React : Day 10"},{"content":"40. useEffect useEffect is a React hook that lets you perform side effects in functional components. Common use cases include:\nEstablishing a database connection when the DOM content loads. Updating the page title when the content changes. Note: The useEffect hook runs after the component has rendered.\n41. What to Put in useEffect Use useEffect for:\nNetwork requests Operations that take time to complete (e.g., fetching data, setting timers, etc.) 42. useEffect Syntax 42.1. Importing useEffect import React, { useEffect } from \u0026#39;react\u0026#39;; 42.2. useEffect Syntax useEffect(() =\u0026gt; { // code here return () =\u0026gt; { // cleanup code here }; }, [dependencies]); The first argument is a function containing the code to execute. The second argument is an array of dependencies. If any dependency changes, the function runs again. The return statement is optional and is used for cleanup tasks, such as removing event listeners or canceling subscriptions. This cleanup function is executed: Just before the the useEffect function runs again cause due to dependency change, with variables from the previous render. After the component unmounts (i.e., when removed from the DOM). Note: When your component is added to the DOM, React runs the setup function. After each re-render with changed dependencies, React first executes the cleanup function (if provided) with old values, then runs the setup function with new values.\nExample: useEffect(() =\u0026gt; { const id = setTimeout(() =\u0026gt; { console.log(count); }, 1000); return () =\u0026gt; { clearTimeout(id); }; }, [count]); In this example, the useEffect hook runs whenever the count variable changes. It sets a timeout to log the count value after 1 second, and the cleanup function clears the previous timeout before the next execution. Cleanup Function:\nUsed for tasks like removing event listeners or clearing timeouts. Ensures stale operations are cleared before new ones are executed. Executes when dependencies change or when the component unmounts. 43. Variations of useEffect 43.1. useEffect Without Dependencies Array useEffect(() =\u0026gt; { // code here }); The useEffect function runs after every re-render. 43.2. useEffect With Empty Dependencies Array useEffect(() =\u0026gt; { // code here }, []); The useEffect function runs only once after the initial render, making it ideal for tasks like loading local storage data. 43.3. useEffect With Multiple Dependencies useEffect(() =\u0026gt; { // code here }, [count, name]); The useEffect function runs when either count or name changes. Note: In all of the variation, useEffect always runs after the first render no matter what is passed in the dependencies array.\nExample: Loading Local Storage Data Correct Usage:\nimport React, { useState, useEffect } from \u0026#39;react\u0026#39;; const App = () =\u0026gt; { const [data, setData] = useState([]); useEffect(() =\u0026gt; { const data = localStorage.getItem(\u0026#39;data\u0026#39;); if (data) { setData(JSON.parse(data)); } }, []); return ( \u0026lt;div\u0026gt; {data.map((item, index) =\u0026gt; ( \u0026lt;p key={index}\u0026gt;{item}\u0026lt;/p\u0026gt; ))} \u0026lt;/div\u0026gt; ); }; Incorrect Usage:\nimport React, { useState } from \u0026#39;react\u0026#39;; const App = () =\u0026gt; { const [data, setData] = useState([]); const loadData = () =\u0026gt; { const data = localStorage.getItem(\u0026#39;data\u0026#39;); if (data) { setData(JSON.parse(data)); } }; loadData(); return ( \u0026lt;div\u0026gt; {data.map((item, index) =\u0026gt; ( \u0026lt;p key={index}\u0026gt;{item}\u0026lt;/p\u0026gt; ))} \u0026lt;/div\u0026gt; ); }; Problem: Calling loadData directly causes an infinite loop because it triggers a re-render, which calls loadData again. Solution: Use useEffect with an empty dependency array to ensure the function runs only once after the initial render. Note: useEffect(()=\u0026gt;{},[]) runs on every mount not on every render\n","permalink":"http://localhost:1313/posts/pages/react/react9/","summary":"Learn how to use the useEffect hook in React for performing side effects in functional components.","title":"React : Day 9"},{"content":"38. Understanding the Concept of Prop Drilling Prop drilling refers to the process of passing data from a parent component to a deeply nested child component through all the intermediate components, even if those intermediate components don’t need the data themselves. Let’s break this down with an example.\nComponent Tree Imagine the following component hierarchy: Now, suppose we want to transfer some data from the Product component to the Cart component. Since Product and Cart are in separate branches of the component tree, they don’t have a direct connection.\nHow Prop Drilling Works To make this work, we need to store the shared state in a common ancestor, which is the App component in this case. Then, we have to pass the state down through all the intermediate components, even if those components don’t actually use the data.\nHere’s a visual representation of this:\nData flows from Product → Shop → App (common ancestor). The data then flows from App → Header → CardModel → Cart. This creates a lot of unnecessary overhead because the intermediate components (Shop, Header, and CardModel) don’t need the data but still have to handle it.\nProp drilling can quickly become cumbersome in large applications with deeply nested components. To solve this, we can use state management tools like Redux, Context API, or React Query, which allow us to manage and share state more effectively without passing it through every component.\n39. Introduction to React Context API Context API is a feature in React that allows you to share data between components without having to pass props down manually at every level. It provides a way to pass data through the component tree without having to pass props down manually at every level as shown in the image below.\nHow to use context API Create a context using the createContext function. import { createContext } from \u0026#39;react\u0026#39;; const CartContext = createContext(); export default CartContext; Wrap the parent component with the Provider component. Which Component to wrap? Wrap to the common ancestor of the components that need the context data. In the example below, we wrap the App component with the Provider component. For Example:\nimport CartContext from \u0026#39;./store/CartContext\u0026#39;; function App() { return ( \u0026lt;CartContext.Provider value={data}\u0026gt; \u0026lt;Header /\u0026gt; \u0026lt;Shop /\u0026gt; \u0026lt;/CartContext.Provider\u0026gt; ); } Explaination:Since we want to share the product Component data with the Cart Component SO in order to do that we wrap the first common ancestor of the Product and Cart Component i.e App Component with the Provider Component and pass the data to the value prop of the Provider Component.\nAccess the context data in the child component using the useContext hook. for example:\nimport { useContext } from \u0026#39;react\u0026#39;; import CartContext from \u0026#39;../store/CartContext\u0026#39;; function Cart() { const cartCtx = useContext(CartContext); return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Cart\u0026lt;/h1\u0026gt; {cartCtx.products.map(product =\u0026gt; ( \u0026lt;p key={product.id}\u0026gt;{product.name}\u0026lt;/p\u0026gt; ))} \u0026lt;/div\u0026gt; ); } What Whappen when the data is updated? When the data is updated in the Provider component, all the child components that are using the context data will be re-rendered automatically. Task: Design a simple application that has a component called App. App has two child components: Header and Shop. Header has one child, CartModel, and Shop has one child, Product. Pass the data from the Product component to the CartModel component using the Context API.\nStructure of the project\nsrc\r|_components\r|_App\r|_App.js\r|_Header\r|_Header.js\r|_CartModel.js\r|_Shop\r|_Shop.js\r|_Product.js\r|_store\r|_CartContext.js CartContext.js\nimport { createContext } from \u0026#39;react\u0026#39;; const CartContext = createContext(); export default CartContext; App.js\nimport CartContext from \u0026#39;../store/CartContext\u0026#39;; import Header from \u0026#39;../Header/Header\u0026#39;; import Shop from \u0026#39;../Shop/Shop\u0026#39;; import { useState } from \u0026#39;react\u0026#39;; function App() { const [cartProducts, setCartProducts] = useState([]); const addProductToCart = (product) =\u0026gt; { setCartProducts((prevProducts) =\u0026gt; [...prevProducts, product]); }; return ( \u0026lt;CartContext.Provider value={ { products: cartProducts, addProduct: addProductToCart } }\u0026gt; \u0026lt;Header /\u0026gt; \u0026lt;Shop /\u0026gt; \u0026lt;/CartContext.Provider\u0026gt; ); } export default App; Header.js\nimport CartModel from \u0026#39;./CartModel\u0026#39;; function Header() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Header\u0026lt;/h1\u0026gt; \u0026lt;CartModel /\u0026gt; \u0026lt;/div\u0026gt; ); } export default Header; CartModel.js\nimport { useContext } from \u0026#39;react\u0026#39;; import CartContext from \u0026#39;../../store/CartContext\u0026#39;; function CartModel() { const cartCtx = useContext(CartContext); return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;CartModel\u0026lt;/h1\u0026gt; {cartCtx.products.map(product =\u0026gt; ( \u0026lt;p key={product.id}\u0026gt;{product.name}\u0026lt;/p\u0026gt; ))} \u0026lt;/div\u0026gt; ); } export default CartModel; Shop.js\nimport Product from \u0026#39;./Product\u0026#39;; function Shop() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Shop\u0026lt;/h1\u0026gt; \u0026lt;Product /\u0026gt; \u0026lt;/div\u0026gt; ); } export default Shop; Product.js\nimport { useContext } from \u0026#39;react\u0026#39;; import CartContext from \u0026#39;../../store/CartContext\u0026#39;; function Product() { const cartCtx = useContext(CartContext); const product = { id: 1, name: \u0026#39;Laptop\u0026#39; }; return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Product\u0026lt;/h1\u0026gt; \u0026lt;button onClick={() =\u0026gt; cartCtx.addProduct(product)}\u0026gt;Add to Cart\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } export default Product; Outsoursing the Context Provider Since all the logic related to the context is in the App Component so we can outsource the context provider and its logic to a separate component in order to make the App Component more clean and readable.\nCartContext.js\nimport { createContext, useState } from \u0026#39;react\u0026#39;; const CartContext = createContext(); export const CartContextProvider = (props) =\u0026gt; { const [cartProducts, setCartProducts] = useState([]); const addProductToCart = (product) =\u0026gt; { setCartProducts((prevProducts) =\u0026gt; [...prevProducts, product]); }; const context = { products: cartProducts, addProduct: addProductToCart }; return ( \u0026lt;CartContext.Provider value={context}\u0026gt; {props.children} \u0026lt;/CartContext.Provider\u0026gt; ); }; App.js\nimport Header from \u0026#39;../Header/Header\u0026#39;; import Shop from \u0026#39;../Shop/Shop\u0026#39;; import { CartContextProvider } from \u0026#39;../store/CartContext\u0026#39;; function App() { return ( \u0026lt;CartContextProvider\u0026gt; \u0026lt;Header /\u0026gt; \u0026lt;Shop /\u0026gt; \u0026lt;/CartContextProvider\u0026gt; ); } export default App; Other Components remain the same.\n39.UseReducer Hook in React USe reducer is a hook that is used for state management in React. It is an alternative to useState. It is usually preferable when you have complex state logic that involves multiple sub-values or when the next state depends on the previous one.\nHow to use useReducer Hook Create a reducer function. A reducer function is a function that takes the current state and an action as arguments and returns a new state based on the action type.action . action:It contains the object that is sent by the dispatch function. For Example:\nconst counterReducer = (state, action) =\u0026gt; { if (action.type === \u0026#39;INCREMENT\u0026#39;) { return { counter: state.counter + 1 }; } if (action.type === \u0026#39;DECREMENT\u0026#39;) { return { counter: state.counter - 1 }; } return state; }; Here, the reducer function takes two arguments: state and action. It checks the action type and returns a new state based on the action type.\nUse the useReducer hook in the component. The useReducer hook takes two arguments: the reducer function and the initial state and returns the current state and a dispatch function as an array which is shown below. For Example: import { useReducer } from \u0026#39;react\u0026#39;; const [counterState, dispatchCounter] = useReducer(counterReducer, { counter: 0 }); Here, counterState is the current state and dispatchCounter is the dispatch function that is used to dispatch an action to the reducer function and { counter: 0 } is the initial state such that the counter is initialized to 0.\nDispatch an action to the reducer function. To dispatch an action to the reducer function, you need to call the dispatch function with an object that contains the action type and any additional data that is required by the reducer function. For Example: dispatchCounter({ type: \u0026#39;INCREMENT\u0026#39; }); To change the state, you need to call the dispatch function with an object that contains the action type.Here, the action type is \u0026lsquo;INCREMENT\u0026rsquo; which increments the counter by 1.\nTask: Design a simple counter application that has a component called Counter. The Counter component has two buttons: Increment and Decrement. Use the useReducer hook to manage the state of the counter.\nStructure of the project\nsrc\r|_components\r|_Counter\r|_Counter.js Counter.js\nimport { useReducer } from \u0026#39;react\u0026#39;; const counterReducer = (state, action) =\u0026gt; { if (action.type === \u0026#39;INCREMENT\u0026#39;) { return { counter: state.counter + 1 }; } if (action.type === \u0026#39;DECREMENT\u0026#39;) { return { counter: state.counter - 1 }; } return state; }; function Counter() { const [counterState, dispatchCounter] = useReducer(counterReducer, { counter: 0 }); const handleIncrement = () =\u0026gt; { dispatchCounter({ type: \u0026#39;INCREMENT\u0026#39; }); }; const handleDecrement = () =\u0026gt; { dispatchCounter({ type: \u0026#39;DECREMENT\u0026#39; }); }; return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Counter\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;{counterState.counter}\u0026lt;/p\u0026gt; \u0026lt;button onClick={handleIncrement}\u0026gt;Increment\u0026lt;/button\u0026gt; \u0026lt;button onClick={handleDecrement}\u0026gt;Decrement\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } If we use useState hook then the code will be like this:\nimport { useState } from \u0026#39;react\u0026#39;; function Counter() { const [counter, setCounter] = useState(0); const handleIncrement = () =\u0026gt; { setCounter(counter=\u0026gt;counter + 1); }; const handleDecrement = () =\u0026gt; { setCounter(counter=\u0026gt;counter - 1); }; return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Counter\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;{counter}\u0026lt;/p\u0026gt; \u0026lt;button onClick={handleIncrement}\u0026gt;Increment\u0026lt;/button\u0026gt; \u0026lt;button onClick={handleDecrement}\u0026gt;Decrement\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } What is the difference between useState and useReducer?\nuseState is a simple and straightforward way to manage state in React. It is suitable for managing simple state logic. useReducer is more powerful and flexible than useState. It is suitable for managing complex state logic that involves multiple sub-values or when the next state depends on the previous one. Looking the example case Scenario: Here using reducer we write all the logic in a single function and then we dispatch the action to the reducer function and then the reducer function returns the new state based on the action type. This makes the code more readable and maintainable.\nbut in the case of useState, we have to write the logic for each state change separately which makes the code more complex and difficult to maintain.\nNote: Always change in state variable will cause the re-rendering of the component.\n","permalink":"http://localhost:1313/posts/pages/react/react8/","summary":"Learn about prop drilling and how to use the Context API in React to manage and share state effectively.","title":"React : Day 8"},{"content":"1.1 When to use asyncio? Asyncio is a library to write concurrent code using the async/await syntax. It is a single-threaded, single-process design that is ideal for I/O-bound and high-level structured network code. It is not suitable for CPU-bound code, which is better handled by the multiprocessing module.It is used for :\n2.1 Coroutine Think of a coroutine like a regular Python function but with the superpower that it can pause its execution when it encounters an operation that could take a while to complete. When that long-running operation is complete, we can “wake up” our paused coroutine and finish executing any other code in that coroutine. While a paused coroutine is waiting for the operation it paused for to finish, we can run other code. This running of other code while waiting is what gives our application concur rency. We can also run several time-consuming operations concurrently, which can give our applications big performance improvements. To both create and pause a coroutine, we’ll need to learn to use Python’s async and await keywords. The async keyword will let us define a coroutine; the await key word will let us pause our coroutine when we have a long-running operation.\n2.2 Creating a coroutine with async creating a coroutine is straightforward and not much different from creating a nor mal Python function. The only difference is that, instead of using the def keyword, we use async def. The async keyword marks a function as a coroutine instead of a nor mal Python function.\nimport asyncio async def mero_coroutine(): print(\u0026#34;Hello From Asyncio\u0026#34;) The coroutine in the preceding listing does nothing yet other than print “Hello world!” It’s also worth noting that this coroutine does not perform any long-running operations; it just prints our message and returns. This means that, when we put the coroutine on the event loop, it will execute immediately because we don’t have any blocking I/O, and nothing is pausing execution yet. This syntax is simple, but we’re creating something very different from a plain Python function. To illustrate this, let’s create a function that adds one to an integer as well as a coroutine that does the same and compare the results of calling each. We’ll also use the type convenience function to look at the type returned by calling a corou tine as compared to calling our normal function.\ndef add_function(a,b): return a+b async def add_coroutine(a,b): return a+b function=add_function(1,2) coroutine=add_coroutine(1,2) print(type(function)) print(type(coroutine)) When we run this code, we’ll see output like the following\nMethod result is 3 and the type is \u0026lt;class \u0026#39;int\u0026#39;\u0026gt;\rCoroutine result is \u0026lt;coroutine object coroutine_add_one at 0x1071d6040\u0026gt; and the type is \u0026lt;class \u0026#39;coroutine\u0026#39;\u0026gt; Notice how when we call our normal add_one function it executes immediately and returns what we would expect, another integer. However, when we call coroutine_ add_one we don’t get our code in the coroutine executed at all. We get a coroutine object instead. This is an important point, as coroutines aren’t executed when we call them directly. Instead, we create a coroutine object that can be run later. To run a corou tine, we need to explicitly run it on an event loop. So how can we create an event loop and run our coroutine?\nIn versions of Python older than 3.7, we had to create an event loop if one did not already exist. However, the asyncio library has added several functions that abstract the event loop management. There is a convenience function, asyncio.run, we can use to run our coroutine. This is illustrated in the following listing.\nimport asyncio async def add_coroutine(a,b): return a+b res=asyncio.run(add_coroutine(1,2)) print(res) When we run this code, we’ll see output like the following:\n3 We’ve properly put our coroutine on the event loop, and we have executed it! asyncio.run is doing a few important things in this scenario. First, it creates a brand-new event. Once it successfully does so, it takes whichever coroutine we pass into it and runs it until it completes, returning the result. This function will also do some cleanup of anything that might be left running after the main coroutine fin ishes. Once everything has finished, it shuts down and closes the event loop. Possibly the most important thing about asyncio.run is that it is intended to be the main entry point into the asyncio application we have created. It only executes one coroutine, and that coroutine should launch all other aspects of our application. As we progress further, we will use this function as the entry point into nearly all our applications. The coroutine that asyncio.run executes will create and run other coroutines that will allow us to utilize the concurrent nature of asyncio.\n2.3 Pausing execution with the await keyword The example we saw in block 2.2 did not need to be a coroutine, as it executed only non-blocking Python code. The real benefit of asyncio is being able to pause execu tion to let the event loop run other tasks during a long-running operation. To pause execution, we use the await keyword. The await keyword is usually followed by a call to a coroutine (more specifically, an object known as an awaitable, which is not always a coroutine; we’ll learn more about awaitables later in the chapter). Using the await keyword will cause the coroutine following it to be run, unlike calling a coroutine directly, which produces a coroutine object. The await expression will also pause the coroutine where it is contained in until the coroutine we awaited finishes and returns a result. When the coroutine we awaited finishes, we’ll have access to the result it returned, and the containing coroutine will “wake up” to handle the result. We can use the await keyword by putting it in front of a coroutine call. Expanding on our earlier program, we can write a program where we call the add_coroutine function inside of a “main” async function and get the result\nimport asyncio async def add_one(number: int) -\u0026gt; int: return number + 1 async def main() -\u0026gt; None: one_plus_one = await add_one(1) # Pause, and wait for the result of add_one(1). two_plus_one = await add_one(2) # Pause, and wait for the result of add_one(2). print(one_plus_one) print(two_plus_one) asyncio.run(main()) Note: Coroutine will only run when we use await keyword. If we call the coroutine directly it will return a coroutine object.\nIn above code we pause execution twice. We first await the call to add_one(1). Once we have the result, the main function will be “unpaused,” and we will assign the return value from add_one(1) to the variable one_plus_one, which in this case will be two. We then do the same for add_one(2) and then print the results.We can visualize the execution flow of our application, as shown in figure\nAs it stands now, this code does not operate differently from normal, sequential code. We are, in effect, mimicking a normal call stack. Next, let’s look at a simple example of how to run other code by introducing a dummy sleep operation while we’re waiting.\n2.4 Introducing long-running coroutines with sleep Our previous examples did not use any slow operations and were used to help us learn the basic syntax of coroutines. To fully see the benefits and show how we can run mul tiple events simultaneously, we’ll need to introduce some long-running operations. Instead of making web API or database queries right away, which are nondeterministic as to how much time they will take, we’ll simulate long-running operations by specify ing how long we want to wait. We’ll do this with the asyncio.sleep function. We can use asyncio.sleep to make a coroutine “sleep” for a given number of sec onds. This will pause our coroutine for the time we give it, simulating what would hap pen if we had a long-running call to a database or web API. asyncio.sleep is itself a coroutine, so we must use it with the await keyword. If we call it just by itself, we’ll get a coroutine object. Since asyncio.sleep is a coroutine, this means that when a coroutine awaits it, other code will be able to run. Let’s examine a simple example, shown in the following listing, that sleeps for 1 sec ond and then prints a \u0026lsquo;Hello World!\u0026rsquo; message.\nimport asyncio async def hello_world_message(): await asyncio.sleep(1) print(\u0026#34;Hello World\u0026#34;) asyncio.run(hello_world_message()) When we run this application, our program will wait 1 second before printing our \u0026lsquo;Hello World!\u0026rsquo; message. Since hello_world_message is a coroutine and we pause it for 1 second with asyncio.sleep, we now have 1 second where we could be running other code concurrently.\nWe’ll be using sleep a lot in the next few examples, so let’s invest the time to cre ate a reusable coroutine that sleeps for us and prints out some useful information. We’ll call this coroutine delay. This is shown in the following listing\nimport asyncio async def delay(delaysecond): print(f\u0026#39;Sleeping for delay seconds : {delaysecond}\u0026#39;) await asyncio.sleep(delaysecond) print(f\u0026#39;finished sleeping for {delay_seconds} second(s)\u0026#39;) return delay_seconds delay will take in an integer of the duration in seconds that we’d like the function to sleep and will return that integer to the caller once it has finished sleeping. We’ll also print when sleep begins and ends. This will help us see what other code, if any, is run ning concurrently while our coroutines are paused.\nTo make referencing this utility function easier in future code listings, we’ll create a module that we’ll import in the remainder of this book when needed. We’ll also add to this module as we create additional reusable functions. We’ll call this module util, and we’ll put our delay function in a file called delay_functions.py. We’ll also add an init.py file with the following line, so we can nicely import the timer\nfrom util.delay_functions import delay From now on in this book, we’ll use from util import delay whenever we need to use the delay function. Now that we have a reusable delay coroutine, let’s combine it with the earlier coroutine add_one to see if we can get our simple addition to run concur rently while hello_world_message is paused.\nimport asyncio from util.delay_functions import delay async def add_one(number): return number + 1 async def hello_world_message(): await delay(1) print(\u0026#34;Hello World\u0026#34;) async def main() -\u0026gt; None: message = await hello_world_message() #pause until hello_world_message is finished one_plus_one = await add_one(1) #pause until add_one is finished print(one_plus_one) print(message) asyncio.run(main()) When we run this, 1 second passes before the results of both function calls are printed. What we really want is the value of add_one(1) to be printed immediately while hello_world_message()runs concurrently. So why isn’t this happening with this code? The answer is that await pauses our current coroutine and won’t execute any other code inside that coroutine until the await expression gives us a value. Since it will take 1 second for our hello_world_message function to give us a value, the main coroutine will be paused for 1 second. Our code behaves as if it were sequential in this case. This behavior is illustrated in figure\nWe can see that the main coroutine is paused for 1 second while hello_world_\nBoth main and hello_world paused while we wait for delay(1) to finish. After it has finished, main resumes and can execute add_one. We’d like to move away from this sequential model and run add_one concurrently with hello_world. To achieve this, we’ll need to introduce a concept called tasks.\n2.5 Running concurrently with task In Python\u0026rsquo;s asyncio, you can create tasks to run code concurrently. This is done using the asyncio.create_task function. When you create a task, it starts running in the background immediately, allowing your program to do other things while waiting for the task to finish.\nKey Points: Creating a Task:\nUse asyncio.create_task() with a coroutine function as its input. It returns a task object instantly. Awaiting a Task:\nYou can use await with the task object to pause your program until the task is done and get its result. Why Use Tasks?\nTasks allow other parts of your program to run without waiting for one operation to finish. Code Example: Creating and Using a Task import asyncio from util import delay # A custom function that simulates a delay async def main(): # Create a task that takes 3 seconds to complete sleep_for_three = asyncio.create_task(delay(3)) # Immediately print the type of the task object print(f\u0026#34;Task type: {type(sleep_for_three)}\u0026#34;) # Wait for the task to finish and get the result result = await sleep_for_three print(f\u0026#34;Task result: {result}\u0026#34;) # Run the main coroutine asyncio.run(main()) What’s Happening in the Code: Task Creation:\nasyncio.create_task(delay(3)) creates a task to run the delay(3) coroutine in the background. The task is of type \u0026lt;class '_asyncio.Task'\u0026gt;, which is different from a regular coroutine. Running Concurrently:\nAfter creating the task, the program does not wait for the task to finish. The print() statement runs immediately after the task is created. Waiting for the Task:\nThe await sleep_for_three line pauses the main coroutine until the task finishes. Once the task is complete, it returns its result, which is printed. Why Await is Important: If you don’t use await on a task, it might not get enough time to finish. When the asyncio.run function exits, the event loop stops, and any unfinished tasks are “cleaned up” without completing. Using await ensures the task has a chance to finish.\nNote : When we create task using asyncio.create_task it run the task immediately in the background. It does not wait for the task to finish and immediately return a task object such that our program can do other things while waiting for the task to finish.We can use await later on to pause the program until the task is done and get its result.\n2.6 Running multiple tasks concurrently Given that tasks are created instantly and are scheduled to run as soon as possible, this allows us to run many long-running tasks concurrently. We can do this by sequentially starting multiple tasks with our long-running coroutine.\nimport asyncio from util.delay_functions import delay async def main(): # Create two tasks that take 3 seconds to complete sleep_for_three=asyncio.create_task(delay(3)) sleep_again=asyncio.create_task(delay(3)) sleep_once_more=asyncio.create_task(delay(3)) await sleep_for_three await sleep_again await sleep_once_more asyncio.run(main()) In this code, we create three tasks that each sleep for 3 seconds. We then await each task in sequence. This will cause each task to run concurrently, and the total time to complete will be around 3 seconds, not 9 seconds. This is because we are not waiting for each task to finish before starting the next one. Lets breakdown\nStarting Three Tasks:\nThe program begins by creating three tasks, each of which takes 3 seconds to complete. The create_task function starts the tasks immediately but doesn\u0026rsquo;t wait for them to finish—it just sets them up to run in the background. The First Await Statement:\nWhen the code reaches the await sleep_for_three line, it pauses and gives control to the event loop. This pause allows the event loop to check for any tasks waiting to run and starts them “as soon as possible.” Tasks Run Simultaneously:\nAll three tasks begin running their sleep operations at the same time because the event loop handles them concurrently. This concurrency allows the program to complete the work in 3 seconds instead of 9. Concurrency in Action:\nWhile the sleep operations run concurrently, any other code in the tasks (like print statements) runs one at a time, not simultaneously. This means only the parts of the tasks that involve waiting (like sleeping) are parallelized. Time Saved:\nIf the tasks were executed one after another, the program would take 9 seconds (3 seconds × 3 tasks). By running the tasks concurrently, the program finishes in just 3 seconds, saving a lot of time. This is illustrated in figure NOTE This benefit compounds as we add more tasks; if we had launched 10 of these tasks, we would still take roughly 3 seconds, giving us a 10-fold speedup. This is the power of concurrency in asyncio.\nasyncio.gather function Gather function is a quick way to run multiple tasks concurrently and wait for all of them to complete. It takes in an iterable of awaitables and returns a single awaitable that will yield results in the order they were created. This is useful when we want to run multiple tasks concurrently and wait for all of them to finish before proceeding.\nimport asyncio from util.delay_functions import delay async def main(): # Create three tasks that take 3 seconds to complete and handel using asyncio.gather results = await asyncio.gather( delay(3), delay(3), delay(3) ) print(results) asyncio.run(main()) Note : For understanding You can use this logic . There is a task queue and event loop. When we only await coroutine there is only one task in the task queue and event loop .\ncoroutine need to await for running the task i.e keep in the task queue and eventloop if we directly run coroutine it will just give us coroutine object.\nWhen we use asyncio.createtask() there are as much task in the task queue as the number of tasks created and event loop will run all the tasks concurrently also when we await new coroutine it will be added to the task queue and event loop will run it concurrently.\nIt return a task object instantly and run all the task concurrently i.e keep in the task queue and event loop without awaiting but does not wait for the task to finish it need to be awaited to get the proper result.\nWhen we use asyncio.gather() it will run all the tasks concurrently and wait for all of them to finish before proceeding.\nIt need to be awaited to keep all the task in the task queue and event loop and wait for all of them to finish before proceeding.After finishing all the task it will return the result in the order they were created and jump to the next line of code of the main coroutine.\n3. Synchronization Premitives Locks Semaphores 3.1 Locks Locks are a synchronization primitive that allows us to limit access to a shared resource to only one coroutine at a time. This is useful when we have a resource that can only be accessed by one coroutine at a time, like a file or a database connection. Locks are created using the asyncio.Lock class and can be acquired using the acquire method and released using the release method.\n#basic example of lock\nimport asyncio async def locking(lock): print(\u0026#39;Waiting for the lock\u0026#39;) async with lock: print(\u0026#39;Acquired the lock\u0026#39;) await asyncio.sleep(2) print(\u0026#39;Released the lock\u0026#39;) async def main(): lock = asyncio.Lock() await asyncio.gather( locking(lock), locking(lock), locking(lock) ) asyncio.run(main()) Output:\nWaiting for the lock\rAcquired the lock\rWaiting for the lock\rWaiting for the lock\rReleased the lock\rAcquired the lock\rReleased the lock\rAcquired the lock\rReleased the lock In this example, we create a lock using asyncio.Lock and pass it to the locking coroutine. We then use the async with statement to acquire the lock and release it when we are done. When we run the program, we can see that only one coroutine can acquire the lock at a time, and the other coroutines have to wait until the lock is released.\n3.2 Semaphores Semaphores are a synchronization primitive that allows us to limit access to a shared resource to a fixed number of coroutines at a time. This is useful when we have a resource that can be accessed by a limited number of coroutines, like a connection pool or a web API. Semaphores are created using the asyncio.Semaphore class and can be acquired using the acquire method and released using the release method.\n#basic example of semaphore\nimport asyncio async def semaphoring(semaphore): async with semaphore: print(\u0026#39;Acquired the semaphore\u0026#39;) await asyncio.sleep(2) print(\u0026#39;Released the semaphore\u0026#39;) async def main(): semaphore = asyncio.Semaphore(2) await asyncio.gather( semaphoring(semaphore), semaphoring(semaphore), semaphoring(semaphore), semaphoring(semaphore) ) asyncio.run(main()) Output:\nAcquired the semaphore\rAcquired the semaphore\rAcquired the semaphore\rReleased the semaphore\rReleased the semaphore\rReleased the semaphore\rAcquired the semaphore\rReleased the semaphore In this example, we create a semaphore with a limit of 2 using asyncio.Semaphore and pass it to the semaphoring coroutine. We then use the async with statement to acquire the semaphore and release it when we are done. When we run the program, we can see that only two coroutines can acquire the semaphore at a time, and the other coroutines have to wait until the semaphore is released.\nSome popular asyncio libraries aiohttp: An HTTP client and server library for asyncio. fastapi: A modern web framework for building APIs with Python 3.6+ based on standard Python type hints. aiofiles: A file operations library for asyncio. ","permalink":"http://localhost:1313/posts/pages/asyncio/asyncio2/","summary":"how to write programs using this single-threaded concurrency model with asyncio","title":"Async io : Asyncio Basics (Day 2)"},{"content":"36. useRef Hook in React useRef is a hook that is specially designed to work with DOM elements. It allows you to create a reference to a DOM element and access it directly in your components so you can modify it or read its properties as needed.\nAnother important distinction is that useRef holds the same reference across re-renders of the component Similarly, useState also retains its value between renders. However, updating a state value with useState will always trigger a re-render, whereas updating the value of a useRef does not. Its explained in the below example in ## 2. Advanvced Usage\n1. Basic Usage 1. Import useRef import { useRef } from \u0026#39;react\u0026#39;; 2. Create a Reference const myRef = useRef(); 3. Attach to DOM Elements function MyComponent() { const myRef = useRef(); return ( \u0026lt;div ref={myRef}\u0026gt; \u0026lt;h1\u0026gt;useRef Example\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ); } 4. Accessing the Reference // Access the DOM element using .current const element = myRef.current; use myRef.current.value for input elements. use myRef.current.checked for checkbox elements. use myRef.current.focus() to focus on an element. use myRef.current.style to access the style object of an element.\nNote: While you can access DOM elements directly with useRef, it\u0026rsquo;s recommended to avoid manipulating them directly unless necessary.\nPractical Example: Form Input Here\u0026rsquo;s a complete example showing how to use useRef with form inputs:\nimport { useRef, useState } from \u0026#39;react\u0026#39;; function InputExample() { const inputRef = useRef(); const [inputValue, setInputValue] = useState(\u0026#39;\u0026#39;); const handleClick = () =\u0026gt; { setInputValue(inputRef.current.value); inputRef.current.value = \u0026#39;\u0026#39;; // Clear input after reading }; return ( \u0026lt;div\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; ref={inputRef} placeholder=\u0026#34;Type something...\u0026#34; /\u0026gt; \u0026lt;button onClick={handleClick}\u0026gt;Save Input\u0026lt;/button\u0026gt; \u0026lt;p\u0026gt;Saved value: {inputValue}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } Explanation:\nWe create a reference to the input element using useRef. When the button is clicked, we read the input value using inputRef.current.value and update the state. We clear the input field by setting inputRef.current.value to an empty string. 2. Advanced Usage of useRef and useState useRef and useState are both hooks used in React. Both hooks help us store values, but they behave differently: useState: The value is persistent across re-renders, but updating it triggers a re-render. useRef: The value is also persistent across re-renders, but updating it does not trigger a re-render. 2.1. Managing Previous Values in a Stopwatch Here’s an example of how to use useRef and useState to build a simple stopwatch in React:\nimport { useRef, useState } from \u0026#39;react\u0026#39;; function Stopwatch() { const timerRef = useRef(0); // To store the timer ID const [time, setTime] = useState(0); // To store the current time const [isRunning, setIsRunning] = useState(false); // To track if the stopwatch is running // Start the timer when the Start button is clicked const startTimer = () =\u0026gt; { if (!isRunning) { timerRef.current = setInterval(() =\u0026gt; { setTime((time) =\u0026gt; time + 1); // Increment the time every second }, 1000); setIsRunning(true); // Set the timer as running } }; // Stop the timer when the Stop button is clicked const stopTimer = () =\u0026gt; { clearInterval(timerRef.current); // Clear the interval to stop the timer setIsRunning(false); // Set the timer as not running }; // Reset the timer when the Reset button is clicked const resetTimer = () =\u0026gt; { clearInterval(timerRef.current); // Clear the interval to stop the timer setIsRunning(false); // Set the timer as not running setTime(0); // Reset the time to 0 }; return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Stopwatch\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;Time: {time} seconds\u0026lt;/p\u0026gt; \u0026lt;button onClick={startTimer}\u0026gt;Start\u0026lt;/button\u0026gt; \u0026lt;button onClick={stopTimer}\u0026gt;Stop\u0026lt;/button\u0026gt; \u0026lt;button onClick={resetTimer}\u0026gt;Reset\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } Explanation Creating useRef and useState variables:\ntimerRef: This holds the timer ID (returned by setInterval). We use useRef here because we don’t need the component to re-render when the timer ID changes. time: This stores the current time value of the stopwatch, and we use useState for this because we want the component to re-render whenever the time updates. isRunning: This tracks whether the stopwatch is running or not. Starting the timer (Start Button):\nWhen the \u0026ldquo;Start\u0026rdquo; button is clicked, we check if the timer is already running. If it isn’t, we start it by calling setInterval, which increments the time value every second. setInterval returns an interval ID that we store in timerRef.current. This ID will be used to stop the timer later. Stopping the timer (Stop Button):\nWhen the \u0026ldquo;Stop\u0026rdquo; button is clicked, we clear the interval using clearInterval(timerRef.current) to stop the timer. We also set isRunning to false to indicate that the timer is no longer running. Resetting the timer (Reset Button):\nWhen the \u0026ldquo;Reset\u0026rdquo; button is clicked, we clear the interval to stop the timer, set isRunning to false, and reset the time back to 0. Why useRef? Why not just use a regular variable?\nA regular variable inside the component would reset every time the component re-renders. Since the timer is being updated every second, this would cause issues because the value would be reset each time, and the timer wouldn’t function correctly. Why useRef over useState for the timer ID?\nWe use useRef to store the timer ID because updating it with useState would trigger a re-render every time the timer ID changes. Since the timer is running independently, we don’t need a re-render, so useRef is more efficient here. Key Takeaways useRef is useful for storing values that don’t require the component to re-render when they change. useState is used for values that should trigger a re-render when updated, like the time value in our stopwatch. useRef does not cause a re-render when its value changes, making it ideal for holding values like the interval ID that don’t need to affect the UI. Common Use Cases Storing previous values Managing focus, text selection, or media playback Integrating with third-party DOM libraries Accessing underlying DOM elements Isolation in Components: Any variable that is declared inside a component is isolated to that component. It is not shared with other components unless explicitly passed as props. This isolation helps maintain the encapsulation and modularity of components in React.\n37.Forwarding Refs in React Forwarding refs is a technique in React that allows you to pass a ref from a parent component to a child component. This is useful when you want to access the DOM element of a child component from a parent component.\n1. Basic Usage 1.Import useRef import { useRef } from \u0026#39;react\u0026#39;; 2. Create a Ref in the Parent Component const myRef= useRef(); 3. Pass the Ref to the Child Component \u0026lt;MyChildComponent ref={myRef} /\u0026gt; 4.Import forward ref in child component import React, { forwardRef } from \u0026#39;react\u0026#39;; 5. Using forwardRef to Forward the Ref const MyChildComponent = forwardRef((props, ref) =\u0026gt; { return \u0026lt;input ref={ref} /\u0026gt;; }); 6. Accessing the Ref in the Parent Component const element = myRef.current.value; Practical Example: Input Focus to take input from user and focus on the input field of the child component from the parent component.\nimport React, { useRef } from \u0026#39;react\u0026#39;; const InputComponent = forwardRef(({title}, ref) =\u0026gt; { return\u0026lt;\u0026gt; \u0026lt;h1\u0026gt;{title}\u0026lt;/h1\u0026gt; \u0026lt;input ref={ref}/\u0026gt; \u0026lt;/\u0026gt; }); function ParentComponent() { const inputRef = useRef(); const handleClick = () =\u0026gt; { inputRef.current.focus(); console.log(inputRef.current.value); }; return ( \u0026lt;div\u0026gt; \u0026lt;InputComponent ref={inputRef} title=\u0026#34;ENter the Input\u0026#34;/\u0026gt; \u0026lt;button onClick={handleClick}\u0026gt;Focus Input\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 38.useImperativeHandle in React In large-scale applications, we generally avoid using refs directly to access child components. Instead, we use the useImperativeHandle hook to expose specific methods from the child component to the parent component. This approach allows the developer working on the parent component to interact with the child component\u0026rsquo;s methods without needing to understand its internal implementation. Additionally, this separation enables the developer of the child component to modify or update the child component independently, without affecting the parent component. Since only the exposed methods are used by the parent, changes to the internal structure of the child component do not disrupt the parent-child interaction.This is specially used in forwardRef to expose methods of child component to parent component.\nBasic Usage 1.Pass a Ref to the Child Component import {useRef} from \u0026#39;react\u0026#39;; function App() { const childRef = useRef(); return \u0026lt;ChildComponent ref={childRef} /\u0026gt;; } =\u0026gt; Here, we create a ref using useRef and pass it to the ChildComponent using the ref prop.\n2. Use useImperativeHandle in the Child Component with forwardRef to expose methods import { useImperativeHandle, forwardRef } from \u0026#39;react\u0026#39;; const ChildComponent = forwardRef((props, ref) =\u0026gt; { useImperativeHandle(ref, () =\u0026gt; ({ focus: () =\u0026gt; { // Focus on the input element }, reset: () =\u0026gt; { // Reset the input element }, inputValue:\u0026#39;vaule\u0026#39; }),[dependencies]); return \u0026lt;input /\u0026gt;; }); In the ChildComponent, we use the useImperativeHandle hook to expose the focus and reset methods to the parent component. The ref object is passed as the first argument, and the second argument is a function that returns an object containing the methods to be exposed. dependencies is an optional array of values that, when changed, will trigger the re-evaluation of the function that returns the methods. If the dependencies array is not provided, the function will be called on every render and empty array will call only once in entire lifecycle.\n3. Access the Exposed Methods in the Parent Component function App() { const childRef = useRef(); const handleClick = () =\u0026gt; { childRef.current.focus(); }; const resetClick = () =\u0026gt; { childRef.current.reset(); }; return ( \u0026lt;\u0026gt; \u0026lt;ChildComponent ref={childRef} /\u0026gt; \u0026lt;button onClick={handleClick}\u0026gt;Focus Input\u0026lt;/button\u0026gt; \u0026lt;button onClick={resetClick}\u0026gt;Reset Input\u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; ); } In the parent component, we can access the exposed methods using the current property of the ref object. In this example, we call the focus method when the \u0026ldquo;Focus Input\u0026rdquo; button is clicked.\nPractical Example: Use forwardRef and useImperativeHandle to Expose Methods for reset the input field and get the value of the input field. import {useRef} from \u0026#39;react\u0026#39;; function App(){ const childRef = useRef(); const handleClick = () =\u0026gt; { childRef.current.focus(); }; const resetClick = () =\u0026gt; { childRef.current.reset(); }; const getValue = () =\u0026gt; { console.log(childRef.current.value); }; return ( \u0026lt;\u0026gt; \u0026lt;ChildComponent ref={childRef} /\u0026gt; \u0026lt;button onClick={handleClick}\u0026gt;Focus Input\u0026lt;/button\u0026gt; \u0026lt;button onClick={resetClick}\u0026gt;Reset Input\u0026lt;/button\u0026gt; \u0026lt;button onClick={getValue}\u0026gt;Get Value\u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; ); } export default App; import { useImperativeHandle, forwardRef,useRef } from \u0026#39;react\u0026#39;; const ChildComponent = forwardRef((props, ref) =\u0026gt; { const inputRef = useRef(); useImperativeHandle(ref, () =\u0026gt; ({ focus: () =\u0026gt; { inputRef.current.focus(); }, reset: () =\u0026gt; { inputRef.current.value = \u0026#39;\u0026#39;; }, value: inputRef.current.value }),[]); return \u0026lt;input ref={inputRef} /\u0026gt;; }); export default ChildComponent; =\u0026gt; By using useImperativeHandle, we can expose specific methods from the child component to the parent component, allowing for more controlled interactions between the components such as focusing on the input field, resetting the input field, and getting the value of the input field in this example. =\u0026gt; By using this approach, we can maintain a clear separation of concerns between the parent and child components, making it easier to manage and update the components independently.\n37. Portals in React Portals in React provide a way to render children components outside the DOM hierarchy of the parent component. This allows you to render a child component at a different location in the DOM, such as at the root level or inside a specific container, without affecting the parent\u0026rsquo;s layout or styles.\nImporting portal from react-dom import { createPortal } from \u0026#39;react-dom\u0026#39;; using createPortal const MyPortal = ({title}) =\u0026gt; { return createPortal( \u0026lt;\u0026gt; \u0026lt;h1\u0026gt;{title}\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;This is a portal\u0026lt;/p\u0026gt; \u0026lt;\u0026gt;, document.getElementById(\u0026#39;portal-root\u0026#39;)); }; =\u0026gt;When the MyPortal component is rendered, the content will be rendered inside the element with the id \u0026lsquo;portal-root\u0026rsquo;, which can be located anywhere in the DOM.\n","permalink":"http://localhost:1313/posts/pages/react/react7/","summary":"Learn about useRef hook, ref forwarding, useImperativeHandle and Portals in React for DOM manipulation and component interactions.","title":"React : Day 7"},{"content":"1. Some Important Concepts 1.1 Parallism vs Concurrency Parallism: Running multiple tasks at the same time. There are multiple Threads or Processes running at the same time. Concurrency: Switching between multiple tasks. When one task is waiting for I/O, another task can run. There is only one Thread or Process running at a time. 1.2 Synchronous vs Asynchronous Synchronous: Code is executed in sequence. Previous task/line must be completed before the next task/line execution starts. Asynchronous: Code is executed in parallel. Tasks can run concurrently. The next task can start before the previous task is completed. 1.3 Blocking vs Non-Blocking Blocking: The execution of the code is blocked until the task is completed. The next task can\u0026rsquo;t start until the previous task is completed. import time def task1(): print(\u0026#34;Task 1 started\u0026#34;) time.sleep(2) print(\u0026#34;Task 1 completed\u0026#34;) def task2(): print(\u0026#34;Task 2 started\u0026#34;) time.sleep(2) print(\u0026#34;Task 2 completed\u0026#34;) task1() task2() Non-Blocking: The excecution of the code is not blocked. The next task can start before the previous task is completed. import asyncio async def task1(): print(\u0026#34;Task 1 started\u0026#34;) await asyncio.sleep(2) print(\u0026#34;Task 1 completed\u0026#34;) async def task2(): print(\u0026#34;Task 2 started\u0026#34;) await asyncio.sleep(2) print(\u0026#34;Task 2 completed\u0026#34;) async def main(): await asyncio.gather(task1(), task2()) asyncio.run(main()) 1.4 I/O Bound vs CPU Bound I/O Bound: The program is waiting for input/output operations to complete. The program is not using the CPU much. CPU Bound: The program is using the CPU a lot. The program is not waiting for input/output operations to complete. import request response = request.get(\u0026#34;https://www.google.com\u0026#34;) # I/O Bound items = response.headers.items() # CPU Bound headers = [f\u0026#39;{key}: {header}\u0026#39; for key, header in items] # CPU Bound formatted_headers = \u0026#39;\\n\u0026#39;.join(headers) # CPU Bound with open(\u0026#39;headers.txt\u0026#39;, \u0026#39;w\u0026#39;) as file: # I/O Bound file.write(formatted_headers) # I/O Bound 2. How Concurrency is Achieved in Os level To better understand this, we’ll need to dive into how sockets work and, in particular, how non-blocking sockets work.\n2.1 Sockets A socket is a low-level abstraction for sending and receiving data over a network. It is the basis for how data is transferred to and from servers. Sockets support two main operations: sending bytes and receiving bytes. We write bytes to a socket, which will then get sent to a remote address, typically some type of server. Once we’ve sent those bytes, we wait for the server to write its response back to our socket. Once these bytes have been sent back to our socket, we can then read the result.\nIn the case of getting the contents from example.com as we saw earlier, we open a socket that connects to example.com’s server. We then write a request to get the contents to that socket and wait for the server to reply with the result: in this case, the HTML of the web page. We can visualize the flow of bytes to and from the server in figure 1.7\nSockets are blocking by default. Simply put, this means that when we are waiting for a server to reply with data, we halt our application or block it until we get data to read. Thus, our application stops running any other tasks until we get data from the server, an error happens, or there is a timeout. At the operating system level, we don’t need to do this blocking. Sockets can operate in non-blocking mode. In non-blocking mode, when we write bytes to a socket, we can just fire and forget the write or read, and our application can go on to perform other tasks. Later, we can have the operating system tell us that we received bytes and deal with it at that time. This lets the application do any number of things while we wait for bytes to come back to us. Instead of blocking and waiting for data to come to us, we become more reactive, letting the operating system inform us when there is data for us to act on. In the background, this is performed by a few different event notification systems, depending on which operating system we’re running. asyncio is abstracted enough that it switches between the different notification systems, depending on which one our operating system supports. The following are the event notification systems used by specific operating systems:\nkqueue—FreeBSD and MacOS epoll—Linux IOCP (I/O completion port)—Windows These systems keep track of our non-blocking sockets and notify us when they are ready for us to do something with them. This notification system is the basis of how asyncio can achieve concurrency.\nBut how do we keep track of multiple tasks that are waiting for data to come back to them? This is where the event loop comes in.\n2.2 Event Loop The event loop is the core of every asyncio application. In asyncio, the event loop keeps a queue of tasks.\n2.2.1 How the Event Loop Works The event loop works by keeping a queue of tasks instead of messages. Each task is a coroutine. When a task is added to the event loop, it will execute until it encounters an I/O operation (such as a web request). When a task hits an I/O-bound operation, it pauses and allows the event loop to run other tasks that are not waiting for I/O operations to complete. 2.2.2 Understanding Event Loops in Asynchronous Programming When working with event loops in asynchronous programming, the process can be understood as a sequence of steps that efficiently handle tasks without blocking the execution. Here\u0026rsquo;s a breakdown of how it works:\n2.2.2.1 Creating the Event Loop When an event loop is created, an empty queue of tasks is initialized. This queue will hold all the tasks that need to be executed.\n2.2.2.2 Adding Tasks to the Queue We add tasks to the event loop’s queue. These tasks are executed one at a time, based on their order in the queue.\n2.2.2.3 Processing Tasks Iteratively Each iteration of the event loop checks for tasks that need to be executed. It processes tasks sequentially, running them one by one.\n2.2.2.4 Handling I/O Operations If a task encounters an I/O operation (like reading from a file or making a network request), it cannot proceed immediately. In this case, the task is paused and put on hold.\n2.2.2.5 Pausing and Waiting for I/O Completion When a task is paused, the event loop instructs the operating system to monitor any associated sockets or resources for I/O completion. During this time, the event loop continues checking for and executing other tasks.\n2.2.2.6 Waking Up Paused Tasks On each iteration of the event loop, we check if any of the I/O operations have completed. If they have:\nThe paused task is woken up. The task resumes execution and completes its process. 2.2.2.7. Conclusion This cycle of pausing, waiting for I/O, and resuming tasks allows the event loop to run multiple tasks concurrently, making it an efficient way to handle asynchronous operations without blocking the program.\nBy continuously iterating and checking for completed I/O tasks, the event loop ensures that no task is left idle while waiting for I/O operations, enabling a smooth and efficient workflow.\nVisualizing the Event Loop with Asynchronous Tasks We can visualize how the event loop works with asynchronous tasks as shown in Figure 1.9: the main thread submits tasks to the event loop, which then runs them. When a task encounters an I/O operation, it pauses and allows other tasks to run. Once the I/O operation is complete, the paused task is resumed.\nExample: Submitting Multiple Asynchronous Tasks Let\u0026rsquo;s consider three tasks that each make an asynchronous web request. These tasks consist of:\nCPU-bound setup: Some code that prepares data for the web request. I/O-bound web request: The asynchronous part where we send the web request. CPU-bound post-processing: After the web request completes, we do some more CPU-intensive work. Now, let\u0026rsquo;s submit these tasks to the event loop simultaneously. Here’s how we can write this in pseudocode:\ndef make_request(): cpu_bound_setup() io_bound_web_request() cpu_bound_postprocess() task_one = make_request() task_two = make_request() task_three = make_request() First task starts executing code, and the other two are left waiting to run. Once the CPU-bound setup work is finished in Task 1, it hits an I/O-bound operation and will pause itself to say, “I’m waiting for I/O; any other tasks waiting to run can run.” Once this happens, Task 2 can begin executing. Task 2 starts its CPU-bound code and then pauses, waiting for I/O. At this time both Task 1 and Task 2 are waiting concurrently for their network request to complete. Since Tasks 1 and 2 are both paused waiting for I/O, we start running Task 3. Now imagine once Task 3 pauses to wait for its I/O to complete, the web request for Task 1 has finished. We’re now alerted by our operating system’s event notification system that this I/O has finished. We can now resume executing Task 1 while both Task 2 and Task 3 are waiting for their I/O to finish. In figure 1.10, we show the execution flow of the pseudocode we just described. If we look at any vertical slice of this diagram, we can see that only one CPU-bound piece of work is running at any given time; however, we have up to two I/O-bound operations happening concurrently. This overlapping of waiting for I/O per each task is where the real time savings of asyncio comes in.\n","permalink":"http://localhost:1313/posts/pages/asyncio/asyncio1/","summary":"An introduction to asynchronous programming in Python using asyncio.","title":"Async io : Async io Intro (Day 1)"},{"content":"34.Styling in CSS 34.1 Setting Inline Styles =\u0026gt; In react for inline styles we use the style attribute and pass an object with camelCase properties.\nimport React from \u0026#39;react\u0026#39;; const myStyle = { color: \u0026#39;blue\u0026#39;, backgroundColor: \u0026#39;yellow\u0026#39; } const MyComponent = () =\u0026gt; { return ( \u0026lt;div style={myStyle}\u0026gt; \u0026lt;h1\u0026gt;Inline Styles\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ) } or we can use the style attribute directly in the element.\nimport React from \u0026#39;react\u0026#39;; const MyComponent = () =\u0026gt; { return ( \u0026lt;div style={{color: \u0026#39;blue\u0026#39;, backgroundColor: \u0026#39;yellow\u0026#39;}}\u0026gt; \u0026lt;h1\u0026gt;Inline Styles\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ) } 34.2 Setting External Styles =\u0026gt; We can also use external CSS files in react. We can import the CSS file in the component file and use the class name in the\nimport React from \u0026#39;react\u0026#39;; import \u0026#39;./MyComponent.css\u0026#39;; const MyComponent = () =\u0026gt; { return ( \u0026lt;div className=\u0026#34;myStyle\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;External Styles\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ) } 34.3 Setting Inline Dynamic Styles =\u0026gt;You can also set the inline styles dynamically by using the state.\nimport React,{useState} from \u0026#39;react\u0026#39;; const App=()=\u0026gt;{ const [valid,setValid]=useState(true); function changeStyle(){ setValid(!valid); } const myStyle={ color:valid?\u0026#39;blue\u0026#39;:\u0026#39;red\u0026#39;, backgroundColor:valid?\u0026#39;yellow\u0026#39;:\u0026#39;green\u0026#39; } return( \u0026lt;div\u0026gt; \u0026lt;button onClick={changeStyle}\u0026gt;Change Style\u0026lt;/button\u0026gt; \u0026lt;div style={myStyle}\u0026gt; \u0026lt;h1\u0026gt;Inline Dynamic Styles\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) } export default App; or we can use the style attribute directly in the element.\nimport React,{useState} from \u0026#39;react\u0026#39;; const App=()=\u0026gt;{ const [valid,setValid]=useState(true); function changeStyle(){ setValid(!valid); } return( \u0026lt;div\u0026gt; \u0026lt;button onClick={changeStyle}\u0026gt;Change Style\u0026lt;/button\u0026gt; \u0026lt;div style={{color:valid?\u0026#39;blue\u0026#39;:\u0026#39;red\u0026#39;,backgroundColor:valid?\u0026#39;yellow\u0026#39;:\u0026#39;green\u0026#39;}}\u0026gt; \u0026lt;h1\u0026gt;Inline Dynamic Styles\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) } export default App; 34.4 Setting Css Classes Dynamically =\u0026gt; We can also set the CSS classes dynamically by using the state.\nimport React,{useState} from \u0026#39;react\u0026#39;; import \u0026#39;./MyComponent.css\u0026#39;; const App=()=\u0026gt;{ const [valid,setValid]=useState(true); const [active,setActive]=useState(true); function changeStyle(){ setValid(!valid); setActive(!active); } return( \u0026lt;div\u0026gt; \u0026lt;button onClick={changeStyle}\u0026gt;Change Style\u0026lt;/button\u0026gt; \u0026lt;div className={`div-control ${valid?\u0026#39;right\u0026#39;:\u0026#39;wrong\u0026#39;} ${active?\u0026#39;active\u0026#39;:\u0026#39;inactive\u0026#39;}`}\u0026gt; \u0026lt;h1\u0026gt;Setting Css Classes Dynamically\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) } export default App; 34.5 Css modules =\u0026gt; Every time we import Css file in react component they are regarded as global styles i.e One component style can affect another component style =\u0026gt;So, to avoid this we can use CSS modules. CSS modules are local by default. We can use CSS modules by naming the CSS file as filename.module.css. =\u0026gt; The CSS file is imported in the component file and the class name is used as an object.\nProblem1 =\u0026gt; Imagine that you have two components with the same class name. The styles of one component can affect the styles of another component.which is not good for the application to solve this problem we can use CSS modules.\nStructure of the project\nsrc\r|_components\r|_MyComponent\r|_MyComponent.js\r|_MyComponent.module.css Step 1: Create a CSS file with the name MyComponent.module.css\n.myStyle{ color: blue; background-color: yellow; } .right{ text-align: right; } Step 2: Import the CSS file in the component file as shown below.\nimport React from \u0026#39;react\u0026#39;; import styles from \u0026#39;./MyComponent.module.css\u0026#39;; step 3: Use the class name as shown below.\nconst MyComponent = () =\u0026gt; { return ( \u0026lt;div className={styles.myStyle}\u0026gt; \u0026lt;h1\u0026gt;CSS Modules\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ) } Combined code\nimport React from \u0026#39;react\u0026#39;; import styles from \u0026#39;./MyComponent.module.css\u0026#39;; const MyComponent = () =\u0026gt; { return ( \u0026lt;div className={styles.myStyle}\u0026gt; \u0026lt;h1\u0026gt;CSS Modules\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ) } export default MyComponent; 34.5.1 Combining multiple classes import React from \u0026#39;react\u0026#39;; import styles from \u0026#39;./MyComponent.module.css\u0026#39;; const MyComponent = () =\u0026gt; { return ( \u0026lt;div className={`${styles.myStyle} ${styles.right}`}\u0026gt; \u0026lt;h1\u0026gt;CSS Modules\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ) } export default MyComponent; 34.6 Dynamic CSS Modules =\u0026gt; We can also set the CSS classes dynamically by using the state.\nimport React,{useState} from \u0026#39;react\u0026#39;; import styles from \u0026#39;./MyComponent.module.css\u0026#39;; const MyComponent = () =\u0026gt; { const [valid,setValid]=useState(true); const [active,setActive]=useState(true); function changeStyle(){ setValid(!valid); setActive(!active); } return ( \u0026lt;div className={`${styles.myStyle} ${valid?styles.right:styles.wrong} ${active?styles.active:styles.inactive}`}\u0026gt; \u0026lt;h1\u0026gt;CSS Modules\u0026lt;/h1\u0026gt; \u0026lt;button onClick={changeStyle}\u0026gt;Change Style\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } export default MyComponent; ","permalink":"http://localhost:1313/posts/pages/react/react5/","summary":"Learn various methods to style React components including inline styles, external styles, dynamic styles, and CSS modules.","title":"React : Day 5"},{"content":"35. Debugging in react 35.1 Using console.log import React from \u0026#39;react\u0026#39;; const MyComponent = () =\u0026gt; { const name = \u0026#39;John Doe\u0026#39;; console.log(name); return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Debugging in React\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ) } export default MyComponent; 35.2 Strict Mode =\u0026gt; In Strict Mode,React will render components twice. It helps to idenify the issues in the code.\nimport React,{StrictMode} from \u0026#39;react\u0026#39;; const MyComponent = () =\u0026gt; { const name = \u0026#39;John Doe\u0026#39;; console.log(name); return ( \u0026lt;StrictMode\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Debugging in React\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/StrictMode\u0026gt; ) } export default MyComponent; You can wrap any component in StrictMode.Just difference is that it will render the component twice.\n=\u0026gt; We can wrap the entire application in StrictMode in the index.js file.\nimport React,{StrictMode} from \u0026#39;react\u0026#39;; import ReactDOM from \u0026#39;react-dom\u0026#39;; import App from \u0026#39;./App\u0026#39;; ReactDOM.render( \u0026lt;StrictMode\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/StrictMode\u0026gt;, document.getElementById(\u0026#39;root\u0026#39;) ); 35.3 React Developer Tools React Developer Tools is a Chrome extension that allows you to inspect the React component hierarchy in the Chrome Developer Tools. Videos\n","permalink":"http://localhost:1313/posts/pages/react/react6/","summary":"Learn how to debug React applications using console.log, Strict Mode, and React Developer Tools.","title":"React : Day 6"},{"content":"Python Fundamentals: A Beginner\u0026rsquo;s Guide (Part 1) 1. Virtual Environment A virtual environment is a feature in Python that allows you to install the same package with different versions on the same system. This enables you to work on multiple projects using different versions of the same package.\n1.1. Installing venv The venv module is included in the Python standard library, so you don\u0026rsquo;t need to install it separately. However, if you are using an older version of Python (before 3.3), you can install virtualenv using pip:\npip install virtualenv 1.2. Creating a Virtual Environment To create a virtual environment, you can use the venv module, which is included in the Python standard library. Here\u0026rsquo;s how you can create a virtual environment named myenv:\npython -m venv myenv This command creates a new directory named myenv that contains the necessary files for the virtual environment.\n1.3. Activating a Virtual Environment To activate the virtual environment, you may run the following command:\n# For Linux/Mac: source myenv/bin/activate # For Windows: myenv\\Scripts\\activate 2. Python Packages 2.1. List All the Python Packages To list or save all the installed packages in the current environment, you can use the following command using freeze:\npip freeze # To list all the installed packages pip freeze \u0026gt; requirements.txt # To save all the installed packages in a file 2.2. Installing Python Packages To install a Python package, you can use the pip install command followed by the package name. For example, to install the requests package, you can run:\npip install requests 2.3. Uninstalling Python Packages To uninstall a Python package, you can use the pip uninstall command followed by the package name. For example, to uninstall the requests package, you can run:\npip uninstall requests 2.4. Run Python Package/Script To run a python package or script, you can use the following command:\npython -m package_name 3. Python Basics 3.1. Running a Python Script To run a Python script, you can use the following command:\npython script.py 3.2. Python Indentation In Python, the code block (body of the function, loop, etc.) starts with a colon (:) and the line following the colon should be indented.\nif 5 \u0026gt; 2: print(\u0026#34;Five is greater than two!\u0026#34;) # Indented block 3.3. Python Comments There are two types of comments in Python:\n# This is a single line comment \u0026#34;\u0026#34;\u0026#34; This is a multiline comment This is a multiline comment This is a multiline comment This is a multiline comment \u0026#34;\u0026#34;\u0026#34; 3.4. Print Statement The print() function is used to display the output on the console. For example:\nprint(\u0026#34;Hello, World!\u0026#34;) 3.5. Data Types Python has the following data types:\nint float str bool list tuple set dict None a = 10 # int b = 10.5 # float c = \u0026#34;Hello\u0026#34; # str d = True # bool e = [1,2,3] # list f = (1,2,3) # tuple g = {1,2,3} # set h = {\u0026#34;name\u0026#34;:\u0026#34;John\u0026#34;,\u0026#34;age\u0026#34;:30} # dict i = None # None print(type(a)) # \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; Note:Use type() function to check the data type of a variable.As it return the class of the variable.\n3.6. Rules of Variable Declaration A variable name must start with a letter or the underscore character. A variable name cannot start with a number. A variable name can only contain alpha-numeric characters and underscores (A-z, 0-9, and _ ). Variable names are case-sensitive (age, Age, and AGE are three different variables). 3.7. Type Conversion You can convert one data type to another using the following functions:\nint(): To convert to an integer float(): To convert to a float str(): To convert to a string bool(): To convert to a boolean list(): To convert to a list tuple(): To convert to a tuple set(): To convert to a set dict(): To convert to a dictionary a = 10 #a=10 b = float(a) #b=10.0 c = str(a) #c=\u0026#39;10\u0026#39; d = bool(a) #d=True e = list(c) #e=[\u0026#39;1\u0026#39;,\u0026#39;0\u0026#39;] f = tuple(c) #f=(\u0026#39;1\u0026#39;,\u0026#39;0\u0026#39;) g = set(c) #g={\u0026#39;1\u0026#39;,\u0026#39;0\u0026#39;} h = dict(name=\u0026#34;John\u0026#34;,age=30) or dict([(\u0026#34;name\u0026#34;,\u0026#34;John\u0026#34;),(\u0026#34;age\u0026#34;,30)]) #h={\u0026#39;name\u0026#39;:\u0026#39;John\u0026#39;,\u0026#39;age\u0026#39;:30} Note: Python is dynamically typed, which means a variable\u0026rsquo;s data type can be changed.\n4. Operators 4.1. Arithmetic Operators +: Addition -: Subtraction *: Multiplication /: Division %: Modulus **: Power //: Floor Division a = 10 b = 3 print(a + b) # 13 print(a - b) # 7 print(a * b) # 30 print(a / b) # 3.3333333333333335 print(a % b) # 1 print(a ** b) # 1000 print(a // b) # 3 4.2. Assignment Operators =: Assign value +=: Add and assign -=: Subtract and assign *=: Multiply and assign /=: Divide and assign %=: Modulus and assign **=: Power and assign //=: Floor Division and assign a = 10 a += 5 # a = a + 5 a -= 5 # a = a - 5 a *= 5 # a = a * 5 a /= 5 # a = a / 5 a %= 5 # a = a % 5 a **= 5 # a = a ** 5 a //= 5 # a = a // 5 4.3. Comparison Operators ==: Equal to !=: Not equal to \u0026gt;: Greater than \u0026lt;: Less than \u0026gt;=: Greater than or equal to \u0026lt;=: Less than or equal to a = 10 b = 20 print(a == b) # False print(a != b) # True print(a \u0026gt; b) # False print(a \u0026lt; b) # True print(a \u0026gt;= b) # False print(a \u0026lt;= b) # True 4.4. Logical Operators and: Returns True if both statements are true or: Returns True if one of the statements is true not: Reverse the result, returns False if the result is true a = 10 b = 20 c = 30 print(a \u0026lt; b and b \u0026lt; c) # True print(a \u0026lt; b or b \u0026gt; c) # True print(not(a \u0026lt; b and b \u0026lt; c)) # False 4.5. Identity Operators is: Returns True if both variables are the same object is not: Returns True if both variables are not the same object a = [1,2,3] b = [1,2,3] print(a is b) # False print(a is not b) # True 4.6. Membership Operators in: Returns True if a sequence with the specified value is present in the object not in: Returns True if a sequence with the specified value is not present in the object a = [1,2,3] #Can be used in list , tuple , set , dict, string print(1 in a) # True print(4 not in a) # True 4.7. Bitwise Operators \u0026amp;: AND |: OR ^: XOR ~: NOT \u0026lt;\u0026lt;: Left Shift \u0026gt;\u0026gt;: Right Shift a = 10 b = 4 print(a \u0026amp; b) # 0 print(a | b) # 14 print(a ^ b) # 14 print(~a) # -11 print(a \u0026lt;\u0026lt; 2) # 40 print(a \u0026gt;\u0026gt; 2) # 2 Note: is vs ==\nis is used to compare the memory location of two objects. == is used to compare the values of two objects. # For Mutable objects (list, dict, set): a = [1,2,3] b = [1,2,3] print(a == b) # True print(a is b) # False # For immutable objects (int, float, string, tuple, None): a = 10 b = 10 print(a == b) # True print(a is b) # True c = None d = None print(c == d) # True print(c is d) # True 5.Taking User Input In Python, you can take user input using the input() function. Here\u0026rsquo;s an example:\nname = input(\u0026#34;Enter your name: \u0026#34;) print(\u0026#34;Hello, \u0026#34; + name) Note: The input() function always returns a string. If you want to convert it to another data type, you can use type conversion functions like int(), float(), etc.\n","permalink":"http://localhost:1313/posts/pages/python/python_basics/","summary":"A comprehensive guide to Python programming fundamentals covering core concepts for beginners","title":"Python Fundamentals: A Beginner's Guide (Part 1)"},{"content":"30. Sharing State Between React Components: Lifting State Up In React, components are the building blocks of a user interface. Each component can have its own state, but there are situations where multiple components need to share the same state. In such cases, the concept of \u0026ldquo;lifting state up\u0026rdquo; is used to manage the shared state in a common ancestor component.\u0026ldquo;Lifting state up\u0026rdquo; is a common pattern in React used when two or more components need to share data or state. Instead of managing the state in one of the components and creating a dependency between them, the state is \u0026ldquo;lifted up\u0026rdquo; to the closest common ancestor of the components that need the state.\nKey Concept When multiple components need to interact with the same state:\nThe closest common ancestor is identified. The state is moved to this common ancestor. This ancestor manages the state and passes it down to the child components as props. If any child needs to modify the state, the ancestor provides a function (passed as a prop) to handle the state update. Step-by-Step Procedure and Syntax Identify the Closest Common Ancestor:\nDetermine which component is the nearest common parent of all components that need to share the state. Lift the State Up:\nMove the state to the identified ancestor component. Use the useState hook (or class component state) to manage the state. const [state, setState] = useState(initialValue); Pass State Down as Props:\nPass the state to child components that need it via props. \u0026lt;ChildComponent state={state} /\u0026gt; Create State-Modifier Functions:\nDefine functions in the ancestor component to modify the state. const modifyStateHandler = (newData) =\u0026gt; { setState((prev) =\u0026gt; ({ ...prev, newData })); }; Pass Modifier Functions to Children:\nPass these functions to the child components as props so they can trigger state updates. \u0026lt;ChildComponent onModifyState={modifyStateHandler} /\u0026gt; Use Props in Child Components:\nAccess and use the state and modifier functions passed as props in the child components. function ChildComponent({ state, onModifyState }) { return ( \u0026lt;button onClick={() =\u0026gt; onModifyState(\u0026#34;new data\u0026#34;)}\u0026gt;Modify State\u0026lt;/button\u0026gt; ); } Example (Sharing State/Data Between Two Child Component) Parent Component (App.js) The parent component will hold the shared state and provide functions for updating it. It will pass the state and update functions as props to the child components.\nimport React, { useState } from \u0026#34;react\u0026#34;; import ChildOne from \u0026#34;./ChildOne\u0026#34;; import ChildTwo from \u0026#34;./ChildTwo\u0026#34;; const App = () =\u0026gt; { // Shared state const [sharedState, setSharedState] = useState(\u0026#34;Initial State\u0026#34;); // Function to update the state const updateState = (newState) =\u0026gt; { setSharedState(newState); }; return ( \u0026lt;div style={{ padding: \u0026#34;20px\u0026#34;, fontFamily: \u0026#34;Arial\u0026#34; }}\u0026gt; \u0026lt;h1\u0026gt;Parent Component\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;Shared State: {sharedState}\u0026lt;/p\u0026gt; \u0026lt;hr /\u0026gt; \u0026lt;ChildOne sharedState={sharedState} updateState={updateState} /\u0026gt; \u0026lt;hr /\u0026gt; \u0026lt;ChildTwo sharedState={sharedState} updateState={updateState} /\u0026gt; \u0026lt;/div\u0026gt; ); }; export default App; Child Component 1 (ChildOne.js) This component will display the shared state and allow the user to modify it through an input field.\nimport React from \u0026#34;react\u0026#34;; const ChildOne = ({ sharedState, updateState }) =\u0026gt; { const handleChange = (e) =\u0026gt; { updateState(e.target.value); }; return ( \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;Child Component One\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;Shared State: {sharedState}\u0026lt;/p\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; value={sharedState} onChange={handleChange} placeholder=\u0026#34;Update State\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; ); }; export default ChildOne; Child Component 2 (ChildTwo.js) This component will display the shared state and provide a button to reset it.\nimport React from \u0026#34;react\u0026#34;; import React from \u0026#34;react\u0026#34;; const ChildTwo = ({ sharedState, updateState }) =\u0026gt; { const handleReset = () =\u0026gt; { updateState(\u0026#34;Initial State\u0026#34;); }; return ( \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;Child Component Two\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;Shared State: {sharedState}\u0026lt;/p\u0026gt; \u0026lt;button onClick={handleReset}\u0026gt;Reset State\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); }; export default ChildTwo; Folder Structure src/ ├── App.js ├── ChildOne.js ├── ChildTwo.js ├── index.js Explanation:\nThe App component is the parent component that holds the shared state and passes it down to ChildOne and ChildTwo. ChildOne and ChildTwo are child components that receive the shared state and update functions as props. ChildOne allows the user to update the shared state through an input field, while ChildTwo provides a button to reset the state. Note: We cant directly pass data from one child component to another child component. We need to pass the data to the parent component and then pass it to the other child component. This is called lifting state up.\nExample (Sharing State/Data Between Two Sibling Components) Parent Component (App.js) import {usState} from \u0026#39;react\u0026#39;; import Expenses from \u0026#39;./Expenses\u0026#39;; import NewExpense from \u0026#39;./NewExpense\u0026#39;; const App=()=\u0026gt;{ const [expenses,setExpenses]=useState([ {id:1,title:\u0026#39;Car Insurance\u0026#39;,amount:294.67,date:new Date(2021,2,28)}, {id:2,title:\u0026#39;Health Insurance\u0026#39;,amount:394.67,date:new Date(2021,3,28)}, {id:3,title:\u0026#39;Home Insurance\u0026#39;,amount:494.67,date:new Date(2021,4,28)}, ]); const addExpenseHandler=(expense)=\u0026gt;{ setExpenses((prevExpenses)=\u0026gt;{ return [expense,...prevExpenses]; }); }; return ( \u0026lt;div\u0026gt; \u0026lt;NewExpense onAddExpense={addExpenseHandler}/\u0026gt; \u0026lt;Expenses items={expenses}/\u0026gt; \u0026lt;/div\u0026gt; ); }; export default App; NewExpense Component import ExpenseForm from \u0026#39;./ExpenseForm\u0026#39;; const NewExpense=(props)=\u0026gt;{ const saveExpenseDataHandler=(enteredExpenseData)=\u0026gt;{ const expenseData={ ...enteredExpenseData, id:Math.random().toString() }; props.onAddExpense(expenseData); }; return ( \u0026lt;div\u0026gt; \u0026lt;ExpenseForm onSaveExpenseData={saveExpenseDataHandler}/\u0026gt; \u0026lt;/div\u0026gt; ); }; export default NewExpense; Expenses function Expenses({iteam}){ return ( \u0026lt;\u0026gt; {items.map((expense)=\u0026gt;( \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;{expense.title}\u0026lt;/h2\u0026gt; \u0026lt;div\u0026gt;{expense.amount}\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;{expense.date.toISOString()}\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ))} \u0026lt;/div\u0026gt; ) } 31. Dynamically setting object keys In JavaScript, object keys are usually set statically, but there are situations where you may need to set object keys dynamically based on some conditions or variables. This can be achieved using the square bracket notation ([]) to set object keys dynamically.\nfor example:\nconst data=\u0026#34;name\u0026#34;; const person={ [data]:\u0026#39;John\u0026#39; }; console.log(person); // {name:\u0026#39;John\u0026#39;} If we dont use square bracket notation, then the key will be set as \u0026lsquo;data\u0026rsquo; instead of \u0026rsquo;name\u0026rsquo;.\nconst data=\u0026#34;name\u0026#34;; const person={ data:\u0026#39;John\u0026#39; }; console.log(person); // {data:\u0026#39;John\u0026#39;} 32.Using SAme State Variable to store multiple values =\u0026gt; We can use the same state variable to store multiple values by using an object.\nconst [userInput,setUserInput]=useState({ enteredTitle:\u0026#39;\u0026#39;, enteredAmount:\u0026#39;\u0026#39;, enteredDate:\u0026#39;\u0026#39; }); const titleChangeHandler=(event)=\u0026gt;{ setUserInput({ ...userInput, enteredTitle:event.target.value }); }; const amountChangeHandler=(event)=\u0026gt;{ setUserInput({ ...userInput, enteredAmount:event.target.value }); }; const dateChangeHandler=(event)=\u0026gt;{ setUserInput({ ...userInput, enteredDate:event.target.value }); }; return ( \u0026lt;div\u0026gt; Title:\u0026lt;input type=\u0026#34;text\u0026#34; value={userInput.enteredTitle} onChange={titleChangeHandler}/\u0026gt; Amount:\u0026lt;input type=\u0026#34;number\u0026#34; value={userInput.enteredAmount} onChange={amountChangeHandler}/\u0026gt; Date:\u0026lt;input type=\u0026#34;date\u0026#34; value={userInput.enteredDate} onChange={dateChangeHandler}/\u0026gt; The entered title is {userInput.enteredTitle} The entered amount is {userInput.enteredAmount} The entered date is {userInput.enteredDate} \u0026lt;/div\u0026gt; ); =\u0026gt; In the above code, we are using the same state variable userInput to store multiple values. We are using an object to store the values. We are using the spread operator to copy the existing values of the object and then updating the required value.\n33.Handeling page reloads when a form is submitted When a form is submitted, the page reloads by default. This is not what we want in a single page application. We want to stay on the same page and update the content of the page. We can do this by using the preventDefault() method on the event object. The preventDefault() method prevents the default behavior of the event object. In this case, it prevents the page from reloading when the form is submitted. const submitHandler=(event)=\u0026gt;{ event.preventDefault(); // code to handle form submission }; ","permalink":"http://localhost:1313/posts/pages/react/react4/","summary":"Learn how to share state between React components by lifting state up to a common ancestor.","title":"React : Day 4"},{"content":"1. Python Manupulation of Data Types We have already discussed the basic concepts of Python programming in the previous part of this series. In this part, we will dive deeper into operations and manipulations of different data types in Python.\n1.1.Numeric Operations 1.1.1. abs() Function The abs() function returns the absolute value of a number. For example:\nnum = -10 print(abs(num)) # Output: 10 1.1.2. round() Function The round() function rounds a number to the nearest integer. For example:\nnum = 3.14159 print(round(num)) # Output: 3 1.1.3. ord() Function The ord() function returns the Unicode code point of a character. For example:\nchar = \u0026#39;A\u0026#39; print(ord(char)) # Output: 65 1.2. String Operations String is a sequence of characters enclosed within single, double, or triple quotes. In Python, strings are immutable, meaning they cannot be changed once created. Here are some common string operations:\n1.2.1. Declaring a String we can declare a string using single, double, or triple quotes. For example:\nstr1 = \u0026#39;Hello, World!\u0026#39; #for single line string str2 = \u0026#34;Hello, World!\u0026#34; #for single line string str3 = \u0026#39;\u0026#39;\u0026#39;Hello, World! This is a multiline string.\u0026#39;\u0026#39;\u0026#39;#for multiline string 1.2.2. Text Decorators There are many text decorators available in Python to format strings among them we use \\n for a new line, \\t for a tab. For example:\nstr1 = \u0026#39;Hello, \\nWorld!\u0026#39; #for new line str2 = \u0026#34;Hello, \\tWorld!\u0026#34; #for tab 1.2.3. String Indexing The indexing of a string starts from 0 to n-1, where n is the length of the string. For example: for example: a=\u0026ldquo;hello\u0026rdquo;\na = H e l l o 0 1 2 3 4 0 -4 -3 -2 -1 1.2.4. Ascessing Characters in a String We can access characters in a string using the index using []. For example:\nstr = \u0026#34;Hello, World!\u0026#34; print(str[0]) # Output: H print(str[-1]) # Output: ! 1.2.5. String Concatenation We can concatenate two strings using the + operator and * operator . For example:\nstr1 = \u0026#34;Hello\u0026#34; str2 = \u0026#34;World\u0026#34; print(str1 + str2) # Output: HelloWorld print(str1 * 3) # Output: HelloHelloHello 1.2.6. String Slicing We can slice a string using the syntax variable[start:end:step] to get a substring.\nNote: The substring contains characters from index start to end-1, meaning the character at the end index is not included but character at the start index is included . The step refers to the increment or jump of the index\nFor example:\na = \u0026#34;hello\u0026#34; # Slice from index 1 to the end of the string print(a[1:]) # ello (Characters from index 1 to the end) # Slice from the beginning of the string to index 4 (doesn\u0026#39;t contain character at index 4) print(a[:4]) # hell (Characters from index 0 to 3) # Slice from index 1 to index 4 (doesn\u0026#39;t contain character at index 4) print(a[1:4]) # ell (Characters from index 1 to 3) # Full slice of the string with default values print(a[::]) # hello (Default start is 0, end is the string length, step is 1) # Defining a step value in slicing # Slice with a step of 2 print(a[::2]) # hlo (Start from index 0 to the end, select every 2nd character) # Reverse the string using a negative step print(a[::-1]) # olleh (Reverse the string by stepping backward) # Combining start, end, and step print(a[1:4:2]) # el #(Start from index 1 to 4 (doesn\u0026#39;t contain character at index 4), with a step of 2) 1.2.7. String Methods Python provides various built-in methods to manipulate strings. Some of the commonly used string methods are:\nlen() : Returns the length of the string. str = \u0026#34;Hello, World!\u0026#34; print(len(str)) # Output: 13 replace() : Replaces a substring with another substring. str = \u0026#34;Hello, World!\u0026#34; print(str.replace(\u0026#34;World\u0026#34;, \u0026#34;Universe\u0026#34;)) # Output: Hello, Universe! upper() : Converts the string to uppercase. str = \u0026#34;Hello, World!\u0026#34; print(str.upper()) # Output: HELLO, WORLD! lower() : Converts the string to lowercase. str = \u0026#34;Hello, World!\u0026#34; print(str.lower()) # Output: hello, world! split() : Splits the string into a list based on the delimiter. str = \u0026#34;Hello, World!\u0026#34; print(str.split(\u0026#34;,\u0026#34;)) # Output: [\u0026#39;Hello\u0026#39;, \u0026#39; World!\u0026#39;] capitalize() : Converts the first character of the string to uppercase.\nstr = \u0026#34;hello, world!\u0026#34; print(str.capitalize()) # Output: Hello, world! -find() : Returns the index of the first occurrence of a substring.\nstr = \u0026#34;Hello, World!\u0026#34; print(str.find(\u0026#34;World\u0026#34;)) # Output: 7 print(str.find(\u0026#34;e\u0026#34;)) # Output: 1 print(str.find(\u0026#34;Universe\u0026#34;)) # Output: -1 count() : Returns the number of occurrences of a substring. str = \u0026#34;Hello, World!\u0026#34; print(str.count(\u0026#34;l\u0026#34;)) # Output: 3 startswith() : Returns True if the string starts with a specified substring. str = \u0026#34;Hello, World!\u0026#34; print(str.startswith(\u0026#34;Hello\u0026#34;)) # Output: True endswith() : Returns True if the string ends with a specified substring. str = \u0026#34;Hello, World!\u0026#34; print(str.endswith(\u0026#34;World!\u0026#34;)) # Output: True strip() : Removes leading and trailing whitespaces from the string. We can also specify the characters to be removed. str = \u0026#34; Hello, World! \u0026#34; print(str.strip()) # Output: Hello, World! str = \u0026#34;!!!!!!!!Hello, World!!!!!\u0026#34; print(str.strip(\u0026#34;!\u0026#34;)) # Output: Hello, World! lstrip() : Removes leading whitespaces from the string.we can also specify the characters to be removed. str = \u0026#34; Hello, World! \u0026#34; print(str.lstrip()) # Output: Hello, World! str = \u0026#34;!!!!!!!!Hello, World!!!!!\u0026#34; print(str.lstrip(\u0026#34;!\u0026#34;)) # Output: Hello, World!!!!! rstrip() : Removes trailing whitespaces from the string.We can also specify the characters to be removed. str = \u0026#34; Hello, World! \u0026#34; print(str.rstrip()) # Output: Hello, World! str = \u0026#34;!!!!!!!!Hello, World!!!!!\u0026#34; print(str.rstrip(\u0026#34;!\u0026#34;)) # Output: !!!!!!!!Hello, World 1.2.8. f-Strings f-strings are a convenient way to format strings in Python. They allow you to embed expressions inside string literals, using curly braces {}. For example:\nname = \u0026#34;Alice\u0026#34; age = 30 print(f\u0026#34;My name is {name} and I am {age} years old.\u0026#34;) # Output: My name is Alice and I am 30 years old. 1.2.9. Raw Strings Raw strings are used to ignore escape characters in a string. They are prefixed with an r or R. For example:\npath=\u0026#34;C:\\Users\\Alice\\Documents\u0026#34; print(path) # Output: C:UsersAliceDocuments path = r\u0026#34;C:\\Users\\Alice\\Documents\u0026#34; print(path) # Output: C:\\Users\\Alice\\Documents Note:String is immutable in python.\na = \u0026#34;Hello\u0026#34; a[0] = \u0026#34;h\u0026#34; # Error: \u0026#39;str\u0026#39; object does not support item assignment #Instead To change the string value we can use the following method a=\u0026#39;k\u0026#39;+a[1::] # Output: \u0026#39;kello\u0026#39; 1.3. List Operations A list is a collection of items enclosed within square brackets []. Lists are mutable, meaning they can be changed after creation. Here are some common list operations: Key Points:\nList is mutable in python. List support indexing and slicing like string 1.3.1. Declaring a List We can declare a list by enclosing items within square brackets []. For example:\nlist1 = [1, 2, 3, 4, 5] list2 = [\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;] list3 = [1, \u0026#34;apple\u0026#34;, True, 3.14] 1.3.2 List Concatenation We can concatenate two or more lists using the + operator. For example:\nlist1 = [1, 2, 3] list2 = [4, 5, 6] print(list1 + list2) # Output: [1, 2, 3, 4, 5, 6] 1.3.3. Mutable property of List List is mutable in python and its example is shown below:\n#for string a = \u0026#34;Hello\u0026#34; a[0] = \u0026#34;h\u0026#34; # Error: \u0026#39;str\u0026#39; object does not support item assignment #for list list1 = [1, 2, 3] list1[0] = 10 print(list1) # Output: [10, 2, 3] 1.3.4. Built-in List Methods Python provides various built-in methods to manipulate lists. Some of the commonly used list methods are:\nlen() : Returns the length of the list. list1 = [1, 2, 3, 4, 5] print(len(list1)) # Output: 5 append() : Adds an element to the end of the list /Change orginal list does not return anything. list1 = [1, 2, 3] list1.append(4) print(list1) # Output: [1, 2, 3, 4] insert() : Inserts an element at a specified position in the list /Change orginal list does not return anything. list1 = [1, 2, 3] list1.insert(1, 4) print(list1) # Output: [1, 4, 2, 3] pop() : Removes the element at the specified position in the list and returns it. If no index is specified, it removes and returns the last element. list1 = [1, 2, 3] print(list1.pop(1)) # Output: 2 print(list1) # Output: [1, 3] print(list1.pop()) # Output: 3 print(list1) # Output: [1] remove() : Removes the first occurrence of the specified element from the list. list1 = [1, 2, 3, 2] list1.remove(2) print(list1) # Output: [1, 3, 2] -sort() : Sorts the list in ascending order.Does not return anything but change the original list.\nlist1 = [3, 1, 2] list1.sort() print(list1) # Output: [1, 2, 3] -reverse() : Reverses the order of the list. Does not return anything but change the original list.\nlist1 = [1, 2, 3] list1.reverse() print(list1) # Output: [3, 2, 1] -count() : Returns the number of occurrences of a specified element in the list.\nlist1 = [1, 2, 3, 2] print(list1.count(2)) # Output: 2 -index() : Returns the index of the first occurrence of the specified element in the list.\nlist1 = [1, 2, 3, 2] print(list1.index(2)) # Output: 1 1.3.5. List Comprehension List comprehension is a concise way to create lists from existing lists. There are 3 type of syntax.\nNot using if list1=[variable for variable in iterable] Using if only list1 = [variable for variable in iterable if condition] Using if else list1 = [variable if condition else variable for variable in iterable] Traditional way of creating list\nlist1 = [] for i in range(5): list1.append(i) print(list1) # Output: [0, 1, 2, 3, 4] Using list comprehension\nlist1 = [i for i in range(5)] print(list1) # Output: [0, 1, 2, 3, 4] list1 = [i for i in range(5) if i%2==0] print(list1) # Output: [0, 2, 4] list1 = [i if i%2==0 else i**2 for i in range(5)] print(list1) # Output: [0, 1, 2, 9, 4] Note: When you attempt to access an index that is out of range, Python will raise an IndexError so put it in try-except block to handle the error.\nNote: The indexing and slicing of list are similar to string.\n1.4 Dictionary Operations A dictionary is a collection of key-value pairs enclosed within curly braces {}. Dictionaries are mutable and unordered. Here are some common dictionary operations:\n1.4.1. Declaring a Dictionary We can declare a dictionary by specifying key-value pairs within curly braces {}. For example:\ndict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} dict2 = {1: \u0026#34;apple\u0026#34;, 2: \u0026#34;banana\u0026#34;, 3: \u0026#34;cherry\u0026#34;} dict3 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;, \u0026#34;hobbies\u0026#34;: [\u0026#34;reading\u0026#34;, \u0026#34;painting\u0026#34;]} 1.4.2. Accessing Dictionary Elements We can access dictionary elements using keys. For example:\ndict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} print(dict1[\u0026#34;name\u0026#34;]) # Output: Alice 1.4.3 Adding Dictionary Elements We can add new key-value pairs to a dictionary by specifying the key and value. For example:\ndict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30} dict1[\u0026#34;city\u0026#34;] = \u0026#34;New York\u0026#34; print(dict1) # Output: {\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 30, \u0026#39;city\u0026#39;: \u0026#39;New York\u0026#39;} 1.4.4. Updating Dictionary Elements We can update the value of an existing key in a dictionary. For example:\ndict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} dict1[\u0026#34;age\u0026#34;] = 35 print(dict1) # Output: {\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 35, \u0026#39;city\u0026#39;: \u0026#39;New York\u0026#39;} 1.4.5 Dictionary Methods Python provides various built-in methods to manipulate dictionaries. Some of the commonly used dictionary methods are:\nlen() : Returns the number of key-value pairs in the dictionary. dict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} print(len(dict1)) # Output: 3 keys() : Returns a list of all the keys in the dictionary. dict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} print(dict1.keys()) # Output: dict_keys([\u0026#39;name\u0026#39;, \u0026#39;age\u0026#39;, \u0026#39;city\u0026#39;]) values() : Returns a list of all the values in the dictionary. dict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} print(dict1.values()) # Output: dict_values([\u0026#39;Alice\u0026#39;, 30, \u0026#39;New York\u0026#39;]) items() : Returns a list of key-value pairs in the dictionary. dict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} print(dict1.items()) # Output: dict_items([(\u0026#39;name\u0026#39;, \u0026#39;Alice\u0026#39;), (\u0026#39;age\u0026#39;, 30), (\u0026#39;city\u0026#39;, \u0026#39;New York\u0026#39;)]) -pop() : Removes the element with the specified key and returns its value.\ndict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} print(dict1.pop(\u0026#34;age\u0026#34;)) # Output: 30 print(dict1) # Output: {\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;city\u0026#39;: \u0026#39;New York\u0026#39;} -get() : Returns the value of the specified key. If the key does not exist, it returns the specified default value.\ndict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} print(dict1.get(\u0026#34;age\u0026#34;)) # Output: 30 print(dict) # Output: {\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 30, \u0026#39;city\u0026#39;: \u0026#39;New York\u0026#39;} Note: When you attempt to access a key that does not exist in the dictionary, Python will raise a KeyError so put it in try-except block to handle the error or use get() method to avoid the error.\n1.4.6. Nested Dictionaries A dictionary can contain another dictionary as a value. This is known as a nested dictionary. For example:\ndict1 = { \u0026#34;person1\u0026#34;: {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30}, \u0026#34;person2\u0026#34;: {\u0026#34;name\u0026#34;: \u0026#34;Bob\u0026#34;, \u0026#34;age\u0026#34;: 25} } print(dict1[\u0026#34;person1\u0026#34;][\u0026#34;name\u0026#34;]) # Output: Alice 1.4.7. Dictionary Comprehension Dictionary comprehension is a concise way to create dictionaries. For example:\ndict1 = {x: x**2 for x in range(5)} # Output: {0: 0, 1: 1, 2: 4, 3: 9, 4: 16} #using if only dict1 = {x: x**2 for x in range(5) if x%2==0} # Output: {0: 0, 2: 4, 4: 16} #using if else dict1 = {x: x**2 if x%2==0 else x**3 for x in range(5)} # Output: {0: 0, 1: 1, 2: 4, 3: 27, 4: 16} 1.5. Tuple Operations A tuple is a collection of items enclosed within parentheses (). Tuples are immutable, meaning they similar to python as they cant be changed using indexing as a[0]=10 will give an error.\n1.5.1. Declaring a Tuple We can declare a tuple by enclosing items within parentheses (). For example:\ntuple1 = (1, 2, 3) tuple2 = (\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;) tuple3 = (1, \u0026#34;apple\u0026#34;, True, 3.14) 1.5.2. Accessing Tuple Elements We can access tuple elements using indexing . For example:\ntuple1 = (1, 2, 3) print(tuple1[0]) # Output: 1 1.5.3. Slice Tuple We can slice a tuple using the syntax variable[start:end:step] to get a sub-tuple. For example:\ntuple1 = (1, 2, 3, 4, 5) print(tuple1[1:4]) # Output: (2, 3, 4) 1.5.4. Tuple Methods Python provides various built-in methods to manipulate tuples. Some of the commonly used tuple methods are:\ncount() : Returns the number of occurrences of a specified element in the tuple. tuple1 = (1, 2, 3, 2) print(tuple1.count(2)) # Output: 2 index() : Returns the index of the first occurrence of the specified element in the tuple. tuple1 = (1, 2, 3, 2) print(tuple1.index(2)) # Output: 1 len() : Returns the length of the tuple. tuple1 = (1, 2, 3, 2) print(len(tuple1)) # Output: 4 1.5.5 concatenation of tuple We can concatenate two or more tuples using the + operator. For example:\ntuple1 = (1, 2, 3) tuple2 = (4, 5, 6) print(tuple1 + tuple2) # Output: (1, 2, 3, 4, 5, 6) 1.5.6. Tuple Unpacking Tuple unpacking allows us to assign multiple variables at once. For example:\ntuple1 = (1, 2, 3) a, b, c = tuple1 d,*e = tuple1 print(a) # Output: 1 print(b) # Output: 2 print(c) # Output: 3 print(d) # Output: 1 print(e) # Output: [2, 3] tuple1 = (1, 2, 3, 4, 5) a, *b, c = tuple1 print(a) # Output: 1 print(b) # Output: [2, 3, 4] print(c) # Output: 5 Note:Ascessing and slicing of tuple is similar to list and string.\n1.6. Boolean Operations Boolean is a data type that represents one of two values: True or False. Boolean values are used to evaluate conditions in programming. Here are some common boolean operations:\n1.6.1. Condition when variable is True When a variable has a non-zero value, it is considered True. a = 10 if a: print(\u0026#34;The value of a is True\u0026#34;) When a string is not empty, it is considered True. a = \u0026#34;Hello\u0026#34; if a: print(\u0026#34;The value of a is True\u0026#34;) When a list is not empty, it is considered True. a = [1, 2, 3] if a: print(\u0026#34;The value of a is True\u0026#34;) When a dictionary is not empty, it is considered True. a = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30} if a: print(\u0026#34;The value of a is True\u0026#34;) When a tuple is not empty, it is considered True. a = (1, 2, 3) if a: print(\u0026#34;The value of a is True\u0026#34;) When a set is not empty, it is considered True. a = {1, 2, 3} if a: print(\u0026#34;The value of a is True\u0026#34;) When a variable is explicitly set to True, it is considered True. a = True if a: print(\u0026#34;The value of a is True\u0026#34;) 1.6.2. Condition when variable is False Those which are not in the above condition are considered as False.\n1.7. Set Operations A set is a collection of unique items enclosed within curly braces {}. Main Uses of set are:\nTo remove duplicate elements from a list. To perform mathematical set operations like union, intersection, difference, etc. 1.7.1. Declaring a Set We can declare a set by enclosing items within curly braces {} or set(). For example:\nset1 = {1, 2, 3} set2 = {\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;} set3 = {1, \u0026#34;apple\u0026#34;, True, 3.14} #using set() set4 = set([1, 2, 3]) set5=set() 1.7.2. Set Methods Python provides various built-in methods to manipulate sets. Some of the commonly used set methods are:\n-len() : Returns the number of elements in the set.\nset1 = {1, 2, 3} print(len(set1)) # Output: 3 -add() : Adds an element to the set.Doesn\u0026rsquo;t return anything.\nset1 = {1, 2, 3} set1.add(4) print(set1) # Output: {1, 2, 3, 4} -clear() : Removes all elements from the set.Doesn\u0026rsquo;t return anything.\nset1 = {1, 2, 3} set1.clear() print(set1) # Output: set() -remove() : Removes the specified element from the set. If the element is not present, it raises an error.\nset1 = {1, 2, 3} set1.remove(2) print(set1) # Output: {1, 3} discard() : Removes the specified element from the set. If the element is not present, it does not raise an error.\nset1 = {1, 2, 3} set1.discard(2) print(set1) # Output: {1, 3} -union() : Returns a set containing the union of two sets.\nset1 = {1, 2, 3} set2 = {3, 4, 5} print(set1.union(set2)) # Output: {1, 2, 3, 4, 5} -intersection() : Returns a set containing the intersection of two sets.\nset1 = {1, 2, 3} set2 = {3, 4, 5} print(set1.intersection(set2)) # Output: {3} -difference() : Returns a set containing the difference between two sets.\nset1 = {1, 2, 3} set2 = {3, 4, 5} print(set1.difference(set2)) # Output: {1, 2} -symmetric_difference() : Returns a set containing the symmetric difference between two sets.\nset1 = {1, 2, 3} set2 = {3, 4, 5} print(set1.symmetric_difference(set2)) # Output: {1, 2, 4, 5} -issubset() : Returns True if all elements of a set are present in another set.\nset1 = {1, 2, 3} set2 = {1, 2, 3, 4, 5} print(set1.issubset(set2)) # Output: True 1.8 Used in All iterable 1.8.1. in Operator The in operator is used to check if an element is present in an iterable. For example:\n# in string str = \u0026#34;Hello, World!\u0026#34; print(\u0026#34;Hello\u0026#34; in str) # Output: True # in list list1 = [1, 2, 3, 4, 5] print(3 in list1) # Output: True # in tuple tuple1 = (1, 2, 3, 4, 5) print(6 in tuple1) # Output: False # in set set1 = {1, 2, 3, 4, 5} print(5 in set1) # Output: True # in dictionary dict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30} print(\u0026#34;name\u0026#34; in dict1) # Output: True 1.8.2. not in Operator The not in operator is used to check if an element is not present in an iterable. For example:\n# not in string str = \u0026#34;Hello, World!\u0026#34; print(\u0026#34;Alice\u0026#34; not in str) # Output: True # not in list list1 = [1, 2, 3, 4, 5] print(6 not in list1) # Output: True # not in tuple tuple1 = (1, 2, 3, 4, 5) print(5 not in tuple1) # Output: False # not in set set1 = {1, 2, 3, 4, 5} print(5 not in set1) # Output: False # not in dictionary dict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30} print(\u0026#34;name\u0026#34; not in dict1) # Output: False 1.8.3. len() Function The len() function is used to get the length of an iterable. For example:\n# for string str = \u0026#34;Hello, World!\u0026#34; print(len(str)) # Output: 13 # for list list1 = [1, 2, 3, 4, 5] print(len(list1)) # Output: 5 # for tuple tuple1 = (1, 2, 3, 4, 5) print(len(tuple1)) # Output: 5 # for set set1 = {1, 2, 3, 4, 5} print(len(set1)) # Output: 5 # for dictionary dict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30} print(len(dict1)) # Output: 2 1.8.4. max() and min() Functions The max() function is used to get the maximum value from an iterable, and the min() function is used to get the minimum value for list,string,set and tuples only. for dictionary you can use .keys() or .values() and use it. For example:\n# for list list1 = [1, 2, 3, 4, 5] print(max(list1)) # Output: 5 print(min(list1)) # Output: 1 # for tuple tuple1 = (1, 2, 3, 4, 5) print(max(tuple1)) # Output: 5 print(min(tuple1)) # Output: 1 # for string string = \u0026#34;Hello, World!\u0026#34; print(max(string)) # Output: r print(min(string)) # Output: \u0026#39; \u0026#39; # for set set1 = {1, 2, 3, 4, 5} print(max(set1)) # Output: 5 print(min(set1)) # Output: 1 1.8.5. join() Function The join() function is used to concatenate elements of an iterable with a separator. For example:\n# for list list1 = [\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;] print(\u0026#34;, \u0026#34;.join(list1)) # Output: apple, banana, cherry # for tuple tuple1 = (\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;) print(\u0026#34;, \u0026#34;.join(tuple1)) # Output: apple, banana, cherry # for set set1 = {\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;} print(\u0026#34;, \u0026#34;.join(set1)) # Output: apple, banana, cherry # for string string = \u0026#34;Hello, World!\u0026#34; print(\u0026#34;, \u0026#34;.join(string)) # Output: H, e, l, l, o, ,, , W, o, r, l, d, ! ","permalink":"http://localhost:1313/posts/pages/python/python_datatype_operations/","summary":"An in-depth look at Python data types, exploring their usage and importance in programming.","title":"Python Fundamentals: Understanding Data Types (Part 2)"},{"content":"22. Fragments in React Fragments are a way to group multiple elements in React without adding extra nodes to the DOM. Fragments are useful when you want to return multiple elements from a component, but you don\u0026rsquo;t want to add an extra div or span element to the DOM.\nFragments are represented by the \u0026lt;Fragment\u0026gt; tag or the shorthand syntax \u0026lt;\u0026gt;. You can use fragments to return multiple elements from a component without adding extra nodes to the DOM.\nWithout using fragments:\nfunction App() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Hello, World!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;Welcome to React\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } Here, the App component returns two elements, but they are wrapped in a div element. If you don\u0026rsquo;t want to add an extra div element to the DOM, you can use fragments.\nUsing fragments:\nfunction App() { return ( \u0026lt;\u0026gt; or \u0026lt;Fragment\u0026gt; \u0026lt;h1\u0026gt;Hello, World!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;Welcome to React\u0026lt;/p\u0026gt; \u0026lt;/\u0026gt; or \u0026lt;/Fragment\u0026gt; ); } 23. Passing jsx as props In React, you can pass JSX as props to other components. This allows you to create reusable components that can be used in different parts of your application.\nPassing JSX as props: function App() { const heading = \u0026lt;div\u0026gt;\u0026lt;h1\u0026gt;Hello, World!\u0026lt;/h1\u0026gt;\u0026lt;p\u0026gt;My name is nirajan Khatiwada\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;; return \u0026lt;Greeting message={heading} /\u0026gt;; } or function App() { return \u0026lt;Greeting message={\u0026lt;div\u0026gt;\u0026lt;h1\u0026gt;Hello, World!\u0026lt;/h1\u0026gt;\u0026lt;p\u0026gt;My name is nirajan Khatiwada\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;} /\u0026gt;; } Using props in the Greeting component: function Greeting(props) { return \u0026lt;div\u0026gt;{props.message}\u0026lt;/div\u0026gt;; } Passing built-in components as props: function App() { return \u0026lt;Greeting element=\u0026#34;button\u0026#34; /\u0026gt;; } 24. Isolation of Component in React Isolation of components is a key concept in React that allows you to create reusable components that are independent of each other. This means that each component should be self-contained and not rely on external data or state.\nfor example:\nfunction Button(props){ const [showText, setShowText] = useState(false); return ( \u0026lt;button onClick={() =\u0026gt; setShowText(!showText)}\u0026gt; {showText ? \u0026#39;Hide Text\u0026#39; : \u0026#39;Show Text\u0026#39;} \u0026lt;/button\u0026gt; ); } function App(){ return ( \u0026lt;div\u0026gt; \u0026lt;Button /\u0026gt; \u0026lt;Button /\u0026gt; \u0026lt;/div\u0026gt; ); } Here The component Button is isolated means one state of the component does not affect the other component. Each component is self-contained and does not rely on external data or state. for example, the showText state in one Button component does not affect the showText state in the other Button component.\n25. Taking User Input in React Using onChange event: function App() { const [name, setName] = useState(\u0026#39;\u0026#39;); const handleChange = (e) =\u0026gt; { setName(e.target.value); }; return ( \u0026lt;div\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; value={name} onChange={handleChange} /\u0026gt; \u0026lt;p\u0026gt;Hello, {name}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } Whats Happen Here\nHere, we have an input element that takes user input. When the user types in the input field,the onChange event is triggered for ervy keypress. The handleChange function is called with the event object as an argument for every keypress. The setName function is called with value of user input and it rerender the component with the updated value for every keypress. The value of the input field is set to the name state, and the name is displayed below the input field. Note: use onChange event to take user input in React and update the state accordingly to reflect the changes in the UI. If you use value as a prop in the input field, you must also provide an onChange event handler to update the state. Use this method if you want to update in real-time as the user types in the input field.\nOther method will be discussed in upcoming posts. 26.Rendering 2D Arrays in React In React, you can render 2D arrays by using nested map functions to iterate over the rows and columns of the array. This allows you to display tabular data or grid-like structures in your application.\nRendering a 2D array: function App() { const data = [ [\u0026#39;John\u0026#39;, \u0026#39;Doe\u0026#39;, 30], [\u0026#39;Jane\u0026#39;, \u0026#39;Smith\u0026#39;, 25], [\u0026#39;Alice\u0026#39;, \u0026#39;Brown\u0026#39;, 35], ]; return ( \u0026lt;table\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;First Name\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Last Name\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Age\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; {data.map((row, index) =\u0026gt; ( \u0026lt;tr key={index}\u0026gt; {row.map((cell, index) =\u0026gt; ( \u0026lt;td key={index}\u0026gt;{cell}\u0026lt;/td\u0026gt; ))} \u0026lt;/tr\u0026gt; ))} \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; ); } 27. Immutable update patterns in React In react while changing the state we shouldnot change the orginal state directly Instead, we should create a new copy of the state and update the copy with the new values. This is known as immutable update pattern.speciaaly when working with arrays and objects.\nThe Wrong way to update state: function App() { const [items, setItems] = useState([\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;cherry\u0026#39;]); const removeItem = (index) =\u0026gt; { items.splice(index, 1); setItems(items); }; return ( \u0026lt;div\u0026gt; \u0026lt;ul\u0026gt; {items.map((item, index) =\u0026gt; ( \u0026lt;li key={index}\u0026gt; {item} \u0026lt;button onClick={() =\u0026gt; removeItem(index)}\u0026gt;Remove\u0026lt;/button\u0026gt; \u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ); } The Correct way to update state: function App() { const [items, setItems] = useState([\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;cherry\u0026#39;]); const removeItem = (index) =\u0026gt; { const newItems = [...items]; newItems.splice(index, 1); setItems(newItems); }; return ( \u0026lt;div\u0026gt; \u0026lt;ul\u0026gt; {items.map((item, index) =\u0026gt; ( \u0026lt;li key={index}\u0026gt; {item} \u0026lt;button onClick={() =\u0026gt; removeItem(index)}\u0026gt;Remove\u0026lt;/button\u0026gt; \u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt;x x \u0026lt;/div\u0026gt; ); } Note: Always create a new copy of the state when updating arrays or objects in React. This ensures that the state is updated correctly and prevents unexpected behavior in your application. 28. Common Pattern for update,delete and add in React In React, you can use common patterns to update, delete, and add items to an array. These patterns involve creating new copies of the array and updating the state with the new values.\nAdd an item to an array: function App() { const [items, setItems] = useState([\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;cherry\u0026#39;]); const addItem = (item) =\u0026gt; { setItems([...items, item]); // or // const newItems = [...items]; // newItems.push(item); // setItems(newItems); }; return ( \u0026lt;div\u0026gt; \u0026lt;ul\u0026gt; {items.map((item, index) =\u0026gt; ( \u0026lt;li key={index}\u0026gt;{item}\u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;button onClick={() =\u0026gt; addItem(\u0026#39;orange\u0026#39;)}\u0026gt;Add Item\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } Deleting an item from an array: function App() { const [items, setItems] = useState([\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;cherry\u0026#39;]); const removeItem = (index) =\u0026gt; { const newItems = items.filter((item, i) =\u0026gt; i !== index); setItems(newItems); }; return ( \u0026lt;div\u0026gt; \u0026lt;ul\u0026gt; {items.map((item, index) =\u0026gt; ( \u0026lt;li key={index}\u0026gt; {item} \u0026lt;button onClick={() =\u0026gt; removeItem(index)}\u0026gt;Remove\u0026lt;/button\u0026gt; \u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ); } Updating an data of an array using map: function App() { const [items, setItems] = useState([ { id: 1, name: \u0026#39;apple\u0026#39;, price: 1 }, { id: 2, name: \u0026#39;banana\u0026#39;, price: 2 }, { id: 3, name: \u0026#39;cherry\u0026#39;, price: 3 }, ]); const updateItem = (id, price) =\u0026gt; { const newItems = items.map((item) =\u0026gt; item.id === id ? { ...item, price: price } : item ); setItems(newItems); }; return ( \u0026lt;div\u0026gt; \u0026lt;ul\u0026gt; {items.map((item) =\u0026gt; ( \u0026lt;li key={item.id}\u0026gt; {item.name} - ${item.price}{\u0026#39; \u0026#39;} \u0026lt;button onClick={() =\u0026gt; updateItem(item.id, item.price + 1)}\u0026gt; Increase Price \u0026lt;/button\u0026gt; \u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ); } Updating an data of an array using find: function App() { const [items, setItems] = useState([ { id: 1, name: \u0026#39;apple\u0026#39;, price: 1 }, { id: 2, name: \u0026#39;banana\u0026#39;, price: 2 }, { id: 3, name: \u0026#39;cherry\u0026#39;, price: 3 }, ]); const updateItem = (id, price) =\u0026gt; { const newItems= [...items]; const newItem = newItems.find((item) =\u0026gt; item.id === id); if (newItem) { newItem.price = price; setItems(newItems); } }; return ( \u0026lt;div\u0026gt; \u0026lt;ul\u0026gt; {items.map((item) =\u0026gt; ( \u0026lt;li key={item.id}\u0026gt; {item.name} - ${item.price}{\u0026#39; \u0026#39;} \u0026lt;button onClick={() =\u0026gt; updateItem(item.id, item.price + 1)}\u0026gt; Increase Price \u0026lt;/button\u0026gt; \u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ); } Note: Always prefer map over find when updating an array of objects in React. This ensures that the state is updated correctly and prevents unexpected behavior in your application.\n29.Updating object in react In React, you can update an object in state by creating a new copy of the object and updating the copy with the new values. This ensures that the state is updated correctly and prevents unexpected behavior in your application.\nUpdating an object in state: function App() { const [person, setPerson] = useState({ name: \u0026#39;John\u0026#39;, age: 30 }); const updatePerson = () =\u0026gt; { setPerson({ ...person, age: person.age + 1 }); }; return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;Name: {person.name}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Age: {person.age}\u0026lt;/p\u0026gt; \u0026lt;button onClick={updatePerson}\u0026gt;Increase Age\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } use list if you want to show the list of items and use object if you want to show the details of the item to identify which one is clicked or update you can pass the index or id of the item to the function. Or you can hardcode the value to update the object or list.\n","permalink":"http://localhost:1313/posts/pages/react/react3/","summary":"A comprehensive guide covering React\u0026rsquo;s advanced concepts including Fragments, JSX Props, Component Isolation, and proper state management patterns","title":"React : Day 3"},{"content":"Python Control Structures: Mastering Loops and Conditionals In Python programming, control structures are essential for managing the flow of execution in your code. They allow you to make decisions, repeat tasks, and create complex algorithms. In this guide, we will explore two fundamental control structures in Python: loops and conditionals.\n1. Conditional Statements Conditional statements in Python allow you to execute specific blocks of code based on certain conditions. The most common conditional statements are if, elif, and else.\n1.1. The if Statement The if statement is used to check a condition and execute a block of code if the condition is true.\nExample:\nx = 10 if x \u0026gt; 5: print(\u0026#34;x is greater than 5\u0026#34;) Output:\nx is greater than 5 1.2. The elif Statement The elif statement allows you to check multiple conditions after the initial if statement. If the previous conditions are false, the elif block is evaluated.\nExample:\nx = 5 if x \u0026gt; 5: print(\u0026#34;x is greater than 5\u0026#34;) elif x == 5: print(\u0026#34;x is equal to 5\u0026#34;) Output:\nx is equal to 5 1.3. The else Statement The else statement is used to execute a block of code when all the previous conditions are false.\nExample:\nx = 3 if x \u0026gt; 5: print(\u0026#34;x is greater than 5\u0026#34;) elif x == 5: print(\u0026#34;x is equal to 5\u0026#34;) else: print(\u0026#34;x is less than 5\u0026#34;) Output:\nx is less than 5 2. Loops Loops in Python allow you to execute a block of code repeatedly. There are two main types of loops in Python: for loops and while loops.\n2.1. The while Loop The while loop executes a block of code as long as a specified condition is true.\nSyntax:\nwhile condition: # Code block else: # Optional else block Example:\ncount = 0 while count \u0026lt; 5: print(count) count += 1 else: print(\u0026#34;Loop completed\u0026#34;) 2.2. The for Loop The for loop is used to iterate over a sequence (such as a list, tuple, or string) and execute a block of code for each item in the sequence.\nSyntax:\nfor item in sequence: # Code block else: # Optional else block Example:\nfruits = [\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;] for fruit in fruits: print(fruit) else: print(\u0026#34;No more fruits\u0026#34;) 2.3 Using For Loops with different data types 2.3.1. For Loop with Strings Example:\nfor char in \u0026#34;Python\u0026#34;: print(char) Output:\np\ry\rt\rh\ro\rn 2.3.2. For Loop with Lists Example:\nnumbers = [1, 2, 3, 4, 5] for num in numbers: print(num) Output:\n1\r2\r3\r4\r5 2.3.3. For Loop with tuples Example:\nfruits = (\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;) for fruit in fruits: print(fruit) Output:\napple\rbanana\rcherry Tuple unpacking can also be used in for loops to iterate over multiple values in a tuple.\ncoordinates = [(1, 2), (3, 4), (5, 6)] for x, y in coordinates: print(f\u0026#34;X: {x}, Y: {y}\u0026#34;) Output:\nX: 1, Y: 2\rX: 3, Y: 4\rX: 5, Y: 6 2.3.4. For Loop with Sets Example:\ncolors = {\u0026#34;red\u0026#34;, \u0026#34;green\u0026#34;, \u0026#34;blue\u0026#34;} for color in colors: print(color) Output:\nred\rgreen\rblue 2.3.5. For Loop with Dictionaries Example:\nperson = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} for key, value in person.items(): print(f\u0026#34;{key}: {value}\u0026#34;) Output:\nname: Alice\rage: 30\rcity: New York 2.4. break , pass and continue statements in loops 2.4.1. The break Statement The break statement is used to exit a loop prematurely. It terminates the current loop and resumes execution at the next statement after the loop.\nExample:\nfor num in [1, 2, 3, 4, 5]: if num == 3: break print(num) Output:\n1\r2 2.4.2. The continue Statement The continue statement is used to skip the rest of the code inside a loop for the current iteration and jump to the next iteration.\nExample:\nfor num in [1, 2, 3, 4, 5]: if num == 3: continue print(num) Output:\n1\r2\r4\r5 2.4.3. The pass Statement The pass statement is a null operation that does nothing. It is used when a statement is required syntactically but you do not want any code to execute.\nExample:\nfor num in [1, 2, 3, 4, 5]: pass ","permalink":"http://localhost:1313/posts/pages/python/python_control_structure/","summary":"A detailed examination of Python\u0026rsquo;s control structures, focusing on loops and conditionals to enhance your programming skills.","title":"Python Fundamentals: Mastering Control Structures (Part 3)"},{"content":"17. Hooks in React Anythong that start with prefix use is considered as a hook in react\n17.1. Rules of Hooks Only Call Hook inside a component function correct:\nfunction App() { const [val, setVal] = useState(0); } Incorrect:\nconst [val, setVal] = useState(0); function App() { } Only Call Hooks at the Top Level Hook must not be called inside code statement (e.g., inside an if statement, loop, or nested function). correct: function App() { const [val, setVal] = useState(0); } incorrect:\nfunction App() { if (true) { const [val, setVal] = useState(0); } } 3.Hook can be used inside other custom hooks too\n18. useState Hook useState is a React hook that allows you to manage component-specific state. It provides a way to declare state variables in functional components and ensure that changes to these variables cause the component or child component to re-render while the parent component remains unaffected from where the component whose set state is triggered.\nuse useState hoo if you want to reflect the changes in the UI. for example:\nfunction App() { return ( \u0026lt;div\u0026gt; \u0026lt;MemoComp /\u0026gt; \u0026lt;/div\u0026gt; ); } function MemoComp() { const [data, setData] = useState(\u0026#34;No data\u0026#34;); function handle() { setData(\u0026#34;data\u0026#34;); } return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;{data}\u0026lt;/p\u0026gt; \u0026lt;button onClick={handle}\u0026gt;Click me\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } When button is clicked the handle function is called and the setData function is called which updates the data state variable. This cause the MemoComp and its child component to re-render with a new value of data.\n18.1. Syntax const [state, setState] = useState(initialState); 18.2. Managing State State management in React involves handling data and telling React to re-execute a function using the useState hook. This ensures that state updates lead to new state values. Example:\nconst [countes, setcountes] = useState(0); countes is the state variable that holds the current state value. setcountes is the function that updates the state variable. useState(0) is the initial state value. How it works: Initially, the state variable countes is set to 0. When the setcountes function is called, it updates the state variable to a new value. This triggers a re-render of the component, updating the UI with the new state value.\n18.3 Updating State Based on Previous State Suppose the age is 42. The handler calls setAge(age + 1) three times.\nfunction handleClick() { setAge(age + 1); // setAge(42 + 1) setAge(age + 1); // setAge(42 + 1) setAge(age + 1); // setAge(42 + 1) } if the initial age is 42, after calling this function, the age will be 43, not 45.\nTo solve this problem, we use an updater function to pass setAge calls.\nfunction handleClick() { setAge(a =\u0026gt; a + 1); // setAge(42 =\u0026gt; 43) setAge(a =\u0026gt; a + 1); // setAge(43 =\u0026gt; 44) setAge(a =\u0026gt; a + 1); // setAge(44 =\u0026gt; 45) } After this age will be 45 so use updater function when you want to update value based on previous value \u0026amp; it\u0026rsquo;s always recommended to use updater function in.\nIt is mostly used in:\nCounters Toggles Incrementing or decrementing a value 18.4. Pitfalls in useState In React state updates are asynchronous meaning they don\u0026rsquo;t immediately reflect in the current execution cycle. When you call a state setter function like setSelectedValue, React schedules the state update for the next render. This can lead to unexpected behavior if you try to access the updated state immediately after setting it.\nExample: function clickHandler(data) { setSelectedValue(`${data} is being clicked`); console.log(selectedTopic); // logs the old state, not updated one } Why It Happens State updates are asynchronous: React batches state updates and applies them during the next render cycle to optimize performance. Therefore, the state change you request won’t be immediately reflected in the current execution.\nLogging state immediately: Since the update happens after the current execution cycle, logging the state/selected topic immediately after calling setSelectedValue will show the old value (before the update).\nThis can be fixed using useEffect which is read later.\nNote: Always use the state variable when you want to reflect the changes in the UI.\n19. An Example demostrating useState Hook import {useState} from \u0026#39;react\u0026#39;; function App(){ const [count,setCount] = useState(0); return(){ \u0026lt;div\u0026gt; {count} \u0026lt;/div\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;Increment\u0026lt;/button\u0026gt; } } export default App; In the above example, we have a functional component App that uses the useState hook to manage the state of the count variable. The initial value of count is set to 0 using useState(0). The setCount function is used to update the value of count when the button is clicked. The count value is displayed in the UI, and clicking the button increments the count value by 1.\n20.Conditional Rendering in React Conditional rendering is a technique used to render different components or elements based on certain conditions. In React, conditional rendering can be achieved using ternary operators, and logical operators like \u0026amp;\u0026amp; .\n20.1. Ternary Operator The ternary operator is a concise way to write conditional statements in JavaScript. It consists of a condition followed by a question mark ?, an expression to execute if the condition is true, a colon :, and an expression to execute if the condition is false.\nExample:\nfunction App() { const isLoggedIn = true; return ( \u0026lt;div\u0026gt; {isLoggedIn ? \u0026lt;p\u0026gt;Welcome, User!\u0026lt;/p\u0026gt; : \u0026lt;p\u0026gt;Please log in\u0026lt;/p\u0026gt;} \u0026lt;/div\u0026gt; ); } Also We can write jsx code in variable and use it in return statement\nfunction App() { const isLoggedIn = true; const welcomeMessage=\u0026lt;p\u0026gt;Welcome, User!\u0026lt;/p\u0026gt;; const loginMessage=\u0026lt;p\u0026gt;Please log in\u0026lt;/p\u0026gt;; return ( \u0026lt;div\u0026gt; {isLoggedIn ? welcomeMessage : loginMessage} \u0026lt;/div\u0026gt; ); } 20.2. Logical \u0026amp;\u0026amp; Operator The logical \u0026amp;\u0026amp; operator is another way to conditionally render elements in React. The \u0026amp;\u0026amp; operator works by evaluating the expression on the left side of the \u0026amp;\u0026amp; operator. If the expression is true, the expression on the right side of the \u0026amp;\u0026amp; operator is executed. If the expression is false, the right side is not executed.\nExample:\nfunction App() { const isLoggedIn = true; return ( \u0026lt;div\u0026gt; {isLoggedIn \u0026amp;\u0026amp; \u0026lt;p\u0026gt;Welcome, User!\u0026lt;/p\u0026gt;} {isLoggedIn \u0026amp;\u0026amp; \u0026lt;button\u0026gt;Logout\u0026lt;/button\u0026gt;} {!isLoggedIn \u0026amp;\u0026amp; \u0026lt;p\u0026gt;Please log in\u0026lt;/p\u0026gt;} \u0026lt;/div\u0026gt; ); } Also We can write jsx code in variable and use it in return statement\nfunction App() { const isLoggedIn = true; const welcomeMessage=\u0026lt;p\u0026gt;Welcome, User!\u0026lt;/p\u0026gt;; const logoutButton=\u0026lt;button\u0026gt;Logout\u0026lt;/button\u0026gt;; const loginMessage=\u0026lt;p\u0026gt;Please log in\u0026lt;/p\u0026gt;; return ( \u0026lt;div\u0026gt; {isLoggedIn \u0026amp;\u0026amp; welcomeMessage} {isLoggedIn \u0026amp;\u0026amp; logoutButton} {!isLoggedIn \u0026amp;\u0026amp; loginMessage} \u0026lt;/div\u0026gt; ); } 21.Outputting list data dynamically In react we use map function to output list data dynamically as using map.\n21.1. Have a list of data You typically store the list in an array, which might come from a state, props, or external data source like an API\nconst data = [ { id: 1, name: \u0026#34;John\u0026#34; }, { id: 2, name: \u0026#34;Doe\u0026#34; }, { id: 3, name: \u0026#34;Jane\u0026#34; }, ]; 21.2 Using map function to output list data const listItems = data.map((item) =\u0026gt; \u0026lt;li key={item.id}\u0026gt;{item.name}\u0026lt;/li\u0026gt;); Key is used to uniquely identify each element in the list. It helps React identify which items have changed, are added, or are removed.It can be number or string.\n21.3. Rendering the list Use {} to embed the transformed list inside your component’s JSX.\n\u0026lt;ul\u0026gt;{listItems}\u0026lt;/ul\u0026gt;; 21.4. Putting it all together function App() { const data = [ { id: 1, name: \u0026#34;John\u0026#34; }, { id: 2, name: \u0026#34;Doe\u0026#34; }, { id: 3, name: \u0026#34;Jane\u0026#34; }, ]; const listItems = data.map((item) =\u0026gt; \u0026lt;li key={item.id}\u0026gt;{item.name}\u0026lt;/li\u0026gt;); return \u0026lt;ul\u0026gt;{listItems}\u0026lt;/ul\u0026gt;; } 21.5 Another form function App() { const data = [ { id: 1, name: \u0026#34;John\u0026#34; }, { id: 2, name: \u0026#34;Doe\u0026#34; }, { id: 3, name: \u0026#34;Jane\u0026#34; }, ]; return \u0026lt;ul\u0026gt;{data.map((item) =\u0026gt; \u0026lt;li key={item.id}\u0026gt;{item.name}\u0026lt;/li\u0026gt;); }\u0026lt;/ul\u0026gt;; } When will Rerender Occur?\nWhen state varaible or props value changes ","permalink":"http://localhost:1313/posts/pages/react/react1/","summary":"A detailed guide to help you understand and use hooks in React effectively.","title":"React : Day 2"},{"content":"Python Fundamentals: Exploring Advanced Operations (Part 4) In Python programming, advanced operations allow you to perform complex tasks efficiently. These operations include working with ranges, enumerations, zip functions, and more. In this guide, we will explore various advanced operations in Python to enhance your programming skills.\n1. Ranges Ranges in Python are used to generate a sequence of numbers. They are commonly used in loops to iterate over a specific range of values. Ranges can be created using the range() function.\n1.1. Creating a Range To create a range of numbers, you can use the range() function with the desired start, stop, and step values where start number is in inclusive and stop number is exclusive.\nExample:\n# Generate a range of numbers from 0 to 9 for i in range(10): print(i) Output:\n0\r1\r2\r3\r4\r5\r6\r7\r8\r9 Example:\n# Generate a range of numbers from 1 to 10 with a step of 2 for i in range(0, 10,2): print(i) Output:\n0\r2\r4\r6\r8 1.2 Enumerate Function The enumerate() function in Python is used to iterate over a sequence while keeping track of the index and value of each item. It returns a tuple containing the index and the value of the item.\nExample:\n# Enumerate a list of fruits fruits = [\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;cherry\u0026#39;] for index, fruit in enumerate(fruits): print(index, fruit) Output:\n0 apple\r1 banana\r2 cherry Example:\na=\u0026#34;nirajan\u0026#34; for index, char in enumerate(a): print(index, char) Output:\n0 n\r1 i\r2 r\r3 a\r4 j\r5 a\r6 n 1.3. Zip Function The zip() function in Python is used to combine multiple iterables (such as lists) element-wise. It returns an iterator of tuples where the i-th tuple contains the i-th element from each of the input iterables.\nExample:\n# Zip two lists together names = [\u0026#39;Alice\u0026#39;, \u0026#39;Bob\u0026#39;, \u0026#39;Charlie\u0026#39;] ages = [25, 30, 35] for name, age in zip(names, ages): print(name, age) Output:\nAlice 25\rBob 30\rCharlie 35 Example:\na=[1,2,3] b=[4,5,6] c=[7,8,9] print(list(zip(a,b,c))) Output:\n[(1, 4, 7), (2, 5, 8), (3, 6, 9)] 1.5 Sorted Function The sorted() function in Python is used to sort a list of elements. It returns a new sorted list without modifying the original list.The main feature of the sorted() function is that it can take a key argument that specifies a function to be called on each list element prior to making comparisons.\nExample:\n# Sort a list of numbers numbers = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5] sorted_numbers = sorted(numbers) print(sorted_numbers) Output:\n[1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] Example:\n# Sort a list of strings based on the length of the string fruits = [\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;cherry\u0026#39;, \u0026#39;date\u0026#39;] sorted_fruits = sorted(fruits, key=len) print(sorted_fruits) Output:\n[\u0026#39;date\u0026#39;, \u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;cherry\u0026#39;] Example:\n#Sort an dictionary based on the value d = {\u0026#39;apple\u0026#39;: 10, \u0026#39;banana\u0026#39;: 5, \u0026#39;cherry\u0026#39;: 15} sorted_d = sorted(d.items(), key=lambda x: x[1]) print(sorted_d) Output:\n[(\u0026#39;banana\u0026#39;, 5), (\u0026#39;apple\u0026#39;, 10), (\u0026#39;cherry\u0026#39;, 15)] Example:\n#Sort a list of tuples based on the second element t = [(1, 2), (3, 1), (5, 6)] sorted_t = sorted(t, key=lambda x: x[1]) print(sorted_t) Output:\n[(3, 1), (1, 2), (5, 6)] #2. Import in Python In Python, the import statement is used to import modules or packages into your script. It allows you to use functions, classes, and variables defined in other modules in your code.\n2.1. Importing Modules To import a module in Python, you can use the import keyword followed by the module name. You can then access the functions, classes, and variables defined in the module using dot notation.\nExample:\n# Import the math module import math # Calculate the square root of a number x = 16 print(math.sqrt(x)) Output:\n4.0 Example:\n# Import the datetime module import datetime # Get the current date and time now = datetime.datetime.now() print(now) Output:\n2024-11-17 10:30:00 2.2. Importing Specific Functions You can import specific functions or variables from a module using the from keyword. This allows you to use the imported functions directly without using the module name.\nExample:\n# Import the pi constant from the math module from math import pi # Print the value of pi print(pi) Output:\n3.141592653589793 Example:\n# Import the date class from the datetime module from datetime import date # Get the current date today = date.today() print(today) Output:\n2024-11-17 2.3. Aliasing Modules You can alias a module or package by using the as keyword. This allows you to refer to the module by a different name in your code.\nExample:\n# Import the math module and alias it as m import math as m # Calculate the square root of a number x = 25 print(m.sqrt(x)) Output:\n5.0 Example:\n# Import the datetime module using import and from and alias it as dt from datetime import datetime as dt now = dt.now() print(now) Output:\n2024-11-17 10:30:00 2.4. Importing All Functions You can import all functions and variables from a module using the * operator. This imports all the functions and variables defined in the module.\nExample:\n# Import all functions from the math module from math import * # Calculate the square root of a number x = 36 print(sqrt(x)) Output:\n6.0 The General Syntax is\nfrom module_name.submodule_name.submodule_name... import funtion_name or variable_name or filename as alias_name\nrandom module The random module in Python is used to generate random numbers. It provides various functions to generate random integers, floating-point numbers, and sequences.\n1. Generating Random Numbers The random module provides functions to generate random numbers within a specified range which can contain both integers starting and ending number.\nExample:\nfrom random import randint # Generate a random integer between 1 and 10 random_number = randint(1, 10) print(random_number) Output:\n5 2.Shuffling a List The random module provides a function to shuffle the elements of a list randomly. It modifies the original list in place.\nExample:\nfrom random import shuffle # Shuffle a list of numbers numbers = [1, 2, 3, 4, 5] shuffle(numbers) print(numbers) Output:\n[3, 1, 5, 2, 4] ","permalink":"http://localhost:1313/posts/pages/python/python_advanced_operations/","summary":"An in-depth exploration of advanced Python operations to enhance your programming skills.","title":"Python Fundamentals: Exploring Advanced Operations (Part 4)"},{"content":"Python Fundamentals: Understanding Functions In Python programming, functions are essential building blocks that allow you to organize and reuse code effectively. Functions help break down complex problems into smaller, manageable tasks, making your code more readable and maintainable. In this guide, we will explore the fundamentals of Python functions, including their syntax, parameters, return values, and more.\n1. Defining Functions A function in Python is defined using the def keyword followed by the function name and parentheses. You can also specify parameters inside the parentheses if the function requires input values.\nSyntax:\ndef function_name(parameters): # Function body # Statements Example:\ndef greet(): print(\u0026#34;Hello, World!\u0026#34;) 2. Calling Functions To call a function in Python, you simply write the function name followed by parentheses. If the function requires input values, you can pass them inside the parentheses.\nSyntax:\nfunction_name(arguments) Example:\ngreet() 3. return Statement The return statement in Python is used to exit a function and return a value to the caller. You can use the return statement to send a result back to the calling code.\nSyntax:\ndef function_name(parameters): # Function body return value Demostration using all:\ndef add_numbers(a, b): return a + b result = add_numbers(5, 3) print(result) 4. Args , Default Args and Kwargs 4.1. Args Using Args you can pass any number of arguments to a function. The arguments are passed as a tuple.\nSyntax:\ndef function_name(*args): # Function body Example:\ndef display_args(*args): print(args) display_args(1, 2, 3, 4, 5) Output:\n(1, 2, 3, 4, 5) 4.2. Default Args Default arguments are used when you do not pass a value for an argument in the function call. If a value is not provided, the default value is used.\nSyntax:\ndef function_name(arg=value): # Function body Example:\ndef add(a,b,c=0): return a+b+c result = add(5,3) print(result) result = add(5,3,2) print(result) Output:\n8\r10 4.3. Kwargs Using Kwargs you can pass any number of keyword arguments to a function. The arguments are passed as a dictionary.\nSyntax:\ndef function_name(**kwargs): # Function body Example:\ndef display_kwargs(**kwargs): print(kwargs) display_kwargs(name=\u0026#34;Alice\u0026#34;, age=30, city=\u0026#34;New York\u0026#34;) Output:\n{\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 30, \u0026#39;city\u0026#39;: \u0026#39;New York\u0026#39;} 4.4. Combination of Args and Kwargs Example:\ndef display_args_kwargs(*args, **kwargs): print(args) print(kwargs) display_args_kwargs(1, 2, 3, name=\u0026#34;Alice\u0026#34;, age=30) Output:\n(1, 2, 3)\r{\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 30} 4.5. Unpacking Args and Kwargs Example:\ndef display_args_kwargs(*args, **kwargs): print(args) print(kwargs) args = (1, 2, 3) kwargs = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30} display_args_kwargs(*args, **kwargs) Output:\n(1, 2, 3)\r{\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 30} 5. Lambda Functions Lambda functions, also known as anonymous functions, are small, single-expression functions that do not require a name. They are defined using the lambda keyword.\nSyntax:\nlambda arguments: expression Example:\nadd = lambda a, b: a + b result = add(5, 3) print(result) Output:\n8 6.Map and filter functions 6.1. Map Function The map() function in Python applies a given function to each item of an iterable (such as a list, tuple, or set) and returns a new iterable with the results.\nSyntax:\nmap(function, iterable) Example:\nnumbers = [1, 2, 3, 4, 5] squared = map(lambda x: x ** 2, numbers) print(list(squared)) Output:\n[1, 4, 9, 16, 25] 6.2. Filter Function The filter() function in Python filters elements from an iterable based on a given function. It returns an iterator with the elements that satisfy the condition.\nSyntax:\nfilter(function, iterable) Example:\nnumbers = [1, 2, 3, 4, 5] even = filter(lambda x: x % 2 == 0, numbers) print(list(even)) Output:\n[2, 4] 7.Local and Global Variables 7.1. Local Variables Local variables are defined within a function and are only accessible within that function. They are created when the function is called and destroyed when the function exits.\nExample:\ndef display(): message = \u0026#34;Hello, World!\u0026#34; print(message) display() # Trying to access the local variable outside the function will result in an error print(message) # NameError: name \u0026#39;message\u0026#39; is not defined 7.2. Global Variables Global variables are defined outside any function and can be accessed from any part of the code. You can use the global keyword to modify a global variable inside a function.\nExample:\nmessage = \u0026#34;Hello, World!\u0026#34; def display(): print(message) display() # Modifying a global variable inside a function def change_message(): global message message = \u0026#34;Hello, Python!\u0026#34; change_message() print(message) Output:\nHello, World!\rHello, Python! 7.3. Local vs. Global Variables If a local variable has the same name as a global variable, the local variable takes precedence within the function scope.\nExample:\nmessage = \u0026#34;Hello, World!\u0026#34; def display(): message = \u0026#34;Hello, Python!\u0026#34; print(message) display() print(message) Output:\nHello, Python!\rHello, World! ","permalink":"http://localhost:1313/posts/pages/python/python_function/","summary":"An in-depth exploration of Python functions, their usage, and importance in programming.","title":"Python Fundamentals: Understanding Functions (Part 5)"},{"content":"1. Create A React Project To create a React app we use Vite and its command is:\nnpm create vite@latest 2. Component In a React application, one page is broken down into multiple components. Components allow:\nReusability: For example, we can create one component for cards and use it to create multiple cards with different data. Related code lives together: Related items (JS code) are stored together. Separation of logic: Different components handle different data and logic. Diagram 3. Folder Structure my-app/\r├─ node_modules/\r├─ public/\r│ ├─ index.html\r│ ├─ image.png\r│ └─ favicon.ico\r├─ src/\r│ ├─ index.js\r│ ├─ App.js\r│ ├─ App.css\r│ └─ index.css\r├─ package.json\r└─ README.md node_module: Contains all the files of installed packages.\npublic: All static files are kept in this folder. For example, if image.png is in public, we can access it in the browser as 127.0.0.1:8000/image.png.\nindex.html: It is the page that is served to us and its content is managed by React using the DOM.Modify this file if you want to change the title or favicon.\npackage.json: Contains all the configuration of the project, package list, versions, and all related information.\nsrc: This is the folder where all the code is written.\nsrc/index.js React runs this file first.Code of index.js\nThe DOM selects the element of index.html whose id is root because of this code: document.getElementById('root') Then render() renders the \u0026lt;App/\u0026gt; component so that the root element will contain the data of the \u0026lt;App/\u0026gt; component. All changes are done in the index.html root element using the DOM. Remember that we never edit this file (code). src/App.js : This is where we will write all the SPA code. We start coding from App.jsx and link components as required.\nsrc/index.css : This CSS file is used by main.jsx, so it applies to the whole page. You can remove it if needed by removing its import in main.jsx.\n*** src/App.css:*** This CSS file is used by App.jsx, so it applies to all App components.\nRemember: Component functions must follow two rules:\nThe name should start with an uppercase letter (e.g., Head, MyHead). The function must return renderable content. The function must return a value that can be rendered (displayed on screen) by React. In most cases, return JSX. Example of a simple component:\nfunction App() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Hello world\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ); } As we know, App.jsx is provided by default when we create a React app. We can modify it and tailor it to our requirements\n4. Making Custom Components function FunctionName() { return ( \u0026lt;tagname\u0026gt; content \u0026lt;/tagname\u0026gt; ); } Important Note:\nTags that don\u0026rsquo;t have ending tags, such as \u0026lt;br\u0026gt; and \u0026lt;hr\u0026gt;, should be written as \u0026lt;br/\u0026gt; and \u0026lt;hr/\u0026gt;. class is replaced by className. For example, \u0026lt;body class=\u0026quot;data\u0026quot;\u0026gt; is written as \u0026lt;body className=\u0026quot;data\u0026quot;\u0026gt;. During a return in React, we cannot return multiple elements directly. Instead, we need to wrap them inside a single parent element like \u0026lt;div\u0026gt;, \u0026lt;\u0026gt;\u0026lt;/\u0026gt;. For Example :\nWrong Way: function component1() { return ( \u0026lt;div\u0026gt; Hi \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; Hello \u0026lt;/div\u0026gt; ); } right way: function component1() { return ( \u0026lt;div\u0026gt; {/* or \u0026lt;\u0026gt; */} \u0026lt;div\u0026gt; Hi \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; Hello \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; {/* or \u0026lt;/\u0026gt; */} ); } 5.Using One Component Inside Another Component To use one component inside another in React, follow the steps\nCreate a component. function Comp1() { return \u0026lt;div\u0026gt; Component \u0026lt;/div\u0026gt; } Use the component inside another component. function Comp2() { return ( \u0026lt;div\u0026gt; \u0026lt;Comp1 /\u0026gt; or \u0026lt;Comp1\u0026gt; \u0026lt;Comp1 /\u0026gt; content \u0026lt;/div\u0026gt; ) } Here, Comp1 is used inside Comp2.We can use Comp1 multiple times inside Comp2 as needed. Note: For proper management, create a components folder, create one file for each component, and export from there. Then, import and use it in another component.\nExample structure:\nsrc/\r├─ Assets/\r├─ App.jsx\r└─ Components/\r├─ Comp1.jsx\r└─ Comp2.jsx Task: Break Down a Component into Multiple Components\nfunction App() { return ( \u0026lt;\u0026gt; \u0026lt;header\u0026gt; I am header \u0026lt;/header\u0026gt; \u0026lt;main\u0026gt; I am main content \u0026lt;/main\u0026gt; \u0026lt;footer\u0026gt; I am footer \u0026lt;/footer\u0026gt; \u0026lt;/\u0026gt; ); } Solution: components/Header.jsx\nfunction Header() { return ( \u0026lt;header\u0026gt; I am header \u0026lt;/header\u0026gt; ); } export default Header; components/Footer.jsx\nfunction Footer() { return ( \u0026lt;footer\u0026gt; I am footer \u0026lt;/footer\u0026gt; ); } export default Footer; Finally, App.jsx\nimport Header from \u0026#39;./components/Header\u0026#39;; import Footer from \u0026#39;./components/Footer\u0026#39;; function App() { return ( \u0026lt;\u0026gt; \u0026lt;Header /\u0026gt; \u0026lt;main\u0026gt; I am main content \u0026lt;/main\u0026gt; \u0026lt;Footer /\u0026gt; \u0026lt;/\u0026gt; ); } export default App; structure:\nsrc/\r├─ Assets/\r├─ App.jsx\r└─ components/\r├─ Header.jsx\r└─ Footer.jsx Note: You Can Always break down a component as many times as you want. The main goal is to make the code more readable and maintainable.\n6. Some Component Hierarchies Examples THis is the simple example of a component hierarchy. 7. Embedding JavaScript code in JSX In JSX, we can embed JavaScript code using curly braces {}. We can write any JavaScript code inside the curly braces. For example, we can write a variable, function, or any JavaScript expression but of single line.\nfunction componentName() { return ( \u0026lt;div\u0026gt; { JavaScript code } \u0026lt;/div\u0026gt; ); } Example:\nfunction App() { const name = \u0026#39;John Doe\u0026#39;; return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt; Hello, {name} \u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ); } Where To Write Javascript Logic?\nWe can write JavaScript logic inside the component function. We can write JavaScript logic outside the component function and use it inside the component function. 7.1 Using JavaScript Logic Outside Component Function syntax:\n// Multiple lines of JavaScript code function ComponentName() { return ( \u0026lt;div\u0026gt; {/* JSX code */} \u0026lt;/div\u0026gt; ); } 7.2 Using JavaScript Logic Inside Component Function syntax:\nfunction ComponentName() { // Multiple lines of JavaScript code return ( \u0026lt;div\u0026gt; {/* JSX code */} \u0026lt;/div\u0026gt; ); } When to use Inside Component Function Outside Component Function Use Case When the logic is specific to the component and not used anywhere else. When the logic is used in multiple components. Advantages Logic is specific to the component. Logic can be reused in multiple components. Disadvantages Logic cannot be reused in other components. Logic is not specific to the component. Combined Example Task1: Create a component that generate random number between 1 to 10 and display in every page reload\nfunction RandomNumber(){ return \u0026lt;\u0026gt; \u0026lt;h1\u0026gt;Random Number: {Math.floor(Math.random() * 10) + 1}\u0026lt;/h1\u0026gt; } export default RandomNumber; This can be done in another ways which is more readable and maintainable\nfunction RandomNumber(){ const randomNumber = Math.floor(Math.random() * 10) + 1; return \u0026lt;h1\u0026gt;Random Number: {randomNumber}\u0026lt;/h1\u0026gt; } export default RandomNumber; Task2 : Create a component that generate random element from an array and display on each page reload\nconst elements = [\u0026#39;Earth\u0026#39;, \u0026#39;Water\u0026#39;, \u0026#39;Fire\u0026#39;, \u0026#39;Air\u0026#39;]; function generateRandomElement(){ return elements[Math.floor(Math.random() * elements.length)]; } function RandomElement(){ const randomElement = generateRandomElement(); return \u0026lt;h1\u0026gt;Random Element: {randomElement}\u0026lt;/h1\u0026gt; } export default RandomElement; This can be done by putting the logic inside the component function\nconst elements = [\u0026#39;Earth\u0026#39;, \u0026#39;Water\u0026#39;, \u0026#39;Fire\u0026#39;, \u0026#39;Air\u0026#39;]; function generateRandomElement(){ return elements[Math.floor(Math.random() * elements.length)]; } function RandomElement(){ const randomElement = elements[Math.floor(Math.random() * elements.length)]; return \u0026lt;h1\u0026gt;Random Element: {randomElement}\u0026lt;/h1\u0026gt; } export default RandomElement; The most optimal way is using this\nconst elements = [\u0026#39;Earth\u0026#39;, \u0026#39;Water\u0026#39;, \u0026#39;Fire\u0026#39;, \u0026#39;Air\u0026#39;]; function RandomElement(){ const randomElement = elements[Math.floor(Math.random() * elements.length)]; return \u0026lt;h1\u0026gt;Random Element: {randomElement}\u0026lt;/h1\u0026gt; } export default RandomElement; 8.Loading Images in React step 1: put the images in assets folder that need to be loaded step 2: import the image in the component where it is needed as shown below import imageName from Location Note: Location is the path of the image from the current file location and imageName can be set to any name\nstep 3: use the image in the component as shown below \u0026lt;img src={imageName} alt=\u0026#34;description\u0026#34; /\u0026gt; Note: imageName is the location of the image as src/Assets/logo.png\nTask: Load an image in a Header component with the image name logo.png and description logo. structure:\nsrc/\r├─ Assets/\r└─ logo.png\r├─ App.jsx\r└─ components/\r├─ Header.jsx import logo from \u0026#39;../Assets/logo.png\u0026#39;; function Header() { return ( \u0026lt;header\u0026gt; \u0026lt;img src={logo} alt=\u0026#34;logo\u0026#34; /\u0026gt; \u0026lt;/header\u0026gt; ); } 9.Importing CSS in React step 1: create a css file in the src folder step 2: import the css file in the component where it is needed as shown below import cssfileLocation Note: style.css is the name of the css file\nfor example:\nimport \u0026#39;./style.css\u0026#39; function App() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt; Hello world \u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ); } 9.1 Managing CSS in React Create css file in same directory as of your component src/ ├─ App.jsx └─ components/ ├─ Header.jsx └─ Header.css -Import the css file in the component where it is needed as shown below\r```jsx\rimport \u0026#39;./Header.css\u0026#39; 10.Props in React Props are used to pass data from parent component to child component. It is used to reuse the same component with different data. Props are passed as attributes to the component. Prop accept any type of value like string, number, array, object, function,compenent,jsx bool etc. 10.1 Passing Props from Parent to Child Component Parent Component function ParentComponent() { return ( \u0026lt;ChildComponent prop1={value1} prop2={value2} /\u0026gt; ); } 10.2 Receiving Props in Child Component Child Component function ChildComponent(props) { console.log(props); // will print object of props {prop1: value1, prop2:value2} return ( \u0026lt;\u0026gt; {props.prop1} {props.prop2} \u0026lt;/\u0026gt; ); } This approach is not recommended because it is not clear what props are being passed to the component. Instead, we can destructure the props as shown below.\n10.3 Destructuring Props Child Component function ChildComponent({prop1, prop2}) { return ( \u0026lt;\u0026gt; {prop1} {prop2} \u0026lt;/\u0026gt; ); } Task: Create a card cmponent and use multiple cards in the App component to make card section\nfunction Card({title, description, image}) { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;{title}\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;{description}\u0026lt;/p\u0026gt; \u0026lt;img src={image} alt=\u0026#34;description\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; ); } export default Card; import Card from \u0026#39;./components/Card\u0026#39;; function App() { return ( \u0026lt;div\u0026gt; \u0026lt;Card title=\u0026#34;Card 1\u0026#34; description=\u0026#34;This is card 1\u0026#34; image={image1} /\u0026gt; \u0026lt;Card title=\u0026#34;Card 2\u0026#34; description=\u0026#34;This is card 2\u0026#34; image={image2} /\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; 11. Children Props in React Children props are used to pass data between opening and closing tags of a component. 11.1 Passing Children Props Parent Component function ParentComponent() { return ( \u0026lt;ChildComponent\u0026gt; \u0026lt;h1\u0026gt; Hello \u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt; World \u0026lt;/p\u0026gt; \u0026lt;/ChildComponent\u0026gt; ); } 11.2 Receiving Children Props Child Component function ChildComponent({ children }) { return ( \u0026lt;div\u0026gt; {children} \u0026lt;/div\u0026gt; ); } 11.3 Output \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt; Hello \u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt; World \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; 12.Using Props and Children Props Together Task: Create a card component that accepts title, description, and children props. Use the card component in the App component to make a card section.\nfunction Card({ title, description, children }) { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;{title}\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;{description}\u0026lt;/p\u0026gt; {children} \u0026lt;/div\u0026gt; ); } export default Card; import Card from \u0026#39;./components/Card\u0026#39;; function App() { return ( \u0026lt;div\u0026gt; \u0026lt;Card title=\u0026#34;Card 1\u0026#34; description=\u0026#34;This is card 1\u0026#34;\u0026gt; \u0026lt;h1\u0026gt; Hello \u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt; World \u0026lt;/p\u0026gt; \u0026lt;/Card\u0026gt; \u0026lt;Card title=\u0026#34;Card 2\u0026#34; description=\u0026#34;This is card 2\u0026#34;\u0026gt; \u0026lt;h1\u0026gt; Hello \u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt; World \u0026lt;/p\u0026gt; \u0026lt;/Card\u0026gt; \u0026lt;/div\u0026gt; ); } 13. Making a Button Component 13.1 Using Props function App() { return ( \u0026lt;div\u0026gt; \u0026lt;Button text=\u0026#34;Click me\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; ); } function Button({ text}) { return ( \u0026lt;button\u0026gt; {text} \u0026lt;/button\u0026gt; ); } export default Button; 13.2 Using Children Props function App() { return ( \u0026lt;div\u0026gt; \u0026lt;Button\u0026gt;Click me\u0026lt;/Button\u0026gt; \u0026lt;/div\u0026gt; ); } function Button({ children }) { return ( \u0026lt;button\u0026gt; {children} \u0026lt;/button\u0026gt; ); } export default Button; 14. Reacting to Events In React, we can add event listeners like onClick, onMouseOver, onMouseOut, etc to buildin components lie button, div, etc using syntax \u0026lt;InbuiltComponent eventlistener={functionName} /\u0026gt; Note: functionName is the name of the function that will be called when the event is triggered.\nThere are Many eventlisteners that can be used in React like onClick, onMouseOver, onMouseOut etc.\nYou can check the full list of event listeners in the React documentation also note that the event listener will always start with on followed by the event name.\nWe can call the handle function in two ways:\n14.1 The First Way function App() { function handleClick() { console.log(\u0026#39;Button clicked\u0026#39;); } return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={handleClick}\u0026gt;Click me\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 14.2 The Second Way function App() { return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={() =\u0026gt; {console.log(\u0026#39;Button clicked\u0026#39;)}}\u0026gt;Click me\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 15. Event Listeners in Custom Components since by default when we add event listeners to custom component it doesnot work just because it is passed as prop but on simple tweaking we can make it work\nDesign Pattern for applying event listeners in custom components\nfunction App(){ function handleClick(){ console.log(\u0026#39;Button clicked\u0026#39;); } return ( \u0026lt;div\u0026gt; \u0026lt;Button onClick={handleClick} /\u0026gt; \u0026lt;/div\u0026gt; ); } The onclick method is passed as a prop to the button component and then used in the button component as shown below\nfunction Button({onClick}){ return ( \u0026lt;button onClick={onClick}\u0026gt;Click me\u0026lt;/button\u0026gt; ); } 16. Passing Arguments to Event Functions To pass Custom arguments to event functions, we can use the arrow function syntax as shown below \u0026lt;inbuildComponent eventListener={() =\u0026gt; functionName(argument)} /\u0026gt; Example function App() { function handleClick(name) { console.log(\u0026#39;Button clicked by\u0026#39;, name); } return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={() =\u0026gt; handleClick(\u0026#39;John\u0026#39;)}\u0026gt;Click me\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } ","permalink":"http://localhost:1313/posts/pages/react/react/","summary":"A detailed reference guide to help you quickly set up and manage React projects, components, and folder structures.","title":"React : Day 1"},{"content":"Python Fundamentals: Understanding Error Handling In Python programming, error handling is an essential concept that allows you to gracefully manage exceptions and errors that may occur during program execution. By handling errors effectively, you can prevent your program from crashing and provide meaningful feedback to users. In this guide, we will explore the fundamentals of error handling in Python, including exceptions, try-except blocks, and best practices.\n1. Exceptions In Python, exceptions are events that occur during the execution of a program that disrupt the normal flow of code. When an exception occurs, the interpreter raises an exception object that can be caught and handled by the program. Exceptions can be caused by various reasons, such as invalid input, file not found, or division by zero.\n2.What May Cause Exceptions Exceptions can be caused by various reasons, such as:\nDivision by zero Invalid input File not found Syntax errors Out of Index of list, tuple , String Key Error in dictionary 3.Types of Exceptions Commonly used exceptions in Python include:\nZeroDivisionError: Raised when division or modulo by zero occurs. ValueError: Raised when a function receives an argument of the correct type but an inappropriate value. TypeError: Raised when an operation or function is applied to an object of an inappropriate type. IndexError: Raised when a sequence subscript is out of range. KeyError: Raised when a dictionary key is not found. SyntaxError: Raised when the parser encounters a syntax error. Note: All exceptions in Python are subclasses of the Exception class.\n3.Handling Exceptions To handle exceptions in Python, you can use the try-except block, which allows you to catch and handle exceptions gracefully. The try block contains the code that may raise an exception, and the except block handles the exception if it occurs.The program control will transfer the control to the except block if any exception occurs in the try block but if there is not exception then the control will not transfer to the except block.\n4.1. Using try-except Block Here\u0026rsquo;s an example of using the try-except block to handle exceptions in Python:\nsyntax:\ntry: # Code that may raise an exception except ExceptionType as e: # Handle the exception Example:\ntry: x = 10 / 0 except Exception as e: print(\u0026#34;Error: Division by zero\u0026#34;) Output:\nError: Division by zero Note: if you don\u0026rsquo;t know the type of exception you can use Exception to catch all exceptions.\nIf you dont handel exception then it will show error and stop the program.\n4.2. Finally Block The finally block is used to execute code that should always run, regardless of whether an exception occurs or not. The finally block is typically used to release resources or clean up operations that need to be performed after the try block, regardless of the outcome Any how the finally block will run. if yout return from the try block then also the finally block will run.\nsyntax:\ntry: # Code that may raise an exception except ExceptionType as e: # Handle the exception finally: # Code that always runs Example:\ntry: x = 10 / 0 except Exception as e: print(\u0026#34;Error: Division by zero\u0026#34;) finally: print(\u0026#34;Cleanup code\u0026#34;) Output:\nError: Division by zero\rCleanup code 3.5. Raising Exceptions You can raise exceptions in Python using the raise statement. This allows you to create custom exceptions and raise them when needed. You can also raise built-in exceptions to indicate errors or exceptional conditions.\nsyntax:\nraise ExceptionType(\u0026#34;Error message\u0026#34;) Example:\nx = -1 if x \u0026lt; 0: raise ValueError(\u0026#34;Value cannot be negative\u0026#34;) Output:\nValueError: Value cannot be negative 3.6. Multiple except Blocks You can use multiple except blocks to handle different types of exceptions in Python. This allows you to catch and handle specific exceptions based on their type.\nsyntax:\ntry: # Code that may raise an exception except ExceptionType1 as e: # Handle ExceptionType1 except ExceptionType2 as e: # Handle ExceptionType2 Example:\ntry: x = 10 / 0 except ZeroDivisionError as e: print(\u0026#34;Error: Division by zero\u0026#34;) except ValueError as e: print(\u0026#34;Error: Invalid value\u0026#34;) Output:\nError: Division by zero 3.7. Custom Exceptions You can create custom exceptions in Python by defining a new exception class that inherits from the Exception class. Custom exceptions allow you to define specific error conditions for your application and raise them when needed.\nsyntax:\nclass CustomException(Exception): pass Example:\n#Will read about class in oop section class CustomError(Exception): def __init__(self,message,value): self.message=message self.value=value def __str__(self): return f\u0026#34;{self.message}\\nError code:{self.value}\u0026#34; try: x = -1 if x \u0026lt; 0: raise CustomError(\u0026#34;Value cannot be negative\u0026#34;,1001) except CustomError as e: print(e) Note: Custom exceptions should inherit from the Exception class or one of its subclasses. You can simply use:\ntry: #code except: #code try: #code except Exception as e: #code try: #code except Exception: #code try: #code except: #code finally: #code ","permalink":"http://localhost:1313/posts/pages/python/python_error_handeling/","summary":"An in-depth exploration of Python error handling, exceptions, and best practices.","title":"Python Fundamentals: Understanding Error Handling (Part 6)"},{"content":"Python Fundamentals: Packages, Generators, and Decorators In this guide, we will explore advanced Python topics including packages, generators, and decorators. These concepts are essential for writing efficient and maintainable Python code. Let\u0026rsquo;s dive in!\n1. Python Packages Python packages are a way of organizing and structuring your code into reusable modules. Packages allow you to group related modules together, making it easier to manage and maintain your codebase. In this section, we will explore how to create and use Python packages.\n1.1. Creating a Package To create a Python package, you need to organize your code into a directory structure with a special file called __init__.py. This file tells Python that the directory is a package and allows you to import modules from the package.\nExample directory structure:\nmy_package/\r│\r├── __init__.py\r├── module1.py\r└── module2.py 1.2. Using a Package To use a Python package, you can import modules from the package using the import statement. You can import specific modules or the entire package.\nExample:\n# Importing a specific module from my_package import module1 # Using a function from the imported module module1.my_function() # Importing the entire package import my_package # Using a function from a module within the package my_package.module2.another_function() #Importing Function from a module from my_package.module1 import my_function my_function() Note : init.py file can be empty or contain initialization code for the package. It will automatically run when the package is imported.\n1.3 Creating a Subpackage You can create subpackages within a package to further organize your code. Subpackages are simply packages within packages, allowing you to create a hierarchical structure for your codebase.\nExample directory structure:\nmy_package/\r│\r├── __init__.py\r├── module1.py\r└── subpackage/\r├── __init__.py\r├── module3.py\r└── module4.py 1.4. Using a Subpackage To use a subpackage, you can import modules from the subpackage using the dot notation.\nExample:\n# Importing a module from a subpackage from my_package.subpackage import module3 # Using a function from the imported module module3.another_function() # Importing the entire subpackage import my_package.subpackage # Using a function from a module within the subpackage my_package.subpackage.module4.some_function() #Importing Function from a module from my_package.subpackage.module3 import another_function another_function() 1.5. name == \u0026ldquo;main\u0026rdquo; We use the __name__ variable to check if a script is being run as the main program or being imported as a module. When a script is run as the main program, __name__ is set to \u0026quot;__main__\u0026quot;. This allows you to include code that should only run when the script is executed directly.\nFor Example:\nStructure:\nMain Directory/\r├── main.py\r└── package/\r├── __init__.py\r└── module1.py module1.py:\ndef my_function(): print(\u0026#34;Hello from module1\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: my_function() When you run module1.py directly, the my_function() will be executed. However, if you import module1 into another script, the my_function() will not be executed.\nFor Example:\nfrom package import module1 print(\u0026#34;Imported module1\u0026#34;) Output:\nImported module1 When use Dont use if __name__ == \u0026quot;__main__\u0026quot;: in module1.py:\ndef my_function(): print(\u0026#34;Hello from module1\u0026#34;) my_function() also,\nfrom package import module1 print(\u0026#34;Imported module1\u0026#34;) Output:\nHello from module1\rImported module1 2. Python Generators Using generator we can instantly return all the values using the yield keyword without storing them in memory. This is useful when working with large datasets or infinite sequences.\n2.1. Creating a Generator To create a generator in Python, you can use a function with the yield keyword. When a function contains the yield keyword, it becomes a generator function. The yield keyword suspends the function\u0026rsquo;s execution and returns a value to the caller.\nExample:\ndef my_generator(): yield 1 yield 2 yield 3 # Using the generator gen = my_generator() print(next(gen)) # Output: 1 print(next(gen)) # Output: 2 print(next(gen)) # Output: 3 Example:\n#using generator in loop def generate(n): for i in range(n): yield i for i in generate(10): print(i) 3. Python Decorators Decorators are a powerful feature in Python that allows you to modify or extend the behavior of functions or methods. Decorators are functions that take another function as an argument and return a new function that extends the behavior of the original function.\n3.1. Creating a Decorator To create a decorator in Python, you can define a function that takes another function as an argument and returns a new function that extends the behavior of the original function.\nSyntax:\ndef my_decorator(func): def wrapper(): # Code to execute before calling the decorated function func() # Code to execute after return wrapper Example:\ndef my_decorator(func): def wrapper(): print(\u0026#34;Before function call\u0026#34;) func() print(\u0026#34;After function call\u0026#34;) return wrapper @my_decorator def say_hello(): print(\u0026#34;Hello!\u0026#34;) say_hello() #call to my_decorator(say_hello)() just because we use @my_decorator Output:\nBefore function call\rHello!\rAfter function call Example For decorator :\ndef Add_Wrapper(func): def wrapper(a,b,c): print(\u0026#34;Status code is\u0026#34;,c) return func(a,b) return wrapper @Add_Wrapper def add(a,b): return a+b print(add(2,3,200)) Output:\nStatus code is 200\r5 3.2. Decorator with Arguments You can also create decorators that accept arguments by defining a decorator function that takes arguments and returns a decorator function.\nSyntax:\ndef my_decorator_with_args(arg1, arg2): def decorator(func): def wrapper(): # Code to execute before calling the decorated function func() # Code to execute after return wrapper return decorator Example:\ndef my_decorator_with_args(arg1, arg2): def decorator(func): def wrapper(): print(f\u0026#34;Decorator arguments: {arg1}, {arg2}\u0026#34;) func() return wrapper return decorator @my_decorator_with_args(\u0026#34;arg1\u0026#34;, \u0026#34;arg2\u0026#34;) def say_hello(): print(\u0026#34;Hello!\u0026#34;) say_hello() Output:\nDecorator arguments: arg1, arg2\rHello! ","permalink":"http://localhost:1313/posts/pages/python/python_advanced_topics/","summary":"An in-depth exploration of Python packages, generators, and decorators.","title":"Python Fundamentals: Packages, Generators, and Decorators (Part 7)"},{"content":"Python Fundamentals: Understanding request In this guide, we will explore request package in python. This package is used to make HTTP requests in python. Let\u0026rsquo;s dive in!\n1. Python request Python request is a simple and elegant HTTP library for Python. It provides methods for sending HTTP requests and handling the responses. The requests library allows you to send HTTP requests using a simple and intuitive API, and it also provides support for handling cookies, sessions, and authentication.\n1.1. Installing requests To use the requests library in your Python project, you need to install it using pip. You can install the requests library by running the following command in your terminal:\npip install requests 1.2. Types of requests The requests library supports various types of HTTP requests, including GET, POST, PUT, DELETE, and more. You can use these methods to interact with web services and APIs.\nExample:\nimport requests # Send a GET request response = requests.get(\u0026#39;https://api.github.com\u0026#39;) # Send a POST request response = requests.post(\u0026#39;https://httpbin.org/post\u0026#39;) # Send a PUT request response = requests.put(\u0026#39;https://httpbin.org/put\u0026#39;) # Send a DELETE request response = requests.delete(\u0026#39;https://httpbin.org/delete\u0026#39;) 1.3 Parameters for requests The requests library allows you to pass various parameters when making HTTP requests. These parameters include headers, query parameters, request body, and more.\nHeaders: You can pass custom headers in your request using the headers parameter. Example: import requests # Send a GET request with custom headers headers = {\u0026#39;User-Agent\u0026#39;: \u0026#39;Mozilla/5.0\u0026#39;} response = requests.get(\u0026#39;https://api.github.com\u0026#39;, headers=headers) # Send a POST request with custom headers response = requests.post(\u0026#39;https://httpbin.org/post\u0026#39;, headers=headers) #similarly for PUT and DELETE cookie: You can pass cookies in your request using the cookies parameter. Example: import requests # Send a GET request with cookies cookies = {\u0026#39;session_id\u0026#39;: \u0026#39;12345\u0026#39;} response = requests.get(\u0026#39;https://api.github.com\u0026#39;, cookies=cookies) # Send a POST request with cookies response = requests.post(\u0026#39;https://httpbin.org/post\u0026#39;, cookies=cookies) #similarly for PUT and DELETE file: You can upload files in your request using the files parameter. Example: import requests # Upload a file in a POST request files = {\u0026#39;file\u0026#39;: open(\u0026#39;file.txt\u0026#39;, \u0026#39;rb\u0026#39;)} response = requests.post(\u0026#39;https://httpbin.org/post\u0026#39;, files=files) #similarly for PUT and DELETE params: You can pass query parameters in your request using the params parameter. Example: import requests # Send a GET request with query parameters params = {\u0026#39;key1\u0026#39;: \u0026#39;value1\u0026#39;, \u0026#39;key2\u0026#39;: \u0026#39;value2\u0026#39;} response = requests.get(\u0026#39;https://api.github.com\u0026#39;, params=params) # Send a POST request with query parameters response = requests.post(\u0026#39;https://httpbin.org/post\u0026#39;, params=params) #similarly for PUT and DELETE data: You can pass data in your request body using the data parameter. Example: import requests # Send a POST request with data data = {\u0026#39;key1\u0026#39;: \u0026#39;value1\u0026#39;, \u0026#39;key2\u0026#39;: \u0026#39;value2\u0026#39;} response = requests.post(\u0026#39;https://httpbin.org/post\u0026#39;, data=data) #similarly for PUT and DELETE json: You can pass JSON data in your request body using the json parameter. Example: import requests # Send a POST request with JSON data data = {\u0026#39;key1\u0026#39;: \u0026#39;value1\u0026#39;, \u0026#39;key2\u0026#39;: \u0026#39;value2\u0026#39;} response = requests.post(\u0026#39;https://httpbin.org/post\u0026#39;, json=data) #similarly for PUT and DELETE Note: The requests library provides a wide range of parameters and options for making HTTP requests. You can refer to the official documentation for more details.\n** Note ** : While using json it will automatically set the content type to application/json and dump the data to json format but while using data it will set the content type to application/x-www-form-urlencoded and encode the data to urlencoded format.\n1.4. Handling responses The requests library provides methods for handling the responses returned by HTTP requests. You can access the response content, status code, headers, and more.\nResponse content: You can access the response content using the text attribute. Example: import requests # Send a GET request response = requests.get(\u0026#39;https://api.github.com\u0026#39;) # Get the response content content = response.text print(content) Response Content in bytes: You can access the response content in bytes using the content attribute. Example: import requests # Send a GET request response = requests.get(\u0026#39;https://api.github.com\u0026#39;) # Get the response content in bytes content = response.content print(content) json: You can access the response content as JSON using the json method. Example:\nimport requests # Send a GET request response = requests.get(\u0026#39;https://api.github.com\u0026#39;) # Get the response content as JSON data = response.json() print(data) Status code: You can access the response status code using the status_code attribute. Example: import requests # Send a GET request response = requests.get(\u0026#39;https://api.github.com\u0026#39;) # Get the response status code status_code = response.status_code print(status_code) Headers: You can access the response headers using the headers attribute. Example: import requests # Send a GET request response = requests.get(\u0026#39;https://api.github.com\u0026#39;) # Get the response headers headers = response.headers print(headers) Cookies: You can access the response cookies using the cookies attribute. Example: import requests # Send a GET request response = requests.get(\u0026#39;https://api.github.com\u0026#39;) # Get the response cookies cookies = response.cookies print(cookies) ","permalink":"http://localhost:1313/posts/pages/python/python_request/","summary":"An in-depth exploration of Python request.","title":"Python Fundamentals: Understanding request (Part 8)"},{"content":"Python Fundamentals: Understanding File Handeling In Python programming, file handling is an essential operation that allows you to read, write, and manipulate files on your system. Files are used to store data permanently, and Python provides various functions and methods to work with files efficiently. In this guide, we will explore the basics of file handling in Python, including opening, reading, writing, and closing files.\n1.Context Manager Python provides a built-in way to manage resources and ensure that they are properly released when they are no longer needed. This is done using the with statement and is known as a context manager. When working with files, it is recommended to use the with statement to ensure that the file is properly closed after use.\n1.1. Using the with Statement The with statement in Python is used to create a context manager that automatically takes care of resource management. When working with files, the with statement ensures that the file is properly closed after use, even if an error occurs during file operations.\nExample:\nwith open(\u0026#34;example.txt\u0026#34;, \u0026#34;r\u0026#34;) as file: data = file.read() print(data) 2. Opening a File Before you can read or write to a file, you need to open it using the open() function. The open() function takes two arguments: the file path and the mode in which you want to open the file.\n2.1. Modes for Opening Files Python supports various modes for opening files, depending on the operations you want to perform. Some common modes include:\nr: Read mode. Opens the file for reading. The file must exist. w: Write mode. Opens the file for writing. If the file exists, it will be truncated. If the file does not exist, a new file will be created. a: Append mode. Opens the file for writing. If the file exists, the data will be appended to the end. If the file does not exist, a new file will be created. b: Binary mode. Opens the file in binary mode.use for image,video,etc as it will not convert the data to text .You can add b to any mode to open the file in binary mode like rb,wb,ab. t: Text mode. Opens the file in text mode (default). 2.2. Opening a File To open a file, you can use the open() function with the desired file path and mode. You can also specify additional parameters such as encoding, buffering, and newline characters.\nExample:\n# Open a file in read mode with open(\u0026#34;example.txt\u0026#34;, \u0026#34;r\u0026#34;) as file: data = file.read() print(data) 3. Reading from a File Once you have opened a file, you can read its contents using various methods provided by Python. The most common methods for reading from a file is read().\n# Open a file in read mode with open(\u0026#34;example.txt\u0026#34;, \u0026#34;r\u0026#34;) as file: data = file.read() print(data) 4. Writing to a File To write data to a file, you can use the write() method provided by Python. You can write text data to a file using the write() method.\nUsing w mode: # Open a file in write mode with open(\u0026#34;example.txt\u0026#34;, \u0026#34;w\u0026#34;) as file: file.write(\u0026#34;Hello, World!\u0026#34;) Using a mode: # Open a file in append mode with open(\u0026#34;example.txt\u0026#34;, \u0026#34;a\u0026#34;) as file: file.write(\u0026#34;Hello, World!\u0026#34;) 5.Context Manager Reference\nUse of Context Manager: In any programming language, the usage of resources like file operations or database connections is very common. But these resources are limited in supply. Therefore, the main problem lies in making sure to release these resources after usage. If they are not released then it will lead to resource leakage and may cause the system to either slow down or crash. It would be very helpful if users have a mechanism for the automatic setup and teardown of resources. In Python, it can be achieved by the usage of context managers which facilitate the proper handling of resources.\nWhat is happened When the with statement is executed, it will automatically call the __enter__ before entering the code block, and __exit__ after exiting the code block.\nHow to create a context manager To create a context manager, you need to define a class that implements the __enter__ and __exit__ methods. The __enter__ method is called when the with statement is executed, and the __exit__ method is called after the code block is executed.\nSyntax:\nclass MyContextManager: def __init__(self,params): # Code to initialize resources def __enter__(self): # Code to setup resources return self def __exit__(self, exc_type, exc_value, traceback): # Code to release resources Example:\n#implementatio of own file handeling context manager class MeroHandle: def __init__(self,filename,mode): self.filename = filename self.mode = mode def __enter__(self): self.file = open(self.filename,self.mode) return self.file def __exit__(self,exc_type,exc_value,traceback): self.file.close() #using the context manager with MeroHandle(\u0026#34;example.txt\u0026#34;,\u0026#34;r\u0026#34;) as file: data = file.read() print(data) Normal way of file handeling try: file = open(\u0026#34;example.txt\u0026#34;,\u0026#34;r\u0026#34;) data = file.read() print(data) file.close() except: print(\u0026#34;Error Occured\u0026#34;) Advantage of context manager Over normal code When we use normal code shown above then when error occured in try block before file.close() then it will not close the file(i.e file will not be closed) and it will lead to resource leakage . But when we use context manager then it will automatically close the file just because __exit__ method is called after the code block is executed whether error occured or not. but in normal code we can manage this by using finally block but it is not recommended as it is not pythonic way of doing things. try: file = open(\u0026#34;example.txt\u0026#34;,\u0026#34;r\u0026#34;) data = file.read() print(data) except: print(\u0026#34;Error Occured\u0026#34;) finally: file.close() This will work but it is not pythonic way of doing things.Just because we have to write whole try,except,finally block for just opening and closing the file. which make code more complex and lengthy.\n","permalink":"http://localhost:1313/posts/pages/python/python_filehandeling/","summary":"An in-depth look at File Handeling.","title":"Python Fundamentals: Understanding File Handeling (Part 9)"},{"content":"Python Fundamentals: Some Important Package to Know In Python programming, packages are collections of modules that provide additional functionality to your programs. Python has a rich ecosystem of packages that can help you perform a wide range of tasks, from data analysis and visualization to web development and machine learning. In this guide, we will explore some of the most important packages in Python that you should be familiar with.\n1.json The json package in Python provides functions for encoding and decoding JSON data. JSON (JavaScript Object Notation) is a lightweight data interchange format that is easy for humans to read and write and easy for machines to parse and generate. The json package allows you to work with JSON data in Python by converting Python objects to JSON strings and vice versa.\nConversion of Python dictionary to JSON string We can convert a Python dictionary to a JSON string using the json.dumps() function. This function takes a Python object as input and returns a JSON string representation of the object. Example:\nimport json # Create a Python dictionary data = { \u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34; } # Convert the dictionary to a JSON string json_string = json.dumps(data) print(json_string) Conversion of JSON string to Python dictionary We can convert a JSON string to a Python dictionary using the json.loads() function. This function takes a JSON string as input and returns a Python object (usually a dictionary) representing the JSON data. Example:\nimport json # JSON string json_string = \u0026#39;{\u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;}\u0026#39; # Convert the JSON string to a Python dictionary data = json.loads(json_string) print(data) 2.os The os package in Python provides functions for interacting with the operating system.You can get indepth knowladge of os using its own documentation.but the most common methods are:\nos.path.join(\u0026quot;C:\u0026quot;,\u0026quot;users\u0026quot;,\u0026quot;bin\u0026quot;): Join one or more path components intelligently. os.rename(\u0026quot;old\u0026quot;,\u0026quot;new\u0026quot;): Rename a file or directory. 3.time The time package in Python provides functions for working with time-related tasks. You can use the time package to get the current time, sleep for a specified duration, and measure the execution time of your code.\ntime.time(): Returns the current time in seconds since the epoch. time.sleep(seconds): Suspends the execution of the current thread for the given number of seconds. 4.uuid The uuid package in Python provides functions for generating and working with UUIDs (Universally Unique Identifiers). UUIDs are unique identifiers that are used to identify objects in a distributed computing environment. The uuid package allows you to generate UUIDs based on various algorithms and formats.\nGenerating a UUID You can generate a UUID using the uuid.uuid4() function, which generates a random UUID. Example:\nimport uuid # Generate a random UUID uuid_value = uuid.uuid4() print(uuid_value) 5.Datetime The datetime package in Python provides classes for working with dates and times. You can use the datetime package to create, manipulate, and format dates and times in your Python programs.\nCreating a datetime object You can create a datetime object using the datetime.datetime() constructor, which takes the year, month, day, hour, minute, second, and microsecond as input. Example:\nimport datetime # Create a datetime object dt = datetime.datetime(2022, 11, 27, 10, 30, 0) print(dt) Output:\n2022-11-27 10:30:00 get current date and time You can get the current date and time using the datetime.now() method. Example:\nimport datetime # Get the current date and time now = datetime.datetime.now() print(now) Output:\n2022-11-27 10:30:00 Formatting a datetime object some Properties of datetime object:\nyear: The year of the datetime object month: The month of the datetime object (1-12) day: The day of the datetime object (1-31) hour: The hour of the datetime object (0-23) minute: The minute of the datetime object (0-59) second: The second of the datetime object (0-59) import datetime # Create a datetime object dt = datetime.datetime.now() # Format the datetime object print(dt.month()) print(dt.day()) print(dt.year()) print(dt.hour()) print(dt.minute()) print(dt.second()) Output:\n11\r27\r2022\r10\r30\r0 ","permalink":"http://localhost:1313/posts/pages/python/python_extrapackage/","summary":"An in-depth look at frequently used important package.","title":"Python Fundamentals: Some Important Package to Know (Part 10)"},{"content":"Shared References in Python: How Changes Propagate Across Variables In Python, variables are references to objects in memory. When you assign a value to a variable, you are creating a reference to the object that holds that value. In some cases, multiple variables can refer to the same object in memory. This is known as a shared reference.\nMutability and Shared References in Python: How Changes Propagate Across Variables List Lists are mutable, so if two variables reference the same list, changes through one variable will affect the other.\n# Create a list list1 = [1, 2, 3] # Create a reference to the list list2 = list1 # Modify the list through one reference list2.append(4) # Check the original list print(list1) # Output: [1, 2, 3, 4] Dictionary Dictionaries are mutable as well. If two variables point to the same dictionary, any change made through one will reflect in the other.\n# Create a dictionary dict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30} # Create a reference to the dictionary dict2 = dict1 # Modify the dictionary through one reference dict2[\u0026#34;age\u0026#34;] = 31 # Check the original dictionary print(dict1) # Output: {\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 31} Set Sets are mutable, so changes made through one reference will affect the other if two variables point to the same set.\n# Create a set set1 = {1, 2, 3} # Create a reference to the set set2 = set1 # Modify the set through one reference set2.add(4) # Check the original set print(set1) # Output: {1, 2, 3, 4} Custom Objects\nclass Person: def __init__(self, name, age): self.name = name self.age = age # Create an instance of the Person class person1 = Person(\u0026#34;Alice\u0026#34;, 30) # Create a reference to the instance person2 = person1 # Modify the instance through one reference person2.age = 31 # Check the original instance print(person1.age) # Output: 31 Note: Mutable objects like lists, dictionaries, sets, and custom objects allow changes to propagate across variables that reference the same object. Immutable objects like integers, strings, and tuples do not exhibit this behavior.\n","permalink":"http://localhost:1313/posts/pages/python/python_shared_references/","summary":"An in-depth look at shared references in Python.","title":"Python Fundamentals : Shared References in Python (part 11)"},{"content":"Object oriented programming in python Object oriented programming is a programming paradigm that provides a means of structuring programs so that properties and behaviors are bundled into individual objects.\n1. Class and Object Class is a blueprint for creating objects (a particular data structure), providing initial values for state (member variables or attributes), and implementations of behavior (member functions or methods).\nObject is an instance of a class. When class is defined, only the description for the object is defined. Therefore, no memory or storage is allocated.\n1.1 Creating a class We can create a class using the class keyword followed by the class name. The class definition can contain class variables, instance variables, methods, and constructors.\nSyntax:\nclass ClassName: #code block Example:\nclass Person: name=\u0026#34;Nirajan\u0026#34; age=20 classes=\u0026#34;Bachelor\u0026#34; 1.2 Creating an object To create an object of a class, we use the class name followed by parentheses. This calls the constructor method of the class and returns an object.\nSyntax:\nobject_name = ClassName() Example:\nperson1 = Person() 1.3 Accessing class attributes We can access the attributes of a class using the dot operator (.) followed by the attribute name.\nSyntax:\nobject_name.attribute_name Example:\nprint(person1.name) # Output: Nirajan print(person1.age) # Output: 20 print(person1.classes) # Output: Bachelor 1.4 Modifying class attributes We can modify the attributes of a class using the dot operator (.) followed by the attribute name.\nSyntax:\nobject_name.attribute_name = new_value Example:\nperson1.age = 21 print(person1.age) # Output: 21 1.5 Creating a member function We can create a member function (method) inside a class using the def keyword followed by the function name. The first parameter of the method should be self, which refers to the current instance of the class.we will see about self in next part.\nSyntax:\nclass ClassName: def method_name(self, parameters): #code block Example:\nclass Person: name=\u0026#34;Nirajan\u0026#34; age=20 classes=\u0026#34;Bachelor\u0026#34; def display(self): print(f\u0026#34;Name: {self.name}\u0026#34;) print(f\u0026#34;Age: {self.age}\u0026#34;) print(f\u0026#34;Class: {self.classes}\u0026#34;) 1.6 Calling a member function We can call a member function of a class using the dot operator (.) followed by the function name and parentheses.\nSyntax:\nobject_name.method_name(arguments) Example:\nperson1.display() 1.7 Nested member function We can call a member function from another member function of the same class using the self keyword.\nSyntax:\nclass ClassName: def method1(self): #code block self.method2() def method2(self): #code block Example:\nclass Person: name=\u0026#34;Nirajan\u0026#34; age=20 classes=\u0026#34;Bachelor\u0026#34; def display(self): print(f\u0026#34;Name: {self.name}\u0026#34;) print(f\u0026#34;Age: {self.age}\u0026#34;) print(f\u0026#34;Class: {self.classes}\u0026#34;) self.greet() def greet(self): print(\u0026#34;Hello, Welcome to the class\u0026#34;) 1.8 self parameter The self parameter is a reference to the current instance of the class, and is used to access variables and methods of the class. It is the first parameter of any method in a class.\nSyntax:\nclass ClassName: def method_name(self, parameters): #code block Example:\nclass Person: name=\u0026#34;Nirajan\u0026#34; age=20 classes=\u0026#34;Bachelor\u0026#34; def display(self): print(f\u0026#34;Name: {self.name}\u0026#34;) print(f\u0026#34;Age: {self.age}\u0026#34;) print(f\u0026#34;Class: {self.classes}\u0026#34;) self.greet() def greet(self): print(\u0026#34;Hello, Welcome to the class\u0026#34;) 2. Constructor in Python A constructor is a special type of method (function) which is used to initialize the instance members of the class. It is called when an object of the class is created.\n2.1 Creating a constructor In Python, the constructor method is called __init__. It is a special method that is automatically called when an object is created.\nSyntax:\nclass ClassName: def __init__(self, parameters): #code block Example:\nclass Person: def __init__(self, name, age, classes): self.name = name self.age = age self.classes = classes def display(self): print(f\u0026#34;Name: {self.name}\u0026#34;) print(f\u0026#34;Age: {self.age}\u0026#34;) print(f\u0026#34;Class: {self.classes}\u0026#34;) 2.2 Creating an object with constructor When an object is created, the constructor method is automatically called with the arguments passed to the class.\nSyntax:\nobject_name = ClassName(arguments) Example:\nperson1 = Person(\u0026#34;Nirajan\u0026#34;, 20, \u0026#34;Bachelor\u0026#34;) 3. Getters and Setters in Python 3.1. Getters Getters are methods is implementes by using the @property decorator. They are specially used\nto act as an value ie data instead of a method. to access the value of a private attribute without directly accessing it. Syntax:\nclass ClassName: @property def method_name(self): #code block Example:\nclass Person: def __init__(self, name, age): self._name = name self._age = age @property def display(self): return f\u0026#34;Name: {self._name}, Age: {self._age}\u0026#34; person1 = Person(\u0026#34;Nirajan\u0026#34;, 20) print(person1.display) # Output: Name: Nirajan, Age: 20 3.2. Setters Setters are methods is implementes by using the @method_name.setter decorator. They are specially used\nto set the value of a private attribute without directly setting it. to perform validation before setting the value of an attribute. Syntax:\nclass ClassName: @method_name.setter def method_name(self, value): #code block Example:\nclass Person: def __init__(self, name, age): self._name = name self._age = age @property def display(self): return f\u0026#34;Name: {self._name}, Age: {self._age}\u0026#34; @display.setter def display(self, value): self._name, self._age = value.split(\u0026#34;,\u0026#34;) self._age = int(self._age) person1 = Person(\u0026#34;Nirajan\u0026#34;, 20) print(person1.display) # Output: Name: Nirajan, Age: 20 person1.display = \u0026#34;Alice, 30\u0026#34; print(person1.display) # Output: Name: Alice, Age: 30 4. Inheritance in Python Inheritance is a mechanism in which one class acquires the properties and behavior of another class. The class which inherits the properties and behavior is known as the child class, and the class whose properties and behavior are inherited is known as the parent class.\n4.1. Creating a child class To create a child class that inherits from a parent class, we specify the parent class in parentheses after the child class name.\nSyntax:\nclass ChildClassName(ParentClassName): #code block Example:\nclass Employee: def __init__(self,name,age,id): self.name=name self.age=age self.id=id def display(self): print(f\u0026#34;Name: {self.name}\u0026#34;) print(f\u0026#34;Age: {self.age}\u0026#34;) print(f\u0026#34;ID: {self.id}\u0026#34;) class Manager(Employee):# it has all the properties of Employee class so we can access the # properties of Employee class also its method using object of Manager class def task(self): self.display() print(\u0026#34;Assigning tasks to employees\u0026#34;) class Developer(Employee): # it has all the properties of Employee class so we can access # the properties of Employee class also its method using object of Developer class def task(self): self.display() print(\u0026#34;Developing software applications\u0026#34;) manager1 = Manager(\u0026#34;Alice\u0026#34;, 30, 101) manager1.task() developer1 = Developer(\u0026#34;Bob\u0026#34;, 25, 102) developer1.task() Note : Only public and protected members are inherited by the child class. Private members are not inherited by the child class.\n5.Ascess Specifiers in Python 5.1. Public members Public members are accessible from outside the class. They can be accessed using the dot operator (.) from outside the class.\nExample:\nclass Person: name = \u0026#34;Alice\u0026#34; # Public member person1 = Person() print(person1.name) # Output: Alice 5.2. Protected members Protected members are accessible within the class and its subclasses. They are denoted by a single underscore (_) before the member name.\nExample:\nclass Person: _age = 30 # Protected member class Student(Person): def display(self): print(self._age) # Accessing protected member student1 = Student() student1.display() # Output: 30 Example of protected variable and method\nclass Person: _name = \u0026#34;Alice\u0026#34; # Protected variable def _display(self): # Protected method print(f\u0026#34;Name: {self._name}\u0026#34;) class Student(Person): def display(self): self._display() # Accessing protected metho student1 = Student() student1.display() # Output: Name: Alice 5.3. Private members Private members are accessible only within the class. They are denoted by a double underscore (__) before the member name.\nExample:\nclass Person: __city = \u0026#34;New York\u0026#34; # Private member person1 = Person() print(person1.__city) # Error: \u0026#39;Person\u0026#39; object has no attribute \u0026#39;__city\u0026#39; Example of private variable and method\nclass Person: __name = \u0026#34;Alice\u0026#34; # Private variable def __display(self): # Private method print(f\u0026#34;Name: {self.__name}\u0026#34;) person1 = Person() print(person1.__name) # Error: \u0026#39;Person\u0026#39; object has no attribute \u0026#39;__name\u0026#39; person1.__display() # Error: \u0026#39;Person\u0026#39; object has no attribute \u0026#39;__display\u0026#39; Table of Access Specifiers in Python:\nAccess Specifier Accessible from class Accessible from subclass Accessible from outside class Public Yes Yes Yes Protected Yes Yes No Private Yes No No Static Method in Python Static Method is those method that can be called without creating an object of the class. They are defined using the @staticmethod decorator. They can be called using the class name . Syntax: class ClassName: @staticmethod def method_name(parameters): #code block Example:\nclass Calculator: @staticmethod def add(a, b): return a + b result = Calculator.add(5, 3) print(result) # Output: 8 #Can call using object also calculator = Calculator() result = calculator.add(5, 3) print(result) # Output: 8 #this is also valid but it is not recommended Class Method in Python They are defined using the @classmethod decorator.The useage of class method is to access the class variable and change class variable. ie when we change variable using class method it will change for all the object of the class.THey can be called using the class name. Syntax:\nclass ClassName: @classmethod def method_name(cls, parameters): #code block Example:\nclass copany : copany=\u0026#34;Google\u0026#34; @classmethod def change_company(cls,new_company): cls.copany=new_company print(copany.copany) #Output: Google copany.change_company(\u0026#34;Microsoft\u0026#34;) print(copany.copany) #Output: Microsoft c1=copany() print(c1.copany) #Output: Microsoft c1.change_company(\u0026#34;Apple\u0026#34;) c2=copany() print(c2.copany) #Output: Applex Dir and dict method in Python dir() method is used to return a list of attributes and methods of any object. It returns a list of valid attributes and methods of the object. Syntax:\ndir(object) Example:\nclass Person: name = \u0026#34;Alice\u0026#34; age = 30 person1 = Person() print(dir(person1)) # Output: [\u0026#39;__class__\u0026#39;, \u0026#39;__delattr__\u0026#39;, \u0026#39;__dict__\u0026#39;, \u0026#39;__dir__\u0026#39;, \u0026#39;__doc__\u0026#39;, \u0026#39;__eq__\u0026#39;, \u0026#39;__format__\u0026#39;, \u0026#39;__ge__\u0026#39;, \u0026#39;__getattribute__\u0026#39;, \u0026#39;__gt__\u0026#39;, \u0026#39;__hash__\u0026#39;, \u0026#39;__init__\u0026#39;, \u0026#39;__init_subclass__\u0026#39;, \u0026#39;__le__\u0026#39;, \u0026#39;__lt__\u0026#39;, \u0026#39;__module__\u0026#39;, \u0026#39;__ne__\u0026#39;, \u0026#39;__new__\u0026#39;, \u0026#39;__reduce__\u0026#39;, \u0026#39;__reduce_ex__\u0026#39;, \u0026#39;__repr__\u0026#39;, \u0026#39;__setattr__\u0026#39;, \u0026#39;__sizeof__\u0026#39;, \u0026#39;__str__\u0026#39;, \u0026#39;__subclasshook__\u0026#39;, \u0026#39;__weakref__\u0026#39;, \u0026#39;age\u0026#39;, \u0026#39;name\u0026#39;] Example:\nl=[1,2,3] print(dir(l)) # Output: [\u0026#39;__add__\u0026#39;, \u0026#39;__class__\u0026#39;, \u0026#39;__class_getitem__\u0026#39;, \u0026#39;__contains__\u0026#39;, \u0026#39;__delattr__\u0026#39;, \u0026#39;__delitem__\u0026#39;, \u0026#39;__dir__\u0026#39;, \u0026#39;__doc__\u0026#39;, \u0026#39;__eq__\u0026#39;, \u0026#39;__format__\u0026#39;, \u0026#39;__ge__\u0026#39;, \u0026#39;__getattribute__\u0026#39;, \u0026#39;__getitem__\u0026#39;, \u0026#39;__getstate__\u0026#39;, \u0026#39;__gt__\u0026#39;, \u0026#39;__hash__\u0026#39;, \u0026#39;__iadd__\u0026#39;, \u0026#39;__imul__\u0026#39;, \u0026#39;__init__\u0026#39;, \u0026#39;__init_subclass__\u0026#39;, \u0026#39;__iter__\u0026#39;, \u0026#39;__le__\u0026#39;, \u0026#39;__len__\u0026#39;, \u0026#39;__lt__\u0026#39;, \u0026#39;__mul__\u0026#39;, \u0026#39;__ne__\u0026#39;, \u0026#39;__new__\u0026#39;, \u0026#39;__reduce__\u0026#39;, \u0026#39;__reduce_ex__\u0026#39;, \u0026#39;__repr__\u0026#39;, \u0026#39;__reversed__\u0026#39;, \u0026#39;__rmul__\u0026#39;, \u0026#39;__setattr__\u0026#39;, \u0026#39;__setitem__\u0026#39;, \u0026#39;__sizeof__\u0026#39;, \u0026#39;__str__\u0026#39;, \u0026#39;__subclasshook__\u0026#39;, \u0026#39;append\u0026#39;, \u0026#39;clear\u0026#39;, \u0026#39;copy\u0026#39;, \u0026#39;count\u0026#39;, \u0026#39;extend\u0026#39;, \u0026#39;index\u0026#39;, \u0026#39;insert\u0026#39;, \u0026#39;pop\u0026#39;, \u0026#39;remove\u0026#39;, \u0026#39;reverse\u0026#39;, \u0026#39;sort\u0026#39;] __dict__ method is used to return a dictionary containing the attributes of an object. It returns a dictionary containing the attributes of the object.\nSyntax:\nobject.__dict__ Example:\nclass Person: name = \u0026#34;Alice\u0026#34; age = 30 person1 = Person() print(person1.__dict__) # Output: {\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 30} 9.super() method in Python When a parent class and a child class define a method with the same name, and we create an object of the child class, invoking the method on the child class object will execute the method defined in the child class, not the one in the parent class. To explicitly call the parent class\u0026rsquo;s method, we can use the super() function.\nTo explicitly invoke the parent class\u0026rsquo;s version of the method, the super() function is used. This is especially useful when the child class\u0026rsquo;s method needs to build upon or extend the functionality of the parent class\u0026rsquo;s method.\nSyntax:\nsuper().method_name() Example:\nclass Person: def display(self): print(\u0026#34;Person class\u0026#34;) class Student(Person): def display(self): super().display() print(\u0026#34;Student class\u0026#34;) student1 = Student() student1.display() # Output: # Person class # Student class Example:\nclass Person: def __init__(self,name,age): self.name=name self.age=age class Student(Person): def __init__(self,name,age,roll): super().__init__(name,age) self.roll=roll def display(self): print(f\u0026#34;Name: {self.name}\u0026#34;) print(f\u0026#34;Age: {self.age}\u0026#34;) print(f\u0026#34;Roll: {self.roll}\u0026#34;) student1 = Student(\u0026#34;Alice\u0026#34;, 30, 101) student1.display() # Output: # Name: Alice # Age: 30 # Roll: 101 Note: Use super for single inheritance only. For multiple inheritance, use the class name directly.\nMagic/dunder methods in Python Magic methods are special methods that have double underscores at the beginning and end of their names. They are also known as dunder methods (short for \u0026ldquo;double underscore\u0026rdquo;). Magic methods are used to define the behavior of objects. They are automatically called when certain operations are performed on objects. Some of the commonly used magic methods are:\n__init__: Constructor method, called when an object is created. __str__: Called by the str() built-in function to return a string representation of an object. __repr__: Called by the repr() built-in function to return an unambiguous string representation of an object. __add__: Called by the + operator to perform addition. __len__: Called by the len() built-in function to return the length of an object. __call__: Called when an object is called as a function. Note : All magic method can be seen using dir(objectname) method and we can override the magic method in our class.\nexample of all method:\nclass Person: def __init__(self, name, age): self.name = name self.age = age def __str__(self): return f\u0026#34;Name: {self.name}, Age: {self.age}\u0026#34; def __repr__(self): return f\u0026#34;Person(\u0026#39;{self.name}\u0026#39;, {self.age})\u0026#34; def __add__(self, other): return self.age + other.age def __len__(self): return len(self.name) def __call__(self): return f\u0026#34;Name: {self.name}, Age: {self.age}\u0026#34; person1 = Person(\u0026#34;Alice\u0026#34;, 30) person2 = Person(\u0026#34;Bob\u0026#34;, 25) print(person1) # Output: Name: Alice, Age: 30 print(repr(person1)) # Output: Person(\u0026#39;Alice\u0026#39;, 30) print(person1 + person2) # Output: 55 print(len(person1)) # Output: 5 print(person1()) # Output: Name: Alice, Age: 30 Method Overriding Method overriding is a feature of object-oriented programming that allows a subclass to provide a specific implementation of a method that is already provided by its parent class. When a method in a subclass has the same name, same parameters or signature, and same return type as a method in its parent class, then the method in the subclass is said to override the method in the parent class. Example:\nclass Person: def display(self): print(\u0026#34;Person class\u0026#34;) class Student(Person): def display(self): print(\u0026#34;Student class\u0026#34;) student1 = Student() student1.display() # Output: Student class We can also call the parent class\u0026rsquo;s method from the overridden method using the super() function.\nExample:\nclass Person: def display(self): print(\u0026#34;Person class\u0026#34;) class Student(Person): def display(self): super().display() #Or Person.display(self) print(\u0026#34;Student class\u0026#34;) student1 = Student() student1.display() # Output: # Person class # Student class Operator overloading in Python Operator overloading is a feature of object-oriented programming that allows us to define the behavior of operators for user-defined objects. It allows us to define the behavior of operators such as +, -, *, /, ==, !=, etc., for objects of a class. To overload an operator, we need to define a special method in the class that corresponds to the operator. These special methods are called magic methods or dunder methods.\nExample:\nclass Point: def __init__(self, x, y): self.x = x self.y = y def __add__(self, other): x = self.x + other.x y = self.y + other.y return Point(x, y) def __str__(self): return f\u0026#34;({self.x}, {self.y})\u0026#34; point1 = Point(1, 2) point2 = Point(3, 4) point3 = point1 + point2 print(point3) # Output: (4, 6) Types of Inheritance in Python Inheritance is a mechanism in which one class acquires the properties and behavior of another class. There are different types of inheritance in Python: Single Inheritance: In single inheritance, a class inherits from only one parent class. The pictorial representation of single inheritance is:\nA\r|\rB Syntax:\nclass ParentClass: #code block class ChildClass(ParentClass): #code block Example:\nclass Person: def __init__(self, name, age): self.name = name self.age = age def display(self): return f\u0026#34;Name: {self.name}, Age: {self.age}\u0026#34; def __str__(self): return f\u0026#34;Name: {self.name}, Age: {self.age}\u0026#34; def __repr__(self): return f\u0026#34;Person(\u0026#39;{self.name}\u0026#39;, {self.age})\u0026#34; def __call__(self): return f\u0026#34;Name: {self.name}, Age: {self.age}\u0026#34; class Student(Person): def __init__(self,naem,age,id): super().__init__(name,age) #or Person.__init__(self,name,age) self.id=id def display(self): print(f\u0026#34;ID: {self.id}\u0026#34;,super().display()) #or Person.display(self) student1 = Student(\u0026#34;Alice\u0026#34;, 30, 101) student1.display() # Output: # ID: 101 # Name: Alice, Age: 30 Multiple Inheritance: In multiple inheritance, a class inherits from more than one parent class. The pictorial representation of multiple inheritance is:\nA B\r\\ /\rC Syntax:\nclass ParentClass1: #code block class ParentClass2: #code block class ChildClass(ParentClass1, ParentClass2): #code block Example:\nclass Person: def __init__(self, name, age): self.name = name self.age = age def display(self): return f\u0026#34;Name: {self.name}, Age: {self.age}\u0026#34; class Address: def __init__(self,city,state): self.city=city self.state=state def display(self): return f\u0026#34;City: {self.city}, State: {self.state}\u0026#34; class Student(Person,Address): def __init__(self,name,age,id,city,state): Person.__init__(self,name,age) Address.__init__(self,city,state) self.id=id def display(self): print(f\u0026#34;ID: {self.id}\u0026#34;,Person.display(self),Address.display(self)) student1 = Student(\u0026#34;Alice\u0026#34;, 30, 101,\u0026#34;New York\u0026#34;,\u0026#34;New York\u0026#34;) student1.display() # Output: # ID: 101 # Name: Alice, Age: 30 # City: New York, State: New York Multilevel Inheritance: In multilevel inheritance, a class inherits from a parent class, and another class inherits from the child class. The pictorial representation of multilevel inheritance is:\nA\r|\rB\r|\rC Syntax:\nclass ParentClass: #code block class ChildClass(ParentClass): #code block class GrandChildClass(ChildClass): #code block Example:\nclass Person: def __init__(self, name, age): self.name = name self.age = age def display(self): return f\u0026#34;Name: {self.name}, Age: {self.age}\u0026#34; class Student(Person): def __init__(self,name,age,id): super().__init__(name,age) # or Person.__init__(self,name,age) self.id=id def display(self): print(f\u0026#34;ID: {self.id}\u0026#34;,super().display()) # print(f\u0026#34;ID: {self.id}\u0026#34;,Person.display(self)) class CollegeStudent(Student): def __init__(self,name,age,id,classes): super().__init__(name,age,id) #or Student.__init__(self,name,age,id) self.classes=classes def display(self): print(f\u0026#34;Class: {self.classes}\u0026#34;,super().display()) #or print(f\u0026#34;Class: {self.classes}\u0026#34;,Student.display(self)) student1 = CollegeStudent(\u0026#34;Alice\u0026#34;, 30, 101,\u0026#34;Bachelor\u0026#34;) student1.display() # Output: # Class: Bachelor # ID: 101 # Name: Alice, Age: 30 Hierarchical Inheritance: In hierarchical inheritance, more than one class inherits from a single parent class. The pictorial representation of hierarchical inheritance is:\nA\r/ \\\rB C Syntax:\nclass ParentClass: #code block class ChildClass1(ParentClass): #code block class ChildClass2(ParentClass): #code block Example:\nclass Person: def __init__(self, name, age): self.name = name self.age = age def display(self): return f\u0026#34;Name: {self.name}, Age: {self.age}\u0026#34; class Student(Person): def __init__(self,name,age,id): super().__init__(name,age) #or Person.__init__(self,name,age) self.id=id def display(self): print(f\u0026#34;ID: {self.id}\u0026#34;,super().display()) #or print(f\u0026#34;ID: {self.id}\u0026#34;,Person.display(self)) class Employee(Person): def __init__(self,name,age,emp_id): super().__init__(name,age) #or Person.__init__(self,name,age) self.emp_id=emp_id def display(self): print(f\u0026#34;Emp ID: {self.emp_id}\u0026#34;,super().display()) #or print(f\u0026#34;Emp ID: {self.emp_id}\u0026#34;,Person.display(self)) student1 = Student(\u0026#34;Alice\u0026#34;, 30, 101) student1.display() employee1 = Employee(\u0026#34;Bob\u0026#34;, 25, 201) employee1.display() # Output: # ID: 101 # Name: Alice, Age: 30 # Emp ID: 201 # Name: Bob, Age: 25 Note: Hybrid inheritance is a combination of two or more types of inheritance.\n14. MRO (Method Resolution Order) in Python Method Resolution Order (MRO) is the order in which methods are resolved in the inheritance hierarchy. It defines the order in which the base classes are searched when executing a method.\nfor example:\nclass C: f=\u0026#34;dirajan\u0026#34; class A(C): f=\u0026#34;nirajan\u0026#34; class B(C): f=\u0026#34;kirajan\u0026#34; class D(A,B): pass def display(self): print(self.f) d=D() print(D.__mro__) d.display() Output:\n(\u0026lt;class \u0026#39;__main__.D\u0026#39;\u0026gt;, \u0026lt;class \u0026#39;__main__.A\u0026#39;\u0026gt;, \u0026lt;class \u0026#39;__main__.B\u0026#39;\u0026gt;, \u0026lt;class \u0026#39;__main__.C\u0026#39;\u0026gt;, \u0026lt;class \u0026#39;object\u0026#39;\u0026gt;)\rnirajan It means it will search for the method in the order of D-\u0026gt;A-\u0026gt;B-\u0026gt;C-\u0026gt;object if the method is not found in the D it will search in A and so on. but if the method is found in the D it will not search in the A,B,C and object.\n15.Class Inside a Class in Python A class can be defined inside another class. The class inside the class is known as nested class. The nested class can access the attributes and methods of the outer class.\nSyntax:\nclass OuterClass: class InnerClass: #code block Example:\nclass OuterClass: def __init__(self): self.name = \u0026#34;Alice\u0026#34; self.age = 30 class InnerClass: def display(self, outer): print(f\u0026#34;Name: {outer.name}\u0026#34;) print(f\u0026#34;Age: {outer.age}\u0026#34;) outer1 = OuterClass() inner1 = outer1.InnerClass() inner1.display(outer1) # Output: # Name: Alice # Age: 30 16. Nested class in Python A class can be defined inside another class. The class inside the class is known as nested class. The nested class can access the attributes and methods of the outer class.\nSyntax:\nclass OuterClass: class InnerClass: #code block Creating an object of the nested class: Syntax:\nouter_object = OuterClass() inner_object = outer_object.InnerClass() Example:\nclass OuterClass: def __init__(self): self.name = \u0026#34;Alice\u0026#34; self.age = 30 class InnerClass: def display(self, outer): print(f\u0026#34;Name: {outer.name}\u0026#34;) print(f\u0026#34;Age: {outer.age}\u0026#34;) outer1 = OuterClass() inner1 = outer1.InnerClass() inner1.display(outer1) # Output: # Name: Alice # Age: 30 creating an object of the nested class inside the outer class:\nclass OuterClass: def __init__(self): self.name = \u0026#34;Alice\u0026#34; self.age = 30 self.inner = self.InnerClass() class InnerClass: def display(self, outer): print(f\u0026#34;Name: {outer.name}\u0026#34;) print(f\u0026#34;Age: {outer.age}\u0026#34;) outer1 = OuterClass() outer1.inner.display(outer1) # Output: # Name: Alice # Age: 30 ","permalink":"http://localhost:1313/posts/pages/python/python_object_oriented1/","summary":"This is the first part of series of Object Oriented Programming in Python","title":"Python Fundamentals: Exploring OOP (Part 12)"},{"content":"DOM (Document Object Model) Theory The DOM is a programming interface for HTML and XML documents. It represents the document as a tree structure where each node is an object representing a part of the document. This allows programming languages to interact with the document structure, style, and content.\n1. DOM Selection Methods a) document.getElementById() Selects an element by its ID attribute.\n\u0026lt;!-- HTML --\u0026gt; \u0026lt;div id=\u0026#34;myDiv\u0026#34;\u0026gt;Hello\u0026lt;/div\u0026gt; // JavaScript const element = document.getElementById(\u0026#39;myDiv\u0026#39;); console.log(element.innerText); // Output: // \u0026#34;Hello\u0026#34; b) document.getElementsByClassName() Returns a collection of elements with the specified class name.\n\u0026lt;!-- HTML --\u0026gt; \u0026lt;div class=\u0026#34;myClass\u0026#34;\u0026gt;Item 1\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;myClass\u0026#34;\u0026gt;Item 2\u0026lt;/div\u0026gt; // JavaScript const elements = document.getElementsByClassName(\u0026#39;myClass\u0026#39;); for (let i = 0; i \u0026lt; elements.length; i++) { console.log(elements[i].innerText); } // Output: // \u0026#34;Item 1\u0026#34; // \u0026#34;Item 2\u0026#34; c) document.getElementsByTagName() Returns a collection of elements with the specified tag name.\n\u0026lt;!-- HTML --\u0026gt; \u0026lt;p\u0026gt;Paragraph 1\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Paragraph 2\u0026lt;/p\u0026gt; // JavaScript const paragraphs = document.getElementsByTagName(\u0026#39;p\u0026#39;); for (let i = 0; i \u0026lt; paragraphs.length; i++) { console.log(paragraphs[i].innerText); // Output: // \u0026#34;Paragraph 1\u0026#34; // \u0026#34;Paragraph 2\u0026#34; d) document.querySelector() Returns the first element that matches the CSS selector.\n\u0026lt;!-- HTML --\u0026gt; \u0026lt;div class=\u0026#34;myClass\u0026#34;\u0026gt;First Element\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;myClass\u0026#34;\u0026gt;Second Element\u0026lt;/div\u0026gt; // JavaScript const firstElement = document.querySelector(\u0026#39;.myClass\u0026#39;); console.log(firstElement.innerText); // Output: // \u0026#34;First Element\u0026#34; e) document.querySelectorAll() Returns all elements that match the CSS selector.\n\u0026lt;!-- HTML --\u0026gt; \u0026lt;div class=\u0026#34;myClass\u0026#34;\u0026gt;First Element\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;myClass\u0026#34;\u0026gt;Second Element\u0026lt;/div\u0026gt; // JavaScript const allElements = document.querySelectorAll(\u0026#39;.myClass\u0026#39;); allElements.forEach(el =\u0026gt; console.log(el.innerText)); // Output: // \u0026#34;First Element\u0026#34; // \u0026#34;Second Element\u0026#34; 2. DOM Properties a) innerText Gets or sets the text content of an element.\n\u0026lt;!-- HTML --\u0026gt; \u0026lt;div id=\u0026#34;textElement\u0026#34;\u0026gt;Original Text\u0026lt;/div\u0026gt; // JavaScript const element = document.getElementById(\u0026#39;textElement\u0026#39;); element.innerText = \u0026#39;Hello World\u0026#39;; console.log(element.innerText); // Output: // \u0026#34;Hello World\u0026#34; b) innerHTML Gets or sets the HTML content of an element.\n\u0026lt;!-- HTML --\u0026gt; \u0026lt;div id=\u0026#34;htmlElement\u0026#34;\u0026gt;Original Content\u0026lt;/div\u0026gt; // JavaScript const element = document.getElementById(\u0026#39;htmlElement\u0026#39;); element.innerHTML = \u0026#39;\u0026lt;span\u0026gt;Hello World\u0026lt;/span\u0026gt;\u0026#39;; console.log(element.innerHTML); // Output: // \u0026#34;\u0026lt;span\u0026gt;Hello World\u0026lt;/span\u0026gt;\u0026#34; c) textContent Gets or sets the text content of a node and its descendants.\n\u0026lt;!-- HTML --\u0026gt; \u0026lt;div id=\u0026#34;contentElement\u0026#34;\u0026gt;Original Content\u0026lt;/div\u0026gt; // JavaScript const element = document.getElementById(\u0026#39;contentElement\u0026#39;); element.textContent = \u0026#39;Hello World\u0026#39;; console.log(element.textContent); // Output: // \u0026#34;Hello World\u0026#34; d) style Gets or sets inline styles of an element.\n\u0026lt;!-- HTML --\u0026gt; \u0026lt;div id=\u0026#34;styledElement\u0026#34;\u0026gt;Style Me\u0026lt;/div\u0026gt; // JavaScript const element = document.getElementById(\u0026#39;styledElement\u0026#39;); element.style.backgroundColor = \u0026#39;red\u0026#39;; element.style.fontSize = \u0026#39;16px\u0026#39;; // Result: Element with red background and font size of 16px 3. Events in JavaScript Events are actions that occur in a web page that can be detected by JavaScript.\nClick Event Example \u0026lt;!-- HTML --\u0026gt; \u0026lt;button id=\u0026#34;clickButton\u0026#34;\u0026gt;Click Me\u0026lt;/button\u0026gt; // JavaScript const button = document.getElementById(\u0026#39;clickButton\u0026#39;); button.addEventListener(\u0026#39;click\u0026#39;, function(e) { console.log(\u0026#39;Clicked!\u0026#39;); }); // Output when clicked: // \u0026#34;Clicked!\u0026#34; Mouse Over Event Example \u0026lt;!-- HTML --\u0026gt; \u0026lt;div id=\u0026#34;hoverElement\u0026#34;\u0026gt;Hover Over Me\u0026lt;/div\u0026gt; // JavaScript const element = document.getElementById(\u0026#39;hoverElement\u0026#39;); element.addEventListener(\u0026#39;mouseover\u0026#39;, function(e) { console.log(\u0026#39;Mouse over!\u0026#39;); }); // Output when hovered: // \u0026#34;Mouse over!\u0026#34; ","permalink":"http://localhost:1313/posts/pages/js/domevents/","summary":"A complete reference guide for DOM manipulation and Events","title":"Javascript : Dom and Events"},{"content":"Asynchronous Programming in JavaScript Asynchronous programming allows a program to perform multiple tasks simultaneously. It enables non-blocking operations, making it possible to execute long-running tasks without freezing the main program.\nFor example:\nconsole.log(\u0026#39;Start\u0026#39;); setTimeout(() =\u0026gt; { console.log(\u0026#39;This message is delayed by 2 seconds\u0026#39;); }, 2000); console.log(\u0026#39;End\u0026#39;); When you run this code, the output will be:\nStart End This message is delayed by 2 seconds Explanation:\nconsole.log('Start'); is executed, and \u0026ldquo;Start\u0026rdquo; is printed. setTimeout() sets up a callback function to run after 2000 milliseconds (2 seconds) but does not block the next line. console.log('End'); is executed immediately after, and \u0026ldquo;End\u0026rdquo; is printed. After 2 seconds, the callback function in setTimeout() is executed, and \u0026ldquo;This message is delayed by 2 seconds\u0026rdquo; is printed. This demonstrates how asynchronous functions like setTimeout() work without blocking the execution of subsequent code.\nPromises Promises are a way to handle asynchronous operations in JavaScript. They represent a value that may be available now, in the future, or never. Promises can be in one of three states: pending, fulfilled, or rejected. They allow us to run code when the promise is fulfilled or rejected using the .then() and .catch() methods.\nSyntax to create a new Promise:\nconst promise = new Promise((resolve, reject) =\u0026gt; { // Perform an asynchronous operation // If successful, call resolve(value) // If an error occurs, call reject(error) }); Why We Use Promises Consider the following code:\nfunction main() { setTimeout(() =\u0026gt; { console.log(\u0026#34;Hello\u0026#34;); }, 1000); } main(); main(); main(); This code waits for 1 second and then logs \u0026ldquo;Hello\u0026rdquo; three times instantly. But what if we want to wait for the first to be completed before the second?\nThis can be solved using promises:\nfunction promise() { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { console.log(\u0026#34;Hello\u0026#34;); resolve(\u0026#34;Done\u0026#34;); }, 2000); }); } let data = promise(); When a promise is called, it returns a promise object instantly in a pending state. When the asynchronous operation completes, the promise is either fulfilled or rejected.\nHandling Promises To do a task when the promise is fulfilled (resolved):\ndata.then((data) =\u0026gt; { console.log(data); }); To do a task when the promise is rejected:\ndata.catch((err) =\u0026gt; { console.log(\u0026#34;Promise rejected\u0026#34;, err); }); Handling Multiple Promises function promise1() { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { console.log(\u0026#34;Promise 1 resolved\u0026#34;); resolve(\u0026#34;Done 1\u0026#34;); }, 2000); }); } function promise2() { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { console.log(\u0026#34;Promise 2 resolved\u0026#34;); resolve(\u0026#34;Done 2\u0026#34;); }, 2000); }); } function promise3() { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { console.log(\u0026#34;Promise 3 resolved\u0026#34;); resolve(\u0026#34;Done 3\u0026#34;); }, 2000); }); } let data1 = promise1(); let data2 = promise2(); let data3 = promise3(); How Promises Work:\npromise1 is called. promise2 is called immediately. promise3 is called immediately, regardless of whether the previous promises are resolved. To execute promises one by one:\nlet data1 = promise1(); data1.then((data) =\u0026gt; { console.log(data); return promise2(); }).then((data) =\u0026gt; { console.log(data); return promise3(); }).then((data) =\u0026gt; { console.log(data); }).catch((err) =\u0026gt; { console.log(\u0026#34;Error\u0026#34;, err); }); Here, the first promise will run, then the second, then the third, and so on, one by one.\nAsync and Await Async functions always return a promise. await is used to wait for a promise to be resolved, such that the code below it will not run until the promise is resolved.\nTo use await, we need to use an async function:\nasync function main() { console.log(\u0026#34;Hello\u0026#34;); } main(); Example with await:\nlet promise = new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { resolve(\u0026#34;Done\u0026#34;); }, 2000); }); async function main() { console.log(\u0026#34;Hello\u0026#34;); await promise; console.log(\u0026#34;Hello again\u0026#34;); } main(); console.log(\u0026#34;Hi\u0026#34;); What happens here is the main function is called, it prints \u0026ldquo;Hello\u0026rdquo;, then waits for 2 seconds to resolve. During that time, it prints \u0026ldquo;Hi\u0026rdquo;. When the promise is resolved, it prints \u0026ldquo;Hello again\u0026rdquo;.\nWhen await is called, the function pauses its execution until the promise is resolved. Then it continues the execution of the function, such that code below await will not run until the promise is resolved, but the code outside the function will run.\nasync function main() { console.log(\u0026#34;Hello\u0026#34;); await promise; await promise; await promise; console.log(\u0026#34;Hello again\u0026#34;); } Here, the first promise is resolved, then the second is resolved, and so on.\n","permalink":"http://localhost:1313/posts/pages/js/asyncronous/","summary":"A complete guide to asynchronous programming in JavaScript, covering promises and async/await.","title":"Asynchronous Programming in JavaScript"},{"content":"Basics of Vim Vim is a powerful text editor, often used in the command line, that is known for its efficiency and speed once mastered. Here are the basic commands and modes that you need to get started.\nOpening a File To open a file in Vim, use the following command:\nvim filename Replace filename with the name of the file you wish to open.\nBasic Modes in Vim Vim operates in different modes, and understanding these modes is crucial for using Vim effectively:\nNormal Mode: This is the default mode when you open a file. In this mode, you can navigate, delete, copy, and paste text. To return to Normal Mode from other modes, press Esc.\nInsert Mode: This mode allows you to insert text into the file. To enter Insert Mode, press i. After you\u0026rsquo;re done typing, press Esc to go back to Normal Mode.\nCommon Commands Here are some essential commands for working with files in Vim:\nSave the current file:\n:w This writes (saves) changes to the file.\nQuit Vim:\n:q To quit Vim. If there are unsaved changes, Vim will warn you. You can force quit without saving using:\n:q! Save changes and quit:\n:wq or\n:x These commands save changes and then exit Vim.\nTips for Beginners Press Esc frequently to return to Normal Mode, as it helps you avoid unintended actions while in other modes. Practice using both Normal and Insert modes to become comfortable with the flow of editing and saving files in Vim. Vim can be intimidating at first, but with practice, it becomes an extremely efficient tool for editing text files, especially in programming and development environments. ","permalink":"http://localhost:1313/posts/pages/linux/vim_basics_guide/","summary":"Learn the basics of using Vim, including navigation, saving, and quitting.","title":"Basics of Vim"},{"content":"Docker Cheat Sheet: Commands and Concepts This guide covers essential Docker commands, from creating containers, managing images, building Dockerfiles, to working with volumes.\n🚀 Creating and Running Containers 1. Run a Container from an Image To create and run a container from an image:\ndocker run image 2. Run a Container in Interactive Mode To run a container and open its terminal:\ndocker run -it image After the container starts, you can interact with it directly in the terminal. 3. Name a Container To give a container a specific name:\ndocker run --name container_name image 4. Port Mapping To map a port from your computer to the container:\ndocker run -p computer_port:container_port image Incoming traffic to computer_port will be forwarded to container_port in the container. 5. Run a Container in the Background (Detached Mode) To run the container in the background:\ndocker run -d image 6. Passing Environment Variables to a Container To pass environment variables to a container:\ndocker run -e key=value image 🛠️ Managing Containers 7. Start a Container To start an existing container:\ndocker start container_id 8. Stop a Container To stop a running container:\ndocker stop container_id 9. Remove a Container To remove a container:\ndocker rm container_id Note: The container must be stopped before removal. 10. Execute a Command in a Running Container To start a terminal session inside a running container:\ndocker exec -it container_id bash 11. View Running Containers To list all currently running containers:\ndocker ps 12. View All Containers (Running and Stopped) To see all containers, including those that are stopped:\ndocker ps -a 🧱 Building Docker Images 13. Creating a Dockerfile A Dockerfile is a script used to build Docker images. Here’s an example of common Dockerfile commands:\n# Set the base image for your container FROM base_image # Run commands during the image build process RUN command # Copy files from your local machine to the container COPY source /path/in/container # Set environment variables ENV key=value # Expose a port for the container EXPOSE 8080 # Define the command to run when the container starts CMD [\u0026#34;executable\u0026#34;] # Optionally, run commands automatically when the container starts ENTRYPOINT [\u0026#34;/path/to/script\u0026#34;] # Set the working directory in the container WORKDIR /app # Copy all files from the local directory to the container, excluding files listed in .dockerignore COPY . . 14. Building a Docker Image To build a Docker image from a Dockerfile:\ndocker build -t image_name /path/to/Dockerfile 📂 Managing Docker Files 15. Using the .dockerignore File The .dockerignore file helps exclude unnecessary files from being copied into the Docker image, improving build speed and reducing image size:\nnode_modules/ .git/ 16. COPY Command in Dockerfile The COPY command copies files from your local system to the container:\nCopy all files from the current directory to the container: COPY . /path/in/container Copy a specific file: COPY ./filename.extension /path/in/container Copy an entire folder: COPY ./foldername /path/in/container Copy contents of a folder (not the folder itself): COPY ./foldername/ /path/in/container 📦 Working with Volumes 17. Mounting Volumes Volumes allow data to persist even if the container is deleted. To mount a folder from your host to the container:\ndocker run -it -v /path/on/host:/path/in/container image Example: docker run -it -v /home/user/backup:/app/data ubuntu This will map /home/user/backup on your host to /app/data inside the container. Use Cases for Volumes: Data Persistence: Preserve data even after the container is removed. Backups: Easily back up container data to the host. Shared Data: Share data between multiple containers or between host and container. 💾 Publishing Docker Images 18. Pushing an Image to Docker Hub To publish an image to Docker Hub:\nTag the image with your Docker Hub username: docker tag image_name username/image_name Log in to Docker Hub: docker login Push the image to your repository: docker push username/image_name This guide gives you the essentials for working with Docker. With these commands, you\u0026rsquo;ll be able to manage containers, build images, use volumes, and more effectively.\n","permalink":"http://localhost:1313/posts/pages/docker/docker_basics/","summary":"A guide to understanding Docker commands and concepts.","title":"Docker Basic: Commands and Concepts"},{"content":"Docker Compose Documentation Introduction Docker Compose is a tool for defining and running multi-container Docker applications. With Docker Compose, you can use a YAML file to configure your application\u0026rsquo;s services and create and start all the services from your configuration with a single command.\nBasic docker-compose.yml Structure The docker-compose.yml file is where you define the services that make up your app. A typical file might look like this:\nversion: \u0026#39;3.8\u0026#39; services: service_name: image: image_name:tag ports: - \u0026#34;host_port:container_port\u0026#34; environment: - ENV_VAR=value volumes: - \u0026#34;host_path:container_path\u0026#34; depends_on: - dependency_service Example Configurations Example 1: Basic Setup with PostgreSQL and Redis version: \u0026#39;3.8\u0026#39; services: postgres: image: postgres ports: - \u0026#34;5432:5432\u0026#34; environment: POSTGRES_USER: postgres POSTGRES_DB: review POSTGRES_PASSWORD: password redis: image: redis ports: - \u0026#34;80:80\u0026#34; Example 2: Real-World Application version: \u0026#39;3\u0026#39; services: pythonapp: image: your-python-image:tag ports: - \u0026#34;8000:8000\u0026#34; volumes: - /Users/data:/src/bin/data depends_on: - db - redis db: image: postgres environment: POSTGRES_DB: mydatabase POSTGRES_USER: myuser POSTGRES_PASSWORD: mypassword redis: image: redis volumes: - /path/to/local/directory:/data Example 3: Building from Dockerfile version: \u0026#39;3\u0026#39; services: pythonapp: build: context: . dockerfile: Dockerfile ports: - \u0026#34;8000:8000\u0026#34; volumes: - /Users/desktop:/src/bin/desktop depends_on: - db - redis db: image: postgres environment: POSTGRES_DB: mydatabase POSTGRES_USER: myuser POSTGRES_PASSWORD: mypassword redis: image: redis volumes: - /path/to/local/directory:/data Example 4: Django Application with PostgreSQL and Redis version: \u0026#39;3.8\u0026#39; services: django-app: container_name: django-app image: django-app:latest # Replace with your actual Django image name/tag ports: - \u0026#34;8000:8000\u0026#34; # Expose Django app on port 8000 environment: - DEBUG=1 # Set Django debug mode to 1 for development - POSTGRES_HOST=postgres # PostgreSQL host - POSTGRES_DB_NAME=nirajan # PostgreSQL database name - POSTGRES_DB_PASSWORD=nirajan@9845 # PostgreSQL database password - REDIS_URL=redis://redis:6379/0 # Redis URL depends_on: - postgres - redis volumes: - static_volume:/code/static # Volume for Django static files - media_volume:/code/media # Volume for Django media files postgres: container_name: postgres image: postgres:latest environment: POSTGRES_DB: nirajan # Database name POSTGRES_USER: nirajan # Database username POSTGRES_PASSWORD: nirajan@9845 # Database password volumes: - postgres_data:/var/lib/postgresql/data redis: container_name: redis image: redis:latest ports: - \u0026#34;6379:6379\u0026#34; Service Names as Hostnames In Docker Compose, the names of the services defined in the docker-compose.yml file are used as hostnames for inter-service communication.\nService Names as Hostnames Each service name in the docker-compose.yml file acts as a hostname for that service. For example, in the configuration above:\nThe django-app service can connect to the postgres service using POSTGRES_HOST=postgres. The django-app service can connect to the redis service using REDIS_URL=redis://redis:6379/0. Example In the django-app service:\nPostgreSQL Host: POSTGRES_HOST=postgres — The Django app connects to the PostgreSQL service using the hostname postgres, which matches the name of the PostgreSQL service defined in Docker Compose. Redis Host: REDIS_URL=redis://redis:6379/0 — The Django app connects to the Redis service using the hostname redis, which matches the name of the Redis service defined in Docker Compose. Note: In Docker, services within a Docker Compose setup are typically connected to the same network by default. This allows containers to communicate with each other using service names as hostnames.\nDocker Compose Commands To start the containers defined in docker-compose.yml:\nsudo docker compose up To stop and remove all containers, networks, and volumes created by docker-compose up:\nsudo docker compose down To run the containers in the background (detached mode):\nsudo docker compose up -d Tips Use depends_on to specify dependencies between services. This ensures that the dependent services start in the correct order. Use volumes to persist data outside of your containers, which is especially useful for databases. Use environment variables to configure your services and avoid hardcoding sensitive information. Conclusion Docker Compose simplifies the process of managing multi-container Docker applications. By defining your services in a docker-compose.yml file, you can easily spin up your entire application stack with a single command. This guide provides a solid starting point for using Docker Compose to manage multi-container applications effectively.\n","permalink":"http://localhost:1313/posts/pages/docker/docker_compose/","summary":"Learn how to define and manage services in Docker Compose.","title":"Docker Compose Documentation"},{"content":"Docker CPU and Memory Limits When you want to control the CPU and memory usage of Docker containers, you can use specific options in both Docker CLI commands and Docker Compose files. Here\u0026rsquo;s a detailed guide on how to use these options:\nDocker CLI Commands Setting CPU Limits:\nOption: --cpus Usage: Specifies the number of CPUs that the container can use. Example: docker run --cpus=\u0026#34;1.5\u0026#34; my-image The --cpus option limits the container to 1.5 CPU cores. Setting Memory Limits:\nOption: --memory or -m\nUsage: Sets the maximum amount of memory the container can use.\nExample:\ndocker run --memory=\u0026#34;500m\u0026#34; my-image This command limits the container to 500MB of RAM. If the limit is exceeded, the container will be throttled or terminated.\nNote: The options take a positive integer followed by suffixes such as b, k, m, or g to indicate bytes, kilobytes, megabytes, or gigabytes.\nSoft Memory Limits:\nOption: --memory-reservation Example: docker run --memory=\u0026#34;1g\u0026#34; --memory-reservation=\u0026#34;512m\u0026#34; nginx This reserves 512MB of memory while setting a hard limit of 1GB. Docker Compose Configuration In Docker Compose, you can define resource limits under the deploy section for version 3.x or directly under the services section for version 2.x.\nSetting CPU and Memory Limits in Docker Compose (Version 2.x):\nversion: \u0026#39;2\u0026#39; services: my-service: image: my-image deploy: resources: limits: cpus: \u0026#39;1.5\u0026#39; memory: 500M This limits the service to 1.5 CPUs and 500MB of memory.\nSetting CPU and Memory Limits in Docker Compose (Version 3.x and above):\nversion: \u0026#39;3.8\u0026#39; services: my-service: image: my-image deploy: resources: limits: cpus: \u0026#39;1.5\u0026#39; memory: \u0026#39;500M\u0026#39; This limits the service to 1.5 CPUs and 500MB of memory.\nNotes: Swap Memory: You can enable swap memory using the --memory-swap option in CLI. For example:\ndocker run --memory=\u0026#34;512m\u0026#34; --memory-swap=\u0026#34;1g\u0026#34; nginx CPU Shares: Set CPU priorities between containers using --cpu-shares, with 1024 being the default.\nBy using these options, you can ensure that your Docker containers use resources efficiently, preventing them from overwhelming the host machine.\n","permalink":"http://localhost:1313/posts/pages/docker/docker_cpu_memory_limits_guide/","summary":"Control the CPU and memory usage of Docker containers with CLI and Docker Compose configurations.","title":"Docker CPU and Memory Limits"},{"content":"Docker Networking and Port Access In Docker, containers are isolated by default, meaning:\nContainers cannot access the host machine\u0026rsquo;s ports directly. Containers cannot access the ports of other containers directly. Container ports are not accessible from outside the host machine unless configured. 🛠️ Accessing Container Ports from Outside To access a container\u0026rsquo;s port from outside (e.g., from the host or another machine), you can use port mapping:\n1. Port Mapping docker run -p host_port:container_port imagename This command maps a container\u0026rsquo;s port to a port on the host machine. 2. Host Network To share the host\u0026rsquo;s network namespace with the container:\ndocker run --network host imagename 🌐 Accessing Container Ports from Another Container To allow inter-container communication, you need to create and use a custom Docker network.\nSteps: 1. Create a Docker Network docker network create my_network 2. Run Containers in the Same Network docker run --network my_network --name container1 imagename docker run --network my_network --name container2 imagename 3. Access One Container from Another Use the container name and port to access one container from another:\ncontainer1:port Example Scenario Create a Network docker network create my_network Run First Container docker run --network my_network --name webserver -d nginx Run Second Container docker run --network my_network --name client -it alpine /bin/sh Access Web Server from Client Inside the client container, use the following commands to access the web server: wget -qO- http://webserver or\ncurl http://webserver 📝 Important Notes Container-to-Container Access: Containers in the same custom network can communicate using their names as hostnames. Host Machine Access: Containers cannot directly access the host machine\u0026rsquo;s ports. External Access: Use port mapping or host networking to access container ports from outside the host machine. List Docker Networks To list all available Docker networks and verify the existence of custom networks:\ndocker network ls ","permalink":"http://localhost:1313/posts/pages/docker/docker_networking_guide/","summary":"Understanding Docker networking and inter-container communication.","title":"Docker Networking and Port Access"},{"content":" 1. Configure Git To set up your Git username and email globally on your machine:\ngit config --global user.name \u0026#34;username\u0026#34; # Set your Git username git config --global user.email \u0026#34;email\u0026#34; # Set your Git email git config --list # Display the current Git configuration (username and email) 2. Git Status and Git Clone Clone a remote repository to your local machine:\ngit clone \u0026lt;url\u0026gt; # Copy repository to the local machine Check the status of your local repository:\ngit status # Show the current status of the repository Git Status Breakdown: untracked: A new file that has not been added or committed. unstaged: A file that has been added but not committed. unchanged: No changes have been made. changed: Changes have been made but not yet added or committed. 3. Git Add and Commit Add specific files or all changes and commit them:\ngit add \u0026lt;filename\u0026gt; # Add a specific file to the staging area git add . # Add all changes (modified and untracked files) git commit -m \u0026#34;Your commit message\u0026#34; # Commit the changes with a message 4. Push Local Repo to Remote To upload your local repository changes to the remote repository:\ngit push [alias] [branch] # Push changes to a specific alias and branch git remote add \u0026lt;alias\u0026gt; \u0026lt;url\u0026gt; # Add a remote alias (e.g., \u0026#39;origin\u0026#39;) git push -u [alias] [branch] # Save the alias and branch for future pushes 5. Git Initialization Initialize a new Git repository:\ngit init # Initialize a new Git repository 6. Git Branches Manage Git branches with the following commands:\ngit branch # List all local branches git branch -m \u0026lt;oldbranch\u0026gt; \u0026lt;newbranch\u0026gt; # Rename a branch git checkout \u0026lt;branchname\u0026gt; # Switch to another branch git checkout -b \u0026lt;branchname\u0026gt; # Create and switch to a new branch git branch -d \u0026lt;branchname\u0026gt; # Delete a branch (ensure you\u0026#39;re not on it) git diff \u0026lt;branchname\u0026gt; # Compare the current branch with another 7. Git Merge Merge changes from one branch into another:\ngit merge \u0026lt;branchname\u0026gt; # Merge changes from \u0026lt;branchname\u0026gt; into the current branch 8. Pull Request and Syncing Changes To pull updates from the remote repository to your local one:\ngit pull # Pull the latest changes from the remote repository git pull [alias] [branch] # Pull changes from a specific alias and branch 9. Undoing Changes If You Have Only Added Changes: git reset \u0026lt;filename\u0026gt; # Unstage a file from the staging area git reset # Unstage all files that have been added If You Have Committed Changes: git reset HEAD~1 # Undo the last commit (one step back) git reset \u0026lt;commit_hash\u0026gt; # Reset to a specific commit hash git reset --hard \u0026lt;commit_hash\u0026gt; # Hard reset to a commit and reflect changes in your editor git log # View all commit hashes and logs 10. Forking Repositories When contributing to open-source projects, you can fork a repository, which creates a copy of the repo under your GitHub account. Afterward, you can make changes and submit a pull request:\n# Fork a repository on GitHub and clone it locally git clone \u0026lt;forked_repo_url\u0026gt; # Clone your forked repository Make changes, commit them, and push to your fork. Finally, create a pull request on GitHub to merge your changes into the original repository.\nIF ANY CONCEPT IS LAGGING THEN: Watch this helpful video\n","permalink":"http://localhost:1313/posts/pages/git/git-cheetsheet/","summary":"A brief tutorial on github recipe and git command","title":"Git Commands and Configuration Guide"},{"content":"How to Create Content for Hugo Using Markdown Hugo, a static site generator, uses Markdown (.md) files to generate content. In this guide, we will explain how you can create content for Hugo using Markdown.\n1. Front Matter Every Markdown file in Hugo requires front matter, which is metadata placed at the top of the file. It helps Hugo understand how to process the file.\nExample:\n--- title: \u0026#34;My First Hugo Post\u0026#34; date: 2024-10-18 tags: [\u0026#34;Hugo\u0026#34;, \u0026#34;Markdown\u0026#34;] summary: \u0026#34;A brief summary of the post.\u0026#34; --- 2. Headers Headers are used to organize content. Use one # for an H1 header, two ## for H2, and so on.\nExample:\n# H1 Header ## H2 Header ### H3 Header Output:\nH3 Header 3. Text Formatting Markdown supports several text formatting options:\nExample:\n**Bold Text** *Italic Text* ~~Strikethrough~~ Output: Bold Text\nItalic Text\nStrikethrough\n4. Spacing and Line Breaks In Markdown, you can create paragraphs by leaving a blank line between lines of text.\nExample:\nThis is the first paragraph. This is the second paragraph. Output: This is the first paragraph.\nThis is the second paragraph.\n5. Horizontal Rules You can create horizontal lines (dividers) using three or more dashes (---), asterisks (***), or underscores (___).\nExample:\n--- Output:\n6. Lists Create unordered lists with - or *, and ordered lists with numbers followed by periods.\nExample:\n- Item 1 - Item 2 1. First item 2. Second item Output:\nItem 1 Item 2 First item Second item 7. Links and Images Add links and images with square brackets [] and parentheses ().\nExample:\n[Hugo Documentation](https://gohugo.io) ![Hugo Logo](/images/hugo.webp) Output: Hugo Documentation\n8. Code Blocks For inline code, use backticks. For block code, use triple backticks.\nExample:\nInline code: `print(\u0026#34;Hello World\u0026#34;)` Output: Inline code: print(\u0026quot;Hello World\u0026quot;)\nExample:\nBlock Code: def hello(): print(\u0026#34;Hello, Hugo!\u0026#34;) def hello(): print(\u0026#34;Hello, Hugo!\u0026#34;) 9. Blockquotes Use the greater than symbol (\u0026gt;) to create blockquotes.\nExample:\n\u0026gt; This is a blockquote in Hugo. Output:\nThis is a blockquote in Hugo.\n10. Tables You can create tables using pipes | and dashes -.\nExample:\n| Column 1 | Column 2 | |----------|----------| | Row 1 | Data 1 | | Row 2 | Data 2 | Output:\nColumn 1 Column 2 Row 1 Data 1 Row 2 Data 2 11. Task Lists Create task lists by using square brackets []. An x in the brackets [x] marks a task as completed.\nExample:\n- [ ] Task 1 - [x] Task 2 (Completed) Output:\nTask 1 Task 2 (Completed) 12. Syntax Highlighting Hugo supports syntax highlighting for various programming languages. You can specify the language after the triple backticks(```).\nExample: Output:\ndef greet(): print(\u0026#34;Hello, Hugo!\u0026#34;) 12. Task Lists Create task lists by using square brackets []. An x in the brackets [x] marks a task as completed.\nExample:\n- [ ] Task 1 - [ ] Sub-task 1 - [x] Sub-task 2 (Completed) - [x] Task 2 (Completed) Output:\nTask 1 Sub-task 1 Sub-task 2 (Completed) Task 2 (Completed) 13. Escaping Special Characters To use special characters like #, escape them using a backslash \\.\nExample:\n\\# This is not a header Output: # This is not a header\n14. Backtick To display backtick use four space before it as\n``` 15. Consistency It\u0026rsquo;s important to maintain consistent formatting throughout your Markdown files to ensure a clean and readable structure.\nBy following these steps, you can effectively create well-formatted content for your Hugo site using Markdown.\n","permalink":"http://localhost:1313/posts/pages/hugo/markdown_hugo_content_guide/","summary":"A tutorial on creating content with Markdown in Hugo.","title":"How to Create Content for Hugo"},{"content":"JavaScript Reference Behavior: Objects and Arrays Introduction In JavaScript, both objects and arrays are considered reference types. This means that when you assign an object or an array to another variable, you’re not creating a new copy of that object or array. Instead, the new variable holds a reference to the original object or array in memory. Understanding this concept is crucial because it directly affects how data is manipulated and shared within your code.\nObject Reference Behavior 1. Overview When you work with objects in JavaScript, it\u0026rsquo;s essential to recognize that assigning an object to a new variable does not create a new object. Instead, it creates a reference to the original object. This means that any changes made through the new reference will affect the original object.\n2. Example const person = { name: \u0026#34;Alice\u0026#34;, address: { city: \u0026#34;Wonderland\u0026#34; } }; const newPerson = person.address; // newPerson now references the same object as person.address newPerson.city = \u0026#34;New Wonderland\u0026#34;; // modifying newPerson affects the original object console.log(person); // Output: { name: \u0026#39;Alice\u0026#39;, address: { city: \u0026#39;New Wonderland\u0026#39; } } ## JavaScript Reference Behavior: Objects and Arrays ### Introduction In JavaScript, both objects and arrays are considered reference types. This means that when you assign an object or an array to another variable, you’re not creating a new copy of that object or array. Instead, the new variable holds a reference to the original object or array in memory. Understanding this concept is crucial because it directly affects how data is manipulated and shared within your code. ### Object Reference Behavior #### 1. Overview When you work with objects in JavaScript, it\u0026#39;s essential to recognize that assigning an object to a new variable does not create a new object. Instead, it creates a reference to the original object. This means that any changes made through the new reference will affect the original object. #### 2. Example ```javascript const person = { name: \u0026#34;Alice\u0026#34;, address: { city: \u0026#34;Wonderland\u0026#34; } }; const newPerson = person.address; // newPerson now references the same object as person.address newPerson.city = \u0026#34;New Wonderland\u0026#34;; // modifying newPerson affects the original object console.log(person); // Output: { name: \u0026#39;Alice\u0026#39;, address: { city: \u0026#39;New Wonderland\u0026#39; } } 3. Explanation Object Reference: When you create const newPerson = person.address;, you\u0026rsquo;re not making a copy of the address object. Instead, newPerson references the same address object that person.address references. Thus, when you update newPerson.city = \u0026quot;New Wonderland\u0026quot;;, it directly modifies the person.address object because both newPerson and person.address are pointing to the same location in memory. Output: The console logs the person object, which now reflects the change: { name: 'Alice', address: { city: 'New Wonderland' } }. Array Reference Behavior 1. Overview Arrays in JavaScript behave similarly to objects in terms of reference handling. When you assign an array to another variable, you create a reference to the original array. As a result, any modifications through this reference will affect the original array.\n2. Example const numbers = [1, 2, 3]; const moreNumbers = numbers; // moreNumbers now references the same array as numbers moreNumbers[0] = 99; // modifying moreNumbers affects the original array console.log(numbers); // Output: [99, 2, 3] 3. Explanation Array Reference: When you create const moreNumbers = numbers;, you\u0026rsquo;re not creating a new array. Instead, moreNumbers becomes a reference to the same array that numbers references. Any changes to moreNumbers, such as moreNumbers[0] = 99, directly modify the numbers array because both variables point to the same array in memory. Output: The console logs the numbers array, which now reflects the change: [99, 2, 3]. Key Takeaways Reference Types: Both objects and arrays are reference types in JavaScript, meaning that variables assigned to them hold references to the same data in memory. Shared Modifications: Changes made to an object or array through one reference will affect all other references to that same object or array. Memory Efficiency: This reference behavior allows for memory-efficient data management but requires careful handling to avoid unintended side effects. JavaScript References with filter() and find() In JavaScript, the way references work with methods like filter() and find() is different, leading to distinct behaviors. Understanding these differences is crucial for working effectively with arrays and avoiding unintended side effects.\nfilter(): Creating a New Array 1. Overview The filter() method in JavaScript creates a new array that contains only the elements that satisfy the provided condition. This means that a new array is returned, and it does not affect the original array. However, if the elements in the array are objects, the references to these objects are retained, meaning any modifications to the objects in the new array will also affect the original array.\n2. Example const originalArray = [ { id: 1, name: \u0026#34;Alice\u0026#34; }, { id: 2, name: \u0026#34;Bob\u0026#34; }, { id: 3, name: \u0026#34;Charlie\u0026#34; } ]; const filteredArray = originalArray.filter(item =\u0026gt; item.id !== 2); // Modify an object in the filtered array filteredArray[0].name = \u0026#34;Alicia\u0026#34;; console.log(originalArray); // Output: [{ id: 1, name: \u0026#39;Alicia\u0026#39; }, { id: 2, name: \u0026#39;Bob\u0026#39; }, { id: 3, name: \u0026#39;Charlie\u0026#39; }] console.log(filteredArray); // Output: [{ id: 1, name: \u0026#39;Alicia\u0026#39; }, { id: 3, name: \u0026#39;Charlie\u0026#39; }] 3. Explanation New Array Creation: The filter() method creates a new array (filteredArray) that includes all elements from originalArray except the one with id 2. However, the objects within the new array are still references to the original objects in originalArray. Shared References: When you modify the name property of the first object in filteredArray (filteredArray[0].name = \u0026quot;Alicia\u0026quot;;), it also changes in originalArray because both arrays reference the same object in memory. Output: The original array shows that the name of the first object has been changed to \u0026ldquo;Alicia\u0026rdquo;, indicating that the object references are shared. find(): Returning a Single Element Reference 1. Overview The find() method returns the first element in the array that satisfies the provided condition. This element is not a copy but a reference to the original element in the array. As a result, any modification to this element directly affects the original array.\n2. Example const originalArray = [ { id: 1, name: \u0026#34;Alice\u0026#34; }, { id: 2, name: \u0026#34;Bob\u0026#34; }, { id: 3, name: \u0026#34;Charlie\u0026#34; } ]; const foundItem = originalArray.find(item =\u0026gt; item.id === 2); // Modify the found item foundItem.name = \u0026#34;Robert\u0026#34;; console.log(originalArray); // Output: [{ id: 1, name: \u0026#39;Alice\u0026#39; }, { id: 2, name: \u0026#39;Robert\u0026#39; }, { id: 3, name: \u0026#39;Charlie\u0026#39; }] console.log(foundItem); // Output: { id: 2, name: \u0026#39;Robert\u0026#39; } 3. Explanation Element Reference: The find() method returns a reference to the first element that meets the condition (item.id === 2). In this case, foundItem references the same object in memory as the element in originalArray with id: 2. Direct Modification: When you modify the name property of foundItem (foundItem.name = \u0026quot;Robert\u0026quot;;), it directly alters the corresponding object in originalArray because they are the same object in memory. Output: The original array now shows that the name of the object with id: 2 has been changed to \u0026ldquo;Robert\u0026rdquo;, demonstrating that the reference was modified. Key Differences Between filter() and find() New Array vs. Single Element: filter(): Returns a new array containing references to elements that meet the condition. find(): Returns a reference to the first element that meets the condition. Impact on Original Array: filter(): The original array remains unchanged, but the objects within the new array are still references to the original objects. find(): The original array can be directly modified through the returned element. Use Cases: Use filter() when you need a subset of the original array without altering it directly. Use find() when you need to retrieve and possibly modify a specific element from the array. Conclusion Understanding how references work with methods like filter() and find() is crucial in JavaScript. While filter() returns a new array that retains references to the original objects, find() returns a direct reference to a single element. Being aware of these behaviors helps prevent unintended modifications to your data.\n","permalink":"http://localhost:1313/posts/pages/js/referencebehavious/","summary":"Learn about reference types in JavaScript, including objects and arrays, and how methods like filter() and find() handle references.","title":"JavaScript Reference Behavior: Objects and Arrays"},{"content":"JavaScript Reference Guide 1. Console.log() Method Purpose: Prints output to the console, useful for debugging. Syntax: console.log(value); Example: const name = \u0026#39;John\u0026#39;; console.log(name); // Output: John 2. Variables: let, const let: Block-scoped variable that can be updated but not accessed before declaration.\nlet x = 10; if (true) { let x = 20; // Block-scoped console.log(x); // 20 } console.log(x); // 10 const: Block-scoped variable that cannot be reassigned and must be initialized when declared.\nconst pi = 3.14; // pi = 3.1415; // Error: Cannot reassign 3. JavaScript Data Types String\nExplanation: Represents a sequence of characters. Can be enclosed in single quotes, double quotes, or backticks (for template literals). Syntax: const str = 'Hello, World!'; Example: const greeting = \u0026#34;Hello, \u0026#34; + \u0026#34;World!\u0026#34;; // Output: Hello, World! Number\nExplanation: Represents both integer and floating-point numbers. JavaScript numbers range from -(2^53 - 1) to 2^53 - 1. Syntax: const num = 123; Example: const amount = 25; // Output: 25 BigInt\nExplanation: Represents integers with arbitrary precision. Denoted by appending an n to the end of the number. Syntax: const bigNum = 1234567890123456789012345678901234567890n; Example: const bigNumber = 1234567890123456789012345678901234567890n; Boolean\nExplanation: Represents a value that is either true or false. Syntax: const isTrue = true; Example: const isActive = Boolean(1); // Output: true Null\nExplanation: Represents the intentional absence of any value. Syntax: const emptyValue = null; Example: const noValue = null; Undefined\nExplanation: Represents a variable that has been declared but not assigned a value. Syntax: let uninitialized; Example: let value; console.log(value); // Output: undefined For Checking Data Type We Use: typeof variableName; 4. Explicit Type Conversion To String: String(value) or value.toString()\nlet str = String(123); // \u0026#39;123\u0026#39; To Number: Number(value), parseInt(value), or parseFloat(value)\nlet num = Number(\u0026#39;456\u0026#39;); // 456 To Boolean: Boolean(value)\nlet bool = Boolean(\u0026#39;hello\u0026#39;); // true 5. JavaScript Operators i) Comparison Operators Greater than: a \u0026gt; b Less than: a \u0026lt; b Greater than or equal to: a \u0026gt;= b Less than or equal to: a \u0026lt;= b Not equal to: a != b Equal to: a == b Strictly equal to: a === b Examples:\nconsole.log(\u0026#34;2\u0026#34; == 2); // true console.log(\u0026#34;2\u0026#34; === 2); // false ii) Logical Operators AND: operand1 \u0026amp;\u0026amp; operand2 OR: operand1 || operand2 NOT: !operand Examples:\nconsole.log(true \u0026amp;\u0026amp; false); // false console.log(true || false); // true console.log(!true); // false iii) Arithmetic Operators Addition: operand1 + operand2 Subtraction: operand1 - operand2 Multiplication: operand1 * operand2 Division: operand1 / operand2 Modulo: operand1 % operand2 Increment: operand++ Decrement: operand-- Examples:\nconsole.log(5 + 3); // 8 console.log(5 - 3); // 2 console.log(5 * 3); // 15 console.log(6 / 3); // 2 console.log(5 % 3); // 2 6. String Methods and Operations 1. Concatenation Explanation: Combines two or more strings into one. Syntax: string1 + string2 Returns: A new string combining the original strings. Example: let a = \u0026#39; My name is nirajan \u0026#39;; let b = \u0026#34;nirajan\u0026#34;; console.log(a + b + \u0026#34;Khatiwada\u0026#34;); // Output: \u0026#39; My name is nirajan nirajanKhatiwada\u0026#39; 2. Simple Form (String Boilerplate) Explanation: Uses template literals to embed expressions within a string. Syntax: ${expression} Returns: A new string with evaluated expressions. Example: let a = \u0026#39; My name is nirajan \u0026#39;; let b = \u0026#34;nirajan\u0026#34;; console.log(`${a}${b}khatiwada`); // Output: \u0026#39; My name is nirajan nirajankhatiwada\u0026#39; 3. Accessing Element of String Explanation: Retrieves the character at a specified index. Syntax: string[index] Returns: The character at the given index (or undefined if out of range). Example: let a = \u0026#39; My name is nirajan \u0026#39;; console.log(a[0]); // Output: \u0026#39; \u0026#39; 4. Finding Length of String Explanation: Gets the number of characters in the string. Syntax: string.length Returns: The length of the string as a number. Example: let a = \u0026#39; My name is nirajan \u0026#39;; console.log(a.length); // Output: 21 5. To Uppercase Explanation: Converts all characters in the string to uppercase. Syntax: string.toUpperCase() Returns: A new string with all characters in uppercase. Example: let a = \u0026#39; My name is nirajan \u0026#39;; console.log(a.toUpperCase()); // Output: \u0026#39; MY NAME IS NIRAJAN \u0026#39; 6. To Lowercase Explanation: Converts all characters in the string to lowercase. Syntax: string.toLowerCase() Returns: A new string with all characters in lowercase. Example: let a = \u0026#39; My name is nirajan \u0026#39;; console.log(a.toLowerCase()); // Output: \u0026#39; my name is nirajan \u0026#39; 8. String Slicing Explanation: Extracts a section of the string based on start and end indices. Syntax: string.slice(start, end) Returns: A new string containing the extracted section. Example: let a = \u0026#39; My name is nirajan \u0026#39;; console.log(a.slice(0, 4)); // Output: \u0026#39; My\u0026#39; 9. Trim Explanation: Removes whitespace from both ends of the string. Syntax: string.trim() Returns: A new string with whitespace removed from both ends. Example: let a = \u0026#39; My name is nirajan \u0026#39;; console.log(a.trim()); // Output: \u0026#39;My name is nirajan\u0026#39; 10. Replace Explanation: Replaces the first occurrence of a specified substring or pattern with a new substring. Syntax: string.replace(search, replacement) Returns: A new string with the specified substring replaced. Example: let a = \u0026#39; My name is nirajan \u0026#39;; console.log(a.replace(\u0026#34;nirajan\u0026#34;, \u0026#34;kirajan\u0026#34;)); // Output: \u0026#39; My name is kirajan \u0026#39; 11. Split Explanation: Splits the string into an array of substrings based on a separator. Syntax: string.split(separator, limit) Returns: An array of substrings. Example: let a = \u0026#39; My name is nirajan \u0026#39;; console.log(a.split(\u0026#34; \u0026#34;)); // Output: [\u0026#39; My\u0026#39;, \u0026#39;name\u0026#39;, \u0026#39;is\u0026#39;, \u0026#39;nirajan\u0026#39;] 7. Number Methods 1. toFixed() Explanation: Formats a number using fixed-point notation with a specified number of decimal places. Syntax: number.toFixed(digits); Returns: A string representing the number with the specified number of decimal places. Example: let c = 10.001; console.log(c.toFixed(10)); // Output: \u0026#39;10.0010000000\u0026#39; 2. Math.ceil() Explanation: Rounds a number up to the nearest integer. Syntax: Math.ceil(number); Returns: The smallest integer greater than or equal to the given number. Example: let a = 1.1000; console.log(Math.ceil(a)); // Output: 2 3. Math.floor() Explanation: Rounds a number down to the nearest integer. Syntax: Math.floor(number); Returns: The largest integer less than or equal to the given number. Example: console.log(Math.floor(a)); // Output: 1 4. Math.round() Explanation: Rounds a number to the nearest integer. Syntax: Math.round(number); Returns: The value of the number rounded to the nearest integer. Example: console.log(Math.round(a)); // Output: 1 5. Math.random() Explanation: Returns a pseudo-random floating-point number between 0 (inclusive) and 1 (exclusive). Syntax: Math.random(); Returns: A floating-point number between 0 (inclusive) and 1 (exclusive). Example: console.log(Math.random()); // Output: A random number between 0 and 1 8. Non-Primitive Data Types in JavaScript 1. Object Explanation: Objects are collections of key-value pairs. Keys are usually strings (or symbols) and values can be any data type. Syntax: let objectName = { key1: value1, key2: value2, // more key-value pairs }; Example: let data = { \u0026#34;name\u0026#34;: \u0026#34;nirajan\u0026#34;, \u0026#34;age\u0026#34;: 20 }; 2. Array Explanation: Arrays are ordered collections of values. Values can be of any data type and are accessed by their index. Syntax: let arrayName = [value1, value2, value3, ...]; Example: let a = [\u0026#34;nirajan\u0026#34;, \u0026#34;kirajan\u0026#34;, \u0026#34;birajan\u0026#34;]; 3. Function Explanation: Functions are blocks of code designed to perform a particular task. They can be invoked (called) to execute their code. Syntax: function functionName(parameters) { // code to be executed } Example: function outer() { console.log(\u0026#34;hi\u0026#34;); } outer(); // Output: hi 9. Array Methods 1. Indexing in Array Accessing Elements: Description: Arrays are zero-indexed, so the first element is at index 0. Returns: Value of the element at the specified index. Example: console.log(a[0]); // Output: 1 console.log(a[3]); // Output: 4 2. Slicing in Array Slicing: Description: Extracts a section of the array and returns it as a new array. Syntax: array.slice(startIndex, endIndex) Returns: A new array containing the elements from startIndex up to, but not including, endIndex. Example: console.log(a.slice(0, 2)); // Output: [1, 2] 3. Length of Array Description: Returns the number of elements in the array. Returns: Integer (length of the array). Example: console.log(a.length); // Output: 4 4. Push Description: Adds one or more elements to the end of the array. Returns: The new length of the array. Example: a.push(5); console.log(a); // Output: [1, 2, 3, 4, 5] 5. Pop Description: Removes the last element from the array. Returns: The removed element. Example: a.pop(); console.log(a); // Output: [1, 2, 3, 4] 6. Shift Description: Removes the first element from the array. Returns: The removed element. Example: a.shift(); console.log(a); // Output: [2, 3, 4] 7. Unshift Description: Adds one or more elements to the beginning of the array. Returns: The new length of the array. Example: a.unshift(0); console.log(a); // Output: [0, 1, 2, 3, 4] 8. Join Description: Joins all elements of an array into a string, separated by a specified separator. Returns: A string representing the array elements joined by the specified separator. Example: let data = a.join(\u0026#34; \u0026#34;); console.log(data); // Output: \u0026#34;1 2 3 4\u0026#34; 9. Concatenation of Two Arrays Description: Merges two or more arrays into one. Returns: A new array containing the elements of the original arrays. Example: let a2 = [5, 4, 1, 3, 4]; console.log(a.concat(a2)); // Output: [1, 2, 3, 4, 5, 4, 1, 3, 4] 10. Sort Description: Sorts the elements of an array in place. Returns: The sorted array. Example: a2.sort(); console.log(a2); // Output: [1, 3, 4, 4, 5] 11. Reverse Description: Reverses the order of the elements in the array. Returns: The reversed array. Example: a2.reverse(); console.log(a2); // Output: [5, 4, 4, 3, 1] 12. Removing Elements from a Specific Position Description: Changes the contents of an array by removing or replacing existing elements. Syntax: array.splice(index, numberOfElementsToRemove) Returns: An array containing the removed elements. Example: let newData = [1, 2, 3, 4]; newData.splice(1, 2); // Removes 2 elements starting at index 1 console.log(newData); // Output: [1, 4] 13. Inserting Elements at a Specific Position Description: Inserts elements into the array. Syntax: array.splice(index, 0, element1, element2, ...) Returns: An array containing the removed elements (empty if no elements were removed). Example: let lasrData = [1, 4]; lasrData.splice(1, 0, 2, 3); // Inserts elements 2 and 3 at index 1 console.log(lasrData); // Output: [1, 2, 3, 4] 14. Spread Operator (\u0026hellip;) Description: Spreads out elements of an array into another array or function arguments. Returns: A new array containing the elements spread from the original arrays. Example: let finalData = [...newData, ...lasrData]; console.log(finalData); // Output: [1, 4, 1, 2, 3, 4] 15. Array Destructuring Description: Allows unpacking values from arrays into distinct variables in a concise and readable way. Basic Syntax: const [var1, var2, var3] = array; Example: const numbers = [1, 2, 3]; const [first, second, third] = numbers; console.log(first); // Output: 1 console.log(second); // Output: 2 console.log(third); // Output: 3 10. Object in Js i. Defining an Object An object in JavaScript is a collection of key-value pairs. Each key (also known as a property) is a unique identifier, and the value can be anything: a string, number, array, function, or even another object. Example:\nconst myObject = { name: \u0026#34;Nirajan\u0026#34;, // String property class: \u0026#34;Bachelor\u0026#34;, // String property is_topper: \u0026#34;No\u0026#34;, // Boolean property (as a string) greet: function (from) { // Method (function inside an object) console.log(`Welcome ${this.name}. From ${from}`); } }; ii. Accessing There are two common ways to access properties in an object:\nDot Notation: console.log(myObject.name); // Output: nirajan This is the most common and preferred method when you know the property name in advance. Bracket Notation: console.log(myObject[\u0026#39;name\u0026#39;]); // Output: nirajan Bracket notation is useful when the property name is stored in a variable or when it contains special characters or spaces. iii. Modifying Object Properties You can modify an object\u0026rsquo;s properties using dot or bracket notation:\nDot Notation: Use when you know the property name.\nmyObject.name = \u0026#34;Kirajan\u0026#34;; // Modifies the \u0026#39;name\u0026#39; property Bracket Notation: Use when the property name is dynamic or contains special characters.\nmyObject[\u0026#39;class\u0026#39;] = \u0026#34;Master\u0026#39;s\u0026#34;; // Modifies the \u0026#39;class\u0026#39; property iv. Adding New Properties You can dynamically add new key-value pairs to an object.\nmyObject.lol = \u0026#34;lol\u0026#34;; console.log(myObject.lol); // Output: lol v. Using the this Keyword The this keyword inside an object’s method refers to the object itself, allowing you to access its properties. Example:\nconst person = { name: \u0026#34;Kirajan\u0026#34;, greet: function() { console.log(`Hello, my name is ${this.name}`); } }; person.greet(); // Output: Hello, my name is Kirajan vi. Objects Inside Objects Objects can contain other objects, allowing you to create complex data structures. Example:\nconst a = { details: { name: \u0026#34;Nirajan\u0026#34;, age: 20 } }; console.log(a.details.name); // Output: Nirajan vii. Spread Operator (\u0026hellip;) The spread operator lets you copy, merge, or combine objects efficiently.\nCopying Properties: const original = { name: \u0026#34;Kirajan\u0026#34;, class: \u0026#34;Bachelor\u0026#34; }; const copy = { ...original }; console.log(copy); // Output: { name: \u0026#34;Kirajan\u0026#34;, class: \u0026#34;Bachelor\u0026#34; } Merging Objects: const info1 = { name: \u0026#34;Kirajan\u0026#34;, class: \u0026#34;Bachelor\u0026#34; }; const info2 = { age: 21, is_topper: true }; const combined = { ...info1, ...info2 }; console.log(combined); // Output: { name: \u0026#34;Kirajan\u0026#34;, class: \u0026#34;Bachelor\u0026#34;, age: 21, is_topper: true } viii. Object Destructuring Destructuring allows you to extract properties from an object and assign them to variables. Example:\nconst lol = { name: \u0026#34;Nirajan\u0026#34;, class: 12, rollno: \u0026#34;11\u0026#34; }; const { name, rollno } = lol; console.log(name); // Output: Nirajan console.log(rollno); // Output: 11 Also, Renaming in Destructuring: const lol = { name: \u0026#34;Nirajan\u0026#34;, class: 12, rollno: \u0026#34;11\u0026#34; }; const { name: studentName, rollno: studentRollNo } = lol; console.log(studentName); // Output: Nirajan console.log(studentRollNo); // Output: 11 ix. Object Methods Objects can have methods—functions that are properties of the object. These methods can perform actions using the object’s data. Example:\nconst calculator = { add: function(a, b) { return a + b; }, subtract: function(a, b) { return a - b; } }; console.log(calculator.add(5, 3)); // Output: 8 console.log(calculator.subtract(5, 3)); // Output: 2 11. JavaScript Functions Function Definitions: Function Expression: const add1 = function(a, b) { return a + b; }; Creates a function and assigns it to a variable. You call the function using the variable name. Arrow Function: const add2 = (a, b) =\u0026gt; { return a + b; }; Provides a shorter syntax and does not have its own this context. Function Declaration: function add3(a, b) { return a + b; } Defines a function with a name. It is hoisted, so it can be called before its declaration. Comparison: add3 has its own this context, while add1 and add2 do not. Using the Spread Operator: function add(...data) { let sum = 0; for (let i = 0; i \u0026lt; data.length; i++) { sum += data[i]; } return sum; } console.log(add(1, 2, 3)); // Output: 6 The ...data syntax lets the function accept any number of arguments as an array.\nImmediately Invoked Function Expression (IIFE): ( function add(a, b) { console.log(a + b); } )(2, 3); // Output: 5 An IIFE is a function that runs immediately after its definition, creating a local scope to avoid affecting the global scope.\n12. Control Flow in JavaScript Conditional Statements: if-else Statement: Executes code blocks based on a condition. let a = 2; if (a === 1) { console.log(1); } else if (a === 2) { console.log(2); } else { console.log(\u0026#34;None\u0026#34;); } Truthy and Falsy Values: Falsy Values: Values that evaluate to false in a boolean context. console.log(Boolean(false)); // false console.log(Boolean(0)); // false console.log(Boolean(-0)); // false console.log(Boolean(0n)); // false console.log(Boolean(\u0026#34;\u0026#34;)); // false console.log(Boolean(null)); // false console.log(Boolean(undefined)); // false console.log(Boolean(NaN)); // false Truthy Values: Any value that is not falsy. console.log(Boolean(true)); // true console.log(Boolean(1)); // true console.log(Boolean(-1)); // true console.log(Boolean(\u0026#34;hello\u0026#34;)); // true console.log(Boolean(\u0026#34; \u0026#34;)); // true console.log(Boolean({})); // true console.log(Boolean([])); // true console.log(Boolean(function() {})); // true console.log(Boolean(Symbol())); // true console.log(Boolean(1n)); // true Nullish Coalescing Operator (??): Provides a default value when dealing with null or undefined. let val1 = null; let val2 = val1 ?? 10; console.log(val2); // Output: 10 Ternary Operator (?:): A shorthand for the if-else statement. let c = 10; let b = 10; let largest = (c \u0026gt; b) ? c : b; console.log(largest); // Output: 10 13. Loops in JavaScript For Loop // Syntax: for(initialization; condition; increment/decrement) { ... } for (let i = 0; i \u0026lt; 10; i++) { console.log(i); } While Loop // Syntax: while(condition) { ... } let i = 0; while (i \u0026lt; 10) { console.log(i); i++; } Do-While Loop // Syntax: do { ... } while(condition); let i = 0; do { console.log(i); i++; } while (i \u0026lt; 10); For-Of Loop Usage: Iterates over arrays and strings const array = [1, 2, 3]; for (const x of array) { console.log(x); } For-In Loop Usage: Iterates over the properties of an object, indices of an array, or characters of a string const obj = { \u0026#34;name\u0026#34;: \u0026#34;nirajan\u0026#34;, \u0026#34;lol\u0026#34;: \u0026#34;lol\u0026#34; }; const arr = [\u0026#34;nirajan\u0026#34;, \u0026#34;lol\u0026#34;]; const str = \u0026#34;mynameisnirajan\u0026#34;; for (const key in obj) { console.log(key); // Prints the keys of the object } for (const index in arr) { console.log(arr[index]); // Prints the values of the array } for (const index in str) { console.log(str[index]); // Prints the characters of the string } For-Each Loop Usage: Iterates over array elements const array = [1, 2, 3]; array.forEach((data) =\u0026gt; { console.log(data); }); Break and Continue Statements break: Exits the loop continue: Skips the current iteration and continues with the next iteration 14. Map, Filter, and Reduce in JavaScript i. filter() Purpose: Creates a new array with elements that pass a test. Example: To get all odd numbers from an array: const a = [1, 2, 3, 4, 5, 6]; const filtered = a.filter(num =\u0026gt; num % 2); // [1, 3, 5] ii. map() Method Purpose: map() creates a new array populated with the results of calling a provided function on every element in the calling array. It’s used to transform each element in the array. Example: Create an array of squares from an existing array. const a = [1, 2, 3, 4, 5, 6]; const squares = a.map((num) =\u0026gt; num * num); console.log(squares); // Output: [1, 4, 9, 16, 25, 36] Here, the function num * num is applied to each element, resulting in a new array of squared numbers. iii. reduce() Method Purpose: reduce() executes a reducer function on each element of the array, resulting in a single output value. It’s used to accumulate or combine values from the array into a single result. Example: Sum up all the numbers in the array. const a = [1, 2, 3, 4, 5, 6]; const sum = a.reduce((accumulator, currentValue) =\u0026gt; accumulator + currentValue, 0); console.log(sum); // Output: 21 Here, accumulator starts at 0 and currentValue iterates over each element, summing them up. iv. Method Chaining Purpose: You can chain filter(), map(), and other array methods together to perform multiple operations in a single, readable statement. Example: Filter out odd numbers and then square them. const a = [1, 2, 3, 4, 5, 6]; const result = a.filter((num) =\u0026gt; num % 2) .map((num) =\u0026gt; num * num); console.log(result); // Output: [1, 9, 25] Here, filter() first selects the odd numbers, and then map() squares those numbers, producing a new array with the squared values of the odd numbers. Summary filter(): Selects elements that meet a specific condition. map(): Transforms elements based on a function. reduce(): Reduces the array to a single value based on a function. Method Chaining: Combines multiple array operations in a concise and readable manner. These methods are powerful tools for processing and transforming arrays in JavaScript. 15. Importing and Exporting in JavaScript Default Export Only one default export is allowed per module. Use for the primary function, class, or object in a module. // utils.js export default function primaryFunction() { console.log(\u0026#34;This is the primary function\u0026#34;); } // main.js import primaryFunction from \u0026#39;./utils.js\u0026#39;; primaryFunction(); // Output: This is the primary function Named Export Allows multiple exports per module. Use to export multiple functions, variables, or objects. // utils.js function function1() { console.log(\u0026#34;This is function1\u0026#34;); } function function2() { console.log(\u0026#34;This is function2\u0026#34;); } export { function1, function2 }; // main.js import { function1, function2 } from \u0026#39;./utils.js\u0026#39;; function1(); // Output: This is function1 function2(); // Output: This is function2 Summary Default Export: One per module, no curly braces during import. Named Export: Multiple per module, use curly braces during import. 16. Error Handling Try-catch blocks are used to handle errors gracefully.\ntry { // Code that might throw an error let result = nonExistentFunction(); } catch (error) { // Code to handle the error console.log(\u0026#39;An error occurred:\u0026#39;, error.message); } finally { // Code that always executes console.log(\u0026#39;This always executes\u0026#39;); } // Output: // \u0026#34;An error occurred: nonExistentFunction is not defined\u0026#34; // \u0026#34;This always executes\u0026#34; 16.1. Custom Error Throwing You can throw custom errors using the throw statement.\nfunction divide(a, b) { if (b === 0) { throw new Error(\u0026#39;Division by zero is not allowed\u0026#39;); } return a / b; } try { console.log(divide(4, 2)); console.log(divide(4, 0)); } catch (error) { console.log(\u0026#39;Error:\u0026#39;, error.message); } // Output: // 2 // \u0026#34;Error: Division by zero is not allowed\u0026#34; 17. Timers setTimeout Schedules a function to be executed after a specified delay (in milliseconds).\nconst timeoutId = setTimeout(() =\u0026gt; { console.log(\u0026#39;Executed after 1 second\u0026#39;); }, 1000); setInterval Repeatedly executes a function at specified intervals (in milliseconds).\nconst intervalId = setInterval((a, b) =\u0026gt; { console.log(a); // Output: hi console.log(b); // Output: oi }, 20, \u0026#34;hi\u0026#34;, \u0026#34;oi\u0026#34;); clearInterval Stops a function from being executed repeatedly by clearing the interval.\nclearInterval(intervalId); clearTimeout Cancels a timeout previously established by setTimeout.\nclearTimeout(timeoutId); 18. Local Storage Local storage is a way to store data in the browser that persists even after the browser is closed.\nStoring Data localStorage.setItem(\u0026#39;name\u0026#39;, \u0026#39;Nirajan\u0026#39;); Retrieving Data const name = localStorage.getItem(\u0026#39;name\u0026#39;); console.log(name); // Output: Nirajan 19. JSON JSON (JavaScript Object Notation) is a lightweight data interchange format that is easy for humans to read and write and easy for machines to parse and generate.\nConverting Objects to JSON const person = { name: \u0026#39;Nirajan\u0026#39;, age: 20 }; const json = JSON.stringify(person); console.log(json); // Output: {\u0026#34;name\u0026#34;:\u0026#34;Nirajan\u0026#34;,\u0026#34;age\u0026#34;:20} Converting JSON to Objects const json = \u0026#39;{\u0026#34;name\u0026#34;:\u0026#34;Nirajan\u0026#34;,\u0026#34;age\u0026#34;:20}\u0026#39;; const person = JSON.parse(json); console.log(person.name); // Output: Nirajan 20. Fetch API Fetch is used to make HTTP requests and returns a promise that resolves to the response of the request.\nBasic Usage fetch(\u0026#39;https://api.example.com/data\u0026#39;) .then(response =\u0026gt; response.json()) .then(data =\u0026gt; console.log(data)) .catch(error =\u0026gt; console.error(\u0026#39;Error:\u0026#39;, error)); 21.Optional Chaining e optional chaining (?.) operator allows safe access to nested properties. If any part of the chain is null or undefined, the expression short-circuits and returns undefined instead of throwing an error.\nWithout Optional Chaining const person = { name: \u0026#39;Nirajan\u0026#39;, address: { city: \u0026#39;Kathmandu\u0026#39; } }; console.log(person.address.street.data); // Error: Cannot read property \u0026#39;street\u0026#39; of undefined With Optional Chaining const person = { name: \u0026#39;Nirajan\u0026#39;, address: { city: \u0026#39;Kathmandu\u0026#39; } }; console.log(person.address.street?.data); // Output: undefined 22.Object Shorthand Property Notation in JavaScript In JavaScript, object shorthand property notation allows you to create an object without explicitly specifying the key-value pairs.\nWithout Shorthand Notation const name = \u0026#39;Nirajan\u0026#39;; const age = 20; const person = { name: name, age: age }; console.log(person); // Output: { name: \u0026#39;Nirajan\u0026#39;, age: 20 } With Shorthand Notation const name = \u0026#39;Nirajan\u0026#39;; const age = 20; const person = { name, age }; console.log(person); // Output: { name: \u0026#39;Nirajan\u0026#39;, age: 20 } ","permalink":"http://localhost:1313/posts/pages/js/javascript/","summary":"A complete reference guide for JavaScript including data types, functions, DOM manipulation, and modern ES6+ features","title":"JavaScript Reference Guide"},{"content":" Linux Commands and Directories Guide Important Directories Default Web Server Root Directory\nLocation: /var/www/html\nThis is the standard location for serving web content on Apache.\nDownloads Folder\nLocation: /home/username/Downloads\nThis is where files downloaded from the internet are usually saved by default.\nDocuments Folder\nLocation: /home/username/Documents\nA common directory for storing personal documents and files.\nDesktop Folder\nLocation: /home/username/Desktop\nThis is the location for files and shortcuts displayed on your desktop screen.\nCommon Commands cd Change the current directory to another one.\nUsage: cd [directory]\nExample: cd /var/www/html changes to the web server root directory.\nls List files and directories in the current location or specified path.\nUsage: ls [options] [path]\nExample: ls -l lists files in a detailed format.\npwd Print the path of the current working directory.\nUsage: pwd\nThis command shows where you are in the filesystem.\nsudo su Switch to the superuser (root) account, allowing you to perform administrative tasks.\nUsage: sudo su\nAfter entering your password, you\u0026rsquo;ll have root access.\nsudo Execute a command with elevated privileges.\nUsage: sudo [command]\nExample: sudo apt update runs the update command as an administrator.\nmkdir Create a new directory.\nUsage: mkdir [directory name]\nExample: mkdir new_folder creates a directory named \u0026ldquo;new_folder\u0026rdquo;.\ndir List files and directories, similar to ls.\nUsage: dir [options] [path]\nThis command can be used interchangeably with ls.\nmv Move or rename files and directories.\nUsage: mv [source] [destination]\nExample: mv /home/username/Downloads/file.txt /home/username/Documents/ moves the file to a different directory.\ncp Copy files or directories.\nUsage: cp [source] [destination]\nExample: cp /home/username/Downloads/file.txt /home/username/Documents/ copies the file.\nrm Remove files or directories.\nUsage: rm [options] [file/directory]\nExample: To remove a directory and its contents, use rm -r [directory].\ntouch Create an empty file or update the timestamp of an existing file.\nUsage: touch [filename]\nExample: touch newfile.txt creates an empty file named \u0026ldquo;newfile.txt\u0026rdquo;.\ncat Display the contents of a file in the terminal.\nUsage: cat [filename]\nExample: cat file.txt shows the content of \u0026ldquo;file.txt\u0026rdquo;.\ngedit Open the Gedit text editor to edit files.\nUsage: gedit [filename]\nExample: gedit notes.txt opens \u0026ldquo;notes.txt\u0026rdquo; for editing.\nkill Terminate a process using its process ID (PID).\nUsage: kill [PID]\nExample: kill 1234 stops the process with the ID 1234.\ntop Display real-time information about system processes and resource usage.\nUsage: top\nThis command helps monitor system performance.\npkill Terminate a process by its name. Usage: pkill [process name] Example: pkill firefox stops all Firefox processes. pkill node stops all Node.js processes. nohup Run a command immune to hangups (HUP) and continue running even after the terminal is closed. Usage: nohup [command] \u0026amp; Example: nohup python script.py \u0026amp; runs the Python script in the background.\napt-get update Update the package lists for upgrades and new package installations.\nUsage: apt-get update\nThis command fetches the latest package information.\napt install path_of_.deb_file Install a .deb file package.\nUsage: apt install ./filename.deb\nExample: apt install ./main.deb installs the specified Debian package.\napt-get upgrade Upgrade all installed packages to their latest versions.\nUsage: apt-get upgrade\nThis command updates your installed software.\napt-get install package Install a specific software package.\nUsage: apt-get install [package]\nExample: apt-get install vim installs the Vim text editor.\nman Display the manual page for a command, providing detailed information.\nUsage: man [command]\nExample: man ls shows the manual for the ls command.\nwhoami Show the currently logged-in user\u0026rsquo;s username.\nUsage: whoami\nThis command is useful for confirming your user identity.\nzip Compress a directory and its contents into a zip file.\nUsage: zip -r [filename.zip] [foldername]\nExample: zip -r archive.zip myfolder creates a zip file of \u0026ldquo;myfolder\u0026rdquo;.\nunzip Extract files from a zip archive.\nUsage: unzip [filename]\nExample: unzip archive.zip extracts files from \u0026ldquo;archive.zip\u0026rdquo;.\napt install apache2 Install the Apache web server.\nUsage: apt install apache2\nThis command sets up Apache on your system.\nservice apache2 start Start the Apache web server.\nUsage: service apache2 start\nUse this to begin serving web content.\nservice apache2 restart Restart the Apache web server.\nUsage: service apache2 restart\nThis is useful for applying configuration changes.\nservice apache2 stop Stop the Apache web server.\nUsage: service apache2 stop\nUse this command to halt the server.\napt install redis Install the Redis database server.\nUsage: apt install redis\nThis sets up Redis for use.\nservice redis start Start the Redis server.\nUsage: service redis start\nThis command activates the Redis service.\nservice redis restart Restart the Redis server.\nUsage: service redis restart\nUse this to refresh the Redis service.\nservice redis stop Stop the Redis server.\nUsage: service redis stop\nThis halts the Redis service.\napt install mysql-server Install the MySQL server.\nUsage: apt install mysql-server\nThis command installs the MySQL database management system.\nchmod Change file or directory permissions.\nUsage: chmod [permissions] [file/folder]\nExample: chmod +rwx file.txt grants read, write, and execute permissions.\nTo remove permissions, use chmod -r file.txt.\nImportant Notes Folder Names with Spaces:\nIf a folder name contains spaces, enclose it in double quotes.\nmkdir \u0026quot;New Folder\u0026quot; creates a single folder named \u0026ldquo;New Folder\u0026rdquo;. mkdir New Folder creates two separate folders named \u0026ldquo;New\u0026rdquo; and \u0026ldquo;Folder\u0026rdquo;. Using Wildcards for Operations:\nTo perform operations on:\nAll files/folders: use *. Files with a specific extension (e.g., .exe): use *.exe. Files/folders starting with \u0026ldquo;hello\u0026rdquo;: use hello*. Use Relative Paths:\nPrefer using relative paths whenever possible to simplify navigation.\nExample: mv /home/username/Downloads/index.html /var/www/html/index.html moves a file to the web server directory. ","permalink":"http://localhost:1313/posts/pages/linux/linux_cheatsheet/","summary":"A practical guide to navigating and managing files in Linux.","title":"Linux Commands and Directories Guide"},{"content":"Learning Journey Topics I Have Learned So Far Docker Linux Django Channels Git Django Rest Framework Python Django JavaScript React Basics HTML CSS Tailwind Css What I Plan to Learn Next Tanstack Query Django Rest Framework (DRF) Deep Dive Django ORM Deep Dive React Advanced Git Advanced Linux Advanced SQL Database or NoSQL Database Docker Advanced WebSocket Deep Dive in Django Read In Sequence Django Database Select Releated and prefetch related,Annotations React Authentication Axios Intercept Tanstack query asyncio Django Channels Deep Dive Django Celery ","permalink":"http://localhost:1313/posts/pages/readinglist/my_reading/","summary":"A detailed overview of my learning journey and future plans.","title":"Learning Journey"},{"content":"Css:Note from starting to end 1. Vanilla CSS Vanilla CSS\n2. Tailwind CSS Tailwind CSS\n","permalink":"http://localhost:1313/posts/pages/css/css/","summary":"Css:Note from starting to end","title":"Css:Note from starting to end"}]