[{"content":"Python Fundamentals: Some Important Package to Know In Python programming, packages are collections of modules that provide additional functionality to your programs. Python has a rich ecosystem of packages that can help you perform a wide range of tasks, from data analysis and visualization to web development and machine learning. In this guide, we will explore some of the most important packages in Python that you should be familiar with.\n1.json The json package in Python provides functions for encoding and decoding JSON data. JSON (JavaScript Object Notation) is a lightweight data interchange format that is easy for humans to read and write and easy for machines to parse and generate. The json package allows you to work with JSON data in Python by converting Python objects to JSON strings and vice versa.\nConversion of Python dictionary to JSON string We can convert a Python dictionary to a JSON string using the json.dumps() function. This function takes a Python object as input and returns a JSON string representation of the object. Example:\nimport json # Create a Python dictionary data = { \u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34; } # Convert the dictionary to a JSON string json_string = json.dumps(data) print(json_string) Conversion of JSON string to Python dictionary We can convert a JSON string to a Python dictionary using the json.loads() function. This function takes a JSON string as input and returns a Python object (usually a dictionary) representing the JSON data. Example:\nimport json # JSON string json_string = \u0026#39;{\u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;}\u0026#39; # Convert the JSON string to a Python dictionary data = json.loads(json_string) print(data) 2.os The os package in Python provides functions for interacting with the operating system.You can get indepth knowladge of os using its own documentation.but the most common methods are:\nos.path.join(\u0026quot;C:\u0026quot;,\u0026quot;users\u0026quot;,\u0026quot;bin\u0026quot;): Join one or more path components intelligently. os.rename(\u0026quot;old\u0026quot;,\u0026quot;new\u0026quot;): Rename a file or directory. 3.time The time package in Python provides functions for working with time-related tasks. You can use the time package to get the current time, sleep for a specified duration, and measure the execution time of your code.\ntime.time(): Returns the current time in seconds since the epoch. time.sleep(seconds): Suspends the execution of the current thread for the given number of seconds. 4.uuid The uuid package in Python provides functions for generating and working with UUIDs (Universally Unique Identifiers). UUIDs are unique identifiers that are used to identify objects in a distributed computing environment. The uuid package allows you to generate UUIDs based on various algorithms and formats.\nGenerating a UUID You can generate a UUID using the uuid.uuid4() function, which generates a random UUID. Example:\nimport uuid # Generate a random UUID uuid_value = uuid.uuid4() print(uuid_value) 5.Datetime The datetime package in Python provides classes for working with dates and times. You can use the datetime package to create, manipulate, and format dates and times in your Python programs.\nCreating a datetime object You can create a datetime object using the datetime.datetime() constructor, which takes the year, month, day, hour, minute, second, and microsecond as input. Example:\nimport datetime # Create a datetime object dt = datetime.datetime(2022, 11, 27, 10, 30, 0) print(dt) Output:\n2022-11-27 10:30:00 get current date and time You can get the current date and time using the datetime.now() method. Example:\nimport datetime # Get the current date and time now = datetime.datetime.now() print(now) Output:\n2022-11-27 10:30:00 Formatting a datetime object some Properties of datetime object:\nyear: The year of the datetime object month: The month of the datetime object (1-12) day: The day of the datetime object (1-31) hour: The hour of the datetime object (0-23) minute: The minute of the datetime object (0-59) second: The second of the datetime object (0-59) import datetime # Create a datetime object dt = datetime.datetime.now() # Format the datetime object print(dt.month()) print(dt.day()) print(dt.year()) print(dt.hour()) print(dt.minute()) print(dt.second()) Output:\n11\r27\r2022\r10\r30\r0 ","permalink":"http://localhost:1313/posts/pages/python_extrapackage/","summary":"An in-depth look at frequently used important package.","title":"Python Fundamentals: Some Important Package to Know (Part 10)"},{"content":"Python Fundamentals: Understanding File Handeling In Python programming, file handling is an essential operation that allows you to read, write, and manipulate files on your system. Files are used to store data permanently, and Python provides various functions and methods to work with files efficiently. In this guide, we will explore the basics of file handling in Python, including opening, reading, writing, and closing files.\n1.Context Manager Python provides a built-in way to manage resources and ensure that they are properly released when they are no longer needed. This is done using the with statement and is known as a context manager. When working with files, it is recommended to use the with statement to ensure that the file is properly closed after use.\n1.1. Using the with Statement The with statement in Python is used to create a context manager that automatically takes care of resource management. When working with files, the with statement ensures that the file is properly closed after use, even if an error occurs during file operations.\nExample:\nwith open(\u0026#34;example.txt\u0026#34;, \u0026#34;r\u0026#34;) as file: data = file.read() print(data) 2. Opening a File Before you can read or write to a file, you need to open it using the open() function. The open() function takes two arguments: the file path and the mode in which you want to open the file.\n2.1. Modes for Opening Files Python supports various modes for opening files, depending on the operations you want to perform. Some common modes include:\nr: Read mode. Opens the file for reading. The file must exist. w: Write mode. Opens the file for writing. If the file exists, it will be truncated. If the file does not exist, a new file will be created. a: Append mode. Opens the file for writing. If the file exists, the data will be appended to the end. If the file does not exist, a new file will be created. b: Binary mode. Opens the file in binary mode.use for image,video,etc as it will not convert the data to text .You can add b to any mode to open the file in binary mode like rb,wb,ab. t: Text mode. Opens the file in text mode (default). 2.2. Opening a File To open a file, you can use the open() function with the desired file path and mode. You can also specify additional parameters such as encoding, buffering, and newline characters.\nExample:\n# Open a file in read mode with open(\u0026#34;example.txt\u0026#34;, \u0026#34;r\u0026#34;) as file: data = file.read() print(data) 3. Reading from a File Once you have opened a file, you can read its contents using various methods provided by Python. The most common methods for reading from a file is read().\n# Open a file in read mode with open(\u0026#34;example.txt\u0026#34;, \u0026#34;r\u0026#34;) as file: data = file.read() print(data) 4. Writing to a File To write data to a file, you can use the write() method provided by Python. You can write text data to a file using the write() method.\nUsing w mode: # Open a file in write mode with open(\u0026#34;example.txt\u0026#34;, \u0026#34;w\u0026#34;) as file: file.write(\u0026#34;Hello, World!\u0026#34;) Using a mode: # Open a file in append mode with open(\u0026#34;example.txt\u0026#34;, \u0026#34;a\u0026#34;) as file: file.write(\u0026#34;Hello, World!\u0026#34;) 5.Context Manager Reference\nUse of Context Manager: In any programming language, the usage of resources like file operations or database connections is very common. But these resources are limited in supply. Therefore, the main problem lies in making sure to release these resources after usage. If they are not released then it will lead to resource leakage and may cause the system to either slow down or crash. It would be very helpful if users have a mechanism for the automatic setup and teardown of resources. In Python, it can be achieved by the usage of context managers which facilitate the proper handling of resources.\nWhat is happened When the with statement is executed, it will automatically call the __enter__ before entering the code block, and __exit__ after exiting the code block.\nHow to create a context manager To create a context manager, you need to define a class that implements the __enter__ and __exit__ methods. The __enter__ method is called when the with statement is executed, and the __exit__ method is called after the code block is executed.\nSyntax:\nclass MyContextManager: def __init__(self,params): # Code to initialize resources def __enter__(self): # Code to setup resources return self def __exit__(self, exc_type, exc_value, traceback): # Code to release resources Example:\n#implementatio of own file handeling context manager class MeroHandle: def __init__(self,filename,mode): self.filename = filename self.mode = mode def __enter__(self): self.file = open(self.filename,self.mode) return self.file def __exit__(self,exc_type,exc_value,traceback): self.file.close() #using the context manager with MeroHandle(\u0026#34;example.txt\u0026#34;,\u0026#34;r\u0026#34;) as file: data = file.read() print(data) Normal way of file handeling try: file = open(\u0026#34;example.txt\u0026#34;,\u0026#34;r\u0026#34;) data = file.read() print(data) file.close() except: print(\u0026#34;Error Occured\u0026#34;) Advantage of context manager Over normal code When we use normal code shown above then when error occured in try block before file.close() then it will not close the file(i.e file will not be closed) and it will lead to resource leakage . But when we use context manager then it will automatically close the file just because __exit__ method is called after the code block is executed whether error occured or not. but in normal code we can manage this by using finally block but it is not recommended as it is not pythonic way of doing things. try: file = open(\u0026#34;example.txt\u0026#34;,\u0026#34;r\u0026#34;) data = file.read() print(data) except: print(\u0026#34;Error Occured\u0026#34;) finally: file.close() This will work but it is not pythonic way of doing things.Just because we have to write whole try,except,finally block for just opening and closing the file. which make code more complex and lengthy.\n","permalink":"http://localhost:1313/posts/pages/python_filehandeling/","summary":"An in-depth look at File Handeling.","title":"Python Fundamentals: Understanding File Handeling (Part 9)"},{"content":"Python Fundamentals: Understanding request In this guide, we will explore request package in python. This package is used to make HTTP requests in python. Let\u0026rsquo;s dive in!\n1. Python request Python request is a simple and elegant HTTP library for Python. It provides methods for sending HTTP requests and handling the responses. The requests library allows you to send HTTP requests using a simple and intuitive API, and it also provides support for handling cookies, sessions, and authentication.\n1.1. Installing requests To use the requests library in your Python project, you need to install it using pip. You can install the requests library by running the following command in your terminal:\npip install requests 1.2. Types of requests The requests library supports various types of HTTP requests, including GET, POST, PUT, DELETE, and more. You can use these methods to interact with web services and APIs.\nExample:\nimport requests # Send a GET request response = requests.get(\u0026#39;https://api.github.com\u0026#39;) # Send a POST request response = requests.post(\u0026#39;https://httpbin.org/post\u0026#39;) # Send a PUT request response = requests.put(\u0026#39;https://httpbin.org/put\u0026#39;) # Send a DELETE request response = requests.delete(\u0026#39;https://httpbin.org/delete\u0026#39;) 1.3 Parameters for requests The requests library allows you to pass various parameters when making HTTP requests. These parameters include headers, query parameters, request body, and more.\nHeaders: You can pass custom headers in your request using the headers parameter. Example: import requests # Send a GET request with custom headers headers = {\u0026#39;User-Agent\u0026#39;: \u0026#39;Mozilla/5.0\u0026#39;} response = requests.get(\u0026#39;https://api.github.com\u0026#39;, headers=headers) # Send a POST request with custom headers response = requests.post(\u0026#39;https://httpbin.org/post\u0026#39;, headers=headers) #similarly for PUT and DELETE cookie: You can pass cookies in your request using the cookies parameter. Example: import requests # Send a GET request with cookies cookies = {\u0026#39;session_id\u0026#39;: \u0026#39;12345\u0026#39;} response = requests.get(\u0026#39;https://api.github.com\u0026#39;, cookies=cookies) # Send a POST request with cookies response = requests.post(\u0026#39;https://httpbin.org/post\u0026#39;, cookies=cookies) #similarly for PUT and DELETE file: You can upload files in your request using the files parameter. Example: import requests # Upload a file in a POST request files = {\u0026#39;file\u0026#39;: open(\u0026#39;file.txt\u0026#39;, \u0026#39;rb\u0026#39;)} response = requests.post(\u0026#39;https://httpbin.org/post\u0026#39;, files=files) #similarly for PUT and DELETE params: You can pass query parameters in your request using the params parameter. Example: import requests # Send a GET request with query parameters params = {\u0026#39;key1\u0026#39;: \u0026#39;value1\u0026#39;, \u0026#39;key2\u0026#39;: \u0026#39;value2\u0026#39;} response = requests.get(\u0026#39;https://api.github.com\u0026#39;, params=params) # Send a POST request with query parameters response = requests.post(\u0026#39;https://httpbin.org/post\u0026#39;, params=params) #similarly for PUT and DELETE data: You can pass data in your request body using the data parameter. Example: import requests # Send a POST request with data data = {\u0026#39;key1\u0026#39;: \u0026#39;value1\u0026#39;, \u0026#39;key2\u0026#39;: \u0026#39;value2\u0026#39;} response = requests.post(\u0026#39;https://httpbin.org/post\u0026#39;, data=data) #similarly for PUT and DELETE json: You can pass JSON data in your request body using the json parameter. Example: import requests # Send a POST request with JSON data data = {\u0026#39;key1\u0026#39;: \u0026#39;value1\u0026#39;, \u0026#39;key2\u0026#39;: \u0026#39;value2\u0026#39;} response = requests.post(\u0026#39;https://httpbin.org/post\u0026#39;, json=data) #similarly for PUT and DELETE Note: The requests library provides a wide range of parameters and options for making HTTP requests. You can refer to the official documentation for more details.\n** Note ** : While using json it will automatically set the content type to application/json and dump the data to json format but while using data it will set the content type to application/x-www-form-urlencoded and encode the data to urlencoded format.\n1.4. Handling responses The requests library provides methods for handling the responses returned by HTTP requests. You can access the response content, status code, headers, and more.\nResponse content: You can access the response content using the text attribute. Example: import requests # Send a GET request response = requests.get(\u0026#39;https://api.github.com\u0026#39;) # Get the response content content = response.text print(content) Response Content in bytes: You can access the response content in bytes using the content attribute. Example: import requests # Send a GET request response = requests.get(\u0026#39;https://api.github.com\u0026#39;) # Get the response content in bytes content = response.content print(content) json: You can access the response content as JSON using the json method. Example:\nimport requests # Send a GET request response = requests.get(\u0026#39;https://api.github.com\u0026#39;) # Get the response content as JSON data = response.json() print(data) Status code: You can access the response status code using the status_code attribute. Example: import requests # Send a GET request response = requests.get(\u0026#39;https://api.github.com\u0026#39;) # Get the response status code status_code = response.status_code print(status_code) Headers: You can access the response headers using the headers attribute. Example: import requests # Send a GET request response = requests.get(\u0026#39;https://api.github.com\u0026#39;) # Get the response headers headers = response.headers print(headers) Cookies: You can access the response cookies using the cookies attribute. Example: import requests # Send a GET request response = requests.get(\u0026#39;https://api.github.com\u0026#39;) # Get the response cookies cookies = response.cookies print(cookies) ","permalink":"http://localhost:1313/posts/pages/python_request/","summary":"An in-depth exploration of Python request.","title":"Python Fundamentals: Understanding request (Part 8)"},{"content":"Python Fundamentals: Packages, Generators, and Decorators In this guide, we will explore advanced Python topics including packages, generators, and decorators. These concepts are essential for writing efficient and maintainable Python code. Let\u0026rsquo;s dive in!\n1. Python Packages Python packages are a way of organizing and structuring your code into reusable modules. Packages allow you to group related modules together, making it easier to manage and maintain your codebase. In this section, we will explore how to create and use Python packages.\n1.1. Creating a Package To create a Python package, you need to organize your code into a directory structure with a special file called __init__.py. This file tells Python that the directory is a package and allows you to import modules from the package.\nExample directory structure:\nmy_package/\r│\r├── __init__.py\r├── module1.py\r└── module2.py 1.2. Using a Package To use a Python package, you can import modules from the package using the import statement. You can import specific modules or the entire package.\nExample:\n# Importing a specific module from my_package import module1 # Using a function from the imported module module1.my_function() # Importing the entire package import my_package # Using a function from a module within the package my_package.module2.another_function() #Importing Function from a module from my_package.module1 import my_function my_function() Note : init.py file can be empty or contain initialization code for the package. It will automatically run when the package is imported.\n1.3 Creating a Subpackage You can create subpackages within a package to further organize your code. Subpackages are simply packages within packages, allowing you to create a hierarchical structure for your codebase.\nExample directory structure:\nmy_package/\r│\r├── __init__.py\r├── module1.py\r└── subpackage/\r├── __init__.py\r├── module3.py\r└── module4.py 1.4. Using a Subpackage To use a subpackage, you can import modules from the subpackage using the dot notation.\nExample:\n# Importing a module from a subpackage from my_package.subpackage import module3 # Using a function from the imported module module3.another_function() # Importing the entire subpackage import my_package.subpackage # Using a function from a module within the subpackage my_package.subpackage.module4.some_function() #Importing Function from a module from my_package.subpackage.module3 import another_function another_function() 1.5. name == \u0026ldquo;main\u0026rdquo; We use the __name__ variable to check if a script is being run as the main program or being imported as a module. When a script is run as the main program, __name__ is set to \u0026quot;__main__\u0026quot;. This allows you to include code that should only run when the script is executed directly.\nFor Example:\nStructure:\nMain Directory/\r├── main.py\r└── package/\r├── __init__.py\r└── module1.py module1.py:\ndef my_function(): print(\u0026#34;Hello from module1\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: my_function() When you run module1.py directly, the my_function() will be executed. However, if you import module1 into another script, the my_function() will not be executed.\nFor Example:\nfrom package import module1 print(\u0026#34;Imported module1\u0026#34;) Output:\nImported module1 When use Dont use if __name__ == \u0026quot;__main__\u0026quot;: in module1.py:\ndef my_function(): print(\u0026#34;Hello from module1\u0026#34;) my_function() also,\nfrom package import module1 print(\u0026#34;Imported module1\u0026#34;) Output:\nHello from module1\rImported module1 2. Python Generators Using generator we can instantly return all the values using the yield keyword without storing them in memory. This is useful when working with large datasets or infinite sequences.\n2.1. Creating a Generator To create a generator in Python, you can use a function with the yield keyword. When a function contains the yield keyword, it becomes a generator function. The yield keyword suspends the function\u0026rsquo;s execution and returns a value to the caller.\nExample:\ndef my_generator(): yield 1 yield 2 yield 3 # Using the generator gen = my_generator() print(next(gen)) # Output: 1 print(next(gen)) # Output: 2 print(next(gen)) # Output: 3 Example:\n#using generator in loop def generate(n): for i in range(n): yield i for i in generate(10): print(i) 3. Python Decorators Decorators are a powerful feature in Python that allows you to modify or extend the behavior of functions or methods. Decorators are functions that take another function as an argument and return a new function that extends the behavior of the original function.\n3.1. Creating a Decorator To create a decorator in Python, you can define a function that takes another function as an argument and returns a new function that extends the behavior of the original function.\nSyntax:\ndef my_decorator(func): def wrapper(): # Code to execute before calling the decorated function func() # Code to execute after return wrapper Example:\ndef my_decorator(func): def wrapper(): print(\u0026#34;Before function call\u0026#34;) func() print(\u0026#34;After function call\u0026#34;) return wrapper @my_decorator def say_hello(): print(\u0026#34;Hello!\u0026#34;) say_hello() #call to my_decorator(say_hello)() just because we use @my_decorator Output:\nBefore function call\rHello!\rAfter function call Example For decorator :\ndef Add_Wrapper(func): def wrapper(a,b,c): print(\u0026#34;Status code is\u0026#34;,c) return func(a,b) return wrapper @Add_Wrapper def add(a,b): return a+b print(add(2,3,200)) Output:\nStatus code is 200\r5 3.2. Decorator with Arguments You can also create decorators that accept arguments by defining a decorator function that takes arguments and returns a decorator function.\nSyntax:\ndef my_decorator_with_args(arg1, arg2): def decorator(func): def wrapper(): # Code to execute before calling the decorated function func() # Code to execute after return wrapper return decorator Example:\ndef my_decorator_with_args(arg1, arg2): def decorator(func): def wrapper(): print(f\u0026#34;Decorator arguments: {arg1}, {arg2}\u0026#34;) func() return wrapper return decorator @my_decorator_with_args(\u0026#34;arg1\u0026#34;, \u0026#34;arg2\u0026#34;) def say_hello(): print(\u0026#34;Hello!\u0026#34;) say_hello() Output:\nDecorator arguments: arg1, arg2\rHello! ","permalink":"http://localhost:1313/posts/pages/python_advanced_topics/","summary":"An in-depth exploration of Python packages, generators, and decorators.","title":"Python Fundamentals: Packages, Generators, and Decorators (Part 7)"},{"content":"Python Fundamentals: Understanding Error Handling In Python programming, error handling is an essential concept that allows you to gracefully manage exceptions and errors that may occur during program execution. By handling errors effectively, you can prevent your program from crashing and provide meaningful feedback to users. In this guide, we will explore the fundamentals of error handling in Python, including exceptions, try-except blocks, and best practices.\n1. Exceptions In Python, exceptions are events that occur during the execution of a program that disrupt the normal flow of code. When an exception occurs, the interpreter raises an exception object that can be caught and handled by the program. Exceptions can be caused by various reasons, such as invalid input, file not found, or division by zero.\n2.What May Cause Exceptions Exceptions can be caused by various reasons, such as:\nDivision by zero Invalid input File not found Syntax errors Out of Index of list, tuple , String Key Error in dictionary 3.Types of Exceptions Commonly used exceptions in Python include:\nZeroDivisionError: Raised when division or modulo by zero occurs. ValueError: Raised when a function receives an argument of the correct type but an inappropriate value. TypeError: Raised when an operation or function is applied to an object of an inappropriate type. IndexError: Raised when a sequence subscript is out of range. KeyError: Raised when a dictionary key is not found. SyntaxError: Raised when the parser encounters a syntax error. Note: All exceptions in Python are subclasses of the Exception class.\n3.Handling Exceptions To handle exceptions in Python, you can use the try-except block, which allows you to catch and handle exceptions gracefully. The try block contains the code that may raise an exception, and the except block handles the exception if it occurs.The program control will transfer the control to the except block if any exception occurs in the try block but if there is not exception then the control will not transfer to the except block.\n4.1. Using try-except Block Here\u0026rsquo;s an example of using the try-except block to handle exceptions in Python:\nsyntax:\ntry: # Code that may raise an exception except ExceptionType as e: # Handle the exception Example:\ntry: x = 10 / 0 except Exception as e: print(\u0026#34;Error: Division by zero\u0026#34;) Output:\nError: Division by zero Note: if you don\u0026rsquo;t know the type of exception you can use Exception to catch all exceptions.\nIf you dont handel exception then it will show error and stop the program.\n4.2. Finally Block The finally block is used to execute code that should always run, regardless of whether an exception occurs or not. The finally block is typically used to release resources or clean up operations that need to be performed after the try block, regardless of the outcome Any how the finally block will run. if yout return from the try block then also the finally block will run.\nsyntax:\ntry: # Code that may raise an exception except ExceptionType as e: # Handle the exception finally: # Code that always runs Example:\ntry: x = 10 / 0 except Exception as e: print(\u0026#34;Error: Division by zero\u0026#34;) finally: print(\u0026#34;Cleanup code\u0026#34;) Output:\nError: Division by zero\rCleanup code 3.5. Raising Exceptions You can raise exceptions in Python using the raise statement. This allows you to create custom exceptions and raise them when needed. You can also raise built-in exceptions to indicate errors or exceptional conditions.\nsyntax:\nraise ExceptionType(\u0026#34;Error message\u0026#34;) Example:\nx = -1 if x \u0026lt; 0: raise ValueError(\u0026#34;Value cannot be negative\u0026#34;) Output:\nValueError: Value cannot be negative 3.6. Multiple except Blocks You can use multiple except blocks to handle different types of exceptions in Python. This allows you to catch and handle specific exceptions based on their type.\nsyntax:\ntry: # Code that may raise an exception except ExceptionType1 as e: # Handle ExceptionType1 except ExceptionType2 as e: # Handle ExceptionType2 Example:\ntry: x = 10 / 0 except ZeroDivisionError as e: print(\u0026#34;Error: Division by zero\u0026#34;) except ValueError as e: print(\u0026#34;Error: Invalid value\u0026#34;) Output:\nError: Division by zero 3.7. Custom Exceptions You can create custom exceptions in Python by defining a new exception class that inherits from the Exception class. Custom exceptions allow you to define specific error conditions for your application and raise them when needed.\nsyntax:\nclass CustomException(Exception): pass Example:\n#Will read about class in oop section class CustomError(Exception): def __init__(self,message,value): self.message=message self.value=value def __str__(self): return f\u0026#34;{self.message}\\nError code:{self.value}\u0026#34; try: x = -1 if x \u0026lt; 0: raise CustomError(\u0026#34;Value cannot be negative\u0026#34;,1001) except CustomError as e: print(e) Note: Custom exceptions should inherit from the Exception class or one of its subclasses. You can simply use:\ntry: #code except: #code try: #code except Exception as e: #code try: #code except Exception: #code try: #code except: #code finally: #code ","permalink":"http://localhost:1313/posts/pages/python_error_handeling/","summary":"An in-depth exploration of Python error handling, exceptions, and best practices.","title":"Python Fundamentals: Understanding Error Handling (Part 6)"},{"content":"Python Fundamentals: Understanding Functions In Python programming, functions are essential building blocks that allow you to organize and reuse code effectively. Functions help break down complex problems into smaller, manageable tasks, making your code more readable and maintainable. In this guide, we will explore the fundamentals of Python functions, including their syntax, parameters, return values, and more.\n1. Defining Functions A function in Python is defined using the def keyword followed by the function name and parentheses. You can also specify parameters inside the parentheses if the function requires input values.\nSyntax:\ndef function_name(parameters): # Function body # Statements Example:\ndef greet(): print(\u0026#34;Hello, World!\u0026#34;) 2. Calling Functions To call a function in Python, you simply write the function name followed by parentheses. If the function requires input values, you can pass them inside the parentheses.\nSyntax:\nfunction_name(arguments) Example:\ngreet() 3. return Statement The return statement in Python is used to exit a function and return a value to the caller. You can use the return statement to send a result back to the calling code.\nSyntax:\ndef function_name(parameters): # Function body return value Demostration using all:\ndef add_numbers(a, b): return a + b result = add_numbers(5, 3) print(result) 4. Args , Default Args and Kwargs 4.1. Args Using Args you can pass any number of arguments to a function. The arguments are passed as a tuple.\nSyntax:\ndef function_name(*args): # Function body Example:\ndef display_args(*args): print(args) display_args(1, 2, 3, 4, 5) Output:\n(1, 2, 3, 4, 5) 4.2. Default Args Default arguments are used when you do not pass a value for an argument in the function call. If a value is not provided, the default value is used.\nSyntax:\ndef function_name(arg=value): # Function body Example:\ndef add(a,b,c=0): return a+b+c result = add(5,3) print(result) result = add(5,3,2) print(result) Output:\n8\r10 4.3. Kwargs Using Kwargs you can pass any number of keyword arguments to a function. The arguments are passed as a dictionary.\nSyntax:\ndef function_name(**kwargs): # Function body Example:\ndef display_kwargs(**kwargs): print(kwargs) display_kwargs(name=\u0026#34;Alice\u0026#34;, age=30, city=\u0026#34;New York\u0026#34;) Output:\n{\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 30, \u0026#39;city\u0026#39;: \u0026#39;New York\u0026#39;} 4.4. Combination of Args and Kwargs Example:\ndef display_args_kwargs(*args, **kwargs): print(args) print(kwargs) display_args_kwargs(1, 2, 3, name=\u0026#34;Alice\u0026#34;, age=30) Output:\n(1, 2, 3)\r{\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 30} 4.5. Unpacking Args and Kwargs Example:\ndef display_args_kwargs(*args, **kwargs): print(args) print(kwargs) args = (1, 2, 3) kwargs = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30} display_args_kwargs(*args, **kwargs) Output:\n(1, 2, 3)\r{\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 30} 5. Lambda Functions Lambda functions, also known as anonymous functions, are small, single-expression functions that do not require a name. They are defined using the lambda keyword.\nSyntax:\nlambda arguments: expression Example:\nadd = lambda a, b: a + b result = add(5, 3) print(result) Output:\n8 6.Map and filter functions 6.1. Map Function The map() function in Python applies a given function to each item of an iterable (such as a list, tuple, or set) and returns a new iterable with the results.\nSyntax:\nmap(function, iterable) Example:\nnumbers = [1, 2, 3, 4, 5] squared = map(lambda x: x ** 2, numbers) print(list(squared)) Output:\n[1, 4, 9, 16, 25] 6.2. Filter Function The filter() function in Python filters elements from an iterable based on a given function. It returns an iterator with the elements that satisfy the condition.\nSyntax:\nfilter(function, iterable) Example:\nnumbers = [1, 2, 3, 4, 5] even = filter(lambda x: x % 2 == 0, numbers) print(list(even)) Output:\n[2, 4] 7.Local and Global Variables 7.1. Local Variables Local variables are defined within a function and are only accessible within that function. They are created when the function is called and destroyed when the function exits.\nExample:\ndef display(): message = \u0026#34;Hello, World!\u0026#34; print(message) display() # Trying to access the local variable outside the function will result in an error print(message) # NameError: name \u0026#39;message\u0026#39; is not defined 7.2. Global Variables Global variables are defined outside any function and can be accessed from any part of the code. You can use the global keyword to modify a global variable inside a function.\nExample:\nmessage = \u0026#34;Hello, World!\u0026#34; def display(): print(message) display() # Modifying a global variable inside a function def change_message(): global message message = \u0026#34;Hello, Python!\u0026#34; change_message() print(message) Output:\nHello, World!\rHello, Python! 7.3. Local vs. Global Variables If a local variable has the same name as a global variable, the local variable takes precedence within the function scope.\nExample:\nmessage = \u0026#34;Hello, World!\u0026#34; def display(): message = \u0026#34;Hello, Python!\u0026#34; print(message) display() print(message) Output:\nHello, Python!\rHello, World! ","permalink":"http://localhost:1313/posts/pages/python_function/","summary":"An in-depth exploration of Python functions, their usage, and importance in programming.","title":"Python Fundamentals: Understanding Functions (Part 5)"},{"content":"Python Fundamentals: Exploring Advanced Operations (Part 4) In Python programming, advanced operations allow you to perform complex tasks efficiently. These operations include working with ranges, enumerations, zip functions, and more. In this guide, we will explore various advanced operations in Python to enhance your programming skills.\n1. Ranges Ranges in Python are used to generate a sequence of numbers. They are commonly used in loops to iterate over a specific range of values. Ranges can be created using the range() function.\n1.1. Creating a Range To create a range of numbers, you can use the range() function with the desired start, stop, and step values where start number is in inclusive and stop number is exclusive.\nExample:\n# Generate a range of numbers from 0 to 9 for i in range(10): print(i) Output:\n0\r1\r2\r3\r4\r5\r6\r7\r8\r9 Example:\n# Generate a range of numbers from 1 to 10 with a step of 2 for i in range(0, 10,2): print(i) Output:\n0\r2\r4\r6\r8 1.2 Enumerate Function The enumerate() function in Python is used to iterate over a sequence while keeping track of the index and value of each item. It returns a tuple containing the index and the value of the item.\nExample:\n# Enumerate a list of fruits fruits = [\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;cherry\u0026#39;] for index, fruit in enumerate(fruits): print(index, fruit) Output:\n0 apple\r1 banana\r2 cherry Example:\na=\u0026#34;nirajan\u0026#34; for index, char in enumerate(a): print(index, char) Output:\n0 n\r1 i\r2 r\r3 a\r4 j\r5 a\r6 n 1.3. Zip Function The zip() function in Python is used to combine multiple iterables (such as lists) element-wise. It returns an iterator of tuples where the i-th tuple contains the i-th element from each of the input iterables.\nExample:\n# Zip two lists together names = [\u0026#39;Alice\u0026#39;, \u0026#39;Bob\u0026#39;, \u0026#39;Charlie\u0026#39;] ages = [25, 30, 35] for name, age in zip(names, ages): print(name, age) Output:\nAlice 25\rBob 30\rCharlie 35 Example:\na=[1,2,3] b=[4,5,6] c=[7,8,9] print(list(zip(a,b,c))) Output:\n[(1, 4, 7), (2, 5, 8), (3, 6, 9)] 1.5 Sorted Function The sorted() function in Python is used to sort a list of elements. It returns a new sorted list without modifying the original list.The main feature of the sorted() function is that it can take a key argument that specifies a function to be called on each list element prior to making comparisons.\nExample:\n# Sort a list of numbers numbers = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5] sorted_numbers = sorted(numbers) print(sorted_numbers) Output:\n[1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] Example:\n# Sort a list of strings based on the length of the string fruits = [\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;cherry\u0026#39;, \u0026#39;date\u0026#39;] sorted_fruits = sorted(fruits, key=len) print(sorted_fruits) Output:\n[\u0026#39;date\u0026#39;, \u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;cherry\u0026#39;] Example:\n#Sort an dictionary based on the value d = {\u0026#39;apple\u0026#39;: 10, \u0026#39;banana\u0026#39;: 5, \u0026#39;cherry\u0026#39;: 15} sorted_d = sorted(d.items(), key=lambda x: x[1]) print(sorted_d) Output:\n[(\u0026#39;banana\u0026#39;, 5), (\u0026#39;apple\u0026#39;, 10), (\u0026#39;cherry\u0026#39;, 15)] Example:\n#Sort a list of tuples based on the second element t = [(1, 2), (3, 1), (5, 6)] sorted_t = sorted(t, key=lambda x: x[1]) print(sorted_t) Output:\n[(3, 1), (1, 2), (5, 6)] #2. Import in Python In Python, the import statement is used to import modules or packages into your script. It allows you to use functions, classes, and variables defined in other modules in your code.\n2.1. Importing Modules To import a module in Python, you can use the import keyword followed by the module name. You can then access the functions, classes, and variables defined in the module using dot notation.\nExample:\n# Import the math module import math # Calculate the square root of a number x = 16 print(math.sqrt(x)) Output:\n4.0 Example:\n# Import the datetime module import datetime # Get the current date and time now = datetime.datetime.now() print(now) Output:\n2024-11-17 10:30:00 2.2. Importing Specific Functions You can import specific functions or variables from a module using the from keyword. This allows you to use the imported functions directly without using the module name.\nExample:\n# Import the pi constant from the math module from math import pi # Print the value of pi print(pi) Output:\n3.141592653589793 Example:\n# Import the date class from the datetime module from datetime import date # Get the current date today = date.today() print(today) Output:\n2024-11-17 2.3. Aliasing Modules You can alias a module or package by using the as keyword. This allows you to refer to the module by a different name in your code.\nExample:\n# Import the math module and alias it as m import math as m # Calculate the square root of a number x = 25 print(m.sqrt(x)) Output:\n5.0 Example:\n# Import the datetime module using import and from and alias it as dt from datetime import datetime as dt now = dt.now() print(now) Output:\n2024-11-17 10:30:00 2.4. Importing All Functions You can import all functions and variables from a module using the * operator. This imports all the functions and variables defined in the module.\nExample:\n# Import all functions from the math module from math import * # Calculate the square root of a number x = 36 print(sqrt(x)) Output:\n6.0 The General Syntax is\nfrom module_name.submodule_name.submodule_name... import funtion_name or variable_name or filename as alias_name\nrandom module The random module in Python is used to generate random numbers. It provides various functions to generate random integers, floating-point numbers, and sequences.\n1. Generating Random Numbers The random module provides functions to generate random numbers within a specified range which can contain both integers starting and ending number.\nExample:\nfrom random import randint # Generate a random integer between 1 and 10 random_number = randint(1, 10) print(random_number) Output:\n5 2.Shuffling a List The random module provides a function to shuffle the elements of a list randomly. It modifies the original list in place.\nExample:\nfrom random import shuffle # Shuffle a list of numbers numbers = [1, 2, 3, 4, 5] shuffle(numbers) print(numbers) Output:\n[3, 1, 5, 2, 4] ","permalink":"http://localhost:1313/posts/pages/python_advanced_operations/","summary":"An in-depth exploration of advanced Python operations to enhance your programming skills.","title":"Python Fundamentals: Exploring Advanced Operations (Part 4)"},{"content":"Python Control Structures: Mastering Loops and Conditionals In Python programming, control structures are essential for managing the flow of execution in your code. They allow you to make decisions, repeat tasks, and create complex algorithms. In this guide, we will explore two fundamental control structures in Python: loops and conditionals.\n1. Conditional Statements Conditional statements in Python allow you to execute specific blocks of code based on certain conditions. The most common conditional statements are if, elif, and else.\n1.1. The if Statement The if statement is used to check a condition and execute a block of code if the condition is true.\nExample:\nx = 10 if x \u0026gt; 5: print(\u0026#34;x is greater than 5\u0026#34;) Output:\nx is greater than 5 1.2. The elif Statement The elif statement allows you to check multiple conditions after the initial if statement. If the previous conditions are false, the elif block is evaluated.\nExample:\nx = 5 if x \u0026gt; 5: print(\u0026#34;x is greater than 5\u0026#34;) elif x == 5: print(\u0026#34;x is equal to 5\u0026#34;) Output:\nx is equal to 5 1.3. The else Statement The else statement is used to execute a block of code when all the previous conditions are false.\nExample:\nx = 3 if x \u0026gt; 5: print(\u0026#34;x is greater than 5\u0026#34;) elif x == 5: print(\u0026#34;x is equal to 5\u0026#34;) else: print(\u0026#34;x is less than 5\u0026#34;) Output:\nx is less than 5 2. Loops Loops in Python allow you to execute a block of code repeatedly. There are two main types of loops in Python: for loops and while loops.\n2.1. The while Loop The while loop executes a block of code as long as a specified condition is true.\nSyntax:\nwhile condition: # Code block else: # Optional else block Example:\ncount = 0 while count \u0026lt; 5: print(count) count += 1 else: print(\u0026#34;Loop completed\u0026#34;) 2.2. The for Loop The for loop is used to iterate over a sequence (such as a list, tuple, or string) and execute a block of code for each item in the sequence.\nSyntax:\nfor item in sequence: # Code block else: # Optional else block Example:\nfruits = [\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;] for fruit in fruits: print(fruit) else: print(\u0026#34;No more fruits\u0026#34;) 2.3 Using For Loops with different data types 2.3.1. For Loop with Strings Example:\nfor char in \u0026#34;Python\u0026#34;: print(char) Output:\np\ry\rt\rh\ro\rn 2.3.2. For Loop with Lists Example:\nnumbers = [1, 2, 3, 4, 5] for num in numbers: print(num) Output:\n1\r2\r3\r4\r5 2.3.3. For Loop with tuples Example:\nfruits = (\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;) for fruit in fruits: print(fruit) Output:\napple\rbanana\rcherry Tuple unpacking can also be used in for loops to iterate over multiple values in a tuple.\ncoordinates = [(1, 2), (3, 4), (5, 6)] for x, y in coordinates: print(f\u0026#34;X: {x}, Y: {y}\u0026#34;) Output:\nX: 1, Y: 2\rX: 3, Y: 4\rX: 5, Y: 6 2.3.4. For Loop with Sets Example:\ncolors = {\u0026#34;red\u0026#34;, \u0026#34;green\u0026#34;, \u0026#34;blue\u0026#34;} for color in colors: print(color) Output:\nred\rgreen\rblue 2.3.5. For Loop with Dictionaries Example:\nperson = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} for key, value in person.items(): print(f\u0026#34;{key}: {value}\u0026#34;) Output:\nname: Alice\rage: 30\rcity: New York 2.4. break , pass and continue statements in loops 2.4.1. The break Statement The break statement is used to exit a loop prematurely. It terminates the current loop and resumes execution at the next statement after the loop.\nExample:\nfor num in [1, 2, 3, 4, 5]: if num == 3: break print(num) Output:\n1\r2 2.4.2. The continue Statement The continue statement is used to skip the rest of the code inside a loop for the current iteration and jump to the next iteration.\nExample:\nfor num in [1, 2, 3, 4, 5]: if num == 3: continue print(num) Output:\n1\r2\r4\r5 2.4.3. The pass Statement The pass statement is a null operation that does nothing. It is used when a statement is required syntactically but you do not want any code to execute.\nExample:\nfor num in [1, 2, 3, 4, 5]: pass ","permalink":"http://localhost:1313/posts/pages/python_control_structure/","summary":"A detailed examination of Python\u0026rsquo;s control structures, focusing on loops and conditionals to enhance your programming skills.","title":"Python Fundamentals: Mastering Control Structures (Part 3)"},{"content":"1. Python Manupulation of Data Types We have already discussed the basic concepts of Python programming in the previous part of this series. In this part, we will dive deeper into operations and manipulations of different data types in Python.\n1.1.Numeric Operations 1.1.1. abs() Function The abs() function returns the absolute value of a number. For example:\nnum = -10 print(abs(num)) # Output: 10 1.1.2. round() Function The round() function rounds a number to the nearest integer. For example:\nnum = 3.14159 print(round(num)) # Output: 3 1.1.3. ord() Function The ord() function returns the Unicode code point of a character. For example:\nchar = \u0026#39;A\u0026#39; print(ord(char)) # Output: 65 1.2. String Operations String is a sequence of characters enclosed within single, double, or triple quotes. In Python, strings are immutable, meaning they cannot be changed once created. Here are some common string operations:\n1.2.1. Declaring a String we can declare a string using single, double, or triple quotes. For example:\nstr1 = \u0026#39;Hello, World!\u0026#39; #for single line string str2 = \u0026#34;Hello, World!\u0026#34; #for single line string str3 = \u0026#39;\u0026#39;\u0026#39;Hello, World! This is a multiline string.\u0026#39;\u0026#39;\u0026#39;#for multiline string 1.2.2. Text Decorators There are many text decorators available in Python to format strings among them we use \\n for a new line, \\t for a tab. For example:\nstr1 = \u0026#39;Hello, \\nWorld!\u0026#39; #for new line str2 = \u0026#34;Hello, \\tWorld!\u0026#34; #for tab 1.2.3. String Indexing The indexing of a string starts from 0 to n-1, where n is the length of the string. For example: for example: a=\u0026ldquo;hello\u0026rdquo;\na = H e l l o 0 1 2 3 4 0 -4 -3 -2 -1 1.2.4. Ascessing Characters in a String We can access characters in a string using the index using []. For example:\nstr = \u0026#34;Hello, World!\u0026#34; print(str[0]) # Output: H print(str[-1]) # Output: ! 1.2.5. String Concatenation We can concatenate two strings using the + operator and * operator . For example:\nstr1 = \u0026#34;Hello\u0026#34; str2 = \u0026#34;World\u0026#34; print(str1 + str2) # Output: HelloWorld print(str1 * 3) # Output: HelloHelloHello 1.2.6. String Slicing We can slice a string using the syntax variable[start:end:step] to get a substring.\nNote: The substring contains characters from index start to end-1, meaning the character at the end index is not included but character at the start index is included . The step refers to the increment or jump of the index\nFor example:\na = \u0026#34;hello\u0026#34; # Slice from index 1 to the end of the string print(a[1:]) # ello (Characters from index 1 to the end) # Slice from the beginning of the string to index 4 (doesn\u0026#39;t contain character at index 4) print(a[:4]) # hell (Characters from index 0 to 3) # Slice from index 1 to index 4 (doesn\u0026#39;t contain character at index 4) print(a[1:4]) # ell (Characters from index 1 to 3) # Full slice of the string with default values print(a[::]) # hello (Default start is 0, end is the string length, step is 1) # Defining a step value in slicing # Slice with a step of 2 print(a[::2]) # hlo (Start from index 0 to the end, select every 2nd character) # Reverse the string using a negative step print(a[::-1]) # olleh (Reverse the string by stepping backward) # Combining start, end, and step print(a[1:4:2]) # el #(Start from index 1 to 4 (doesn\u0026#39;t contain character at index 4), with a step of 2) 1.2.7. String Methods Python provides various built-in methods to manipulate strings. Some of the commonly used string methods are:\nlen() : Returns the length of the string. str = \u0026#34;Hello, World!\u0026#34; print(len(str)) # Output: 13 replace() : Replaces a substring with another substring. str = \u0026#34;Hello, World!\u0026#34; print(str.replace(\u0026#34;World\u0026#34;, \u0026#34;Universe\u0026#34;)) # Output: Hello, Universe! upper() : Converts the string to uppercase. str = \u0026#34;Hello, World!\u0026#34; print(str.upper()) # Output: HELLO, WORLD! lower() : Converts the string to lowercase. str = \u0026#34;Hello, World!\u0026#34; print(str.lower()) # Output: hello, world! split() : Splits the string into a list based on the delimiter. str = \u0026#34;Hello, World!\u0026#34; print(str.split(\u0026#34;,\u0026#34;)) # Output: [\u0026#39;Hello\u0026#39;, \u0026#39; World!\u0026#39;] capitalize() : Converts the first character of the string to uppercase.\nstr = \u0026#34;hello, world!\u0026#34; print(str.capitalize()) # Output: Hello, world! -find() : Returns the index of the first occurrence of a substring.\nstr = \u0026#34;Hello, World!\u0026#34; print(str.find(\u0026#34;World\u0026#34;)) # Output: 7 print(str.find(\u0026#34;e\u0026#34;)) # Output: 1 print(str.find(\u0026#34;Universe\u0026#34;)) # Output: -1 count() : Returns the number of occurrences of a substring. str = \u0026#34;Hello, World!\u0026#34; print(str.count(\u0026#34;l\u0026#34;)) # Output: 3 startswith() : Returns True if the string starts with a specified substring. str = \u0026#34;Hello, World!\u0026#34; print(str.startswith(\u0026#34;Hello\u0026#34;)) # Output: True endswith() : Returns True if the string ends with a specified substring. str = \u0026#34;Hello, World!\u0026#34; print(str.endswith(\u0026#34;World!\u0026#34;)) # Output: True strip() : Removes leading and trailing whitespaces from the string. We can also specify the characters to be removed. str = \u0026#34; Hello, World! \u0026#34; print(str.strip()) # Output: Hello, World! str = \u0026#34;!!!!!!!!Hello, World!!!!!\u0026#34; print(str.strip(\u0026#34;!\u0026#34;)) # Output: Hello, World! lstrip() : Removes leading whitespaces from the string.we can also specify the characters to be removed. str = \u0026#34; Hello, World! \u0026#34; print(str.lstrip()) # Output: Hello, World! str = \u0026#34;!!!!!!!!Hello, World!!!!!\u0026#34; print(str.lstrip(\u0026#34;!\u0026#34;)) # Output: Hello, World!!!!! rstrip() : Removes trailing whitespaces from the string.We can also specify the characters to be removed. str = \u0026#34; Hello, World! \u0026#34; print(str.rstrip()) # Output: Hello, World! str = \u0026#34;!!!!!!!!Hello, World!!!!!\u0026#34; print(str.rstrip(\u0026#34;!\u0026#34;)) # Output: !!!!!!!!Hello, World 1.2.8. f-Strings f-strings are a convenient way to format strings in Python. They allow you to embed expressions inside string literals, using curly braces {}. For example:\nname = \u0026#34;Alice\u0026#34; age = 30 print(f\u0026#34;My name is {name} and I am {age} years old.\u0026#34;) # Output: My name is Alice and I am 30 years old. 1.2.9. Raw Strings Raw strings are used to ignore escape characters in a string. They are prefixed with an r or R. For example:\npath=\u0026#34;C:\\Users\\Alice\\Documents\u0026#34; print(path) # Output: C:UsersAliceDocuments path = r\u0026#34;C:\\Users\\Alice\\Documents\u0026#34; print(path) # Output: C:\\Users\\Alice\\Documents Note:String is immutable in python.\na = \u0026#34;Hello\u0026#34; a[0] = \u0026#34;h\u0026#34; # Error: \u0026#39;str\u0026#39; object does not support item assignment #Instead To change the string value we can use the following method a=\u0026#39;k\u0026#39;+a[1::] # Output: \u0026#39;kello\u0026#39; 1.3. List Operations A list is a collection of items enclosed within square brackets []. Lists are mutable, meaning they can be changed after creation. Here are some common list operations: Key Points:\nList is mutable in python. List support indexing and slicing like string 1.3.1. Declaring a List We can declare a list by enclosing items within square brackets []. For example:\nlist1 = [1, 2, 3, 4, 5] list2 = [\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;] list3 = [1, \u0026#34;apple\u0026#34;, True, 3.14] 1.3.2 List Concatenation We can concatenate two or more lists using the + operator. For example:\nlist1 = [1, 2, 3] list2 = [4, 5, 6] print(list1 + list2) # Output: [1, 2, 3, 4, 5, 6] 1.3.3. Mutable property of List List is mutable in python and its example is shown below:\n#for string a = \u0026#34;Hello\u0026#34; a[0] = \u0026#34;h\u0026#34; # Error: \u0026#39;str\u0026#39; object does not support item assignment #for list list1 = [1, 2, 3] list1[0] = 10 print(list1) # Output: [10, 2, 3] 1.3.4. Built-in List Methods Python provides various built-in methods to manipulate lists. Some of the commonly used list methods are:\nlen() : Returns the length of the list. list1 = [1, 2, 3, 4, 5] print(len(list1)) # Output: 5 append() : Adds an element to the end of the list /Change orginal list does not return anything. list1 = [1, 2, 3] list1.append(4) print(list1) # Output: [1, 2, 3, 4] insert() : Inserts an element at a specified position in the list /Change orginal list does not return anything. list1 = [1, 2, 3] list1.insert(1, 4) print(list1) # Output: [1, 4, 2, 3] pop() : Removes the element at the specified position in the list and returns it. If no index is specified, it removes and returns the last element. list1 = [1, 2, 3] print(list1.pop(1)) # Output: 2 print(list1) # Output: [1, 3] print(list1.pop()) # Output: 3 print(list1) # Output: [1] remove() : Removes the first occurrence of the specified element from the list. list1 = [1, 2, 3, 2] list1.remove(2) print(list1) # Output: [1, 3, 2] -sort() : Sorts the list in ascending order.Does not return anything but change the original list.\nlist1 = [3, 1, 2] list1.sort() print(list1) # Output: [1, 2, 3] -reverse() : Reverses the order of the list. Does not return anything but change the original list.\nlist1 = [1, 2, 3] list1.reverse() print(list1) # Output: [3, 2, 1] -count() : Returns the number of occurrences of a specified element in the list.\nlist1 = [1, 2, 3, 2] print(list1.count(2)) # Output: 2 -index() : Returns the index of the first occurrence of the specified element in the list.\nlist1 = [1, 2, 3, 2] print(list1.index(2)) # Output: 1 1.3.5. List Comprehension List comprehension is a concise way to create lists from existing lists. There are 3 type of syntax.\nNot using if list1=[variable for variable in iterable] Using if only list1 = [variable for variable in iterable if condition] Using if else list1 = [variable if condition else variable for variable in iterable] Traditional way of creating list\nlist1 = [] for i in range(5): list1.append(i) print(list1) # Output: [0, 1, 2, 3, 4] Using list comprehension\nlist1 = [i for i in range(5)] print(list1) # Output: [0, 1, 2, 3, 4] list1 = [i for i in range(5) if i%2==0] print(list1) # Output: [0, 2, 4] list1 = [i if i%2==0 else i**2 for i in range(5)] print(list1) # Output: [0, 1, 2, 9, 4] Note: When you attempt to access an index that is out of range, Python will raise an IndexError so put it in try-except block to handle the error.\nNote: The indexing and slicing of list are similar to string.\n1.4 Dictionary Operations A dictionary is a collection of key-value pairs enclosed within curly braces {}. Dictionaries are mutable and unordered. Here are some common dictionary operations:\n1.4.1. Declaring a Dictionary We can declare a dictionary by specifying key-value pairs within curly braces {}. For example:\ndict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} dict2 = {1: \u0026#34;apple\u0026#34;, 2: \u0026#34;banana\u0026#34;, 3: \u0026#34;cherry\u0026#34;} dict3 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;, \u0026#34;hobbies\u0026#34;: [\u0026#34;reading\u0026#34;, \u0026#34;painting\u0026#34;]} 1.4.2. Accessing Dictionary Elements We can access dictionary elements using keys. For example:\ndict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} print(dict1[\u0026#34;name\u0026#34;]) # Output: Alice 1.4.3 Adding Dictionary Elements We can add new key-value pairs to a dictionary by specifying the key and value. For example:\ndict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30} dict1[\u0026#34;city\u0026#34;] = \u0026#34;New York\u0026#34; print(dict1) # Output: {\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 30, \u0026#39;city\u0026#39;: \u0026#39;New York\u0026#39;} 1.4.4. Updating Dictionary Elements We can update the value of an existing key in a dictionary. For example:\ndict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} dict1[\u0026#34;age\u0026#34;] = 35 print(dict1) # Output: {\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 35, \u0026#39;city\u0026#39;: \u0026#39;New York\u0026#39;} 1.4.5 Dictionary Methods Python provides various built-in methods to manipulate dictionaries. Some of the commonly used dictionary methods are:\nlen() : Returns the number of key-value pairs in the dictionary. dict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} print(len(dict1)) # Output: 3 keys() : Returns a list of all the keys in the dictionary. dict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} print(dict1.keys()) # Output: dict_keys([\u0026#39;name\u0026#39;, \u0026#39;age\u0026#39;, \u0026#39;city\u0026#39;]) values() : Returns a list of all the values in the dictionary. dict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} print(dict1.values()) # Output: dict_values([\u0026#39;Alice\u0026#39;, 30, \u0026#39;New York\u0026#39;]) items() : Returns a list of key-value pairs in the dictionary. dict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} print(dict1.items()) # Output: dict_items([(\u0026#39;name\u0026#39;, \u0026#39;Alice\u0026#39;), (\u0026#39;age\u0026#39;, 30), (\u0026#39;city\u0026#39;, \u0026#39;New York\u0026#39;)]) -pop() : Removes the element with the specified key and returns its value.\ndict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} print(dict1.pop(\u0026#34;age\u0026#34;)) # Output: 30 print(dict1) # Output: {\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;city\u0026#39;: \u0026#39;New York\u0026#39;} -get() : Returns the value of the specified key. If the key does not exist, it returns the specified default value.\ndict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;} print(dict1.get(\u0026#34;age\u0026#34;)) # Output: 30 print(dict) # Output: {\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 30, \u0026#39;city\u0026#39;: \u0026#39;New York\u0026#39;} Note: When you attempt to access a key that does not exist in the dictionary, Python will raise a KeyError so put it in try-except block to handle the error or use get() method to avoid the error.\n1.4.6. Nested Dictionaries A dictionary can contain another dictionary as a value. This is known as a nested dictionary. For example:\ndict1 = { \u0026#34;person1\u0026#34;: {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30}, \u0026#34;person2\u0026#34;: {\u0026#34;name\u0026#34;: \u0026#34;Bob\u0026#34;, \u0026#34;age\u0026#34;: 25} } print(dict1[\u0026#34;person1\u0026#34;][\u0026#34;name\u0026#34;]) # Output: Alice 1.4.7. Dictionary Comprehension Dictionary comprehension is a concise way to create dictionaries. For example:\ndict1 = {x: x**2 for x in range(5)} # Output: {0: 0, 1: 1, 2: 4, 3: 9, 4: 16} #using if only dict1 = {x: x**2 for x in range(5) if x%2==0} # Output: {0: 0, 2: 4, 4: 16} #using if else dict1 = {x: x**2 if x%2==0 else x**3 for x in range(5)} # Output: {0: 0, 1: 1, 2: 4, 3: 27, 4: 16} 1.5. Tuple Operations A tuple is a collection of items enclosed within parentheses (). Tuples are immutable, meaning they similar to python as they cant be changed using indexing as a[0]=10 will give an error.\n1.5.1. Declaring a Tuple We can declare a tuple by enclosing items within parentheses (). For example:\ntuple1 = (1, 2, 3) tuple2 = (\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;) tuple3 = (1, \u0026#34;apple\u0026#34;, True, 3.14) 1.5.2. Accessing Tuple Elements We can access tuple elements using indexing . For example:\ntuple1 = (1, 2, 3) print(tuple1[0]) # Output: 1 1.5.3. Slice Tuple We can slice a tuple using the syntax variable[start:end:step] to get a sub-tuple. For example:\ntuple1 = (1, 2, 3, 4, 5) print(tuple1[1:4]) # Output: (2, 3, 4) 1.5.4. Tuple Methods Python provides various built-in methods to manipulate tuples. Some of the commonly used tuple methods are:\ncount() : Returns the number of occurrences of a specified element in the tuple. tuple1 = (1, 2, 3, 2) print(tuple1.count(2)) # Output: 2 index() : Returns the index of the first occurrence of the specified element in the tuple. tuple1 = (1, 2, 3, 2) print(tuple1.index(2)) # Output: 1 len() : Returns the length of the tuple. tuple1 = (1, 2, 3, 2) print(len(tuple1)) # Output: 4 1.5.5 concatenation of tuple We can concatenate two or more tuples using the + operator. For example:\ntuple1 = (1, 2, 3) tuple2 = (4, 5, 6) print(tuple1 + tuple2) # Output: (1, 2, 3, 4, 5, 6) 1.5.6. Tuple Unpacking Tuple unpacking allows us to assign multiple variables at once. For example:\ntuple1 = (1, 2, 3) a, b, c = tuple1 d,*e = tuple1 print(a) # Output: 1 print(b) # Output: 2 print(c) # Output: 3 print(d) # Output: 1 print(e) # Output: [2, 3] tuple1 = (1, 2, 3, 4, 5) a, *b, c = tuple1 print(a) # Output: 1 print(b) # Output: [2, 3, 4] print(c) # Output: 5 Note:Ascessing and slicing of tuple is similar to list and string.\n1.6. Boolean Operations Boolean is a data type that represents one of two values: True or False. Boolean values are used to evaluate conditions in programming. Here are some common boolean operations:\n1.6.1. Condition when variable is True When a variable has a non-zero value, it is considered True. a = 10 if a: print(\u0026#34;The value of a is True\u0026#34;) When a string is not empty, it is considered True. a = \u0026#34;Hello\u0026#34; if a: print(\u0026#34;The value of a is True\u0026#34;) When a list is not empty, it is considered True. a = [1, 2, 3] if a: print(\u0026#34;The value of a is True\u0026#34;) When a dictionary is not empty, it is considered True. a = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30} if a: print(\u0026#34;The value of a is True\u0026#34;) When a tuple is not empty, it is considered True. a = (1, 2, 3) if a: print(\u0026#34;The value of a is True\u0026#34;) When a set is not empty, it is considered True. a = {1, 2, 3} if a: print(\u0026#34;The value of a is True\u0026#34;) When a variable is explicitly set to True, it is considered True. a = True if a: print(\u0026#34;The value of a is True\u0026#34;) 1.6.2. Condition when variable is False Those which are not in the above condition are considered as False.\n1.7. Set Operations A set is a collection of unique items enclosed within curly braces {}. Main Uses of set are:\nTo remove duplicate elements from a list. To perform mathematical set operations like union, intersection, difference, etc. 1.7.1. Declaring a Set We can declare a set by enclosing items within curly braces {} or set(). For example:\nset1 = {1, 2, 3} set2 = {\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;} set3 = {1, \u0026#34;apple\u0026#34;, True, 3.14} #using set() set4 = set([1, 2, 3]) set5=set() 1.7.2. Set Methods Python provides various built-in methods to manipulate sets. Some of the commonly used set methods are:\n-len() : Returns the number of elements in the set.\nset1 = {1, 2, 3} print(len(set1)) # Output: 3 -add() : Adds an element to the set.Doesn\u0026rsquo;t return anything.\nset1 = {1, 2, 3} set1.add(4) print(set1) # Output: {1, 2, 3, 4} -clear() : Removes all elements from the set.Doesn\u0026rsquo;t return anything.\nset1 = {1, 2, 3} set1.clear() print(set1) # Output: set() -remove() : Removes the specified element from the set. If the element is not present, it raises an error.\nset1 = {1, 2, 3} set1.remove(2) print(set1) # Output: {1, 3} discard() : Removes the specified element from the set. If the element is not present, it does not raise an error.\nset1 = {1, 2, 3} set1.discard(2) print(set1) # Output: {1, 3} -union() : Returns a set containing the union of two sets.\nset1 = {1, 2, 3} set2 = {3, 4, 5} print(set1.union(set2)) # Output: {1, 2, 3, 4, 5} -intersection() : Returns a set containing the intersection of two sets.\nset1 = {1, 2, 3} set2 = {3, 4, 5} print(set1.intersection(set2)) # Output: {3} -difference() : Returns a set containing the difference between two sets.\nset1 = {1, 2, 3} set2 = {3, 4, 5} print(set1.difference(set2)) # Output: {1, 2} -symmetric_difference() : Returns a set containing the symmetric difference between two sets.\nset1 = {1, 2, 3} set2 = {3, 4, 5} print(set1.symmetric_difference(set2)) # Output: {1, 2, 4, 5} -issubset() : Returns True if all elements of a set are present in another set.\nset1 = {1, 2, 3} set2 = {1, 2, 3, 4, 5} print(set1.issubset(set2)) # Output: True 1.8 Used in All iterable 1.8.1. in Operator The in operator is used to check if an element is present in an iterable. For example:\n# in string str = \u0026#34;Hello, World!\u0026#34; print(\u0026#34;Hello\u0026#34; in str) # Output: True # in list list1 = [1, 2, 3, 4, 5] print(3 in list1) # Output: True # in tuple tuple1 = (1, 2, 3, 4, 5) print(6 in tuple1) # Output: False # in set set1 = {1, 2, 3, 4, 5} print(5 in set1) # Output: True # in dictionary dict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30} print(\u0026#34;name\u0026#34; in dict1) # Output: True 1.8.2. not in Operator The not in operator is used to check if an element is not present in an iterable. For example:\n# not in string str = \u0026#34;Hello, World!\u0026#34; print(\u0026#34;Alice\u0026#34; not in str) # Output: True # not in list list1 = [1, 2, 3, 4, 5] print(6 not in list1) # Output: True # not in tuple tuple1 = (1, 2, 3, 4, 5) print(5 not in tuple1) # Output: False # not in set set1 = {1, 2, 3, 4, 5} print(5 not in set1) # Output: False # not in dictionary dict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30} print(\u0026#34;name\u0026#34; not in dict1) # Output: False 1.8.3. len() Function The len() function is used to get the length of an iterable. For example:\n# for string str = \u0026#34;Hello, World!\u0026#34; print(len(str)) # Output: 13 # for list list1 = [1, 2, 3, 4, 5] print(len(list1)) # Output: 5 # for tuple tuple1 = (1, 2, 3, 4, 5) print(len(tuple1)) # Output: 5 # for set set1 = {1, 2, 3, 4, 5} print(len(set1)) # Output: 5 # for dictionary dict1 = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30} print(len(dict1)) # Output: 2 1.8.4. max() and min() Functions The max() function is used to get the maximum value from an iterable, and the min() function is used to get the minimum value for list,string,set and tuples only. for dictionary you can use .keys() or .values() and use it. For example:\n# for list list1 = [1, 2, 3, 4, 5] print(max(list1)) # Output: 5 print(min(list1)) # Output: 1 # for tuple tuple1 = (1, 2, 3, 4, 5) print(max(tuple1)) # Output: 5 print(min(tuple1)) # Output: 1 # for string string = \u0026#34;Hello, World!\u0026#34; print(max(string)) # Output: r print(min(string)) # Output: \u0026#39; \u0026#39; # for set set1 = {1, 2, 3, 4, 5} print(max(set1)) # Output: 5 print(min(set1)) # Output: 1 1.8.5. join() Function The join() function is used to concatenate elements of an iterable with a separator. For example:\n# for list list1 = [\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;] print(\u0026#34;, \u0026#34;.join(list1)) # Output: apple, banana, cherry # for tuple tuple1 = (\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;) print(\u0026#34;, \u0026#34;.join(tuple1)) # Output: apple, banana, cherry # for set set1 = {\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;} print(\u0026#34;, \u0026#34;.join(set1)) # Output: apple, banana, cherry # for string string = \u0026#34;Hello, World!\u0026#34; print(\u0026#34;, \u0026#34;.join(string)) # Output: H, e, l, l, o, ,, , W, o, r, l, d, ! ","permalink":"http://localhost:1313/posts/pages/python_datatype_operations/","summary":"An in-depth look at Python data types, exploring their usage and importance in programming.","title":"Python Fundamentals: Understanding Data Types (Part 2)"},{"content":"Python Fundamentals: A Beginner\u0026rsquo;s Guide (Part 1) 1. Virtual Environment A virtual environment is a feature in Python that allows you to install the same package with different versions on the same system. This enables you to work on multiple projects using different versions of the same package.\n1.1. Installing venv The venv module is included in the Python standard library, so you don\u0026rsquo;t need to install it separately. However, if you are using an older version of Python (before 3.3), you can install virtualenv using pip:\npip install virtualenv 1.2. Creating a Virtual Environment To create a virtual environment, you can use the venv module, which is included in the Python standard library. Here\u0026rsquo;s how you can create a virtual environment named myenv:\npython -m venv myenv This command creates a new directory named myenv that contains the necessary files for the virtual environment.\n1.3. Activating a Virtual Environment To activate the virtual environment, you may run the following command:\n# For Linux/Mac: source myenv/bin/activate # For Windows: myenv\\Scripts\\activate 2. Python Packages 2.1. List All the Python Packages To list or save all the installed packages in the current environment, you can use the following command using freeze:\npip freeze # To list all the installed packages pip freeze \u0026gt; requirements.txt # To save all the installed packages in a file 2.2. Installing Python Packages To install a Python package, you can use the pip install command followed by the package name. For example, to install the requests package, you can run:\npip install requests 2.3. Uninstalling Python Packages To uninstall a Python package, you can use the pip uninstall command followed by the package name. For example, to uninstall the requests package, you can run:\npip uninstall requests 2.4. Run Python Package/Script To run a python package or script, you can use the following command:\npython -m package_name 3. Python Basics 3.1. Running a Python Script To run a Python script, you can use the following command:\npython script.py 3.2. Python Indentation In Python, the code block (body of the function, loop, etc.) starts with a colon (:) and the line following the colon should be indented.\nif 5 \u0026gt; 2: print(\u0026#34;Five is greater than two!\u0026#34;) # Indented block 3.3. Python Comments There are two types of comments in Python:\n# This is a single line comment \u0026#34;\u0026#34;\u0026#34; This is a multiline comment This is a multiline comment This is a multiline comment This is a multiline comment \u0026#34;\u0026#34;\u0026#34; 3.4. Print Statement The print() function is used to display the output on the console. For example:\nprint(\u0026#34;Hello, World!\u0026#34;) 3.5. Data Types Python has the following data types:\nint float str bool list tuple set dict None a = 10 # int b = 10.5 # float c = \u0026#34;Hello\u0026#34; # str d = True # bool e = [1,2,3] # list f = (1,2,3) # tuple g = {1,2,3} # set h = {\u0026#34;name\u0026#34;:\u0026#34;John\u0026#34;,\u0026#34;age\u0026#34;:30} # dict i = None # None print(type(a)) # \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; Note:Use type() function to check the data type of a variable.As it return the class of the variable.\n3.6. Rules of Variable Declaration A variable name must start with a letter or the underscore character. A variable name cannot start with a number. A variable name can only contain alpha-numeric characters and underscores (A-z, 0-9, and _ ). Variable names are case-sensitive (age, Age, and AGE are three different variables). 3.7. Type Conversion You can convert one data type to another using the following functions:\nint(): To convert to an integer float(): To convert to a float str(): To convert to a string bool(): To convert to a boolean list(): To convert to a list tuple(): To convert to a tuple set(): To convert to a set dict(): To convert to a dictionary a = 10 #a=10 b = float(a) #b=10.0 c = str(a) #c=\u0026#39;10\u0026#39; d = bool(a) #d=True e = list(c) #e=[\u0026#39;1\u0026#39;,\u0026#39;0\u0026#39;] f = tuple(c) #f=(\u0026#39;1\u0026#39;,\u0026#39;0\u0026#39;) g = set(c) #g={\u0026#39;1\u0026#39;,\u0026#39;0\u0026#39;} h = dict(name=\u0026#34;John\u0026#34;,age=30) or dict([(\u0026#34;name\u0026#34;,\u0026#34;John\u0026#34;),(\u0026#34;age\u0026#34;,30)]) #h={\u0026#39;name\u0026#39;:\u0026#39;John\u0026#39;,\u0026#39;age\u0026#39;:30} Note: Python is dynamically typed, which means a variable\u0026rsquo;s data type can be changed.\n4. Operators 4.1. Arithmetic Operators +: Addition -: Subtraction *: Multiplication /: Division %: Modulus **: Power //: Floor Division a = 10 b = 3 print(a + b) # 13 print(a - b) # 7 print(a * b) # 30 print(a / b) # 3.3333333333333335 print(a % b) # 1 print(a ** b) # 1000 print(a // b) # 3 4.2. Assignment Operators =: Assign value +=: Add and assign -=: Subtract and assign *=: Multiply and assign /=: Divide and assign %=: Modulus and assign **=: Power and assign //=: Floor Division and assign a = 10 a += 5 # a = a + 5 a -= 5 # a = a - 5 a *= 5 # a = a * 5 a /= 5 # a = a / 5 a %= 5 # a = a % 5 a **= 5 # a = a ** 5 a //= 5 # a = a // 5 4.3. Comparison Operators ==: Equal to !=: Not equal to \u0026gt;: Greater than \u0026lt;: Less than \u0026gt;=: Greater than or equal to \u0026lt;=: Less than or equal to a = 10 b = 20 print(a == b) # False print(a != b) # True print(a \u0026gt; b) # False print(a \u0026lt; b) # True print(a \u0026gt;= b) # False print(a \u0026lt;= b) # True 4.4. Logical Operators and: Returns True if both statements are true or: Returns True if one of the statements is true not: Reverse the result, returns False if the result is true a = 10 b = 20 c = 30 print(a \u0026lt; b and b \u0026lt; c) # True print(a \u0026lt; b or b \u0026gt; c) # True print(not(a \u0026lt; b and b \u0026lt; c)) # False 4.5. Identity Operators is: Returns True if both variables are the same object is not: Returns True if both variables are not the same object a = [1,2,3] b = [1,2,3] print(a is b) # False print(a is not b) # True 4.6. Membership Operators in: Returns True if a sequence with the specified value is present in the object not in: Returns True if a sequence with the specified value is not present in the object a = [1,2,3] #Can be used in list , tuple , set , dict, string print(1 in a) # True print(4 not in a) # True 4.7. Bitwise Operators \u0026amp;: AND |: OR ^: XOR ~: NOT \u0026lt;\u0026lt;: Left Shift \u0026gt;\u0026gt;: Right Shift a = 10 b = 4 print(a \u0026amp; b) # 0 print(a | b) # 14 print(a ^ b) # 14 print(~a) # -11 print(a \u0026lt;\u0026lt; 2) # 40 print(a \u0026gt;\u0026gt; 2) # 2 Note: is vs ==\nis is used to compare the memory location of two objects. == is used to compare the values of two objects. # For Mutable objects (list, dict, set): a = [1,2,3] b = [1,2,3] print(a == b) # True print(a is b) # False # For immutable objects (int, float, string, tuple, None): a = 10 b = 10 print(a == b) # True print(a is b) # True c = None d = None print(c == d) # True print(c is d) # True 5.Taking User Input In Python, you can take user input using the input() function. Here\u0026rsquo;s an example:\nname = input(\u0026#34;Enter your name: \u0026#34;) print(\u0026#34;Hello, \u0026#34; + name) Note: The input() function always returns a string. If you want to convert it to another data type, you can use type conversion functions like int(), float(), etc.\n","permalink":"http://localhost:1313/posts/pages/python_basics/","summary":"A comprehensive guide to Python programming fundamentals covering core concepts for beginners","title":"Python Fundamentals: A Beginner's Guide (Part 1)"},{"content":"Basics of Vim Vim is a powerful text editor, often used in the command line, that is known for its efficiency and speed once mastered. Here are the basic commands and modes that you need to get started.\nOpening a File To open a file in Vim, use the following command:\nvim filename Replace filename with the name of the file you wish to open.\nBasic Modes in Vim Vim operates in different modes, and understanding these modes is crucial for using Vim effectively:\nNormal Mode: This is the default mode when you open a file. In this mode, you can navigate, delete, copy, and paste text. To return to Normal Mode from other modes, press Esc.\nInsert Mode: This mode allows you to insert text into the file. To enter Insert Mode, press i. After you\u0026rsquo;re done typing, press Esc to go back to Normal Mode.\nCommon Commands Here are some essential commands for working with files in Vim:\nSave the current file:\n:w This writes (saves) changes to the file.\nQuit Vim:\n:q To quit Vim. If there are unsaved changes, Vim will warn you. You can force quit without saving using:\n:q! Save changes and quit:\n:wq or\n:x These commands save changes and then exit Vim.\nTips for Beginners Press Esc frequently to return to Normal Mode, as it helps you avoid unintended actions while in other modes. Practice using both Normal and Insert modes to become comfortable with the flow of editing and saving files in Vim. Vim can be intimidating at first, but with practice, it becomes an extremely efficient tool for editing text files, especially in programming and development environments. ","permalink":"http://localhost:1313/posts/pages/vim_basics_guide/","summary":"Learn the basics of using Vim, including navigation, saving, and quitting.","title":"Basics of Vim"},{"content":"Docker Cheat Sheet: Commands and Concepts This guide covers essential Docker commands, from creating containers, managing images, building Dockerfiles, to working with volumes.\n🚀 Creating and Running Containers 1. Run a Container from an Image To create and run a container from an image:\ndocker run image 2. Run a Container in Interactive Mode To run a container and open its terminal:\ndocker run -it image After the container starts, you can interact with it directly in the terminal. 3. Name a Container To give a container a specific name:\ndocker run --name container_name image 4. Port Mapping To map a port from your computer to the container:\ndocker run -p computer_port:container_port image Incoming traffic to computer_port will be forwarded to container_port in the container. 5. Run a Container in the Background (Detached Mode) To run the container in the background:\ndocker run -d image 6. Passing Environment Variables to a Container To pass environment variables to a container:\ndocker run -e key=value image 🛠️ Managing Containers 7. Start a Container To start an existing container:\ndocker start container_id 8. Stop a Container To stop a running container:\ndocker stop container_id 9. Remove a Container To remove a container:\ndocker rm container_id Note: The container must be stopped before removal. 10. Execute a Command in a Running Container To start a terminal session inside a running container:\ndocker exec -it container_id bash 11. View Running Containers To list all currently running containers:\ndocker ps 12. View All Containers (Running and Stopped) To see all containers, including those that are stopped:\ndocker ps -a 🧱 Building Docker Images 13. Creating a Dockerfile A Dockerfile is a script used to build Docker images. Here’s an example of common Dockerfile commands:\n# Set the base image for your container FROM base_image # Run commands during the image build process RUN command # Copy files from your local machine to the container COPY source /path/in/container # Set environment variables ENV key=value # Expose a port for the container EXPOSE 8080 # Define the command to run when the container starts CMD [\u0026#34;executable\u0026#34;] # Optionally, run commands automatically when the container starts ENTRYPOINT [\u0026#34;/path/to/script\u0026#34;] # Set the working directory in the container WORKDIR /app # Copy all files from the local directory to the container, excluding files listed in .dockerignore COPY . . 14. Building a Docker Image To build a Docker image from a Dockerfile:\ndocker build -t image_name /path/to/Dockerfile 📂 Managing Docker Files 15. Using the .dockerignore File The .dockerignore file helps exclude unnecessary files from being copied into the Docker image, improving build speed and reducing image size:\nnode_modules/ .git/ 16. COPY Command in Dockerfile The COPY command copies files from your local system to the container:\nCopy all files from the current directory to the container: COPY . /path/in/container Copy a specific file: COPY ./filename.extension /path/in/container Copy an entire folder: COPY ./foldername /path/in/container Copy contents of a folder (not the folder itself): COPY ./foldername/ /path/in/container 📦 Working with Volumes 17. Mounting Volumes Volumes allow data to persist even if the container is deleted. To mount a folder from your host to the container:\ndocker run -it -v /path/on/host:/path/in/container image Example: docker run -it -v /home/user/backup:/app/data ubuntu This will map /home/user/backup on your host to /app/data inside the container. Use Cases for Volumes: Data Persistence: Preserve data even after the container is removed. Backups: Easily back up container data to the host. Shared Data: Share data between multiple containers or between host and container. 💾 Publishing Docker Images 18. Pushing an Image to Docker Hub To publish an image to Docker Hub:\nTag the image with your Docker Hub username: docker tag image_name username/image_name Log in to Docker Hub: docker login Push the image to your repository: docker push username/image_name This guide gives you the essentials for working with Docker. With these commands, you\u0026rsquo;ll be able to manage containers, build images, use volumes, and more effectively.\n","permalink":"http://localhost:1313/posts/pages/docker_basics/","summary":"A guide to understanding Docker commands and concepts.","title":"Docker Basic: Commands and Concepts"},{"content":"Docker Compose Documentation Introduction Docker Compose is a tool for defining and running multi-container Docker applications. With Docker Compose, you can use a YAML file to configure your application\u0026rsquo;s services and create and start all the services from your configuration with a single command.\nBasic docker-compose.yml Structure The docker-compose.yml file is where you define the services that make up your app. A typical file might look like this:\nversion: \u0026#39;3.8\u0026#39; services: service_name: image: image_name:tag ports: - \u0026#34;host_port:container_port\u0026#34; environment: - ENV_VAR=value volumes: - \u0026#34;host_path:container_path\u0026#34; depends_on: - dependency_service Example Configurations Example 1: Basic Setup with PostgreSQL and Redis version: \u0026#39;3.8\u0026#39; services: postgres: image: postgres ports: - \u0026#34;5432:5432\u0026#34; environment: POSTGRES_USER: postgres POSTGRES_DB: review POSTGRES_PASSWORD: password redis: image: redis ports: - \u0026#34;80:80\u0026#34; Example 2: Real-World Application version: \u0026#39;3\u0026#39; services: pythonapp: image: your-python-image:tag ports: - \u0026#34;8000:8000\u0026#34; volumes: - /Users/data:/src/bin/data depends_on: - db - redis db: image: postgres environment: POSTGRES_DB: mydatabase POSTGRES_USER: myuser POSTGRES_PASSWORD: mypassword redis: image: redis volumes: - /path/to/local/directory:/data Example 3: Building from Dockerfile version: \u0026#39;3\u0026#39; services: pythonapp: build: context: . dockerfile: Dockerfile ports: - \u0026#34;8000:8000\u0026#34; volumes: - /Users/desktop:/src/bin/desktop depends_on: - db - redis db: image: postgres environment: POSTGRES_DB: mydatabase POSTGRES_USER: myuser POSTGRES_PASSWORD: mypassword redis: image: redis volumes: - /path/to/local/directory:/data Example 4: Django Application with PostgreSQL and Redis version: \u0026#39;3.8\u0026#39; services: django-app: container_name: django-app image: django-app:latest # Replace with your actual Django image name/tag ports: - \u0026#34;8000:8000\u0026#34; # Expose Django app on port 8000 environment: - DEBUG=1 # Set Django debug mode to 1 for development - POSTGRES_HOST=postgres # PostgreSQL host - POSTGRES_DB_NAME=nirajan # PostgreSQL database name - POSTGRES_DB_PASSWORD=nirajan@9845 # PostgreSQL database password - REDIS_URL=redis://redis:6379/0 # Redis URL depends_on: - postgres - redis volumes: - static_volume:/code/static # Volume for Django static files - media_volume:/code/media # Volume for Django media files postgres: container_name: postgres image: postgres:latest environment: POSTGRES_DB: nirajan # Database name POSTGRES_USER: nirajan # Database username POSTGRES_PASSWORD: nirajan@9845 # Database password volumes: - postgres_data:/var/lib/postgresql/data redis: container_name: redis image: redis:latest ports: - \u0026#34;6379:6379\u0026#34; Service Names as Hostnames In Docker Compose, the names of the services defined in the docker-compose.yml file are used as hostnames for inter-service communication.\nService Names as Hostnames Each service name in the docker-compose.yml file acts as a hostname for that service. For example, in the configuration above:\nThe django-app service can connect to the postgres service using POSTGRES_HOST=postgres. The django-app service can connect to the redis service using REDIS_URL=redis://redis:6379/0. Example In the django-app service:\nPostgreSQL Host: POSTGRES_HOST=postgres — The Django app connects to the PostgreSQL service using the hostname postgres, which matches the name of the PostgreSQL service defined in Docker Compose. Redis Host: REDIS_URL=redis://redis:6379/0 — The Django app connects to the Redis service using the hostname redis, which matches the name of the Redis service defined in Docker Compose. Note: In Docker, services within a Docker Compose setup are typically connected to the same network by default. This allows containers to communicate with each other using service names as hostnames.\nDocker Compose Commands To start the containers defined in docker-compose.yml:\nsudo docker compose up To stop and remove all containers, networks, and volumes created by docker-compose up:\nsudo docker compose down To run the containers in the background (detached mode):\nsudo docker compose up -d Tips Use depends_on to specify dependencies between services. This ensures that the dependent services start in the correct order. Use volumes to persist data outside of your containers, which is especially useful for databases. Use environment variables to configure your services and avoid hardcoding sensitive information. Conclusion Docker Compose simplifies the process of managing multi-container Docker applications. By defining your services in a docker-compose.yml file, you can easily spin up your entire application stack with a single command. This guide provides a solid starting point for using Docker Compose to manage multi-container applications effectively.\n","permalink":"http://localhost:1313/posts/pages/docker_compose/","summary":"Learn how to define and manage services in Docker Compose.","title":"Docker Compose Documentation"},{"content":"Docker CPU and Memory Limits When you want to control the CPU and memory usage of Docker containers, you can use specific options in both Docker CLI commands and Docker Compose files. Here\u0026rsquo;s a detailed guide on how to use these options:\nDocker CLI Commands Setting CPU Limits:\nOption: --cpus Usage: Specifies the number of CPUs that the container can use. Example: docker run --cpus=\u0026#34;1.5\u0026#34; my-image The --cpus option limits the container to 1.5 CPU cores. Setting Memory Limits:\nOption: --memory or -m\nUsage: Sets the maximum amount of memory the container can use.\nExample:\ndocker run --memory=\u0026#34;500m\u0026#34; my-image This command limits the container to 500MB of RAM. If the limit is exceeded, the container will be throttled or terminated.\nNote: The options take a positive integer followed by suffixes such as b, k, m, or g to indicate bytes, kilobytes, megabytes, or gigabytes.\nSoft Memory Limits:\nOption: --memory-reservation Example: docker run --memory=\u0026#34;1g\u0026#34; --memory-reservation=\u0026#34;512m\u0026#34; nginx This reserves 512MB of memory while setting a hard limit of 1GB. Docker Compose Configuration In Docker Compose, you can define resource limits under the deploy section for version 3.x or directly under the services section for version 2.x.\nSetting CPU and Memory Limits in Docker Compose (Version 2.x):\nversion: \u0026#39;2\u0026#39; services: my-service: image: my-image deploy: resources: limits: cpus: \u0026#39;1.5\u0026#39; memory: 500M This limits the service to 1.5 CPUs and 500MB of memory.\nSetting CPU and Memory Limits in Docker Compose (Version 3.x and above):\nversion: \u0026#39;3.8\u0026#39; services: my-service: image: my-image deploy: resources: limits: cpus: \u0026#39;1.5\u0026#39; memory: \u0026#39;500M\u0026#39; This limits the service to 1.5 CPUs and 500MB of memory.\nNotes: Swap Memory: You can enable swap memory using the --memory-swap option in CLI. For example:\ndocker run --memory=\u0026#34;512m\u0026#34; --memory-swap=\u0026#34;1g\u0026#34; nginx CPU Shares: Set CPU priorities between containers using --cpu-shares, with 1024 being the default.\nBy using these options, you can ensure that your Docker containers use resources efficiently, preventing them from overwhelming the host machine.\n","permalink":"http://localhost:1313/posts/pages/docker_cpu_memory_limits_guide/","summary":"Control the CPU and memory usage of Docker containers with CLI and Docker Compose configurations.","title":"Docker CPU and Memory Limits"},{"content":"Docker Networking and Port Access In Docker, containers are isolated by default, meaning:\nContainers cannot access the host machine\u0026rsquo;s ports directly. Containers cannot access the ports of other containers directly. Container ports are not accessible from outside the host machine unless configured. 🛠️ Accessing Container Ports from Outside To access a container\u0026rsquo;s port from outside (e.g., from the host or another machine), you can use port mapping:\n1. Port Mapping docker run -p host_port:container_port imagename This command maps a container\u0026rsquo;s port to a port on the host machine. 2. Host Network To share the host\u0026rsquo;s network namespace with the container:\ndocker run --network host imagename 🌐 Accessing Container Ports from Another Container To allow inter-container communication, you need to create and use a custom Docker network.\nSteps: 1. Create a Docker Network docker network create my_network 2. Run Containers in the Same Network docker run --network my_network --name container1 imagename docker run --network my_network --name container2 imagename 3. Access One Container from Another Use the container name and port to access one container from another:\ncontainer1:port Example Scenario Create a Network docker network create my_network Run First Container docker run --network my_network --name webserver -d nginx Run Second Container docker run --network my_network --name client -it alpine /bin/sh Access Web Server from Client Inside the client container, use the following commands to access the web server: wget -qO- http://webserver or\ncurl http://webserver 📝 Important Notes Container-to-Container Access: Containers in the same custom network can communicate using their names as hostnames. Host Machine Access: Containers cannot directly access the host machine\u0026rsquo;s ports. External Access: Use port mapping or host networking to access container ports from outside the host machine. List Docker Networks To list all available Docker networks and verify the existence of custom networks:\ndocker network ls ","permalink":"http://localhost:1313/posts/pages/docker_networking_guide/","summary":"Understanding Docker networking and inter-container communication.","title":"Docker Networking and Port Access"},{"content":" 1. Configure Git To set up your Git username and email globally on your machine:\ngit config --global user.name \u0026#34;username\u0026#34; # Set your Git username git config --global user.email \u0026#34;email\u0026#34; # Set your Git email git config --list # Display the current Git configuration (username and email) 2. Git Status and Git Clone Clone a remote repository to your local machine:\ngit clone \u0026lt;url\u0026gt; # Copy repository to the local machine Check the status of your local repository:\ngit status # Show the current status of the repository Git Status Breakdown: untracked: A new file that has not been added or committed. unstaged: A file that has been added but not committed. unchanged: No changes have been made. changed: Changes have been made but not yet added or committed. 3. Git Add and Commit Add specific files or all changes and commit them:\ngit add \u0026lt;filename\u0026gt; # Add a specific file to the staging area git add . # Add all changes (modified and untracked files) git commit -m \u0026#34;Your commit message\u0026#34; # Commit the changes with a message 4. Push Local Repo to Remote To upload your local repository changes to the remote repository:\ngit push [alias] [branch] # Push changes to a specific alias and branch git remote add \u0026lt;alias\u0026gt; \u0026lt;url\u0026gt; # Add a remote alias (e.g., \u0026#39;origin\u0026#39;) git push -u [alias] [branch] # Save the alias and branch for future pushes 5. Git Initialization Initialize a new Git repository:\ngit init # Initialize a new Git repository 6. Git Branches Manage Git branches with the following commands:\ngit branch # List all local branches git branch -m \u0026lt;oldbranch\u0026gt; \u0026lt;newbranch\u0026gt; # Rename a branch git checkout \u0026lt;branchname\u0026gt; # Switch to another branch git checkout -b \u0026lt;branchname\u0026gt; # Create and switch to a new branch git branch -d \u0026lt;branchname\u0026gt; # Delete a branch (ensure you\u0026#39;re not on it) git diff \u0026lt;branchname\u0026gt; # Compare the current branch with another 7. Git Merge Merge changes from one branch into another:\ngit merge \u0026lt;branchname\u0026gt; # Merge changes from \u0026lt;branchname\u0026gt; into the current branch 8. Pull Request and Syncing Changes To pull updates from the remote repository to your local one:\ngit pull # Pull the latest changes from the remote repository git pull [alias] [branch] # Pull changes from a specific alias and branch 9. Undoing Changes If You Have Only Added Changes: git reset \u0026lt;filename\u0026gt; # Unstage a file from the staging area git reset # Unstage all files that have been added If You Have Committed Changes: git reset HEAD~1 # Undo the last commit (one step back) git reset \u0026lt;commit_hash\u0026gt; # Reset to a specific commit hash git reset --hard \u0026lt;commit_hash\u0026gt; # Hard reset to a commit and reflect changes in your editor git log # View all commit hashes and logs 10. Forking Repositories When contributing to open-source projects, you can fork a repository, which creates a copy of the repo under your GitHub account. Afterward, you can make changes and submit a pull request:\n# Fork a repository on GitHub and clone it locally git clone \u0026lt;forked_repo_url\u0026gt; # Clone your forked repository Make changes, commit them, and push to your fork. Finally, create a pull request on GitHub to merge your changes into the original repository.\nIF ANY CONCEPT IS LAGGING THEN: Watch this helpful video\n","permalink":"http://localhost:1313/posts/pages/git-cheetsheet/","summary":"A brief tutorial on github recipe and git command","title":"Git Commands and Configuration Guide"},{"content":"How to Create Content for Hugo Using Markdown Hugo, a static site generator, uses Markdown (.md) files to generate content. In this guide, we will explain how you can create content for Hugo using Markdown.\n1. Front Matter Every Markdown file in Hugo requires front matter, which is metadata placed at the top of the file. It helps Hugo understand how to process the file.\nExample:\n--- title: \u0026#34;My First Hugo Post\u0026#34; date: 2024-10-18 tags: [\u0026#34;Hugo\u0026#34;, \u0026#34;Markdown\u0026#34;] summary: \u0026#34;A brief summary of the post.\u0026#34; --- 2. Headers Headers are used to organize content. Use one # for an H1 header, two ## for H2, and so on.\nExample:\n# H1 Header ## H2 Header ### H3 Header Output:\nH3 Header 3. Text Formatting Markdown supports several text formatting options:\nExample:\n**Bold Text** *Italic Text* ~~Strikethrough~~ Output: Bold Text\nItalic Text\nStrikethrough\n4. Spacing and Line Breaks In Markdown, you can create paragraphs by leaving a blank line between lines of text.\nExample:\nThis is the first paragraph. This is the second paragraph. Output: This is the first paragraph.\nThis is the second paragraph.\n5. Horizontal Rules You can create horizontal lines (dividers) using three or more dashes (---), asterisks (***), or underscores (___).\nExample:\n--- Output:\n6. Lists Create unordered lists with - or *, and ordered lists with numbers followed by periods.\nExample:\n- Item 1 - Item 2 1. First item 2. Second item Output:\nItem 1 Item 2 First item Second item 7. Links and Images Add links and images with square brackets [] and parentheses ().\nExample:\n[Hugo Documentation](https://gohugo.io) ![Hugo Logo](/images/hugo.webp) Output: Hugo Documentation\n8. Code Blocks For inline code, use backticks. For block code, use triple backticks.\nExample:\nInline code: `print(\u0026#34;Hello World\u0026#34;)` Output: Inline code: print(\u0026quot;Hello World\u0026quot;)\nExample:\nBlock Code: def hello(): print(\u0026#34;Hello, Hugo!\u0026#34;) def hello(): print(\u0026#34;Hello, Hugo!\u0026#34;) 9. Blockquotes Use the greater than symbol (\u0026gt;) to create blockquotes.\nExample:\n\u0026gt; This is a blockquote in Hugo. Output:\nThis is a blockquote in Hugo.\n10. Tables You can create tables using pipes | and dashes -.\nExample:\n| Column 1 | Column 2 | |----------|----------| | Row 1 | Data 1 | | Row 2 | Data 2 | Output:\nColumn 1 Column 2 Row 1 Data 1 Row 2 Data 2 11. Task Lists Create task lists by using square brackets []. An x in the brackets [x] marks a task as completed.\nExample:\n- [ ] Task 1 - [x] Task 2 (Completed) Output:\nTask 1 Task 2 (Completed) 12. Syntax Highlighting Hugo supports syntax highlighting for various programming languages. You can specify the language after the triple backticks(```).\nExample: Output:\ndef greet(): print(\u0026#34;Hello, Hugo!\u0026#34;) 12. Task Lists Create task lists by using square brackets []. An x in the brackets [x] marks a task as completed.\nExample:\n- [ ] Task 1 - [ ] Sub-task 1 - [x] Sub-task 2 (Completed) - [x] Task 2 (Completed) Output:\nTask 1 Sub-task 1 Sub-task 2 (Completed) Task 2 (Completed) 13. Escaping Special Characters To use special characters like #, escape them using a backslash \\.\nExample:\n\\# This is not a header Output: # This is not a header\n14. Backtick To display backtick use four space before it as\n``` 15. Consistency It\u0026rsquo;s important to maintain consistent formatting throughout your Markdown files to ensure a clean and readable structure.\nBy following these steps, you can effectively create well-formatted content for your Hugo site using Markdown.\n","permalink":"http://localhost:1313/posts/pages/markdown_hugo_content_guide/","summary":"A tutorial on creating content with Markdown in Hugo.","title":"How to Create Content for Hugo"},{"content":" Linux Commands and Directories Guide Important Directories Default Web Server Root Directory\nLocation: /var/www/html\nThis is the standard location for serving web content on Apache.\nDownloads Folder\nLocation: /home/username/Downloads\nThis is where files downloaded from the internet are usually saved by default.\nDocuments Folder\nLocation: /home/username/Documents\nA common directory for storing personal documents and files.\nDesktop Folder\nLocation: /home/username/Desktop\nThis is the location for files and shortcuts displayed on your desktop screen.\nCommon Commands cd Change the current directory to another one.\nUsage: cd [directory]\nExample: cd /var/www/html changes to the web server root directory.\nls List files and directories in the current location or specified path.\nUsage: ls [options] [path]\nExample: ls -l lists files in a detailed format.\npwd Print the path of the current working directory.\nUsage: pwd\nThis command shows where you are in the filesystem.\nsudo su Switch to the superuser (root) account, allowing you to perform administrative tasks.\nUsage: sudo su\nAfter entering your password, you\u0026rsquo;ll have root access.\nsudo Execute a command with elevated privileges.\nUsage: sudo [command]\nExample: sudo apt update runs the update command as an administrator.\nmkdir Create a new directory.\nUsage: mkdir [directory name]\nExample: mkdir new_folder creates a directory named \u0026ldquo;new_folder\u0026rdquo;.\ndir List files and directories, similar to ls.\nUsage: dir [options] [path]\nThis command can be used interchangeably with ls.\nmv Move or rename files and directories.\nUsage: mv [source] [destination]\nExample: mv /home/username/Downloads/file.txt /home/username/Documents/ moves the file to a different directory.\ncp Copy files or directories.\nUsage: cp [source] [destination]\nExample: cp /home/username/Downloads/file.txt /home/username/Documents/ copies the file.\nrm Remove files or directories.\nUsage: rm [options] [file/directory]\nExample: To remove a directory and its contents, use rm -r [directory].\ntouch Create an empty file or update the timestamp of an existing file.\nUsage: touch [filename]\nExample: touch newfile.txt creates an empty file named \u0026ldquo;newfile.txt\u0026rdquo;.\ncat Display the contents of a file in the terminal.\nUsage: cat [filename]\nExample: cat file.txt shows the content of \u0026ldquo;file.txt\u0026rdquo;.\ngedit Open the Gedit text editor to edit files.\nUsage: gedit [filename]\nExample: gedit notes.txt opens \u0026ldquo;notes.txt\u0026rdquo; for editing.\nkill Terminate a process using its process ID (PID).\nUsage: kill [PID]\nExample: kill 1234 stops the process with the ID 1234.\ntop Display real-time information about system processes and resource usage.\nUsage: top\nThis command helps monitor system performance.\napt-get update Update the package lists for upgrades and new package installations.\nUsage: apt-get update\nThis command fetches the latest package information.\napt install path_of_.deb_file Install a .deb file package.\nUsage: apt install ./filename.deb\nExample: apt install ./main.deb installs the specified Debian package.\napt-get upgrade Upgrade all installed packages to their latest versions.\nUsage: apt-get upgrade\nThis command updates your installed software.\napt-get install package Install a specific software package.\nUsage: apt-get install [package]\nExample: apt-get install vim installs the Vim text editor.\nman Display the manual page for a command, providing detailed information.\nUsage: man [command]\nExample: man ls shows the manual for the ls command.\nwhoami Show the currently logged-in user\u0026rsquo;s username.\nUsage: whoami\nThis command is useful for confirming your user identity.\nzip Compress a directory and its contents into a zip file.\nUsage: zip -r [filename.zip] [foldername]\nExample: zip -r archive.zip myfolder creates a zip file of \u0026ldquo;myfolder\u0026rdquo;.\nunzip Extract files from a zip archive.\nUsage: unzip [filename]\nExample: unzip archive.zip extracts files from \u0026ldquo;archive.zip\u0026rdquo;.\napt install apache2 Install the Apache web server.\nUsage: apt install apache2\nThis command sets up Apache on your system.\nservice apache2 start Start the Apache web server.\nUsage: service apache2 start\nUse this to begin serving web content.\nservice apache2 restart Restart the Apache web server.\nUsage: service apache2 restart\nThis is useful for applying configuration changes.\nservice apache2 stop Stop the Apache web server.\nUsage: service apache2 stop\nUse this command to halt the server.\napt install redis Install the Redis database server.\nUsage: apt install redis\nThis sets up Redis for use.\nservice redis start Start the Redis server.\nUsage: service redis start\nThis command activates the Redis service.\nservice redis restart Restart the Redis server.\nUsage: service redis restart\nUse this to refresh the Redis service.\nservice redis stop Stop the Redis server.\nUsage: service redis stop\nThis halts the Redis service.\napt install mysql-server Install the MySQL server.\nUsage: apt install mysql-server\nThis command installs the MySQL database management system.\nchmod Change file or directory permissions.\nUsage: chmod [permissions] [file/folder]\nExample: chmod +rwx file.txt grants read, write, and execute permissions.\nTo remove permissions, use chmod -r file.txt.\nImportant Notes Folder Names with Spaces:\nIf a folder name contains spaces, enclose it in double quotes.\nmkdir \u0026quot;New Folder\u0026quot; creates a single folder named \u0026ldquo;New Folder\u0026rdquo;. mkdir New Folder creates two separate folders named \u0026ldquo;New\u0026rdquo; and \u0026ldquo;Folder\u0026rdquo;. Using Wildcards for Operations:\nTo perform operations on:\nAll files/folders: use *. Files with a specific extension (e.g., .exe): use *.exe. Files/folders starting with \u0026ldquo;hello\u0026rdquo;: use hello*. Use Relative Paths:\nPrefer using relative paths whenever possible to simplify navigation.\nExample: mv /home/username/Downloads/index.html /var/www/html/index.html moves a file to the web server directory. ","permalink":"http://localhost:1313/posts/pages/linux_cheatsheet/","summary":"A practical guide to navigating and managing files in Linux.","title":"Linux Commands and Directories Guide"},{"content":"Learning Journey Topics I Have Learned So Far Docker Linux Celery Django Channels Git Python Django JavaScript React Basics Virtualenv HTML CSS Tailwind Css C and C++ Basics What I Plan to Learn Next Async Deep Dive in Python WebSocket Deep Dive in Django Celery Deep Dive Redis for Cache Kafka Basics + Advanced Docker Advanced + Kubernetes Message Brokers Django Rest Framework (DRF) Django ORM Deep Dive React Advanced Git Advanced Django Docs+Advance Like class based views Python Books to Explore Developer\u0026rsquo;s Library: Python Distilled by David Beazley (2021) Fluent Python by Luciano Ramalho (2022) - O\u0026rsquo;Reilly Media Python Parallel Programming Cookbook by Giancarlo Zaccone (2019) Python Object-Oriented Programming Python Concurrency with Asyncio Additional Topics for Future Learning Real-time WebSocket usage in Django. Kafka streaming for handling large data volumes. Implementing Kubernetes for containerized applications. ","permalink":"http://localhost:1313/posts/pages/my_reading/","summary":"A detailed overview of my learning journey and future plans.","title":"Learning Journey"}]