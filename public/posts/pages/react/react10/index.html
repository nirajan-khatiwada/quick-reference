<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>React : 10 | Quick Reference</title>
<meta name=keywords content="React,Performance,memo,useCallback,useMemo,Web Development"><meta name=description content="A comprehensive guide on optimizing React applications using memo, useCallback and useMemo hooks."><meta name=author content="Nirajan Khatiwada"><link rel=canonical href=http://localhost:1313/posts/pages/react/react10/><link crossorigin=anonymous href=/assets/css/stylesheet.54405a410796490bc874ab6181fac9b675753cc2b91375d8f882566459eca428.css integrity="sha256-VEBaQQeWSQvIdKthgfrJtnV1PMK5E3XY+IJWZFnspCg=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/images/icon.png><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:1313/apple-touch-icon.png><link rel=mask-icon href=http://localhost:1313/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/pages/react/react10/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="React : 10"><meta property="og:description" content="A comprehensive guide on optimizing React applications using memo, useCallback and useMemo hooks."><meta property="og:type" content="article"><meta property="og:url" content="http://localhost:1313/posts/pages/react/react10/"><meta property="og:image" content="http://localhost:1313/images/react/react.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-11-25T00:00:00+00:00"><meta property="article:modified_time" content="2024-11-25T00:00:00+00:00"><meta property="og:site_name" content="Quick Reference"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/images/react/react.jpg"><meta name=twitter:title content="React : 10"><meta name=twitter:description content="A comprehensive guide on optimizing React applications using memo, useCallback and useMemo hooks."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"React : 10","item":"http://localhost:1313/posts/pages/react/react10/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"React : 10","name":"React : 10","description":"A comprehensive guide on optimizing React applications using memo, useCallback and useMemo hooks.","keywords":["React","Performance","memo","useCallback","useMemo","Web Development"],"articleBody":"44. Optimizing Performance 44.1. memo memo is a higher-order function in React that optimizes functional components by preventing unnecessary re-renders. It returns a new component that behaves the same as the original one but only re-renders if its props change or internal state changes not every time the parent component re-renders.\nWhy Use memo? When a parent component re-renders, all its child components also re-render by default—even if their props remain unchanged. This behavior can lead to performance bottlenecks. Using memo, we can avoid these unnecessary re-renders for child components.\nExample:\nimport { memo } from 'react'; const MyComponent = memo((props) =\u003e { return ( \u003cdiv\u003e \u003ch1\u003e{props.title}\u003c/h1\u003e \u003c/div\u003e ); }); export default MyComponent; In the above example, the MyComponent functional component is wrapped with the memo function. This ensures that the component will only re-render if its props have changed or if its satate has been change not every time the parent component re-renders.\nUse Case:\nBefore using memo: In this example, the Custom component re-renders unnecessarily whenever the parent component re-renders, even if its props haven’t changed or internal state hasn’t changed. Custom.js import { useState } from 'react'; const Custom = ({ title }) =\u003e { const [count, setCount] = useState(0); return ( \u003cdiv\u003e \u003ch1\u003e{title}\u003c/h1\u003e \u003cp\u003e{count}\u003c/p\u003e \u003cbutton onClick={() =\u003e setCount(count + 1)}\u003eIncrement\u003c/button\u003e \u003c/div\u003e ); }; export default Custom; App.js\nimport { useState } from 'react'; import Custom from './Custom'; function App() { const [count, setCount] = useState(0); return ( \u003cdiv\u003e \u003cCustom title=\"Counter\" /\u003e \u003cp\u003e{count}\u003c/p\u003e \u003cbutton onClick={() =\u003e setCount(count + 1)}\u003eIncrement Parent Count\u003c/button\u003e \u003c/div\u003e ); } export default App; Problem: The Custom component re-renders whenever the count state in the App component changes, even though the title prop remains the same. This can cause unnecessary rendering and reduce performance.i.e child component re-renders even if the props are not changed when the parent component re-renders.\nAfter using memo: Using memo, we can optimize the Custom component to only re-render when its props change. Custom.jsx import { useState, memo } from 'react'; const Custom = memo(({ title }) =\u003e { const [count, setCount] = useState(0); return ( \u003cdiv\u003e \u003ch1\u003e{title}\u003c/h1\u003e \u003cp\u003e{count}\u003c/p\u003e \u003cbutton onClick={() =\u003e setCount(count + 1)}\u003eIncrement\u003c/button\u003e \u003c/div\u003e ); }); export default Custom; App.js\nimport { useState } from 'react'; import Custom from './Custom'; function App() { const [count, setCount] = useState(0); return ( \u003cdiv\u003e \u003cCustom title=\"Counter\" /\u003e \u003cp\u003e{count}\u003c/p\u003e \u003cbutton onClick={() =\u003e setCount(count + 1)}\u003eIncrement Parent Count\u003c/button\u003e \u003c/div\u003e ); } export default App; After using memo the Custom component will only re-render when its props change or state change i.e when the title prop changes or the count state of the Custom component changes . It will not re-render when the count state of the App component changes, which optimizes performance in this scenario as that change does not affect the Custom component.\n44.2. useCallback In every rerender of a component, the functions defined inside the component are recreated. This can lead to performance issues, especially when passing functions as props to child components. useCallback is a hook in React that memoizes functions to prevent unnecessary re-creations.\nSyntax:\nuseCallback(fn, dependencies) fn: The function value that you want to cache. It can take any arguments and return any values. React will return (not call!) your function back to you during the initial render. On next renders, React will give you the same function again if the dependencies have not changed since the last render. Otherwise, it will give you the function that you have passed during the current render, and store it in case it can be reused later. React will not call your function. The function is returned to you so you can decide when and whether to call it. dependencies: An array of values that, when changed, will cause the function to be re-created. If the dependencies array is empty, the function will only be created once, and will not be re-created on subsequent renders. Whats the use of dependencies array in useCallback? just because dependency array the function is recreated with the new values of the dependencies.\nBefore using useCallback:\nimport { useState,memo } from 'react'; const Child = memo(({ handleClick }) =\u003e { return ( \u003cbutton onClick={handleClick}\u003eClick Me\u003c/button\u003e ); }); const Parent = () =\u003e { const [count, setCount] = useState(0); const handleClick = () =\u003e { setCount(count + 1); }; return ( \u003cdiv\u003e \u003cp\u003e{count}\u003c/p\u003e \u003cChild handleClick={handleClick} /\u003e \u003c/div\u003e ); }; In the above example, the handleClick function is re-created on every re-render of the Parent component. As a result, the reference to the handleClick function passed as a prop to the Child component changes on every re-render of the Parent component. This causes the Child component to re-render unnecessarily, even though the handleClick function remains logically the same After using useCallback:\nimport { useState, useCallback, memo } from 'react'; const Child = memo(({ handleClick }) =\u003e { return ( \u003cbutton onClick={handleClick}\u003eClick Me\u003c/button\u003e ); }); const Parent = () =\u003e { const [count, setCount] = useState(0); const handleClick = useCallback(() =\u003e { setCount(count + 1); }, [count]); return ( \u003cdiv\u003e \u003cp\u003e{count}\u003c/p\u003e \u003cChild handleClick={handleClick} /\u003e \u003c/div\u003e ); }; By using useCallback, the handleClick function is memoized and will only be re-created when the count state changes. The reference to the handleClick function remains the same across re-renders of the Parent component unless the dependencies specified in the dependency array (in this case, [count]) change. This ensures that the Child component only re-renders when the count state changes, and not when the handleClick function reference changes, thus improving performance.\n44.3. useMemo useMemo is a hook in React that memoizes the result of a function. It is similar to useCallback, but instead of memoizing a function, it memoizes the result of a function.\nSyntax:\nconst cachedValue = useMemo(calculateValue, dependencies) calculateValue: The function calculating the value that you want to cache. It should be pure, should take no arguments, and should return a value of any type. React will call your function during the initial render. On next renders, React will return the same value again if the dependencies have not changed since the last render. Otherwise, it will call calculateValue, return its result, and store it so it can be reused later. dependencies: An array of values that, when changed, will cause the function to be re-executed.\nreturn On the initial render, useMemo returns the result of calling calculateValue with no arguments.During next renders, it will either return an already stored value from the last render (if the dependencies haven’t changed), or call calculateValue again, and return the result that calculateValue has returned.\nBefore using useMemo:\nimport { useState, memo } from 'react'; const fibonacci = (n) =\u003e { if (n \u003c= 1) { return n; } return fibonacci(n - 1) + fibonacci(n - 2); }; const Fib = ()=\u003e{ const [count, setCount] = useState(1); const result = fibonacci(100000000000); return ( \u003cdiv\u003e \u003cp\u003e{result} and count is {count}\u003c/p\u003e \u003cbutton onClick={() =\u003e setCount(count + 1)}\u003eIncrease Count\u003c/button\u003e \u003c/div\u003e ); } In the above example, the fibonacci function is called on every re-render of the Fib component. This can lead to performance issues, especially when the function is computationally expensive. In this case, the fibonacci function is called with a large number, which can cause the component to freeze or crash.\nAfter using useMemo:\nimport { useState, useMemo } from 'react'; const fibonacci = (n) =\u003e { if (n \u003c= 1) { return n; } return fibonacci(n - 1) + fibonacci(n - 2); }; const Fib = ()=\u003e{ const [count, setCount] = useState(1); const result = useMemo(() =\u003e fibonacci(100000000000), []); return ( \u003cdiv\u003e \u003cp\u003e{result} and count is {count}\u003c/p\u003e \u003cbutton onClick={() =\u003e setCount(count + 1)}\u003eIncrease Count\u003c/button\u003e \u003c/div\u003e ); } By using useMemo, the result of the fibonacci function is memoized and will only be re-calculated when the dependencies specified in the dependency array change. In this case, the fibonacci function is only called once during the initial render of the Fib component, and the result is stored and reused on subsequent renders. This optimizes performance by preventing unnecessary re-calculation of the fibonacci function on every re-render of the component.\n45.Key conside a scenarion where your base component state variable need to be initialized with the value of the props passed to the component. since the state variable is initialized with the props value, the state variable will not be updated when the props value changes as it is initialized only. to handle we can either use useEffect or we can use key prop.\nUsing useEffect:\nimport { useEffect, useState } from 'react'; const Parent = () =\u003e { const [value, setValue] = useState(0); return ( \u003cdiv\u003e \u003cbutton onClick={() =\u003e setValue(value + 1)}\u003eIncrement\u003c/button\u003e \u003cChild value={value} /\u003e \u003c/div\u003e ); }; const Child = ({ value }) =\u003e { const [stateValue, setStateValue] = useState(value); useEffect(() =\u003e { setStateValue(value); }, [value]); return ( \u003cdiv\u003e \u003cp\u003eState Value: {stateValue}\u003c/p\u003e \u003cp\u003eProps Value: {value}\u003c/p\u003e \u003c/div\u003e ); }; stateValue is initialized with the value prop and const [stateValue, setStateValue] = useState(value); runs only once during initial render so useEffect is used to update the stateValue when the value prop changes.\nUsing key prop:\nimport { useState } from 'react'; const Parent = () =\u003e { const [value, setValue] = useState(0); return ( \u003cdiv\u003e \u003cbutton onClick={() =\u003e setValue(value + 1)}\u003eIncrement\u003c/button\u003e \u003cChild key={value} value={value} /\u003e \u003c/div\u003e ); }; const Child = ({ value }) =\u003e { const [stateValue, setStateValue] = useState(value); return ( \u003cdiv\u003e \u003cp\u003eState Value: {stateValue}\u003c/p\u003e \u003cp\u003eProps Value: {value}\u003c/p\u003e \u003c/div\u003e ); }; IN the above example,When a key changes between renders, React will create a new instance of the component. By using the key prop with the value prop, we ensure that a new instance of the Child component is created whenever the value prop changes. This allows the stateValue to be initialized with the new value prop on every render, without the need for useEffect.\nNote:The useState() hook us run only one time during the initial render of the component. If the state variable is initialized with a prop value, it will not be updated when the prop value changes. To handle this scenario, we can use the useEffect() hook to update the state variable when the prop value changes. Alternatively, we can use the key prop to create a new instance of the component whenever the prop value changes, allowing the state variable to be initialized with the new prop value on every render. Similar goes for useReducer() and useRef() hooks as well.\n","wordCount":"1718","inLanguage":"en","image":"http://localhost:1313/images/react/react.jpg","datePublished":"2024-11-25T00:00:00Z","dateModified":"2024-11-25T00:00:00Z","author":{"@type":"Person","name":"Nirajan Khatiwada"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/pages/react/react10/"},"publisher":{"@type":"Organization","name":"Quick Reference","logo":{"@type":"ImageObject","url":"http://localhost:1313/images/icon.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Quick Reference (Alt + H)">Quick Reference</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/categories/ title=Categories><span>Categories</span></a></li><li><a href=http://localhost:1313/tags/ title=Tags><span>Tags</span></a></li><li><a href=http://localhost:1313/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">React : 10</h1><div class=post-description>A comprehensive guide on optimizing React applications using memo, useCallback and useMemo hooks.</div><div class=post-meta><span title='2024-11-25 00:00:00 +0000 UTC'>November 25, 2024</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;1718 words&nbsp;·&nbsp;Nirajan Khatiwada&nbsp;|&nbsp;<a href=https://github.com/nirajan-khatiwada/quick-reference/tree/main/content/posts/pages/react/react10.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#441-memo>44.1. memo</a></li><li><a href=#442-usecallback>44.2. useCallback</a></li><li><a href=#443-usememo>44.3. useMemo</a></li></ul></nav></div></details></div><div class=post-content><h1 id=44-optimizing-performance>44. Optimizing Performance<a hidden class=anchor aria-hidden=true href=#44-optimizing-performance>#</a></h1><h2 id=441-memo>44.1. memo<a hidden class=anchor aria-hidden=true href=#441-memo>#</a></h2><p>memo is a higher-order function in React that optimizes functional components by preventing unnecessary re-renders. It returns a new component that behaves the same as the original one but only re-renders if its props change or internal state changes not every time the parent component re-renders.</p><p>Why Use memo?
When a parent component re-renders, all its child components also re-render by default—even if their props remain unchanged. This behavior can lead to performance bottlenecks. Using memo, we can avoid these unnecessary re-renders for child components.</p><p>Example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>memo</span> } <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#39;react&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>MyComponent</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>memo</span>((<span style=color:#a6e22e>props</span>) =&gt; {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> (
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#f92672>h1</span>&gt;{<span style=color:#a6e22e>props</span>.<span style=color:#a6e22e>title</span>}&lt;/<span style=color:#f92672>h1</span>&gt;
</span></span><span style=display:flex><span>    &lt;/<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>default</span> <span style=color:#a6e22e>MyComponent</span>;
</span></span></code></pre></div><p>In the above example, the <code>MyComponent</code> functional component is wrapped with the <code>memo</code> function. This ensures that the component will only re-render if its props have changed or if its satate has been change not every time the parent component re-renders.</p><p>Use Case:</p><ul><li>Before using memo:
In this example, the Custom component re-renders unnecessarily whenever the parent component re-renders, even if its props haven&rsquo;t changed or internal state hasn&rsquo;t changed.
Custom.js</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>useState</span> } <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#39;react&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>Custom</span> <span style=color:#f92672>=</span> ({ <span style=color:#a6e22e>title</span> }) =&gt; {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> [<span style=color:#a6e22e>count</span>, <span style=color:#a6e22e>setCount</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>useState</span>(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> (
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#f92672>h1</span>&gt;{<span style=color:#a6e22e>title</span>}&lt;/<span style=color:#f92672>h1</span>&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#f92672>p</span>&gt;{<span style=color:#a6e22e>count</span>}&lt;/<span style=color:#f92672>p</span>&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#f92672>button</span> <span style=color:#a6e22e>onClick</span><span style=color:#f92672>=</span>{() =&gt; <span style=color:#a6e22e>setCount</span>(<span style=color:#a6e22e>count</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)}&gt;<span style=color:#a6e22e>Increment</span>&lt;/<span style=color:#f92672>button</span>&gt;
</span></span><span style=display:flex><span>    &lt;/<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>default</span> <span style=color:#a6e22e>Custom</span>;
</span></span></code></pre></div><p>App.js</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>useState</span> } <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#39;react&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#a6e22e>Custom</span> <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#39;./Custom&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>App</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> [<span style=color:#a6e22e>count</span>, <span style=color:#a6e22e>setCount</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>useState</span>(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> (
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#f92672>Custom</span> <span style=color:#a6e22e>title</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;Counter&#34;</span> /&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#f92672>p</span>&gt;{<span style=color:#a6e22e>count</span>}&lt;/<span style=color:#f92672>p</span>&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#f92672>button</span> <span style=color:#a6e22e>onClick</span><span style=color:#f92672>=</span>{() =&gt; <span style=color:#a6e22e>setCount</span>(<span style=color:#a6e22e>count</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)}&gt;<span style=color:#a6e22e>Increment</span> <span style=color:#a6e22e>Parent</span> <span style=color:#a6e22e>Count</span>&lt;/<span style=color:#f92672>button</span>&gt;
</span></span><span style=display:flex><span>    &lt;/<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>default</span> <span style=color:#a6e22e>App</span>;
</span></span></code></pre></div><p>Problem: The Custom component re-renders whenever the count state in the App component changes, even though the title prop remains the same. This can cause unnecessary rendering and reduce performance.i.e child component re-renders even if the props are not changed when the parent component re-renders.</p><ul><li>After using memo:
Using memo, we can optimize the Custom component to only re-render when its props change.
Custom.jsx</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>useState</span>, <span style=color:#a6e22e>memo</span> } <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#39;react&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>Custom</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>memo</span>(({ <span style=color:#a6e22e>title</span> }) =&gt; {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> [<span style=color:#a6e22e>count</span>, <span style=color:#a6e22e>setCount</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>useState</span>(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> (
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#f92672>h1</span>&gt;{<span style=color:#a6e22e>title</span>}&lt;/<span style=color:#f92672>h1</span>&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#f92672>p</span>&gt;{<span style=color:#a6e22e>count</span>}&lt;/<span style=color:#f92672>p</span>&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#f92672>button</span> <span style=color:#a6e22e>onClick</span><span style=color:#f92672>=</span>{() =&gt; <span style=color:#a6e22e>setCount</span>(<span style=color:#a6e22e>count</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)}&gt;<span style=color:#a6e22e>Increment</span>&lt;/<span style=color:#f92672>button</span>&gt;
</span></span><span style=display:flex><span>    &lt;/<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>default</span> <span style=color:#a6e22e>Custom</span>;
</span></span></code></pre></div><p>App.js</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>useState</span> } <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#39;react&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#a6e22e>Custom</span> <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#39;./Custom&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>App</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> [<span style=color:#a6e22e>count</span>, <span style=color:#a6e22e>setCount</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>useState</span>(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> (
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#f92672>Custom</span> <span style=color:#a6e22e>title</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;Counter&#34;</span> /&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#f92672>p</span>&gt;{<span style=color:#a6e22e>count</span>}&lt;/<span style=color:#f92672>p</span>&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#f92672>button</span> <span style=color:#a6e22e>onClick</span><span style=color:#f92672>=</span>{() =&gt; <span style=color:#a6e22e>setCount</span>(<span style=color:#a6e22e>count</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)}&gt;<span style=color:#a6e22e>Increment</span> <span style=color:#a6e22e>Parent</span> <span style=color:#a6e22e>Count</span>&lt;/<span style=color:#f92672>button</span>&gt;
</span></span><span style=display:flex><span>    &lt;/<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>default</span> <span style=color:#a6e22e>App</span>;
</span></span></code></pre></div><p>After using memo the Custom component will only re-render when its props change or state change i.e when the title prop changes or the count state of the Custom component changes . It will not re-render when the count state of the App component changes, which optimizes performance in this scenario as that change does not affect the Custom component.</p><h2 id=442-usecallback>44.2. useCallback<a hidden class=anchor aria-hidden=true href=#442-usecallback>#</a></h2><p>In every rerender of a component, the functions defined inside the component are recreated. This can lead to performance issues, especially when passing functions as props to child components. useCallback is a hook in React that memoizes functions to prevent unnecessary re-creations.</p><p><em><strong>Syntax:</strong></em></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#a6e22e>useCallback</span>(<span style=color:#a6e22e>fn</span>, <span style=color:#a6e22e>dependencies</span>) 
</span></span></code></pre></div><ul><li><code>fn</code>: The function value that you want to cache. It can take any arguments and return any values. React will return (not call!) your function back to you during the initial render. On next renders, React will give you the same function again if the dependencies have not changed since the last render. Otherwise, it will give you the function that you have passed during the current render, and store it in case it can be reused later. React will not call your function. The function is returned to you so you can decide when and whether to call it.</li><li><code>dependencies</code>: An array of values that, when changed, will cause the function to be re-created. If the dependencies array is empty, the function will only be created once, and will not be re-created on subsequent renders.</li></ul><blockquote><p>Whats the use of dependencies array in useCallback?
just because dependency array the function is recreated with the new values of the dependencies.</p></blockquote><p><em><strong>Before using useCallback:</strong></em></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>useState</span>,<span style=color:#a6e22e>memo</span> } <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#39;react&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>Child</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>memo</span>(({ <span style=color:#a6e22e>handleClick</span> }) =&gt; {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> (
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>button</span> <span style=color:#a6e22e>onClick</span><span style=color:#f92672>=</span>{<span style=color:#a6e22e>handleClick</span>}&gt;<span style=color:#a6e22e>Click</span> <span style=color:#a6e22e>Me</span>&lt;/<span style=color:#f92672>button</span>&gt;
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>Parent</span> <span style=color:#f92672>=</span> () =&gt; {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> [<span style=color:#a6e22e>count</span>, <span style=color:#a6e22e>setCount</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>useState</span>(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>handleClick</span> <span style=color:#f92672>=</span> () =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>setCount</span>(<span style=color:#a6e22e>count</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> (
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#f92672>p</span>&gt;{<span style=color:#a6e22e>count</span>}&lt;/<span style=color:#f92672>p</span>&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#f92672>Child</span> <span style=color:#a6e22e>handleClick</span><span style=color:#f92672>=</span>{<span style=color:#a6e22e>handleClick</span>} /&gt;
</span></span><span style=display:flex><span>    &lt;/<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>In the above example, the handleClick function is re-created on every re-render of the Parent component. As a result, the reference to the handleClick function passed as a prop to the Child component changes on every re-render of the Parent component. This causes the Child component to re-render unnecessarily, even though the handleClick function remains logically the same
After using useCallback:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>useState</span>, <span style=color:#a6e22e>useCallback</span>, <span style=color:#a6e22e>memo</span> } <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#39;react&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>Child</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>memo</span>(({ <span style=color:#a6e22e>handleClick</span> }) =&gt; {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> (
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>button</span> <span style=color:#a6e22e>onClick</span><span style=color:#f92672>=</span>{<span style=color:#a6e22e>handleClick</span>}&gt;<span style=color:#a6e22e>Click</span> <span style=color:#a6e22e>Me</span>&lt;/<span style=color:#f92672>button</span>&gt;
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>Parent</span> <span style=color:#f92672>=</span> () =&gt; {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> [<span style=color:#a6e22e>count</span>, <span style=color:#a6e22e>setCount</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>useState</span>(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>handleClick</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>useCallback</span>(() =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>setCount</span>(<span style=color:#a6e22e>count</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>  }, [<span style=color:#a6e22e>count</span>]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> (
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#f92672>p</span>&gt;{<span style=color:#a6e22e>count</span>}&lt;/<span style=color:#f92672>p</span>&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#f92672>Child</span> <span style=color:#a6e22e>handleClick</span><span style=color:#f92672>=</span>{<span style=color:#a6e22e>handleClick</span>} /&gt;
</span></span><span style=display:flex><span>    &lt;/<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>By using useCallback, the handleClick function is memoized and will only be re-created when the count state changes. The reference to the handleClick function remains the same across re-renders of the Parent component unless the dependencies specified in the dependency array (in this case, [count]) change.
This ensures that the Child component only re-renders when the count state changes, and not when the handleClick function reference changes, thus improving performance.</p><h2 id=443-usememo>44.3. useMemo<a hidden class=anchor aria-hidden=true href=#443-usememo>#</a></h2><p>useMemo is a hook in React that memoizes the result of a function. It is similar to useCallback, but instead of memoizing a function, it memoizes the result of a function.</p><p><em><strong>Syntax:</strong></em></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>cachedValue</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>useMemo</span>(<span style=color:#a6e22e>calculateValue</span>, <span style=color:#a6e22e>dependencies</span>)
</span></span></code></pre></div><p>calculateValue: The function calculating the value that you want to cache. It should be pure, should take no arguments, and should return a value of any type. React will call your function during the initial render. On next renders, React will return the same value again if the dependencies have not changed since the last render. Otherwise, it will call calculateValue, return its result, and store it so it can be reused later.
dependencies: An array of values that, when changed, will cause the function to be re-executed.</p><p><em><strong>return</strong></em>
On the initial render, useMemo returns the result of calling calculateValue with no arguments.During next renders, it will either return an already stored value from the last render (if the dependencies haven’t changed), or call calculateValue again, and return the result that calculateValue has returned.</p><p><em><strong>Before using useMemo:</strong></em></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>useState</span>, <span style=color:#a6e22e>memo</span> } <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#39;react&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>fibonacci</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>n</span>) =&gt; {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>n</span> <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>n</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>fibonacci</span>(<span style=color:#a6e22e>n</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>+</span> <span style=color:#a6e22e>fibonacci</span>(<span style=color:#a6e22e>n</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>Fib</span> <span style=color:#f92672>=</span> ()=&gt;{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> [<span style=color:#a6e22e>count</span>, <span style=color:#a6e22e>setCount</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>useState</span>(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>result</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>fibonacci</span>(<span style=color:#ae81ff>100000000000</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> (
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#f92672>p</span>&gt;{<span style=color:#a6e22e>result</span>} <span style=color:#a6e22e>and</span> <span style=color:#a6e22e>count</span> <span style=color:#a6e22e>is</span> {<span style=color:#a6e22e>count</span>}&lt;/<span style=color:#f92672>p</span>&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#f92672>button</span> <span style=color:#a6e22e>onClick</span><span style=color:#f92672>=</span>{() =&gt; <span style=color:#a6e22e>setCount</span>(<span style=color:#a6e22e>count</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)}&gt;<span style=color:#a6e22e>Increase</span> <span style=color:#a6e22e>Count</span>&lt;/<span style=color:#f92672>button</span>&gt;
</span></span><span style=display:flex><span>    &lt;/<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>In the above example, the fibonacci function is called on every re-render of the Fib component. This can lead to performance issues, especially when the function is computationally expensive. In this case, the fibonacci function is called with a large number, which can cause the component to freeze or crash.</p><p><em><strong>After using useMemo:</strong></em></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>useState</span>, <span style=color:#a6e22e>useMemo</span> } <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#39;react&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>fibonacci</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>n</span>) =&gt; {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>n</span> <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>n</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>fibonacci</span>(<span style=color:#a6e22e>n</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>+</span> <span style=color:#a6e22e>fibonacci</span>(<span style=color:#a6e22e>n</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>Fib</span> <span style=color:#f92672>=</span> ()=&gt;{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> [<span style=color:#a6e22e>count</span>, <span style=color:#a6e22e>setCount</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>useState</span>(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>result</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>useMemo</span>(() =&gt; <span style=color:#a6e22e>fibonacci</span>(<span style=color:#ae81ff>100000000000</span>), []);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> (
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#f92672>p</span>&gt;{<span style=color:#a6e22e>result</span>} <span style=color:#a6e22e>and</span> <span style=color:#a6e22e>count</span> <span style=color:#a6e22e>is</span> {<span style=color:#a6e22e>count</span>}&lt;/<span style=color:#f92672>p</span>&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#f92672>button</span> <span style=color:#a6e22e>onClick</span><span style=color:#f92672>=</span>{() =&gt; <span style=color:#a6e22e>setCount</span>(<span style=color:#a6e22e>count</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)}&gt;<span style=color:#a6e22e>Increase</span> <span style=color:#a6e22e>Count</span>&lt;/<span style=color:#f92672>button</span>&gt;
</span></span><span style=display:flex><span>    &lt;/<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>By using useMemo, the result of the fibonacci function is memoized and will only be re-calculated when the dependencies specified in the dependency array change. In this case, the fibonacci function is only called once during the initial render of the Fib component, and the result is stored and reused on subsequent renders. This optimizes performance by preventing unnecessary re-calculation of the fibonacci function on every re-render of the component.</p><h1 id=45key>45.Key<a hidden class=anchor aria-hidden=true href=#45key>#</a></h1><p>conside a scenarion where your base component state variable need to be initialized with the value of the props passed to the component.
since the state variable is initialized with the props value, the state variable will not be updated when the props value changes as it is initialized only.
to handle we can either use useEffect or we can use key prop.</p><p><em><strong>Using useEffect:</strong></em></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>useEffect</span>, <span style=color:#a6e22e>useState</span> } <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#39;react&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>Parent</span> <span style=color:#f92672>=</span> () =&gt; {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> [<span style=color:#a6e22e>value</span>, <span style=color:#a6e22e>setValue</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>useState</span>(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> (
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#f92672>button</span> <span style=color:#a6e22e>onClick</span><span style=color:#f92672>=</span>{() =&gt; <span style=color:#a6e22e>setValue</span>(<span style=color:#a6e22e>value</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)}&gt;<span style=color:#a6e22e>Increment</span>&lt;/<span style=color:#f92672>button</span>&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#f92672>Child</span> <span style=color:#a6e22e>value</span><span style=color:#f92672>=</span>{<span style=color:#a6e22e>value</span>} /&gt;
</span></span><span style=display:flex><span>    &lt;/<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>Child</span> <span style=color:#f92672>=</span> ({ <span style=color:#a6e22e>value</span> }) =&gt; {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> [<span style=color:#a6e22e>stateValue</span>, <span style=color:#a6e22e>setStateValue</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>useState</span>(<span style=color:#a6e22e>value</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>useEffect</span>(() =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>setStateValue</span>(<span style=color:#a6e22e>value</span>);
</span></span><span style=display:flex><span>  }, [<span style=color:#a6e22e>value</span>]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> (
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#f92672>p</span>&gt;<span style=color:#a6e22e>State</span> <span style=color:#a6e22e>Value</span><span style=color:#f92672>:</span> {<span style=color:#a6e22e>stateValue</span>}&lt;/<span style=color:#f92672>p</span>&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#f92672>p</span>&gt;<span style=color:#a6e22e>Props</span> <span style=color:#a6e22e>Value</span><span style=color:#f92672>:</span> {<span style=color:#a6e22e>value</span>}&lt;/<span style=color:#f92672>p</span>&gt;
</span></span><span style=display:flex><span>    &lt;/<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>stateValue is initialized with the value prop and <code>const [stateValue, setStateValue] = useState(value);</code> runs only once during initial render so useEffect is used to update the stateValue when the value prop changes.</p><p><em><strong>Using key prop:</strong></em></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>useState</span> } <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#39;react&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>Parent</span> <span style=color:#f92672>=</span> () =&gt; {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> [<span style=color:#a6e22e>value</span>, <span style=color:#a6e22e>setValue</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>useState</span>(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> (
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#f92672>button</span> <span style=color:#a6e22e>onClick</span><span style=color:#f92672>=</span>{() =&gt; <span style=color:#a6e22e>setValue</span>(<span style=color:#a6e22e>value</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)}&gt;<span style=color:#a6e22e>Increment</span>&lt;/<span style=color:#f92672>button</span>&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#f92672>Child</span> <span style=color:#a6e22e>key</span><span style=color:#f92672>=</span>{<span style=color:#a6e22e>value</span>} <span style=color:#a6e22e>value</span><span style=color:#f92672>=</span>{<span style=color:#a6e22e>value</span>} /&gt;
</span></span><span style=display:flex><span>    &lt;/<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>Child</span> <span style=color:#f92672>=</span> ({ <span style=color:#a6e22e>value</span> }) =&gt; {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> [<span style=color:#a6e22e>stateValue</span>, <span style=color:#a6e22e>setStateValue</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>useState</span>(<span style=color:#a6e22e>value</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> (
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#f92672>p</span>&gt;<span style=color:#a6e22e>State</span> <span style=color:#a6e22e>Value</span><span style=color:#f92672>:</span> {<span style=color:#a6e22e>stateValue</span>}&lt;/<span style=color:#f92672>p</span>&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#f92672>p</span>&gt;<span style=color:#a6e22e>Props</span> <span style=color:#a6e22e>Value</span><span style=color:#f92672>:</span> {<span style=color:#a6e22e>value</span>}&lt;/<span style=color:#f92672>p</span>&gt;
</span></span><span style=display:flex><span>    &lt;/<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>IN the above example,When a key changes between renders, React will create a new instance of the component. By using the key prop with the value prop, we ensure that a new instance of the Child component is created whenever the value prop changes. This allows the stateValue to be initialized with the new value prop on every render, without the need for useEffect.</p><blockquote><p>Note:The <code>useState()</code> hook us run only one time during the initial render of the component. If the state variable is initialized with a prop value, it will not be updated when the prop value changes. To handle this scenario, we can use the <code>useEffect()</code> hook to update the state variable when the prop value changes. Alternatively, we can use the <code>key</code> prop to create a new instance of the component whenever the prop value changes, allowing the state variable to be initialized with the new prop value on every render.
Similar goes for useReducer() and useRef() hooks as well.</p></blockquote></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/react/>React</a></li><li><a href=http://localhost:1313/tags/performance/>Performance</a></li><li><a href=http://localhost:1313/tags/memo/>Memo</a></li><li><a href=http://localhost:1313/tags/usecallback/>UseCallback</a></li><li><a href=http://localhost:1313/tags/usememo/>UseMemo</a></li><li><a href=http://localhost:1313/tags/web-development/>Web Development</a></li></ul><nav class=paginav><a class=prev href=http://localhost:1313/posts/pages/react/react11/><span class=title>« Prev</span><br><span>React : 11</span>
</a><a class=next href=http://localhost:1313/posts/pages/react/react9/><span class=title>Next »</span><br><span>React : 9</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share React : 10 on x" href="https://x.com/intent/tweet/?text=React%20%3a%2010&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fpages%2freact%2freact10%2f&amp;hashtags=React%2cPerformance%2cmemo%2cuseCallback%2cuseMemo%2cWebDevelopment"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share React : 10 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fpages%2freact%2freact10%2f&amp;title=React%20%3a%2010&amp;summary=React%20%3a%2010&amp;source=http%3a%2f%2flocalhost%3a1313%2fposts%2fpages%2freact%2freact10%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share React : 10 on reddit" href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fposts%2fpages%2freact%2freact10%2f&title=React%20%3a%2010"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share React : 10 on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fposts%2fpages%2freact%2freact10%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share React : 10 on whatsapp" href="https://api.whatsapp.com/send?text=React%20%3a%2010%20-%20http%3a%2f%2flocalhost%3a1313%2fposts%2fpages%2freact%2freact10%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share React : 10 on telegram" href="https://telegram.me/share/url?text=React%20%3a%2010&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fpages%2freact%2freact10%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share React : 10 on ycombinator" href="https://news.ycombinator.com/submitlink?t=React%20%3a%2010&u=http%3a%2f%2flocalhost%3a1313%2fposts%2fpages%2freact%2freact10%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=http://localhost:1313/>Quick Reference</a></span> ·</footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>