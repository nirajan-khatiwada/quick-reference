<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Async io : Async io Intro (Day 1) | Quick Reference</title>
<meta name=keywords content="Python,Programming,asyncio,Tutorial"><meta name=description content="An introduction to asynchronous programming in Python using asyncio."><meta name=author content="Nirajan Khatiwada"><link rel=canonical href=http://localhost:1313/posts/pages/asyncio/asyncio1/><link crossorigin=anonymous href=/assets/css/stylesheet.54405a410796490bc874ab6181fac9b675753cc2b91375d8f882566459eca428.css integrity="sha256-VEBaQQeWSQvIdKthgfrJtnV1PMK5E3XY+IJWZFnspCg=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/images/icon.png><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:1313/apple-touch-icon.png><link rel=mask-icon href=http://localhost:1313/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/pages/asyncio/asyncio1/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Async io : Async io Intro (Day 1)"><meta property="og:description" content="An introduction to asynchronous programming in Python using asyncio."><meta property="og:type" content="article"><meta property="og:url" content="http://localhost:1313/posts/pages/asyncio/asyncio1/"><meta property="og:image" content="http://localhost:1313/images/python.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-11-21T00:00:00+00:00"><meta property="article:modified_time" content="2024-11-21T00:00:00+00:00"><meta property="og:site_name" content="Quick Reference"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/images/python.png"><meta name=twitter:title content="Async io : Async io Intro (Day 1)"><meta name=twitter:description content="An introduction to asynchronous programming in Python using asyncio."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"Async io : Async io Intro (Day 1)","item":"http://localhost:1313/posts/pages/asyncio/asyncio1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Async io : Async io Intro (Day 1)","name":"Async io : Async io Intro (Day 1)","description":"An introduction to asynchronous programming in Python using asyncio.","keywords":["Python","Programming","asyncio","Tutorial"],"articleBody":"1. Some Important Concepts 1.1 Parallism vs Concurrency Parallism: Running multiple tasks at the same time. There are multiple Threads or Processes running at the same time. Concurrency: Switching between multiple tasks. When one task is waiting for I/O, another task can run. There is only one Thread or Process running at a time. 1.2 Synchronous vs Asynchronous Synchronous: Code is executed in sequence. Previous task/line must be completed before the next task/line execution starts. Asynchronous: Code is executed in parallel. Tasks can run concurrently. The next task can start before the previous task is completed. 1.3 Blocking vs Non-Blocking Blocking: The execution of the code is blocked until the task is completed. The next task can’t start until the previous task is completed. import time def task1(): print(\"Task 1 started\") time.sleep(2) print(\"Task 1 completed\") def task2(): print(\"Task 2 started\") time.sleep(2) print(\"Task 2 completed\") task1() task2() Non-Blocking: The excecution of the code is not blocked. The next task can start before the previous task is completed. import asyncio async def task1(): print(\"Task 1 started\") await asyncio.sleep(2) print(\"Task 1 completed\") async def task2(): print(\"Task 2 started\") await asyncio.sleep(2) print(\"Task 2 completed\") async def main(): await asyncio.gather(task1(), task2()) asyncio.run(main()) 1.4 I/O Bound vs CPU Bound I/O Bound: The program is waiting for input/output operations to complete. The program is not using the CPU much. CPU Bound: The program is using the CPU a lot. The program is not waiting for input/output operations to complete. import request response = request.get(\"https://www.google.com\") # I/O Bound items = response.headers.items() # CPU Bound headers = [f'{key}: {header}' for key, header in items] # CPU Bound formatted_headers = '\\n'.join(headers) # CPU Bound with open('headers.txt', 'w') as file: # I/O Bound file.write(formatted_headers) # I/O Bound 2. How Concurrency is Achieved in Os level To better understand this, we’ll need to dive into how sockets work and, in particular, how non-blocking sockets work.\n2.1 Sockets A socket is a low-level abstraction for sending and receiving data over a network. It is the basis for how data is transferred to and from servers. Sockets support two main operations: sending bytes and receiving bytes. We write bytes to a socket, which will then get sent to a remote address, typically some type of server. Once we’ve sent those bytes, we wait for the server to write its response back to our socket. Once these bytes have been sent back to our socket, we can then read the result.\nIn the case of getting the contents from example.com as we saw earlier, we open a socket that connects to example.com’s server. We then write a request to get the contents to that socket and wait for the server to reply with the result: in this case, the HTML of the web page. We can visualize the flow of bytes to and from the server in figure 1.7\nSockets are blocking by default. Simply put, this means that when we are waiting for a server to reply with data, we halt our application or block it until we get data to read. Thus, our application stops running any other tasks until we get data from the server, an error happens, or there is a timeout. At the operating system level, we don’t need to do this blocking. Sockets can operate in non-blocking mode. In non-blocking mode, when we write bytes to a socket, we can just fire and forget the write or read, and our application can go on to perform other tasks. Later, we can have the operating system tell us that we received bytes and deal with it at that time. This lets the application do any number of things while we wait for bytes to come back to us. Instead of blocking and waiting for data to come to us, we become more reactive, letting the operating system inform us when there is data for us to act on. In the background, this is performed by a few different event notification systems, depending on which operating system we’re running. asyncio is abstracted enough that it switches between the different notification systems, depending on which one our operating system supports. The following are the event notification systems used by specific operating systems:\nkqueue—FreeBSD and MacOS epoll—Linux IOCP (I/O completion port)—Windows These systems keep track of our non-blocking sockets and notify us when they are ready for us to do something with them. This notification system is the basis of how asyncio can achieve concurrency.\nBut how do we keep track of multiple tasks that are waiting for data to come back to them? This is where the event loop comes in.\n2.2 Event Loop The event loop is the core of every asyncio application. In asyncio, the event loop keeps a queue of tasks.\n2.2.1 How the Event Loop Works The event loop works by keeping a queue of tasks instead of messages. Each task is a coroutine. When a task is added to the event loop, it will execute until it encounters an I/O operation (such as a web request). When a task hits an I/O-bound operation, it pauses and allows the event loop to run other tasks that are not waiting for I/O operations to complete. 2.2.2 Understanding Event Loops in Asynchronous Programming When working with event loops in asynchronous programming, the process can be understood as a sequence of steps that efficiently handle tasks without blocking the execution. Here’s a breakdown of how it works:\n2.2.2.1 Creating the Event Loop When an event loop is created, an empty queue of tasks is initialized. This queue will hold all the tasks that need to be executed.\n2.2.2.2 Adding Tasks to the Queue We add tasks to the event loop’s queue. These tasks are executed one at a time, based on their order in the queue.\n2.2.2.3 Processing Tasks Iteratively Each iteration of the event loop checks for tasks that need to be executed. It processes tasks sequentially, running them one by one.\n2.2.2.4 Handling I/O Operations If a task encounters an I/O operation (like reading from a file or making a network request), it cannot proceed immediately. In this case, the task is paused and put on hold.\n2.2.2.5 Pausing and Waiting for I/O Completion When a task is paused, the event loop instructs the operating system to monitor any associated sockets or resources for I/O completion. During this time, the event loop continues checking for and executing other tasks.\n2.2.2.6 Waking Up Paused Tasks On each iteration of the event loop, we check if any of the I/O operations have completed. If they have:\nThe paused task is woken up. The task resumes execution and completes its process. 2.2.2.7. Conclusion This cycle of pausing, waiting for I/O, and resuming tasks allows the event loop to run multiple tasks concurrently, making it an efficient way to handle asynchronous operations without blocking the program.\nBy continuously iterating and checking for completed I/O tasks, the event loop ensures that no task is left idle while waiting for I/O operations, enabling a smooth and efficient workflow.\nVisualizing the Event Loop with Asynchronous Tasks We can visualize how the event loop works with asynchronous tasks as shown in Figure 1.9: the main thread submits tasks to the event loop, which then runs them. When a task encounters an I/O operation, it pauses and allows other tasks to run. Once the I/O operation is complete, the paused task is resumed.\nExample: Submitting Multiple Asynchronous Tasks Let’s consider three tasks that each make an asynchronous web request. These tasks consist of:\nCPU-bound setup: Some code that prepares data for the web request. I/O-bound web request: The asynchronous part where we send the web request. CPU-bound post-processing: After the web request completes, we do some more CPU-intensive work. Now, let’s submit these tasks to the event loop simultaneously. Here’s how we can write this in pseudocode:\ndef make_request(): cpu_bound_setup() io_bound_web_request() cpu_bound_postprocess() task_one = make_request() task_two = make_request() task_three = make_request() First task starts executing code, and the other two are left waiting to run. Once the CPU-bound setup work is finished in Task 1, it hits an I/O-bound operation and will pause itself to say, “I’m waiting for I/O; any other tasks waiting to run can run.” Once this happens, Task 2 can begin executing. Task 2 starts its CPU-bound code and then pauses, waiting for I/O. At this time both Task 1 and Task 2 are waiting concurrently for their network request to complete. Since Tasks 1 and 2 are both paused waiting for I/O, we start running Task 3. Now imagine once Task 3 pauses to wait for its I/O to complete, the web request for Task 1 has finished. We’re now alerted by our operating system’s event notification system that this I/O has finished. We can now resume executing Task 1 while both Task 2 and Task 3 are waiting for their I/O to finish. In figure 1.10, we show the execution flow of the pseudocode we just described. If we look at any vertical slice of this diagram, we can see that only one CPU-bound piece of work is running at any given time; however, we have up to two I/O-bound operations happening concurrently. This overlapping of waiting for I/O per each task is where the real time savings of asyncio comes in.\n","wordCount":"1550","inLanguage":"en","image":"http://localhost:1313/images/python.png","datePublished":"2024-11-21T00:00:00Z","dateModified":"2024-11-21T00:00:00Z","author":{"@type":"Person","name":"Nirajan Khatiwada"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/pages/asyncio/asyncio1/"},"publisher":{"@type":"Organization","name":"Quick Reference","logo":{"@type":"ImageObject","url":"http://localhost:1313/images/icon.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Quick Reference (Alt + H)">Quick Reference</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/categories/ title=Categories><span>Categories</span></a></li><li><a href=http://localhost:1313/tags/ title=Tags><span>Tags</span></a></li><li><a href=http://localhost:1313/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Async io : Async io Intro (Day 1)</h1><div class=post-description>An introduction to asynchronous programming in Python using asyncio.</div><div class=post-meta><span title='2024-11-21 00:00:00 +0000 UTC'>November 21, 2024</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;1550 words&nbsp;·&nbsp;Nirajan Khatiwada&nbsp;|&nbsp;<a href=https://github.com/nirajan-khatiwada/quick-reference/tree/main/content/posts/pages/asyncio/asyncio1.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#11-parallism-vs-concurrency>1.1 Parallism vs Concurrency</a></li><li><a href=#12-synchronous-vs-asynchronous>1.2 Synchronous vs Asynchronous</a></li><li><a href=#13-blocking-vs-non-blocking>1.3 Blocking vs Non-Blocking</a></li><li><a href=#14-io-bound-vs-cpu-bound>1.4 I/O Bound vs CPU Bound</a></li></ul><ul><li><a href=#21-sockets>2.1 Sockets</a></li><li><a href=#22-event-loop>2.2 Event Loop</a><ul><li><a href=#221-how-the-event-loop-works>2.2.1 How the Event Loop Works</a></li><li><a href=#222-understanding-event-loops-in-asynchronous-programming>2.2.2 Understanding Event Loops in Asynchronous Programming</a></li></ul></li><li><a href=#visualizing-the-event-loop-with-asynchronous-tasks>Visualizing the Event Loop with Asynchronous Tasks</a><ul><li><a href=#example-submitting-multiple-asynchronous-tasks>Example: Submitting Multiple Asynchronous Tasks</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h1 id=1-some-important-concepts>1. Some Important Concepts<a hidden class=anchor aria-hidden=true href=#1-some-important-concepts>#</a></h1><h2 id=11-parallism-vs-concurrency>1.1 Parallism vs Concurrency<a hidden class=anchor aria-hidden=true href=#11-parallism-vs-concurrency>#</a></h2><ul><li><strong>Parallism</strong>: Running multiple tasks at the same time. There are multiple Threads or Processes running at the same time.</li><li><strong>Concurrency</strong>: Switching between multiple tasks. When one task is waiting for I/O, another task can run. There is only one Thread or Process running at a time.</li></ul><p><img loading=lazy src=/gif/Concurrency-vs-Parallelism.gif alt="Concurrency vs Parallism"></p><h2 id=12-synchronous-vs-asynchronous>1.2 Synchronous vs Asynchronous<a hidden class=anchor aria-hidden=true href=#12-synchronous-vs-asynchronous>#</a></h2><ul><li><strong>Synchronous</strong>: Code is executed in sequence. Previous task/line must be completed before the next task/line execution starts.</li><li><strong>Asynchronous</strong>: Code is executed in parallel. Tasks can run concurrently. The next task can start before the previous task is completed.</li></ul><h2 id=13-blocking-vs-non-blocking>1.3 Blocking vs Non-Blocking<a hidden class=anchor aria-hidden=true href=#13-blocking-vs-non-blocking>#</a></h2><ul><li><strong>Blocking</strong>: The execution of the code is blocked until the task is completed. The next task can&rsquo;t start until the previous task is completed.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> time
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>task1</span>():
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;Task 1 started&#34;</span>)
</span></span><span style=display:flex><span>    time<span style=color:#f92672>.</span>sleep(<span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;Task 1 completed&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>task2</span>():
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;Task 2 started&#34;</span>)
</span></span><span style=display:flex><span>    time<span style=color:#f92672>.</span>sleep(<span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;Task 2 completed&#34;</span>)
</span></span><span style=display:flex><span>task1()
</span></span><span style=display:flex><span>task2()
</span></span></code></pre></div><ul><li><strong>Non-Blocking</strong>: The excecution of the code is not blocked. The next task can start before the previous task is completed.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> asyncio
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>task1</span>():
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;Task 1 started&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>await</span> asyncio<span style=color:#f92672>.</span>sleep(<span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;Task 1 completed&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>task2</span>():
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;Task 2 started&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>await</span> asyncio<span style=color:#f92672>.</span>sleep(<span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;Task 2 completed&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>main</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>await</span> asyncio<span style=color:#f92672>.</span>gather(task1(), task2())
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>asyncio<span style=color:#f92672>.</span>run(main())
</span></span></code></pre></div><h2 id=14-io-bound-vs-cpu-bound>1.4 I/O Bound vs CPU Bound<a hidden class=anchor aria-hidden=true href=#14-io-bound-vs-cpu-bound>#</a></h2><ul><li><strong>I/O Bound</strong>: The program is waiting for input/output operations to complete. The program is not using the CPU much.</li><li><strong>CPU Bound</strong>: The program is using the CPU a lot. The program is not waiting for input/output operations to complete.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> request
</span></span><span style=display:flex><span>response <span style=color:#f92672>=</span> request<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#34;https://www.google.com&#34;</span>)  <span style=color:#75715e># I/O Bound</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>items <span style=color:#f92672>=</span> response<span style=color:#f92672>.</span>headers<span style=color:#f92672>.</span>items()  <span style=color:#75715e># CPU Bound</span>
</span></span><span style=display:flex><span>headers <span style=color:#f92672>=</span> [<span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>{</span>key<span style=color:#e6db74>}</span><span style=color:#e6db74>: </span><span style=color:#e6db74>{</span>header<span style=color:#e6db74>}</span><span style=color:#e6db74>&#39;</span> <span style=color:#66d9ef>for</span> key, header <span style=color:#f92672>in</span> items]  <span style=color:#75715e># CPU Bound</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>formatted_headers <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#39;</span><span style=color:#f92672>.</span>join(headers) <span style=color:#75715e># CPU Bound</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>with</span> open(<span style=color:#e6db74>&#39;headers.txt&#39;</span>, <span style=color:#e6db74>&#39;w&#39;</span>) <span style=color:#66d9ef>as</span> file: <span style=color:#75715e># I/O Bound</span>
</span></span><span style=display:flex><span>    file<span style=color:#f92672>.</span>write(formatted_headers)      <span style=color:#75715e># I/O Bound</span>
</span></span></code></pre></div><h1 id=2-how-concurrency-is-achieved-in-os-level>2. How Concurrency is Achieved in Os level<a hidden class=anchor aria-hidden=true href=#2-how-concurrency-is-achieved-in-os-level>#</a></h1><p>To better understand this, we’ll need to dive into how sockets work and, in particular, how non-blocking sockets work.</p><h2 id=21-sockets>2.1 Sockets<a hidden class=anchor aria-hidden=true href=#21-sockets>#</a></h2><p>A socket is a low-level abstraction for sending and receiving data over a network. It is the basis for how data is transferred to and from servers. Sockets support two main operations: sending bytes and receiving bytes. We write bytes to a socket, which will then get sent to a remote address, typically some type of server. Once we’ve sent those bytes, we wait for the server to write its response back to our socket. Once these bytes have been sent back to our socket, we can then read the result.</p><p>In the case of getting the contents from example.com as we saw earlier, we open a socket that connects to example.com’s server. We then write a request to get the contents to that socket and wait for the server to reply with the result: in this case, the HTML of the web page. We can visualize the flow of bytes to and from the server in figure 1.7</p><p><img loading=lazy src=/images/socket.png#center alt=Sockets></p><p>Sockets are blocking by default. Simply put, this means that when we are waiting for a server to reply with data, we halt our application or block it until we get data to read. Thus, our application stops running any other tasks until we get data from the server, an error happens, or there is a timeout. At the operating system level, we don’t need to do this blocking. Sockets can operate in non-blocking mode. In non-blocking mode, when we write bytes to a socket, we can just fire and forget the write or read, and our application can go on to perform other tasks. Later, we can have the operating system tell us that we received bytes and deal with it at that time. This lets the application do any number of things while we wait for bytes to come back to us. Instead of blocking and waiting for data to come to us, we become more reactive, letting the operating system inform us when there is data for us to act on. In the background, this is performed by a few different event notification systems, depending on which operating system we’re running. asyncio is abstracted enough that it switches between the different notification systems, depending on which one our operating system supports. The following are the event notification systems used by specific operating systems:</p><ul><li>kqueue—FreeBSD and MacOS</li><li>epoll—Linux</li><li>IOCP (I/O completion port)—Windows</li></ul><p>These systems keep track of our non-blocking sockets and notify us when they are ready for us to do something with them. This notification system is the basis of how asyncio can achieve concurrency.</p><p><img loading=lazy src=/images/socket1.png#center alt=Socket1></p><p>But how do we keep track of multiple tasks that are waiting for data to come back to them? This is where the event loop comes in.</p><h2 id=22-event-loop>2.2 Event Loop<a hidden class=anchor aria-hidden=true href=#22-event-loop>#</a></h2><p>The event loop is the core of every asyncio application. In asyncio, the event loop keeps a queue of tasks.</p><h3 id=221-how-the-event-loop-works>2.2.1 How the Event Loop Works<a hidden class=anchor aria-hidden=true href=#221-how-the-event-loop-works>#</a></h3><ul><li>The event loop works by keeping a <strong>queue of tasks</strong> instead of messages. Each task is a <strong>coroutine</strong>.</li><li>When a task is added to the event loop, it will execute until it encounters an I/O operation (such as a web request).</li><li><strong>When a task hits an I/O-bound operation</strong>, it pauses and allows the event loop to run other tasks that are not waiting for I/O operations to complete.</li></ul><h3 id=222-understanding-event-loops-in-asynchronous-programming>2.2.2 Understanding Event Loops in Asynchronous Programming<a hidden class=anchor aria-hidden=true href=#222-understanding-event-loops-in-asynchronous-programming>#</a></h3><p>When working with <strong>event loops</strong> in asynchronous programming, the process can be understood as a sequence of steps that efficiently handle tasks without blocking the execution. Here&rsquo;s a breakdown of how it works:</p><h4 id=2221-creating-the-event-loop>2.2.2.1 <strong>Creating the Event Loop</strong><a hidden class=anchor aria-hidden=true href=#2221-creating-the-event-loop>#</a></h4><p>When an event loop is created, an <strong>empty queue of tasks</strong> is initialized. This queue will hold all the tasks that need to be executed.</p><h4 id=2222-adding-tasks-to-the-queue>2.2.2.2 <strong>Adding Tasks to the Queue</strong><a hidden class=anchor aria-hidden=true href=#2222-adding-tasks-to-the-queue>#</a></h4><p>We add tasks to the event loop’s queue. These tasks are executed one at a time, based on their order in the queue.</p><h4 id=2223-processing-tasks-iteratively>2.2.2.3 <strong>Processing Tasks Iteratively</strong><a hidden class=anchor aria-hidden=true href=#2223-processing-tasks-iteratively>#</a></h4><p>Each iteration of the event loop checks for tasks that need to be executed. It processes tasks sequentially, running them one by one.</p><h4 id=2224-handling-io-operations>2.2.2.4 <strong>Handling I/O Operations</strong><a hidden class=anchor aria-hidden=true href=#2224-handling-io-operations>#</a></h4><p>If a task encounters an <strong>I/O operation</strong> (like reading from a file or making a network request), it cannot proceed immediately. In this case, the task is <strong>paused</strong> and put on hold.</p><h4 id=2225-pausing-and-waiting-for-io-completion>2.2.2.5 <strong>Pausing and Waiting for I/O Completion</strong><a hidden class=anchor aria-hidden=true href=#2225-pausing-and-waiting-for-io-completion>#</a></h4><p>When a task is paused, the event loop instructs the <strong>operating system</strong> to monitor any associated sockets or resources for I/O completion. During this time, the event loop continues checking for and executing other tasks.</p><h4 id=2226-waking-up-paused-tasks>2.2.2.6 <strong>Waking Up Paused Tasks</strong><a hidden class=anchor aria-hidden=true href=#2226-waking-up-paused-tasks>#</a></h4><p>On each iteration of the event loop, we check if any of the I/O operations have completed. If they have:</p><ul><li>The paused task is <strong>woken up</strong>.</li><li>The task resumes execution and completes its process.</li></ul><h4 id=2227-conclusion>2.2.2.7. <strong>Conclusion</strong><a hidden class=anchor aria-hidden=true href=#2227-conclusion>#</a></h4><p>This cycle of pausing, waiting for I/O, and resuming tasks allows the event loop to run multiple tasks concurrently, making it an efficient way to handle asynchronous operations without blocking the program.</p><hr><p>By continuously iterating and checking for completed I/O tasks, the event loop ensures that no task is left idle while waiting for I/O operations, enabling a smooth and efficient workflow.</p><h2 id=visualizing-the-event-loop-with-asynchronous-tasks>Visualizing the Event Loop with Asynchronous Tasks<a hidden class=anchor aria-hidden=true href=#visualizing-the-event-loop-with-asynchronous-tasks>#</a></h2><p>We can visualize how the event loop works with asynchronous tasks as shown in <strong>Figure 1.9</strong>: the main thread submits tasks to the event loop, which then runs them. When a task encounters an I/O operation, it pauses and allows other tasks to run. Once the I/O operation is complete, the paused task is resumed.</p><h3 id=example-submitting-multiple-asynchronous-tasks>Example: Submitting Multiple Asynchronous Tasks<a hidden class=anchor aria-hidden=true href=#example-submitting-multiple-asynchronous-tasks>#</a></h3><p>Let&rsquo;s consider three tasks that each make an asynchronous web request. These tasks consist of:</p><ol><li><strong>CPU-bound setup</strong>: Some code that prepares data for the web request.</li><li><strong>I/O-bound web request</strong>: The asynchronous part where we send the web request.</li><li><strong>CPU-bound post-processing</strong>: After the web request completes, we do some more CPU-intensive work.</li></ol><p>Now, let&rsquo;s submit these tasks to the event loop simultaneously. Here’s how we can write this in <strong>pseudocode</strong>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>make_request</span>():
</span></span><span style=display:flex><span>    cpu_bound_setup()
</span></span><span style=display:flex><span>    io_bound_web_request()
</span></span><span style=display:flex><span>    cpu_bound_postprocess()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>task_one <span style=color:#f92672>=</span> make_request()
</span></span><span style=display:flex><span>task_two <span style=color:#f92672>=</span> make_request()
</span></span><span style=display:flex><span>task_three <span style=color:#f92672>=</span> make_request()
</span></span></code></pre></div><p><img loading=lazy src=/images/event-loop.png#center alt="Event Loop"></p><p>First task starts executing code, and the other two are left waiting to run. Once the CPU-bound setup work is finished in Task 1, it hits an I/O-bound operation and will pause itself to say, “I’m waiting for I/O; any other tasks waiting to run can run.” Once this happens, Task 2 can begin executing. Task 2 starts its CPU-bound code and then pauses, waiting for I/O. At this time both Task 1 and Task 2 are waiting concurrently for their network request to complete. Since Tasks 1 and 2 are both paused waiting for I/O, we start running Task 3. Now imagine once Task 3 pauses to wait for its I/O to complete, the web request for Task 1 has finished. We’re now alerted by our operating system’s event notification system that this I/O has finished. We can now resume executing Task 1 while both Task 2 and Task 3 are waiting for their I/O to finish. In figure 1.10, we show the execution flow of the pseudocode we just described. If we look at any vertical slice of this diagram, we can see that only one CPU-bound piece of work is running at any given time; however, we have up to two I/O-bound operations happening concurrently. This overlapping of waiting for I/O per each task is where the real time savings of asyncio comes in.</p><p><img loading=lazy src=/images/concurrency.png#center alt="concurrency png of asyncio"></p></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/python/>Python</a></li><li><a href=http://localhost:1313/tags/programming/>Programming</a></li><li><a href=http://localhost:1313/tags/asyncio/>Asyncio</a></li><li><a href=http://localhost:1313/tags/tutorial/>Tutorial</a></li></ul><nav class=paginav><a class=prev href=http://localhost:1313/posts/pages/asyncio/asyncio2/><span class=title>« Prev</span><br><span>Async io : Asyncio Basics (Day 2)</span>
</a><a class=next href=http://localhost:1313/posts/pages/python/python_basics/><span class=title>Next »</span><br><span>Python Fundamentals: A Beginner's Guide (Part 1)</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Async io : Async io Intro (Day 1) on x" href="https://x.com/intent/tweet/?text=Async%20io%20%3a%20Async%20io%20Intro%20%28Day%201%29&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fpages%2fasyncio%2fasyncio1%2f&amp;hashtags=Python%2cProgramming%2casyncio%2cTutorial"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Async io : Async io Intro (Day 1) on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fpages%2fasyncio%2fasyncio1%2f&amp;title=Async%20io%20%3a%20Async%20io%20Intro%20%28Day%201%29&amp;summary=Async%20io%20%3a%20Async%20io%20Intro%20%28Day%201%29&amp;source=http%3a%2f%2flocalhost%3a1313%2fposts%2fpages%2fasyncio%2fasyncio1%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Async io : Async io Intro (Day 1) on reddit" href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fposts%2fpages%2fasyncio%2fasyncio1%2f&title=Async%20io%20%3a%20Async%20io%20Intro%20%28Day%201%29"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Async io : Async io Intro (Day 1) on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fposts%2fpages%2fasyncio%2fasyncio1%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Async io : Async io Intro (Day 1) on whatsapp" href="https://api.whatsapp.com/send?text=Async%20io%20%3a%20Async%20io%20Intro%20%28Day%201%29%20-%20http%3a%2f%2flocalhost%3a1313%2fposts%2fpages%2fasyncio%2fasyncio1%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Async io : Async io Intro (Day 1) on telegram" href="https://telegram.me/share/url?text=Async%20io%20%3a%20Async%20io%20Intro%20%28Day%201%29&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fpages%2fasyncio%2fasyncio1%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Async io : Async io Intro (Day 1) on ycombinator" href="https://news.ycombinator.com/submitlink?t=Async%20io%20%3a%20Async%20io%20Intro%20%28Day%201%29&u=http%3a%2f%2flocalhost%3a1313%2fposts%2fpages%2fasyncio%2fasyncio1%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=http://localhost:1313/>Quick Reference</a></span> ·</footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>