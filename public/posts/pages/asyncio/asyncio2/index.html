<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Async io : Asyncio Basics (Day 2) | Quick Reference</title>
<meta name=keywords content="Python,Programming,asyncio,Tutorial"><meta name=description content="how to write programs using this single-threaded concurrency model with asyncio"><meta name=author content="Nirajan Khatiwada"><link rel=canonical href=http://localhost:1313/posts/pages/asyncio/asyncio2/><link crossorigin=anonymous href=/assets/css/stylesheet.54405a410796490bc874ab6181fac9b675753cc2b91375d8f882566459eca428.css integrity="sha256-VEBaQQeWSQvIdKthgfrJtnV1PMK5E3XY+IJWZFnspCg=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/images/icon.png><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:1313/apple-touch-icon.png><link rel=mask-icon href=http://localhost:1313/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/pages/asyncio/asyncio2/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Async io : Asyncio Basics (Day 2)"><meta property="og:description" content="how to write programs using this single-threaded concurrency model with asyncio"><meta property="og:type" content="article"><meta property="og:url" content="http://localhost:1313/posts/pages/asyncio/asyncio2/"><meta property="og:image" content="http://localhost:1313/images/python.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-11-22T00:00:00+00:00"><meta property="article:modified_time" content="2024-11-22T00:00:00+00:00"><meta property="og:site_name" content="Quick Reference"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/images/python.png"><meta name=twitter:title content="Async io : Asyncio Basics (Day 2)"><meta name=twitter:description content="how to write programs using this single-threaded concurrency model with asyncio"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"Async io : Asyncio Basics (Day 2)","item":"http://localhost:1313/posts/pages/asyncio/asyncio2/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Async io : Asyncio Basics (Day 2)","name":"Async io : Asyncio Basics (Day 2)","description":"how to write programs using this single-threaded concurrency model with asyncio","keywords":["Python","Programming","asyncio","Tutorial"],"articleBody":"1.1 When to use asyncio? Asyncio is a library to write concurrent code using the async/await syntax. It is a single-threaded, single-process design that is ideal for I/O-bound and high-level structured network code. It is not suitable for CPU-bound code, which is better handled by the multiprocessing module.It is used for :\n2.1 Coroutine Think of a coroutine like a regular Python function but with the superpower that it can pause its execution when it encounters an operation that could take a while to complete. When that long-running operation is complete, we can “wake up” our paused coroutine and finish executing any other code in that coroutine. While a paused coroutine is waiting for the operation it paused for to finish, we can run other code. This running of other code while waiting is what gives our application concur rency. We can also run several time-consuming operations concurrently, which can give our applications big performance improvements. To both create and pause a coroutine, we’ll need to learn to use Python’s async and await keywords. The async keyword will let us define a coroutine; the await key word will let us pause our coroutine when we have a long-running operation.\n2.2 Creating a coroutine with async creating a coroutine is straightforward and not much different from creating a nor mal Python function. The only difference is that, instead of using the def keyword, we use async def. The async keyword marks a function as a coroutine instead of a nor mal Python function.\nimport asyncio async def mero_coroutine(): print(\"Hello From Asyncio\") The coroutine in the preceding listing does nothing yet other than print “Hello world!” It’s also worth noting that this coroutine does not perform any long-running operations; it just prints our message and returns. This means that, when we put the coroutine on the event loop, it will execute immediately because we don’t have any blocking I/O, and nothing is pausing execution yet. This syntax is simple, but we’re creating something very different from a plain Python function. To illustrate this, let’s create a function that adds one to an integer as well as a coroutine that does the same and compare the results of calling each. We’ll also use the type convenience function to look at the type returned by calling a corou tine as compared to calling our normal function.\ndef add_function(a,b): return a+b async def add_coroutine(a,b): return a+b function=add_function(1,2) coroutine=add_coroutine(1,2) print(type(function)) print(type(coroutine)) When we run this code, we’ll see output like the following\nMethod result is 3 and the type is ","wordCount":"3417","inLanguage":"en","image":"http://localhost:1313/images/python.png","datePublished":"2024-11-22T00:00:00Z","dateModified":"2024-11-22T00:00:00Z","author":{"@type":"Person","name":"Nirajan Khatiwada"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/pages/asyncio/asyncio2/"},"publisher":{"@type":"Organization","name":"Quick Reference","logo":{"@type":"ImageObject","url":"http://localhost:1313/images/icon.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Quick Reference (Alt + H)">Quick Reference</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/categories/ title=Categories><span>Categories</span></a></li><li><a href=http://localhost:1313/tags/ title=Tags><span>Tags</span></a></li><li><a href=http://localhost:1313/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Async io : Asyncio Basics (Day 2)</h1><div class=post-description>how to write programs using this single-threaded concurrency model with asyncio</div><div class=post-meta><span title='2024-11-22 00:00:00 +0000 UTC'>November 22, 2024</span>&nbsp;·&nbsp;17 min&nbsp;·&nbsp;3417 words&nbsp;·&nbsp;Nirajan Khatiwada&nbsp;|&nbsp;<a href=https://github.com/nirajan-khatiwada/quick-reference/tree/main/content/posts/pages/asyncio/asyncio2.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#11-when-to-use-asyncio>1.1 When to use asyncio?</a></li><li><a href=#21-coroutine>2.1 Coroutine</a></li><li><a href=#22-creating-a-coroutine-with-async>2.2 Creating a coroutine with async</a></li><li><a href=#23--pausing-execution-with-the-await-keyword>2.3 Pausing execution with the await keyword</a></li><li><a href=#24--introducing-long-running-coroutines-with-sleep>2.4 Introducing long-running coroutines with sleep</a></li><li><a href=#25-running-concurrently-with-task>2.5 Running concurrently with task</a><ul><li><a href=#key-points>Key Points:</a></li><li><a href=#code-example-creating-and-using-a-task>Code Example: Creating and Using a Task</a></li><li><a href=#whats-happening-in-the-code>What’s Happening in the Code:</a></li><li><a href=#why-await-is-important>Why Await is Important:</a></li></ul></li></ul><ul><li><a href=#asynciogather-function><code>asyncio.gather</code> function</a></li></ul><ul><li><a href=#31-locks>3.1 Locks</a></li><li><a href=#32-semaphores>3.2 Semaphores</a></li><li><a href=#some-popular-asyncio-libraries>Some popular asyncio libraries</a></li></ul></nav></div></details></div><div class=post-content><h2 id=11-when-to-use-asyncio>1.1 When to use asyncio?<a hidden class=anchor aria-hidden=true href=#11-when-to-use-asyncio>#</a></h2><p>Asyncio is a library to write concurrent code using the async/await syntax. It is a single-threaded, single-process design that is ideal for I/O-bound and high-level structured network code. It is not suitable for CPU-bound code, which is better handled by the multiprocessing module.It is used for :</p><h2 id=21-coroutine>2.1 Coroutine<a hidden class=anchor aria-hidden=true href=#21-coroutine>#</a></h2><p>Think of a coroutine like a regular Python function but with the superpower that it
can pause its execution when it encounters an operation that could take a while to
complete. When that long-running operation is complete, we can “wake up” our
paused coroutine and finish executing any other code in that coroutine. While a
paused coroutine is waiting for the operation it paused for to finish, we can run other
code. This running of other code while waiting is what gives our application concur
rency. We can also run several time-consuming operations concurrently, which can
give our applications big performance improvements.
To both create and pause a coroutine, we’ll need to learn to use Python’s async
and await keywords. The async keyword will let us define a coroutine; the await key
word will let us pause our coroutine when we have a long-running operation.</p><h2 id=22-creating-a-coroutine-with-async>2.2 Creating a coroutine with async<a hidden class=anchor aria-hidden=true href=#22-creating-a-coroutine-with-async>#</a></h2><p>creating a coroutine is straightforward and not much different from creating a nor
mal Python function. The only difference is that, instead of using the def keyword, we
use async def. The async keyword marks a function as a coroutine instead of a nor
mal Python function.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> asyncio
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>mero_coroutine</span>():
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;Hello From Asyncio&#34;</span>)
</span></span></code></pre></div><p>The coroutine in the preceding listing does nothing yet other than print “Hello
world!” It’s also worth noting that this coroutine does not perform any long-running
operations; it just prints our message and returns. This means that, when we put the
coroutine on the event loop, it will execute immediately because we don’t have any
blocking I/O, and nothing is pausing execution yet.
This syntax is simple, but we’re creating something very different from a plain
Python function. To illustrate this, let’s create a function that adds one to an integer as
well as a coroutine that does the same and compare the results of calling each. We’ll
also use the type convenience function to look at the type returned by calling a corou
tine as compared to calling our normal function.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>add_function</span>(a,b):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> a<span style=color:#f92672>+</span>b
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>add_coroutine</span>(a,b):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> a<span style=color:#f92672>+</span>b
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>function<span style=color:#f92672>=</span>add_function(<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>coroutine<span style=color:#f92672>=</span>add_coroutine(<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>print(type(function))
</span></span><span style=display:flex><span>print(type(coroutine))
</span></span></code></pre></div><p>When we run this code, we’ll see output like the following</p><pre tabindex=0><code> Method result is 3 and the type is &lt;class &#39;int&#39;&gt;
 Coroutine result is &lt;coroutine object coroutine_add_one at 0x1071d6040&gt; and 
the type is &lt;class &#39;coroutine&#39;&gt;
</code></pre><p>Notice how when we call our normal add_one function it executes immediately and
returns what we would expect, another integer. However, when we call coroutine_
add_one we don’t get our code in the coroutine executed at all. We get a coroutine
object instead.
This is an important point, as coroutines aren’t executed when we call them
directly. Instead, we create a coroutine object that can be run later. To run a corou
tine, we need to explicitly run it on an event loop. So how can we create an event loop
and run our coroutine?</p><p>In versions of Python older than 3.7, we had to create an event loop if one did not
already exist. However, the asyncio library has added several functions that abstract
the event loop management. There is a convenience function, asyncio.run, we can
use to run our coroutine. This is illustrated in the following listing.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> asyncio
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>add_coroutine</span>(a,b):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> a<span style=color:#f92672>+</span>b
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>res<span style=color:#f92672>=</span>asyncio<span style=color:#f92672>.</span>run(add_coroutine(<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>))
</span></span><span style=display:flex><span>print(res)
</span></span></code></pre></div><p>When we run this code, we’ll see output like the following:</p><pre tabindex=0><code>3
</code></pre><p>We’ve properly put our coroutine on the event loop, and we have executed it!
asyncio.run is doing a few important things in this scenario. First, it creates a
brand-new event. Once it successfully does so, it takes whichever coroutine we pass
into it and runs it until it completes, returning the result. This function will also do
some cleanup of anything that might be left running after the main coroutine fin
ishes. Once everything has finished, it shuts down and closes the event loop.
Possibly the most important thing about asyncio.run is that it is intended to be
the main entry point into the asyncio application we have created. It only executes
one coroutine, and that coroutine should launch all other aspects of our application.
As we progress further, we will use this function as the entry point into nearly all our
applications. The coroutine that asyncio.run executes will create and run other
coroutines that will allow us to utilize the concurrent nature of asyncio.</p><h2 id=23--pausing-execution-with-the-await-keyword>2.3 Pausing execution with the await keyword<a hidden class=anchor aria-hidden=true href=#23--pausing-execution-with-the-await-keyword>#</a></h2><p>The example we saw in block 2.2 did not need to be a coroutine, as it executed only
non-blocking Python code. The real benefit of asyncio is being able to pause execu
tion to let the event loop run other tasks during a long-running operation. To pause
execution, we use the await keyword. The await keyword is usually followed by a call
to a coroutine (more specifically, an object known as an awaitable, which is not always a
coroutine; we’ll learn more about awaitables later in the chapter).
Using the await keyword will cause the coroutine following it to be run, unlike
calling a coroutine directly, which produces a coroutine object. The await expression
will also pause the coroutine where it is contained in until the coroutine we awaited
finishes and returns a result. When the coroutine we awaited finishes, we’ll have
access to the result it returned, and the containing coroutine will “wake up” to handle
the result.
We can use the await keyword by putting it in front of a coroutine call. Expanding
on our earlier program, we can write a program where we call the add_coroutine function
inside of a “main” async function and get the result</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> asyncio
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>add_one</span>(number: int) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>return</span> number <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>main</span>() <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>   one_plus_one <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> add_one(<span style=color:#ae81ff>1</span>)     <span style=color:#75715e># Pause, and wait for the result of add_one(1).</span>
</span></span><span style=display:flex><span>   two_plus_one <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> add_one(<span style=color:#ae81ff>2</span>)     <span style=color:#75715e># Pause, and wait for the result of add_one(2).</span>
</span></span><span style=display:flex><span>   print(one_plus_one)
</span></span><span style=display:flex><span>   print(two_plus_one)
</span></span><span style=display:flex><span>asyncio<span style=color:#f92672>.</span>run(main())
</span></span></code></pre></div><blockquote><p>Note: Coroutine will only run when we use <code>await</code> keyword. If we call the coroutine directly it will return a coroutine object.</p></blockquote><p>In above code we pause execution twice. We first await the call to add_one(1). Once
we have the result, the main function will be “unpaused,” and we will assign the return
value from add_one(1) to the variable one_plus_one, which in this case will be two.
We then do the same for add_one(2) and then print the results.We can visualize the
execution flow of our application, as shown in figure</p><p><img loading=lazy src=/images/await.png alt="Await Execution Flow"></p><p>As it stands now, this code does not operate differently from normal, sequential code.
We are, in effect, mimicking a normal call stack. Next, let’s look at a simple example of
how to run other code by introducing a dummy sleep operation while we’re waiting.</p><h2 id=24--introducing-long-running-coroutines-with-sleep>2.4 Introducing long-running coroutines with sleep<a hidden class=anchor aria-hidden=true href=#24--introducing-long-running-coroutines-with-sleep>#</a></h2><p>Our previous examples did not use any slow operations and were used to help us learn
the basic syntax of coroutines. To fully see the benefits and show how we can run mul
tiple events simultaneously, we’ll need to introduce some long-running operations.
Instead of making web API or database queries right away, which are nondeterministic
as to how much time they will take, we’ll simulate long-running operations by specify
ing how long we want to wait. We’ll do this with the asyncio.sleep function.
We can use asyncio.sleep to make a coroutine “sleep” for a given number of sec
onds. This will pause our coroutine for the time we give it, simulating what would hap
pen if we had a long-running call to a database or web API.
asyncio.sleep is itself a coroutine, so we must use it with the await keyword. If we
call it just by itself, we’ll get a coroutine object. Since asyncio.sleep is a coroutine,
this means that when a coroutine awaits it, other code will be able to run.
Let’s examine a simple example, shown in the following listing, that sleeps for 1 sec
ond and then prints a &lsquo;Hello World!&rsquo; message.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> asyncio
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>hello_world_message</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>await</span> asyncio<span style=color:#f92672>.</span>sleep(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;Hello World&#34;</span>)
</span></span><span style=display:flex><span>asyncio<span style=color:#f92672>.</span>run(hello_world_message())
</span></span></code></pre></div><p>When we run this application, our program will wait 1 second before printing our
&lsquo;Hello World!&rsquo; message. Since hello_world_message is a coroutine and we pause it
for 1 second with asyncio.sleep, we now have 1 second where we could be running
other code concurrently.</p><p>We’ll be using sleep a lot in the next few examples, so let’s invest the time to cre
ate a reusable coroutine that sleeps for us and prints out some useful information.
We’ll call this coroutine delay. This is shown in the following listing</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> asyncio
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>delay</span>(delaysecond):
</span></span><span style=display:flex><span>   print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;Sleeping for delay seconds : </span><span style=color:#e6db74>{</span>delaysecond<span style=color:#e6db74>}</span><span style=color:#e6db74>&#39;</span>)
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>await</span> asyncio<span style=color:#f92672>.</span>sleep(delaysecond)
</span></span><span style=display:flex><span>   print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;finished sleeping for </span><span style=color:#e6db74>{</span>delay_seconds<span style=color:#e6db74>}</span><span style=color:#e6db74> second(s)&#39;</span>)
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>return</span> delay_seconds
</span></span></code></pre></div><p>delay will take in an integer of the duration in seconds that we’d like the function to
sleep and will return that integer to the caller once it has finished sleeping. We’ll also
print when sleep begins and ends. This will help us see what other code, if any, is run
ning concurrently while our coroutines are paused.</p><p>To make referencing this utility function easier in future code listings, we’ll create
a module that we’ll import in the remainder of this book when needed. We’ll also add
to this module as we create additional reusable functions. We’ll call this module util,
and we’ll put our delay function in a file called delay_functions.py. We’ll also add
an <strong>init</strong>.py file with the following line, so we can nicely import the timer</p><pre tabindex=0><code> from util.delay_functions import delay
</code></pre><p>From now on in this book, we’ll use from util import delay whenever we need to use
the delay function. Now that we have a reusable delay coroutine, let’s combine it with
the earlier coroutine add_one to see if we can get our simple addition to run concur
rently while hello_world_message is paused.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> asyncio
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> util.delay_functions <span style=color:#f92672>import</span> delay
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>add_one</span>(number):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> number <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>hello_world_message</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>await</span> delay(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;Hello World&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>main</span>() <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>    message <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> hello_world_message()      <span style=color:#75715e>#pause until hello_world_message is finished</span>
</span></span><span style=display:flex><span>    one_plus_one <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> add_one(<span style=color:#ae81ff>1</span>)            <span style=color:#75715e>#pause until add_one is finished</span>
</span></span><span style=display:flex><span>    print(one_plus_one)
</span></span><span style=display:flex><span>    print(message)
</span></span><span style=display:flex><span> asyncio<span style=color:#f92672>.</span>run(main())
</span></span></code></pre></div><p>When we run this, 1 second passes before the results of both function calls are
printed. What we really want is the value of add_one(1) to be printed immediately
while hello_world_message()runs concurrently. So why isn’t this happening with this
code? The answer is that await pauses our current coroutine and won’t execute any
other code inside that coroutine until the await expression gives us a value. Since it
will take 1 second for our hello_world_message function to give us a value, the main
coroutine will be paused for 1 second. Our code behaves as if it were sequential in this
case. This behavior is illustrated in figure</p><p><img loading=lazy src=/images/async1.png alt=asyncio.sleep></p><p>We can see that the main coroutine is paused for 1 second while hello_world_</p><p>Both main and hello_world paused while we wait for delay(1) to finish. After it has
finished, main resumes and can execute add_one.
We’d like to move away from this sequential model and run add_one concurrently
with hello_world. To achieve this, we’ll need to introduce a concept called tasks.</p><h2 id=25-running-concurrently-with-task>2.5 Running concurrently with task<a hidden class=anchor aria-hidden=true href=#25-running-concurrently-with-task>#</a></h2><p>In Python&rsquo;s <code>asyncio</code>, you can create tasks to run code concurrently. This is done using the <code>asyncio.create_task</code> function. When you create a task, it starts running in the background immediately, allowing your program to do other things while waiting for the task to finish.</p><hr><h3 id=key-points>Key Points:<a hidden class=anchor aria-hidden=true href=#key-points>#</a></h3><ol><li><p><strong>Creating a Task</strong>:</p><ul><li>Use <code>asyncio.create_task()</code> with a coroutine function as its input.</li><li>It returns a <em>task object</em> instantly.</li></ul></li><li><p><strong>Awaiting a Task</strong>:</p><ul><li>You can use <code>await</code> with the task object to pause your program until the task is done and get its result.</li></ul></li><li><p><strong>Why Use Tasks?</strong></p><ul><li>Tasks allow other parts of your program to run without waiting for one operation to finish.</li></ul></li></ol><hr><h3 id=code-example-creating-and-using-a-task>Code Example: Creating and Using a Task<a hidden class=anchor aria-hidden=true href=#code-example-creating-and-using-a-task>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> asyncio
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> util <span style=color:#f92672>import</span> delay  <span style=color:#75715e># A custom function that simulates a delay</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>main</span>():
</span></span><span style=display:flex><span>    <span style=color:#75715e># Create a task that takes 3 seconds to complete</span>
</span></span><span style=display:flex><span>    sleep_for_three <span style=color:#f92672>=</span> asyncio<span style=color:#f92672>.</span>create_task(delay(<span style=color:#ae81ff>3</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Immediately print the type of the task object</span>
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;Task type: </span><span style=color:#e6db74>{</span>type(sleep_for_three)<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Wait for the task to finish and get the result</span>
</span></span><span style=display:flex><span>    result <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> sleep_for_three
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;Task result: </span><span style=color:#e6db74>{</span>result<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Run the main coroutine</span>
</span></span><span style=display:flex><span>asyncio<span style=color:#f92672>.</span>run(main())
</span></span></code></pre></div><hr><h3 id=whats-happening-in-the-code>What’s Happening in the Code:<a hidden class=anchor aria-hidden=true href=#whats-happening-in-the-code>#</a></h3><ol><li><p><strong>Task Creation</strong>:</p><ul><li><code>asyncio.create_task(delay(3))</code> creates a task to run the <code>delay(3)</code> coroutine in the background.</li><li>The task is of type <code>&lt;class '_asyncio.Task'></code>, which is different from a regular coroutine.</li></ul></li><li><p><strong>Running Concurrently</strong>:</p><ul><li>After creating the task, the program does not wait for the task to finish.</li><li>The <code>print()</code> statement runs immediately after the task is created.</li></ul></li><li><p><strong>Waiting for the Task</strong>:</p><ul><li>The <code>await sleep_for_three</code> line pauses the <code>main</code> coroutine until the task finishes.</li><li>Once the task is complete, it returns its result, which is printed.</li></ul></li></ol><hr><h3 id=why-await-is-important>Why Await is Important:<a hidden class=anchor aria-hidden=true href=#why-await-is-important>#</a></h3><p>If you don’t use <code>await</code> on a task, it might not get enough time to finish. When the <code>asyncio.run</code> function exits, the event loop stops, and any unfinished tasks are “cleaned up” without completing. Using <code>await</code> ensures the task has a chance to finish.</p><blockquote><p>Note : When we create task using <code>asyncio.create_task</code> it run the task immediately in the background. It does not wait for the task to finish and immediately return a task object such that our program can do other things while waiting for the task to finish.We can use <code>await</code> later on to pause the program until the task is done and get its result.</p></blockquote><h1 id=26-running-multiple-tasks-concurrently>2.6 Running multiple tasks concurrently<a hidden class=anchor aria-hidden=true href=#26-running-multiple-tasks-concurrently>#</a></h1><p>Given that tasks are created instantly and are scheduled to run as soon as possible, this
allows us to run many long-running tasks concurrently. We can do this by sequentially
starting multiple tasks with our long-running coroutine.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> asyncio
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> util.delay_functions <span style=color:#f92672>import</span> delay
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>main</span>():
</span></span><span style=display:flex><span>   <span style=color:#75715e># Create two tasks that take 3 seconds to complete</span>
</span></span><span style=display:flex><span>   sleep_for_three<span style=color:#f92672>=</span>asyncio<span style=color:#f92672>.</span>create_task(delay(<span style=color:#ae81ff>3</span>))
</span></span><span style=display:flex><span>   sleep_again<span style=color:#f92672>=</span>asyncio<span style=color:#f92672>.</span>create_task(delay(<span style=color:#ae81ff>3</span>))
</span></span><span style=display:flex><span>   sleep_once_more<span style=color:#f92672>=</span>asyncio<span style=color:#f92672>.</span>create_task(delay(<span style=color:#ae81ff>3</span>))
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>await</span> sleep_for_three
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>await</span> sleep_again
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>await</span> sleep_once_more
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>asyncio<span style=color:#f92672>.</span>run(main())
</span></span></code></pre></div><p>In this code, we create three tasks that each sleep for 3 seconds. We then await each
task in sequence. This will cause each task to run concurrently, and the total time to
complete will be around 3 seconds, not 9 seconds. This is because we are not waiting
for each task to finish before starting the next one. Lets breakdown</p><ol><li><p><strong>Starting Three Tasks</strong>:</p><ul><li>The program begins by creating three tasks, each of which takes 3 seconds to complete.</li><li>The <code>create_task</code> function starts the tasks immediately but doesn&rsquo;t wait for them to finish—it just sets them up to run in the background.</li></ul></li><li><p><strong>The First Await Statement</strong>:</p><ul><li>When the code reaches the <code>await sleep_for_three</code> line, it pauses and gives control to the event loop.</li><li>This pause allows the event loop to check for any tasks waiting to run and starts them “as soon as possible.”</li></ul></li><li><p><strong>Tasks Run Simultaneously</strong>:</p><ul><li>All three tasks begin running their <code>sleep</code> operations at the same time because the event loop handles them concurrently.</li><li>This concurrency allows the program to complete the work in 3 seconds instead of 9.</li></ul></li><li><p><strong>Concurrency in Action</strong>:</p><ul><li>While the <code>sleep</code> operations run concurrently, any other code in the tasks (like print statements) runs one at a time, not simultaneously.</li><li>This means only the parts of the tasks that involve waiting (like sleeping) are parallelized.</li></ul></li><li><p><strong>Time Saved</strong>:</p><ul><li>If the tasks were executed one after another, the program would take 9 seconds (3 seconds × 3 tasks).</li><li>By running the tasks concurrently, the program finishes in just 3 seconds, saving a lot of time.</li></ul></li></ol><p>This is illustrated in figure
<img loading=lazy src=/images/multiple.png alt="Multiple Tasks"></p><blockquote><p>NOTE This benefit compounds as we add more tasks; if we had launched 10
of these tasks, we would still take roughly 3 seconds, giving us a 10-fold
speedup. This is the power of concurrency in asyncio.</p></blockquote><h2 id=asynciogather-function><code>asyncio.gather</code> function<a hidden class=anchor aria-hidden=true href=#asynciogather-function>#</a></h2><p>Gather function is a quick way to run multiple tasks concurrently and wait for all of them to complete. It takes in an iterable of awaitables and returns a single awaitable that will yield results in the order they were created. This is useful when we want to run multiple tasks concurrently and wait for all of them to finish before proceeding.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> asyncio
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> util.delay_functions <span style=color:#f92672>import</span> delay
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>main</span>():
</span></span><span style=display:flex><span>    <span style=color:#75715e># Create three tasks that take 3 seconds to complete and handel using asyncio.gather</span>
</span></span><span style=display:flex><span>    results <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> asyncio<span style=color:#f92672>.</span>gather(
</span></span><span style=display:flex><span>        delay(<span style=color:#ae81ff>3</span>),
</span></span><span style=display:flex><span>        delay(<span style=color:#ae81ff>3</span>),
</span></span><span style=display:flex><span>        delay(<span style=color:#ae81ff>3</span>)
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    print(results)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>asyncio<span style=color:#f92672>.</span>run(main())
</span></span></code></pre></div><blockquote><p>Note : For understanding You can use this logic . There is a task queue and event loop. When we
only await coroutine there is only one task in the task queue and event loop .</p><blockquote><p>coroutine need to await for running the task i.e keep in the task queue and eventloop if we directly run coroutine it will just give us coroutine object.</p></blockquote></blockquote><blockquote><p>When we use asyncio.createtask() there are as much task in the task queue as the number of tasks created and event loop will run all the tasks concurrently also when we await new coroutine it will be added to the task queue and event loop will run it concurrently.</p><blockquote><p>It return a task object instantly and run all the task concurrently i.e keep in the task queue and event loop without awaiting but does not wait for the task to finish it need to be awaited to get the proper result.</p></blockquote></blockquote><blockquote><p>When we use asyncio.gather() it will run all the tasks concurrently and wait for all of them to finish before proceeding.</p><blockquote><p>It need to be awaited to keep all the task in the task queue and event loop and wait for all of them to finish before proceeding.After finishing all the task it will return the result in the order they were created and jump to the next line of code of the main coroutine.</p></blockquote></blockquote><h1 id=3-synchronization-premitives>3. Synchronization Premitives<a hidden class=anchor aria-hidden=true href=#3-synchronization-premitives>#</a></h1><ul><li>Locks</li><li>Semaphores</li></ul><h2 id=31-locks>3.1 Locks<a hidden class=anchor aria-hidden=true href=#31-locks>#</a></h2><p>Locks are a synchronization primitive that allows us to limit access to a shared resource to only one coroutine at a time. This is useful when we have a resource that can only be accessed by one coroutine at a time, like a file or a database connection. Locks are created using the asyncio.Lock class and can be acquired using the acquire method and released using the release method.</p><p>#basic example of lock</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> asyncio
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>locking</span>(lock):
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#39;Waiting for the lock&#39;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>with</span> lock:
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#39;Acquired the lock&#39;</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>await</span> asyncio<span style=color:#f92672>.</span>sleep(<span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#39;Released the lock&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>main</span>():
</span></span><span style=display:flex><span>    lock <span style=color:#f92672>=</span> asyncio<span style=color:#f92672>.</span>Lock()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>await</span> asyncio<span style=color:#f92672>.</span>gather(
</span></span><span style=display:flex><span>        locking(lock),
</span></span><span style=display:flex><span>        locking(lock),
</span></span><span style=display:flex><span>        locking(lock)
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>asyncio<span style=color:#f92672>.</span>run(main())
</span></span></code></pre></div><p>Output:</p><pre tabindex=0><code>Waiting for the lock
Acquired the lock
Waiting for the lock
Waiting for the lock
Released the lock
Acquired the lock
Released the lock
Acquired the lock
Released the lock
</code></pre><p>In this example, we create a lock using asyncio.Lock and pass it to the locking coroutine. We then use the async with statement to acquire the lock and release it when we are done. When we run the program, we can see that only one coroutine can acquire the lock at a time, and the other coroutines have to wait until the lock is released.</p><h2 id=32-semaphores>3.2 Semaphores<a hidden class=anchor aria-hidden=true href=#32-semaphores>#</a></h2><p>Semaphores are a synchronization primitive that allows us to limit access to a shared resource to a fixed number of coroutines at a time. This is useful when we have a resource that can be accessed by a limited number of coroutines, like a connection pool or a web API. Semaphores are created using the asyncio.Semaphore class and can be acquired using the acquire method and released using the release method.</p><p>#basic example of semaphore</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> asyncio
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>semaphoring</span>(semaphore):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>with</span> semaphore:
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#39;Acquired the semaphore&#39;</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>await</span> asyncio<span style=color:#f92672>.</span>sleep(<span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#39;Released the semaphore&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>main</span>():
</span></span><span style=display:flex><span>    semaphore <span style=color:#f92672>=</span> asyncio<span style=color:#f92672>.</span>Semaphore(<span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>await</span> asyncio<span style=color:#f92672>.</span>gather(
</span></span><span style=display:flex><span>        semaphoring(semaphore),
</span></span><span style=display:flex><span>        semaphoring(semaphore),
</span></span><span style=display:flex><span>        semaphoring(semaphore),
</span></span><span style=display:flex><span>        semaphoring(semaphore)
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>asyncio<span style=color:#f92672>.</span>run(main())
</span></span></code></pre></div><p>Output:</p><pre tabindex=0><code>Acquired the semaphore
Acquired the semaphore
Acquired the semaphore
Released the semaphore
Released the semaphore
Released the semaphore
Acquired the semaphore
Released the semaphore
</code></pre><p>In this example, we create a semaphore with a limit of 2 using asyncio.Semaphore and pass it to the semaphoring coroutine. We then use the async with statement to acquire the semaphore and release it when we are done. When we run the program, we can see that only two coroutines can acquire the semaphore at a time, and the other coroutines have to wait until the semaphore is released.</p><h2 id=some-popular-asyncio-libraries>Some popular asyncio libraries<a hidden class=anchor aria-hidden=true href=#some-popular-asyncio-libraries>#</a></h2><ul><li>aiohttp: An HTTP client and server library for asyncio.</li><li>fastapi: A modern web framework for building APIs with Python 3.6+ based on standard Python type hints.</li><li>aiofiles: A file operations library for asyncio.</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/python/>Python</a></li><li><a href=http://localhost:1313/tags/programming/>Programming</a></li><li><a href=http://localhost:1313/tags/asyncio/>Asyncio</a></li><li><a href=http://localhost:1313/tags/tutorial/>Tutorial</a></li></ul><nav class=paginav><a class=next href=http://localhost:1313/posts/pages/asyncio/asyncio1/><span class=title>Next »</span><br><span>Async io : Async io Intro (Day 1)</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Async io : Asyncio Basics (Day 2) on x" href="https://x.com/intent/tweet/?text=Async%20io%20%3a%20Asyncio%20Basics%20%28Day%202%29&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fpages%2fasyncio%2fasyncio2%2f&amp;hashtags=Python%2cProgramming%2casyncio%2cTutorial"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Async io : Asyncio Basics (Day 2) on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fpages%2fasyncio%2fasyncio2%2f&amp;title=Async%20io%20%3a%20Asyncio%20Basics%20%28Day%202%29&amp;summary=Async%20io%20%3a%20Asyncio%20Basics%20%28Day%202%29&amp;source=http%3a%2f%2flocalhost%3a1313%2fposts%2fpages%2fasyncio%2fasyncio2%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Async io : Asyncio Basics (Day 2) on reddit" href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fposts%2fpages%2fasyncio%2fasyncio2%2f&title=Async%20io%20%3a%20Asyncio%20Basics%20%28Day%202%29"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Async io : Asyncio Basics (Day 2) on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fposts%2fpages%2fasyncio%2fasyncio2%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Async io : Asyncio Basics (Day 2) on whatsapp" href="https://api.whatsapp.com/send?text=Async%20io%20%3a%20Asyncio%20Basics%20%28Day%202%29%20-%20http%3a%2f%2flocalhost%3a1313%2fposts%2fpages%2fasyncio%2fasyncio2%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Async io : Asyncio Basics (Day 2) on telegram" href="https://telegram.me/share/url?text=Async%20io%20%3a%20Asyncio%20Basics%20%28Day%202%29&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fpages%2fasyncio%2fasyncio2%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Async io : Asyncio Basics (Day 2) on ycombinator" href="https://news.ycombinator.com/submitlink?t=Async%20io%20%3a%20Asyncio%20Basics%20%28Day%202%29&u=http%3a%2f%2flocalhost%3a1313%2fposts%2fpages%2fasyncio%2fasyncio2%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=http://localhost:1313/>Quick Reference</a></span> ·</footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>